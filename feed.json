{
    "version": "https://jsonfeed.org/version/1",
    "title": "null",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20250903/",
            "url": "https://xsc062.netlify.app/20250903/",
            "title": "多校杂题",
            "date_published": "2025-09-03T13:28:00.000Z",
            "content_html": "<p>还算能做</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a.-itinerary\">A. Itinerary</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P12195\" class=\"uri\">https://www.luogu.com.cn/problem/P12195</a></p>\n<ul>\n<li><p>画个图可以发现当前仅当同时满足：</p>\n<ul>\n<li>给定的欧拉序子序列合法，即按照给定的顺序，任意一条边不被经过超过两次；为路径上的边按照经过时的方向打上标记。可以用暴力爬山之类的方法验证，这个过程是线性的。</li>\n<li>选定的起点可以到达 <span class=\"math inline\">\\(s_1\\)</span>，且经过的边要么没有标记，要么标记方向和经过的方向相反。</li>\n</ul></li>\n<li><p>所以可以从 <span class=\"math inline\">\\(s_1\\)</span> 做一遍 DFS，要求不能经过拥有相同方向标记的边即可。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    struct edge &#123; int v, id, ix; &#125;;\n    std::vector&lt;std::array&lt;int, 2&gt; &gt; tag(n);\n    std::vector&lt;std::vector&lt;edge&gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(&#123; y, i, 0 &#125;);\n        g[y].push_back(&#123; x, i, 1 &#125;);\n    &#125;\n    std::vector&lt;int&gt; dep(n + 1);\n    std::vector&lt;edge&gt; fa(n + 1);\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int faa) &#123;\n        for (auto [i, id, ix] : g[x])\n            if (i != faa) &#123;\n                dep[i] = dep[x] + 1;\n                fa[i] = &#123; x, id, !ix &#125;;\n                DFS(i, x);\n            &#125;\n        return;\n    &#125;;\n    dep[1] = 1, DFS(1, -1);\n    std::vector&lt;int&gt; s(m + 1);\n    for (int i = 1; i &lt;= m; ++i)\n        std::cin &gt;&gt; s[i];\n    for (int i = 2; i &lt;= m; ++i) &#123;\n        int x = s[i - 1], y = s[i];\n        if (dep[x] &gt; dep[y])\n            for (; dep[x] &gt; dep[y]; x = fa[x].v) &#123;\n                if (tag[fa[x].id][fa[x].ix])\n                    goto outo;\n                tag[fa[x].id][fa[x].ix] = 1;\n            &#125;\n        else\n            for (; dep[y] &gt; dep[x]; y = fa[y].v) &#123;\n                if (tag[fa[y].id][!fa[y].ix])\n                    goto outo;\n                tag[fa[y].id][!fa[y].ix] = 1;\n            &#125;\n        for (; x != y; x = fa[x].v, y = fa[y].v) &#123;\n            if (tag[fa[x].id][fa[x].ix] || tag[fa[y].id][!fa[y].ix])\n                goto outo;\n            tag[fa[x].id][fa[x].ix] = 1;\n            tag[fa[y].id][!fa[y].ix] = 1;\n        &#125;\n        continue;\n    outo:\n        for (int j = 1; j &lt;= n; ++j)\n            std::cout &lt;&lt; 0 &lt;&lt; &#39;\\n&#39;;\n        return 0;\n    &#125;\n    std::vector&lt;int&gt; res(n + 1);\n    DFS = [&amp;](int x, int fa) &#123;\n        res[x] = 1;\n        for (auto [i, id, ix] : g[x])\n            if (i != fa &amp;&amp; !tag[id][!ix])\n                DFS(i, x);\n        return;\n    &#125;;\n    DFS(s[1], -1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b.-2d-conveyer-belt-s\">B. 2D Conveyer Belt S</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P11454\" class=\"uri\">https://www.luogu.com.cn/problem/P11454</a></p>\n<ul>\n<li><p>注意到每个点的出度最多为 1。容易发现一个点是不可用的，当且仅当：</p>\n<ul>\n<li>在至少一个环内部；</li>\n<li>或者，会到达一个环上的点。</li>\n</ul></li>\n<li><p>难点在于如何快速找到每次操作后环内部的点。但发现由于每个点出度为 1，不会出现：</p>\n<p><img src=\"image.png\" /></p>\n之类让人摸不着头脑的情况。可以考虑找到外层合法的点，倒放 + floodfill 来保证复杂度；不知道有没有更简单的做法。</li>\n<li><p>具体 floodfill 的方式是，<strong>对于一个合法的格子，如果其上方有一个方向为 <code>D</code> 的格子，那么上方也是合法的</strong>。这个转化是比较重要的。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int dir[][3] = &#123; &#123; 0, -1, 1 &#125;, &#123; 0, 1, 2 &#125;, &#123; -1, 0, 3 &#125;, &#123; 1, 0, 4 &#125; &#125;;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, q;\n    std::cin &gt;&gt; n &gt;&gt; q, n += 2;\n    std::vector&lt;std::vector&lt;int&gt; &gt; tag(n + 1, std::vector&lt;int&gt; (n + 1)), a(n + 1, std::vector&lt;int&gt; (n + 1));\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; g(q + 1);\n    int tot = 0;\n    for (int i = 1, x, y; i &lt;= q; ++i) &#123;\n        char t;\n        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; t, ++x, ++y;\n        g[i] = &#123; x, y &#125;;\n        if (t == &#39;L&#39;)\n            a[x][y] = 2;\n        else if (t == &#39;R&#39;)\n            a[x][y] = 1;\n        else if (t == &#39;U&#39;)\n            a[x][y] = 4;\n        else\n            a[x][y] = 3;\n    &#125;\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int y) &#123;\n        tag[x][y] = 1, ++tot;\n        for (auto [fx, fy, fi] : dir) &#123;\n            int nx = x + fx, ny = y + fy;\n            if (nx &gt;= 1 &amp;&amp; nx &lt;= n &amp;&amp; ny &gt;= 1 &amp;&amp; ny &lt;= n &amp;&amp; !tag[nx][ny] &amp;&amp; (!a[nx][ny] || a[nx][ny] == fi))\n                DFS(nx, ny);\n        &#125;\n        return;\n    &#125;;\n    DFS(1, 1);\n    std::vector&lt;int&gt; res(q + 1);\n    res[q] = n * n - tot;\n    for (int i = q; i &gt; 1; --i) &#123;\n        auto [x, y] = g[i];\n        if (!tag[x][y] &amp;&amp; (tag[x][y - 1] || tag[x][y + 1] || tag[x - 1][y] || tag[x + 1][y]))\n            DFS(x, y);\n        a[x][y] = 0;\n        res[i - 1] = n * n - tot;\n    &#125;\n    for (int i = 1; i &lt;= q; ++i)\n        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c.-机器人\">C. 机器人</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P12018\" class=\"uri\">https://www.luogu.com.cn/problem/P12018</a></p>\n<ul>\n<li>考察题意，</li>\n</ul>\n",
            "tags": []
        },
        {
            "id": "https://xsc062.netlify.app/20250830/",
            "url": "https://xsc062.netlify.app/20250830/",
            "title": "学习笔记 支配对",
            "date_published": "2025-08-30T03:47:08.000Z",
            "content_html": "<p>一种贪心思想，很符合直觉，又有点像乱搞</p>\n<span id=\"more\"></span>\n<hr />\n<ul>\n<li>考虑一类点对统计问题，形如给定 <span class=\"math inline\">\\([l,r]\\)</span>，对于 <span class=\"math inline\">\\([l\\le x\\le y\\le r]\\)</span>，你需要寻找满足某个限制的 <span class=\"math inline\">\\((x,y)\\)</span> 数量，或者是所有 <span class=\"math inline\">\\((x,y)\\)</span> 的最大权值</li>\n<li><p>如果存在 <span class=\"math inline\">\\([x_1,y_1]\\subset [x_2,y_2]\\)</span> 且 <span class=\"math inline\">\\([x_1,y_1]\\)</span> 满足限制 / 贡献更大，就可以只保留 <span class=\"math inline\">\\([x_1,y_1]\\)</span></p>\n因为统计了 <span class=\"math inline\">\\([x_2,y_2]\\)</span> 就必须要统计 <span class=\"math inline\">\\([x_1,y_1]\\)</span>，反之则不一定成立。</li>\n<li><p>题目会给出一些性质使得最终保留下来的 <span class=\"math inline\">\\([x_1,y_1]\\)</span> 的数量不多</p></li>\n</ul>\n<hr />\n<h2 id=\"树上支配对-第一类支配对\">树上支配对 / 第一类支配对</h2>\n<ul>\n<li>这类问题的特征很明显，多次询问，给定一个编号区间，统计树上点对相关信息。</li>\n<li><p>会想到点分治、dsu on tree 这两个工具，其中点分治处理距离问题更方便，dsu on tree 更常用来处理 LCA 问题</p>\n固定当前的根之后，钦定支配对来自两个不同子树（注意根自身参与形成支配对的情况），那么共有 <span class=\"math inline\">\\(O(n\\log n)\\)</span> 对支配对</li>\n<li><p>先用这两种方法在树上找到支配对，就可以把询问离线下来做扫描线之类的了</p></li>\n</ul>\n<p>本质是利用 LCA 的树上性质，以及点分、dsu on tree 只用统计 <span class=\"math inline\">\\(O(n\\log n)\\)</span> 个单侧点，同时对于每个单侧点只存在 <span class=\"math inline\">\\(O(1)\\)</span> 个相应的前驱、后继点达到 LCA 找到 <span class=\"math inline\">\\(O(n\\log n)\\)</span> 个支配对</p>\n<hr />\n<h3 id=\"d---rldcot\">D - rldcot</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P7880\" class=\"uri\">https://www.luogu.com.cn/problem/P7880</a></p>\n<ul>\n<li>若存在 <span class=\"math inline\">\\((x_1,y_1)\\)</span> 和 <span class=\"math inline\">\\((x_2,y_2)\\)</span> 拥有相同的 LCA，那么认为 <span class=\"math inline\">\\((x_1,y_1)\\)</span> 支配了 <span class=\"math inline\">\\((x_2,y_2)\\)</span></li>\n<li>树有根，故需要 dsu on tree</li>\n<li>用一个 set 处理前驱、后继的查询，然后就是正常的 dsu on tree 了</li>\n<li>离线下来扫描线，树状数组实时维护每个颜色（离散化一下）最靠右的区间即可</li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    using ll = long long;\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(n + 1);\n    for (int i = 1, x, y, w; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;\n        g[x].emplace_back(y, w);\n        g[y].emplace_back(x, w);\n    &#125;\n    int tot = 0;\n    std::vector&lt;ll&gt; dep(n + 1);\n    std::unordered_map&lt;ll, int&gt; tab;\n    std::vector&lt;int&gt; siz(n + 1), son(n + 1), col(n + 1);\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        siz[x] = 1;\n        if (!tab.count(dep[x]))\n            tab[dep[x]] = ++tot;\n        col[x] = tab[dep[x]];\n        for (auto [i, w] : g[x])\n            if (i != fa) &#123;\n                dep[i] = dep[x] + w;\n                DFS(i, x);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1, -1);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; u(n + 1);\n    std::function&lt;void(int, int, int, std::set&lt;int&gt; &amp;)&gt; DFS2 = [&amp;](int col, int x, int fa, std::set&lt;int&gt; &amp;t) &#123;\n        auto p = t.lower_bound(x);\n        if (col == -1)\n            t.insert(x);\n        else &#123;\n            if (p != t.begin())\n                u[x].emplace_back(*std::prev(p), col );\n            if (p != t.end())\n                u[*p].emplace_back(x, col);\n        &#125;\n        for (auto [i, w] : g[x])\n            if (i != fa)\n                DFS2(col, i, x, t);\n        return;\n    &#125;;\n    std::function&lt;void(int, int, std::set&lt;int&gt; &amp;)&gt; DFS1 = [&amp;](int x, int fa, std::set&lt;int&gt; &amp;t) &#123;\n        if (son[x])\n            DFS1(son[x], x, t);\n        for (auto [i, w] : g[x])\n            if (i != fa &amp;&amp; i != son[x]) &#123;\n                std::set&lt;int&gt; nt;\n                DFS1(i, x, nt);\n            &#125;\n        t.insert(x);\n        u[x].emplace_back(x, col[x]);\n        for (auto [i, w] : g[x])\n            if (i != fa &amp;&amp; i != son[x])\n                DFS2(col[x], i, x, t), DFS2(-1, i, x, t);\n        return;\n    &#125;;\n    &#123;\n        std::set&lt;int&gt; t;\n        DFS1(1, -1, t);\n    &#125;\n    std::vector&lt;int&gt; res(m + 1);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; t(n + 1);\n    for (int i = 1, l, r; i &lt;= m; ++i) &#123;\n        std::cin &gt;&gt; l &gt;&gt; r;\n        t[r].emplace_back(l, i);\n    &#125;\n    std::vector&lt;int&gt; bit(n + 1), la(tot + 1);\n    auto lowbit = [](int x) &#123;\n        return x &amp; -x;\n    &#125;;\n    auto add = [&amp;](int x, int v) &#123;\n        for (; x &lt;= n; x += lowbit(x))\n            bit[x] += v;\n        return;\n    &#125;;\n    auto ask = [&amp;](int x) &#123;\n        int res = 0;\n        for (; x; x -= lowbit(x))\n            res += bit[x];\n        return res;\n    &#125;;\n    for (int r = 1; r &lt;= n; ++r) &#123;\n        for (auto [l, c] : u[r])\n            if (l &gt; la[c]) &#123;\n                if (la[c])\n                    add(la[c], -1);\n                add(l, 1), la[c] = l;\n            &#125;\n        for (auto [l, id] : t[r])\n            res[id] = ask(r) - ask(l - 1);\n    &#125;\n    for (int i = 1; i &lt;= m; ++i)\n        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"e---铃原露露\">E - 铃原露露</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P8528\" class=\"uri\">https://www.luogu.com.cn/problem/P8528</a></p>\n<ul>\n<li><p>考虑一下支配关系在哪里，固定一个 LCA <span class=\"math inline\">\\(z\\)</span>，讨论 <span class=\"math inline\">\\(a_z\\)</span> 与 <span class=\"math inline\">\\(a_x,a_y\\)</span> 的大小关系给 <span class=\"math inline\">\\([1,a_x]\\)</span> 间的 <span class=\"math inline\">\\(l\\)</span> 带来的限制：</p>\n<ul>\n<li><span class=\"math inline\">\\(a_z\\in[a_x,a_y]\\)</span>，<span class=\"math inline\">\\((x,y)\\)</span> 总是合法，无限制。</li>\n<li><span class=\"math inline\">\\(a_z&lt;a_x\\)</span>，对于 <span class=\"math inline\">\\(r\\ge a_y\\)</span>，当 <span class=\"math inline\">\\(l\\in(a_z,a_x]\\)</span> 时，<span class=\"math inline\">\\((x,y)\\)</span> 非法。</li>\n<li><span class=\"math inline\">\\(a_z&gt;a_y\\)</span>，当 <span class=\"math inline\">\\(r\\in[a_y,a_z)\\)</span> 时，<span class=\"math inline\">\\((x,y)\\)</span> 总是非法。此时所有 <span class=\"math inline\">\\(l\\in[1,a_x]\\)</span> 不可选。</li>\n</ul></li>\n<li>发现固定 <span class=\"math inline\">\\(a_z,a_x\\)</span>，那么当 <span class=\"math inline\">\\(a_y\\)</span> 越靠近 <span class=\"math inline\">\\(a_x\\)</span> 时给出的限制越紧，反之亦然，就可以得到这样的支配关系</li>\n<li>容易发现当 <span class=\"math inline\">\\(a_z\\notin [a_x,a_y]\\)</span> 时，<span class=\"math inline\">\\((x,y)\\)</span> 不合法；故只需要在 dsu on tree 上找到 <span class=\"math inline\">\\(a_x\\)</span> 的前驱、后继并统计支配对即可</li>\n<li><p>考虑询问，发现需要维护区间加、区间历史 0 个数，后者是经典 trick，是好做的。</p></li>\n</ul>\n<p>历史标记的下传需要格外注意一下，应该只保证标记期间存在 0 的区间拥有懒标记；具体地，<strong>只应将其下传到和当前区间最小值相同的子区间</strong>（具体可以看代码），容易证明是对的。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 2e5 + 5;\nstruct node &#123;\n    long long s;\n    int l, r, u, c, d, d1;\n    node operator+ (const node q) const &#123;\n        node res;\n        res.s = s + q.s;\n        res.l = l, res.r = q.r;\n        res.u = std::min(u, q.u);\n        res.d = res.d1 = res.c = 0;\n        if (u == res.u)\n            res.c = c;\n        if (q.u == res.u)\n            res.c += q.c;\n        return res;\n    &#125;\n&#125; t[maxn &lt;&lt; 2];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid bld(int p, int l, int r) &#123;\n    t[p].c = r - l + 1;\n    t[p].l = l, t[p].r = r;\n    if (l == r)\n        return;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    return;\n&#125;\nvoid pushdown(int p) &#123;\n    if (t[p].d) &#123;\n        t[lt].d += t[p].d, t[lt].u += t[p].d;\n        t[rt].d += t[p].d, t[rt].u += t[p].d;\n        t[p].d = 0;\n    &#125;\n    if (t[p].d1) &#123;\n        if (t[lt].u == t[p].u) &#123;\n            t[lt].s += (long long)t[lt].c * t[p].d1;\n            t[lt].d1 += t[p].d1;\n        &#125;\n        if (t[rt].u == t[p].u) &#123;\n            t[rt].s += (long long)t[rt].c * t[p].d1;\n            t[rt].d1 += t[p].d1;\n        &#125;\n        t[p].d1 = 0;\n    &#125;\n    return;\n&#125;\nvoid add(int p, int l, int r, int v) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        t[p].d += v, t[p].u += v;\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid)\n        add(lt, l, r, v);\n    if (r &gt; mid)\n        add(rt, l, r, v);\n    t[p] = t[lt] + t[rt];\n    return;\n&#125;\nvoid upd(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        if (!t[p].u)\n            t[p].s += t[p].c, ++t[p].d1;\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid)\n        upd(lt, l, r);\n    if (r &gt; mid)\n        upd(rt, l, r);\n    t[p] = t[lt] + t[rt];\n    return;\n&#125;\nlong long ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].s;\n    pushdown(p);\n    auto res(0ll);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid)\n        res = ask(lt, l, r);\n    if (r &gt; mid)\n        res += ask(rt, l, r);\n    return res;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1); \n    for (int i = 2, x; i &lt;= n; ++i)\n        std::cin &gt;&gt; x, g[x].push_back(i);\n    std::vector&lt;int&gt; siz(n + 1), son(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        siz[x] = 1;\n        for (auto i : g[x]) &#123;\n            DFS(i);\n            siz[x] += siz[i];\n            if (siz[i] &gt; siz[son[x]])\n                son[x] = i;\n        &#125;\n        return;\n    &#125;;\n    DFS(1);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; u1(n + 1), u2(n + 1);\n    std::function&lt;void(int, int, std::set&lt;int&gt; &amp;)&gt; DFS2 = [&amp;](int col, int x, std::set&lt;int&gt; &amp;t) &#123;\n        auto p = t.lower_bound(a[x]);\n        if (col == -1)\n            t.insert(a[x]);\n        else &#123;\n            if (p != t.begin()) &#123;\n                int y = *std::prev(p);\n                if (col &lt; y)\n                    u1[a[x]].emplace_back(col + 1, y);\n                else if (col &gt; a[x]) &#123;\n                    u1[a[x]].emplace_back(1, y);\n                    u2[col].emplace_back(1, y);\n                &#125;\n            &#125;\n            if (p != t.end()) &#123;\n                int y = *p;\n                if (col &lt; a[x])\n                    u1[y].emplace_back(col + 1, a[x]);\n                else if (col &gt; y) &#123;\n                    u1[y].emplace_back(1, a[x]);\n                    u2[col].emplace_back(1, a[x]);\n                &#125;\n            &#125;\n        &#125;\n        for (auto i : g[x])\n            DFS2(col, i, t);\n        return;\n    &#125;;\n    std::function&lt;void(int, std::set&lt;int&gt; &amp;)&gt; DFS1 = [&amp;](int x, std::set&lt;int&gt; &amp;t) &#123;\n        if (son[x])\n            DFS1(son[x], t);\n        for (auto i : g[x])\n            if (i != son[x]) &#123;\n                std::set&lt;int&gt; nt;\n                DFS1(i, nt);\n            &#125;\n        t.insert(a[x]);\n        for (auto i : g[x])\n            if (i != son[x])\n                DFS2(a[x], i, t), DFS2(-1, i, t);\n        return;\n    &#125;;\n    &#123;\n        std::set&lt;int&gt; t;\n        DFS1(1, t);\n    &#125;\n    std::vector&lt;long long&gt; res(m + 1);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; t(n + 1);\n    for (int i = 1, l, r; i &lt;= m; ++i) &#123;\n        std::cin &gt;&gt; l &gt;&gt; r;\n        t[r].emplace_back(l, i);\n    &#125;\n    bld(1, 1, n);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (auto [l, r] : u1[i])\n            add(1, l, r, 1);\n        for (auto [l, r] : u2[i])\n            add(1, l, r, -1);\n        upd(1, 1, i);\n        for (auto [l, id] : t[i])\n            res[id] = ask(1, l, i);\n    &#125;\n    for (int i = 1; i &lt;= m; ++i)\n        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "支配对"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250826/",
            "url": "https://xsc062.netlify.app/20250826/",
            "title": "学习笔记 Kruskal 重构树",
            "date_published": "2025-08-26T07:21:09.000Z",
            "content_html": "<p>有很多优秀性质的东西，应用场景比较明显</p>\n<span id=\"more\"></span>\n<hr />\n<p>把 Kruskal 过程中，一次合并连通块的操作看作，建立一个边的虚点，把这个虚点和两侧连通块的根连起来，并成为新连通块的根</p>\n<p>这样就可以把图变成一个二叉树，并且点权从浅到深是单增的，也就是<strong>大根堆</strong>，而且有且仅有实点是叶子</p>\n<p>原图中『两个点路径上最大边权』的最小值，就是重构树上路径边权的最大值，<strong>即两点 LCA 的点权</strong>。</p>\n<p>反过来，如果要找到 <span class=\"math inline\">\\(u\\)</span> 的最大边权最小值 <span class=\"math inline\">\\(\\le w\\)</span> 的所有 <span class=\"math inline\">\\(v\\)</span>，会发现是某个子树的所有实点（叶子）</p>\n<hr />\n<p>实际应用起来不只跟边权有关系，很多时候需要想办法把点权转化成边权，再在重构树上研究原本的点权问题，标志是『找树 / 图上两点间的编号 / 点权最值』</p>\n",
            "tags": [
                "Kruskal 重构树"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250825/",
            "url": "https://xsc062.netlify.app/20250825/",
            "title": "学习笔记 DP 套 DP",
            "date_published": "2025-08-25T12:20:48.000Z",
            "content_html": "\n",
            "tags": []
        },
        {
            "id": "https://xsc062.netlify.app/20250824/",
            "url": "https://xsc062.netlify.app/20250824/",
            "title": "杂题",
            "date_published": "2025-08-24T07:37:55.000Z",
            "content_html": "<p>不会的东西越来越多了</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"b.-k-set-tree\">B. K-Set Tree</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1691F\" class=\"uri\">https://www.luogu.com.cn/problem/CF1691F</a></p>\n<p>令 <span class=\"math inline\">\\(F_i\\)</span> 表示以 <span class=\"math inline\">\\(1\\)</span> 为根时，<span class=\"math inline\">\\(S\\)</span> 在 <span class=\"math inline\">\\(i\\)</span> 子树内的答案。则：</p>\n<p><span class=\"math display\">\\[\nF_u=\\left(C_{siz_u}^k-\\sum C_{siz_v}^k\\right)\\cdot siz_u+\\sum F_v\\\\\n\\]</span></p>\n<p>直接换根是很复杂的；把 <span class=\"math inline\">\\(\\sum C_{siz_v}^k\\)</span> 记作 <span class=\"math inline\">\\(dp_u\\)</span>，把 <span class=\"math inline\">\\(\\sum F_v\\)</span> 记作 <span class=\"math inline\">\\(f_u\\)</span>，那么：</p>\n<p><span class=\"math display\">\\[\nres=\\sum(C_n^k-dp_u)\\cdot n+f_u\\\\\n\\]</span></p>\n<p><strong>这样做是为了把两个和 <span class=\"math inline\">\\(v\\)</span> 有关的乘项拆开来换根</strong>，实际换根的时候就只用分别换 <span class=\"math inline\">\\(f,dp\\)</span> 两个值，不用考虑二次项等问题，计算量会少很多</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[n] = qkp(fac[n], mod - 2);\n    for (int i = n - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto C = [&amp;](int n, int m) &#123;\n        if (m &gt; n)\n            return 0ll;\n        return fac[n] * inv[m] % mod * inv[n - m] % mod;\n    &#125;;\n    auto res(0ll);\n    std::vector&lt;int&gt; siz(n + 1), ss(n + 1);\n    std::vector&lt;long long&gt; f(n + 1), dp(n + 1);\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        siz[x] = 1;\n        for (auto i : g[x])\n            if (i != fa) &#123;\n                DFS(i, x);\n                (f[x] += (C(siz[i], k) - dp[i]) * siz[i] + f[i]) %= mod;\n                (dp[x] += C(siz[i], k)) %= mod;\n                siz[x] += siz[i];\n            &#125;\n        return;\n    &#125;;\n    DFS(1, -1);\n    DFS = [&amp;](int x, int fa) &#123;\n        (res += (C(n, k) - dp[x]) * n + f[x]) %= mod;\n        for (auto i : g[x])\n            if (i != fa) &#123;\n                (f[i] += (C(n - siz[i], k) - (dp[x] - C(siz[i], k))) * (n - siz[i]) + f[x] - f[i] - (C(siz[i], k) - dp[i]) * siz[i]) %= mod;\n                (dp[i] += C(n - siz[i], k)) %= mod;\n                DFS(i, x);\n            &#125;\n        return;\n    &#125;;\n    DFS(1, -1);\n    std::cout &lt;&lt; (res + mod) % mod &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c.-li-hua-and-path\">C. Li Hua and Path</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1797F\" class=\"uri\">https://www.luogu.com.cn/problem/CF1797F</a></p>\n<p>考虑<strong>容斥</strong>，分别求解满足 1、满足 2、满足 12（注意要减两倍）就能计算答案</p>\n<p>发现题目所求点对形式很符合 Kruskal 重构树的要求，考虑以对应点权为边权，分别建立 min，max Kruskal 点权多叉重构树。</p>\n<details>\n<p><summary>点权多叉重构树？</summary></p>\n<p>在点权上做 Kruskal 重构树时，发现边的虚点是不必要的，可以直接将更优点作为父亲。</p>\n<p>写的时候有点难想清楚…… 可以画画图，仔细确定一下 Kruskal 重构树的具体性质</p>\n<p>这样做的优势是没有虚点，一些问题会方便一些；但同时放弃了二叉树的结构，一些题可能没那么好做。</p>\n<p>这道题只用经典 Kruskal 重构树也可以解决。</p>\n</details>\n<p>发现 1 2 均可以转化成两棵树在两棵树上的祖孙关系要求，可以轻松地分别统计满足 1、满足 2 的点对数量</p>\n<p>考虑怎么处理同时满足 12 的，发现要求在两棵树上二者应该都具有祖孙关系，且是相反的。<del>可以考虑在一棵树上 DFS 的同时用主席树存储祖先，在另一颗树上 ask</del></p>\n<p>考虑从更容易用 dfn 表示的子树问题思考，在 min 树上分配 dfn 后，在 max 树上用 DFS + 回溯得到每个点实时祖先序列，存在树状数组里；ask 该点被分配的 dfn 子树区间就能得到答案。</p>\n<p>考虑询问，由于每次加入的都是编号最大的点，对于满足 1、满足 2 的贡献是显然的，而同时满足 12 的点就是在 min 树上的祖先，都是好做的。</p>\n<p>实现的时候一定要把 min / max 树对应的性质思考清楚，不然会很麻烦</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; f1(n + 1), f2(n + 1);\n    std::iota(f1.begin() + 1, f1.end(), 1);\n    std::iota(f2.begin() + 1, f2.end(), 1);\n    std::function&lt;int(int)&gt; find1 = [&amp;](int x) &#123;\n        return x == f1[x] ? x : f1[x] = find1(f1[x]);\n    &#125;;\n    std::function&lt;int(int)&gt; find2 = [&amp;](int x) &#123;\n        return x == f2[x] ? x : f2[x] = find2(f2[x]);\n    &#125;;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1), g2(n + 1), adj1(n + 1), adj2(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        if (x &gt; y)\n            std::swap(x, y);\n        adj1[y].push_back(x);\n        adj2[x].push_back(y);\n    &#125;\n    for (int i = 1; i &lt;= n; ++i)\n        for (auto j : adj1[i]) &#123;\n            int fi = find1(i), fj = find1(j);\n            g1[fi].push_back(fj), f1[fj] = fi;\n        &#125;\n    for (int i = n; i; --i)\n        for (auto j : adj2[i]) &#123;\n            int fi = find2(i), fj = find2(j);\n            g2[fi].push_back(fj), f2[fj] = fi;\n        &#125;\n    std::vector&lt;int&gt; bit(n + 1), dfn(n + 1), rfn(n + 1);\n    auto lowbit = [](int x) &#123;\n        return x &amp; -x;\n    &#125;;\n    auto add = [&amp;](int x, int v) &#123;\n        for (; x &lt;= n; x += lowbit(x))\n            bit[x] += v;\n        return;\n    &#125;;\n    auto ask = [&amp;](int x) &#123;\n        int res = 0;\n        for (; x; x -= lowbit(x))\n            res += bit[x];\n        return res;\n    &#125;;\n    int rt1 = 0, rt2 = 0;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        if (f1[i] == i)\n            rt1 = i;\n        if (f2[i] == i)\n            rt2 = i;\n    &#125;\n    int q;\n    std::cin &gt;&gt; q;\n    std::vector&lt;int&gt; dep1(n + 1), dep2(n + q + 1);\n    long long res = 0ll;\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        dfn[x] = ++now;\n        res += dep1[x];\n        for (auto i : g1[x]) &#123;\n            dep1[i] = dep1[x] + 1;\n            DFS(i);\n        &#125;\n        rfn[x] = now;\n        return;\n    &#125;;\n    DFS(rt1);\n    DFS = [&amp;](int x) &#123;\n        res += dep2[x];\n        res -= 2 * (ask(rfn[x]) - ask(dfn[x] - 1));\n        add(dfn[x], 1);\n        for (auto i : g2[x]) &#123;\n            dep2[i] = dep2[x] + 1;\n            DFS(i);\n        &#125;\n        add(dfn[x], -1);\n        return;\n    &#125;;\n    DFS(rt2);\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    for (int fa; q--; ) &#123;\n        std::cin &gt;&gt; fa;\n        dep2[++n] = dep2[fa] + 1;\n        res += (n - 1) - dep2[n];\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d.-团队选拔\">D. 团队选拔</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6534/problem/4\" class=\"uri\">http://222.180.160.110:61235/contest/6534/problem/4</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(a_{1\\sim n}\\)</span>，从中任选一些互不相交的区间，满足每个区间内元素的 gcd 相同。</p>\n<p><span class=\"math inline\">\\(n\\le 10^5,V\\le 10^7\\)</span>。</p>\n</blockquote>\n<p>注意到固定一个左端点后，移动右端点，gcd 每次至多减小到原来的一半；也就是说，其种类有 <span class=\"math inline\">\\(\\log V\\)</span> 种。故全序列的 gcd 总数是 <span class=\"math inline\">\\(O(n\\log V)\\)</span> 的。</p>\n<p>很容易想到与此原理类似的全局答案求法：对于每个 <span class=\"math inline\">\\(i\\)</span>，向左处理出每一段 <span class=\"math inline\">\\([l,r]\\)</span>，满足 <span class=\"math inline\">\\(\\gcd(a_{l\\cdots i})=\\gcd(a_r\\cdots i)\\)</span>，并记录该 <span class=\"math inline\">\\(\\gcd\\)</span>。这样求出来的 <span class=\"math inline\">\\((i,l,r)\\)</span> 共有 <span class=\"math inline\">\\(O(n\\log V)\\)</span> 段。</p>\n<p>对于每个 gcd 有 <span class=\"math inline\">\\(f_{i}=f_{i-1}+\\sum\\limits_{j=l_i}^{r_i} f_{j - 1}\\)</span>，可以做一个扫描线，得到全局答案；向前向后分别做到 <span class=\"math inline\">\\(i-1,i+1\\)</span>，相乘就能得到 <span class=\"math inline\">\\(i\\)</span> 未被选取时的答案</p>\n<p>考虑怎么完成『相乘』这个动作：最后的 <span class=\"math inline\">\\(f\\)</span> 在每个右端点处发生变化，可以转化成若干段 <span class=\"math inline\">\\(f\\)</span>；反过来的 <span class=\"math inline\">\\(f&#39;\\)</span> 亦可以这样转化。将 <span class=\"math inline\">\\(f\\)</span> 整体后移一位、<span class=\"math inline\">\\(f&#39;\\)</span> 整体前移一位，就可以对齐。二者的端点总数是均摊单 log 的，区间总数也就是均摊单 log 的（归并就能快速寻找到区间），用差分做一个区间加即可。</p>\n<p>用二分勉强单 log 解决了转移；还看到 <span class=\"citation\" data-cites=\"spdarkle\">@spdarkle</span> 疑似在 <span class=\"math inline\">\\(1\\sim n\\)</span> 上直接做的<a href=\"http://222.180.160.110:61235/submission/3108272\">做法</a>，和 <span class=\"citation\" data-cites=\"Rosmist\">@Rosmist</span> 疑似直接在每个 <span class=\"math inline\">\\(i\\)</span> 上做的<a href=\"http://222.180.160.110:61235/submission/3108581\">做法</a>。官解是个看不懂的做法</p>\n<p>呃，好像一不小心拿了最优解。而且优势很明显（怎么总用时比别人一个点还少？），这是为什么？</p>\n<p>可能因为大家都看不懂官解，做法比较多样？除了我之外比较快的 lwz 和 <span class=\"citation\" data-cites=\"GoldSpade\">@GoldSpade</span> 都用归并完成最后一步；我较他们的额外优势大概是用二分换掉了树状数组？迷惑</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;selection.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;selection.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;ex_selection2.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; st(20, std::vector&lt;int&gt; (n + 1));\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i], st[0][i] = a[i];\n    for (int j = 1; (1 &lt;&lt; j) &lt;= n; ++j)\n        for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i)\n            st[j][i] = std::__gcd(st[j - 1][i], st[j - 1][i + (1 &lt;&lt; (j - 1))]);\n    auto askgcd = [&amp;](int l, int r) &#123;\n        int k = std::__lg(r - l + 1);\n        return std::__gcd(st[k][l], st[k][r - (1 &lt;&lt; k) + 1]);\n    &#125;;\n    std::unordered_map&lt;int, int&gt; tab;\n    struct node &#123;\n        int i, l, r;\n        bool operator&lt; (const int q) const &#123;\n            return i &lt; q;\n        &#125;\n        bool operator&lt;= (const int q) const &#123;\n            return i &lt;= q;\n        &#125;\n    &#125;;\n    std::vector&lt;std::vector&lt;node&gt; &gt; p1, p2;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int to = i; to &gt;= 1; ) &#123;\n            int at = i, g = askgcd(to, i);\n            for (int l = 1, r = to, mid; l &lt;= r; ) &#123;\n                mid = (l + r) &gt;&gt; 1;\n                if (askgcd(mid, i) == g)\n                    at = mid, r = mid - 1;\n                else\n                    l = mid + 1;\n            &#125;\n            if (!tab.count(g)) &#123;\n                tab[g] = (int)p1.size();\n                p1.emplace_back(), p2.emplace_back();\n            &#125;\n            p1[tab[g]].push_back(&#123; i, at, to &#125;);\n            to = at - 1;\n        &#125;\n        for (int to = i; to &lt;= n; ) &#123;\n            int at = i, g = askgcd(i, to);\n            for (int l = to, r = n, mid; l &lt;= r; ) &#123;\n                mid = (l + r) &gt;&gt; 1;\n                if (askgcd(i, mid) == g)\n                    at = mid, l = mid + 1;\n                else\n                    r = mid - 1;\n            &#125;\n            if (!tab.count(g)) &#123;\n                tab[g] = (int)p2.size();\n                p1.emplace_back(), p2.emplace_back();\n            &#125;\n            p2[tab[g]].push_back(&#123; i, to, at &#125;);\n            to = at + 1;\n        &#125;\n    &#125;\n    auto s(0ll);\n    std::vector&lt;int&gt; x1(n + 1), x2(n + 2), pos(2 * n + 3);\n    std::vector&lt;long long&gt; f1(n + 1), f2(n + 2), s1(n + 1), s2(n + 2), diff(n + 1);\n    for (auto [g, id] : tab) &#123;\n        // printf(&quot;g = %d: \\n&quot;, g);\n        int n1 = (int)p1[id].size();\n        x1[0] = 0, f1[0] = s1[0] = 1ll;\n        for (int i = 1; i &lt;= n1; ++i) &#123;\n            auto [x, L, R] = p1[id][i - 1];\n            --L, --R;\n            x1[i] = x, f1[i] = f1[i - 1];\n            int l = std::upper_bound(x1.begin() + 1, x1.begin() + i + 1, L) - x1.begin() - 1,\n                r = std::upper_bound(x1.begin() + 1, x1.begin() + i + 1, R) - x1.begin() - 1;\n            if (l == r)\n                (f1[i] += f1[l] * (R - L + 1)) %= mod;\n            else &#123;\n                f1[i] += s1[r - 1] + mod - s1[l];\n                f1[i] += f1[r] * (R - x1[r] + 1);\n                f1[i] += f1[l] * (x1[l + 1] - L);\n                f1[i] %= mod;\n            &#125;\n            // printf(&quot;  r = %d, l = [%d, %d]: %lld\\n&quot;, x, L, R, f1[i]);\n            if (i != n1)\n                s1[i] = (s1[i - 1] + f1[i] * (p1[id][i].i - x)) % mod;\n        &#125;\n        (s += f1[n1] - 1) %= mod;\n        int n2 = (int)p2[id].size();\n        x2[n2 + 1] = n + 1, f2[n2 + 1] = s2[n2 + 1] = 1ll;\n        for (int i = n2; i; --i) &#123;\n            auto [x, L, R] = p2[id][i - 1];\n            ++L, ++R;\n            x2[i] = x, f2[i] = f2[i + 1];\n            int l = std::lower_bound(x2.begin() + i, x2.begin() + n2 + 1, L) - x2.begin(),\n                r = std::lower_bound(x2.begin() + i, x2.begin() + n2 + 1, R) - x2.begin();\n            if (l == r)\n                (f2[i] += f2[l] * (R - L + 1)) %= mod;\n            else&#123;\n                f2[i] += s2[l + 1] + mod - s2[r];\n                f2[i] += f2[r] * (R - x2[r - 1]);\n                f2[i] += f2[l] * (x2[l] - L + 1);\n                f2[i] %= mod;\n            &#125;\n            // printf(&quot;  l = %d, r = [%d, %d]: %lld\\n&quot;, x, L, R, f2[i]);\n            if (i != 1)\n                s2[i] = (s2[i + 1] + f2[i] * (x - p2[id][i - 2].i)) % mod;\n        &#125;\n        for (int i = 0; i &lt; n1; ++i)\n            x1[i] = x1[i + 1];\n        x1[n1] = n;\n        int t = (x2[1] == 1) + 1;\n        for (int i = 1; i &lt;= n2 + 1; ++i)\n            --x2[i];\n        std::merge(x1.begin(), x1.begin() + n1 + 1, x2.begin() + t, x2.begin() + n2 + 2, pos.begin() + 1);\n        int m = std::unique(pos.begin() + 1, pos.begin() + n1 + n2 + 4 - t) - pos.begin() - 1;\n        for (int i = 1, p1 = 0, p2 = t, la = 0; i &lt;= m; ++i) &#123;\n            for (; p1 + 1 &lt;= n1 &amp;&amp; x1[p1] &lt; pos[i]; ++p1);\n            for (; p2 + 1 &lt;= n2 + 1 &amp;&amp; x2[p2] &lt; pos[i]; ++p2);\n            (diff[la + 1] += f1[p1] * f2[p2] + mod - 1) %= mod;\n            // printf(&quot;  [%d, %d]: %lld, %lld\\n&quot;, la + 1, pos[i], f1[p1], f2[p2]);\n            if (pos[i] + 1 &lt;= n)\n                (diff[pos[i] + 1] += mod - f1[p1] * f2[p2] + 1) %= mod;\n            la = pos[i];\n        &#125;\n    &#125;\n    // std::cout &lt;&lt; s &lt;&lt; &#39;\\n&#39;;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        (diff[i] += diff[i - 1]) %= mod;\n        std::cout &lt;&lt; (s + mod - diff[i]) % mod &lt;&lt; &#39; &#39;;\n    &#125;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<p>我一开始将 <span class=\"math inline\">\\(f\\)</span> 定义为单点答案而非前缀和，会导致需要线段树维护等差序列，还丢失了答案段数不多这个性质，非常麻烦。将 <span class=\"math inline\">\\(f\\)</span> 的意义替换为前缀和后，就可以很轻松地做了。</p>\n<hr />\n<h2 id=\"a.-宇宙\">A. 宇宙</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6535/problem/1\" class=\"uri\">http://222.180.160.110:61235/contest/6535/problem/1</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(a_{1\\sim n}\\)</span>，对于 <span class=\"math inline\">\\(k=1,2,\\cdots,n-1\\)</span>，回答：</p>\n<ul>\n<li>令 <span class=\"math inline\">\\(i\\)</span> 从 <span class=\"math inline\">\\(1\\)</span> 开始自增，对于每个 <span class=\"math inline\">\\(i\\)</span>，都可以选取 <span class=\"math inline\">\\(k\\)</span> 个互不相同的下标，并使它们对应的元素增加 1。此时，若存在元素不大于 <span class=\"math inline\">\\(i\\)</span>，停止。输出停止时 <span class=\"math inline\">\\(i\\)</span> 可能的最大值。</li>\n</ul>\n<p><span class=\"math inline\">\\(n\\le 10^6,V\\le 10^9\\)</span>。</p>\n</blockquote>\n<p>发现不大于这个 condition 有些反人类，先将 <span class=\"math inline\">\\(a\\)</span> 全部减 1，转化成小于来考虑</p>\n<p>考虑能坚持到 <span class=\"math inline\">\\(i\\)</span> 的一个必要条件，即 <span class=\"math inline\">\\(\\sum\\limits_{a_j&lt;i} i-a_j\\le k\\cdot i\\)</span></p>\n<p>容易发现该条件同时是充分的，同样从线段覆盖的角度出发，是一个 <span class=\"math inline\">\\(k\\)</span> 的扩展</p>\n<p>对 <span class=\"math inline\">\\(a\\)</span> 排序，停止时参与运算的 <span class=\"math inline\">\\(a_j\\)</span> 是越来越多的，故记录最后一个参与运算的下标，逐步挪动（当发现解出来的 <span class=\"math inline\">\\(i\\)</span> 比下一个更大时就需要挪动），同时解不等式即可。</p>\n<p><span class=\"citation\" data-cites=\"Quack\">@Quack</span> 云我在场上能想出官解对我来说是非常了不起的（其实场上写正解的人少得出奇），我也不得不承认我能做出来确实有一定运气成分，也能从中一窥我令人眼前一黑的数学素养！</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n    std::freopen(&quot;universe.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;universe.out&quot;, &quot;w&quot;, stdout);\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    int n;\n    std::cin &gt;&gt; n, std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i], --a[i];\n    std::sort(a.begin() + 1, a.end());\n    int id = 1;\n    long long s = a[1];\n    for (int i = 1; i &lt; n; ++i) &#123;\n        if (id &lt; i + 1)\n            s += a[++id];\n        long long x = s / (id - i);\n        for (; id != n &amp;&amp; x &gt; a[id + 1]; s += a[++id], x = s / (id - i));\n        std::cout &lt;&lt; x &lt;&lt; &#39; &#39;;\n    &#125;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b.-跳跃\">B. 跳跃</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6535/problem/2\" class=\"uri\">http://222.180.160.110:61235/contest/6535/problem/2</a></p>\n<blockquote>\n<p>给定长度为 <span class=\"math inline\">\\(n\\)</span> 的 01 序列和跳跃上限 <span class=\"math inline\">\\(k\\)</span>。给定 <span class=\"math inline\">\\(q\\)</span> 个询问，回答：</p>\n<ul>\n<li>从 <span class=\"math inline\">\\(a\\)</span> 跳到 <span class=\"math inline\">\\(b\\)</span>，保证 <span class=\"math inline\">\\(a,b\\)</span> 的颜色均为 1，每次不能跳超过 <span class=\"math inline\">\\(k\\)</span> 格或跳出去，在最小化踩到 0 数量的前提下，最小化跳跃次数，输出这两个值。</li>\n</ul>\n<p><span class=\"math inline\">\\(n,q\\le5\\times10^5\\)</span>。</p>\n</blockquote>\n<p>容易发现只能往一个方向跳，那么不妨令 <span class=\"math inline\">\\(a&lt;b\\)</span>。有一个贪心的想法是能往右就往右，手玩发现<strong>是对的</strong>（我场上手玩过后坚定地认为是错的；可能和没时间了兵荒马乱有关）。这样就很好想到第二问需要倍增；但把两个问结合起来考虑是有点困难的，赛时就意识到这两问的联系没有看起来那么大，甚至很可能是割裂的。</p>\n<p>单独考虑第一问，发现对于一段长度为 <span class=\"math inline\">\\(len\\)</span> 的 0，需要踩到恰好 <span class=\"math inline\">\\(\\left\\lfloor\\dfrac {len}k\\right\\rfloor\\)</span> 个 0。答案容易计算。</p>\n<p>单独考虑第二问，考虑一个第一问答案固定为 0 的情况，也即每个 len 都比 <span class=\"math inline\">\\(k\\)</span> 小。则问题转化成在不踩 0 的情况下最小的步数。容易用倍增解决。</p>\n<p>本题最令人印象深刻的点在于二者的结合，发现这 <span class=\"math inline\">\\(\\left\\lfloor\\dfrac {len}k\\right\\rfloor\\cdot k\\)</span> 个 0 是无论如何都会被经过的，所以可以在原始数组里删掉它们，转化成只考虑第二问的情况</p>\n<details>\n<p>？？？</p>\n<p>我对于自己莫名其妙跑得比别人块一大截这件事情已经快要见怪不怪了，这次又是什么原理，我预处理写得比较漂亮吗？？</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;jump.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;jump.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, k, q, op;\n    std::cin &gt;&gt; n, std::cin &gt;&gt; n &gt;&gt; q &gt;&gt; k &gt;&gt; op;\n    std::vector&lt;int&gt; tmp(n + 1), a(1), s(1), to(n + 2);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        char t;\n        std::cin &gt;&gt; t;\n        tmp[i] = t - &#39;0&#39;;\n    &#125;\n    tmp.push_back(1), ++n;\n    int cnt = 0;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        if (tmp[i] == 1) &#123;\n            a.push_back(1), to[i] = (int)a.size() - 1;\n            s.push_back(s.back() + cnt), cnt = 0;\n        &#125;\n        else &#123;\n            ++cnt;\n            if (i == n || tmp[i + 1] == 1) &#123;\n                for (int j = 1; j &lt;= cnt % k; ++j)\n                    a.push_back(0), s.push_back(s.back());\n                cnt /= k;\n            &#125;\n        &#125;\n    &#125;\n    n = (int)a.size() - 1;\n    std::vector&lt;std::vector&lt;int&gt; &gt; f(20, std::vector&lt;int&gt; (n + 1));\n    for (int i = 0; i &lt; 20; ++i)\n        f[i][n] = n;\n    for (int i = n - 1; i; --i) &#123;\n        f[0][i] = std::min(&#123; n, i + k, f[0][i + 1] &#125;);\n        for (; !a[f[0][i]]; --f[0][i]);\n        if (a[i] == 1) &#123;\n            for (int j = 1; j &lt; 20; ++j)\n                f[j][i] = f[j - 1][f[j - 1][i]];\n        &#125;\n    &#125;\n    for (int a, b; q--; ) &#123;\n        std::cin &gt;&gt; a &gt;&gt; b;\n        if (a &gt; b)\n            std::swap(a, b);\n        a = to[a], b = to[b];\n        std::cout &lt;&lt; s[b] - s[a];\n        if (op == 1) &#123;\n            int res = s[b] - s[a];\n            for (int i = 19; ~i; --i)\n                if (f[i][a] &lt; b)\n                    a = f[i][a], res += (1 &lt;&lt; i);\n            std::cout &lt;&lt; &#39; &#39; &lt;&lt; res + 1;\n        &#125;\n        std::cout &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d.-jongmah\">D. Jongmah</h2>\n<p><a href=\"https://codeforces.com/contest/1110/problem/D\" class=\"uri\">https://codeforces.com/contest/1110/problem/D</a></p>\n<p>容易发现当连续出现三次 <span class=\"math inline\">\\((i-1,i,i+1)\\)</span> 时，可以被三次相同代替；</p>\n<p>容易发现需要使用 <span class=\"math inline\">\\(f_{i,a,b}\\)</span> 来代表 DP 到 <span class=\"math inline\">\\(i\\)</span> 时，用了 <span class=\"math inline\">\\(a\\)</span> 组 <span class=\"math inline\">\\((i-1,i,i+1)\\)</span> 和 <span class=\"math inline\">\\(b\\)</span> 组 <span class=\"math inline\">\\((i,i+1,i+2)\\)</span> 时的最大组数；</p>\n<p>但是并没有想到要将二者结合起来！感觉应该是能比较快做出来的水平。能察觉到不太认真。悔过！</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int inf = 0x3f3f3f3f;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;int&gt; cnt(m + 1);\n    for (int i = 1, x; i &lt;= n; ++i)\n        std::cin &gt;&gt; x, ++cnt[x];\n    std::vector&lt;std::vector&lt;std::vector&lt;int&gt; &gt; &gt; f(m + 1, std::vector&lt;std::vector&lt;int&gt; &gt; (3, std::vector&lt;int&gt; (3, -inf)));\n    f[0][0][0] = 0ll;\n    for (int i = 1; i &lt;= m; ++i)\n        for (int a = 0; a &lt;= 2; ++a) // i - 1, i, i + 1\n            for (int b = 0; b &lt;= 2; ++b) // i, i + 1, i + 2\n                for (int c = 0; c &lt;= 2; ++c) &#123; // i - 2, i - 1, i\n                    if (a + b + c &gt; cnt[i]) continue;\n                    f[i][a][b] = std::max(f[i][a][b], f[i - 1][c][a] + b + (cnt[i] - a - b - c) / 3);\n                &#125;\n    std::cout &lt;&lt; f[m][0][0] &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"e.-magic-stones\">E. Magic Stones</h2>\n<p><a href=\"https://codeforces.com/contest/1110/problem/F\" class=\"uri\">https://codeforces.com/contest/1110/problem/F</a></p>\n<p>容易想到考察差分数组，发现这个操作就是交换了差分数组的相邻两个元素。故对于 <span class=\"math inline\">\\(c\\)</span> 和 <span class=\"math inline\">\\(t\\)</span> 的差分数组分别排序，然后 check 是否相等即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1), b(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; b[i];\n    if (a[1] != b[1] || a[n] != b[n]) &#123;\n        std::cout &lt;&lt; &quot;No&quot; &lt;&lt; &#39;\\n&#39;;\n        return 0;\n    &#125;\n    std::vector&lt;int&gt; da(n), db(n);\n    std::adjacent_difference(a.begin() + 1, a.end(), da.begin());\n    std::adjacent_difference(b.begin() + 1, b.end(), db.begin());\n    std::sort(da.begin(), da.end());\n    std::sort(db.begin(), db.end());\n    std::cout &lt;&lt; (da == db ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "倍增",
                "树形 DP",
                "Kruskal 重构树"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250822/",
            "url": "https://xsc062.netlify.app/20250822/",
            "title": "猫树 学习笔记",
            "date_published": "2025-08-22T01:13:46.000Z",
            "content_html": "<p>分治树</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"概念\">概念</h2>\n<ul>\n<li>线段树不能维护背包的原因是 pushup 复杂度太高（单次 <span class=\"math inline\">\\(O(V^2)\\)</span>）。如果确定了要询问的体积（单点 / 区间），能否降低单次合并的复杂度？</li>\n<li>想到 <a href=\"/20250520/#贪玩蓝月\">贪玩蓝月</a> 这个题，如果存在一个 <span class=\"math inline\">\\(mid\\)</span> 在询问区间内，从 <span class=\"math inline\">\\(mid\\)</span> 往两侧预处理对应的单侧前后缀答案，最后询问的时候复杂度就比较低</li>\n<li><p>考虑分治，这样就可以使得对于任意一个询问，总存在一段分治区间将其包含，且分治区间的 <span class=\"math inline\">\\(mid\\)</span> 在询问内。</p>\n<p>这样就可以单 log 预处理之后，比较快地查询。</p>\n<p>基于这样的预处理形式，所以只能支持静态问题。</p>\n空间复杂度为 <span class=\"math inline\">\\(O(n\\log n)\\)</span>，有一些降空间的实现技巧，这里不赘述</li>\n<li><p>实现起来会发现很像链上的点分，也会联想到 <a href=\"/20250819/#星白-by-ttpandas笛卡尔树-dsu-on-tree\">星白</a>，只是这个题更像是 dsu on tree。</p></li>\n</ul>\n<hr />\n<p>对于树上问题，在 uoj 上翻到一个 <span class=\"math inline\">\\(O(n\\log n)\\)</span> 预处理，<span class=\"math inline\">\\(O(1)\\)</span> 单次查询的做法 <a href=\"https://return20071007.blog.uoj.ac/blog/7500\">link</a></p>\n<p>实际上并不用猫树，只需要点分树预处理，欧拉序求 LCA 即可。</p>\n<hr />\n<h2 id=\"a---好吃的题目\">A - 好吃的题目</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P6240\" class=\"uri\">https://www.luogu.com.cn/problem/P6240</a></p>\n<p>背包合并的 单点询问 和 前缀询问 都是 <span class=\"math inline\">\\(O(V)\\)</span> 的，任意区间 是 <span class=\"math inline\">\\(O(V\\log V)\\)</span> 的，也支持取模，像贪玩蓝月那样的</p>\n<p>然后就比较板了</p>\n<p>发现空间不太对，需要把询问离线下来，其实就是经典分治</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, q;\n    std::cin &gt;&gt; n &gt;&gt; q;\n    std::vector&lt;int&gt; v(n + 1), w(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; v[i];\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; w[i];\n    n = 1 &lt;&lt; (std::__lg(n) + 1);\n    v.resize(n), w.resize(n);\n    struct node &#123; int i, l, m; &#125;;\n    std::vector&lt;int&gt; res(q + 1);\n    std::vector&lt;std::vector&lt;std::vector&lt;node&gt; &gt; &gt; t(17, std::vector&lt;std::vector&lt;node&gt; &gt; (n + 1));\n    for (int i = 1, l, r, m; i &lt;= q; ++i) &#123;\n        std::cin &gt;&gt; l &gt;&gt; r &gt;&gt; m;\n        if (l == r)\n            res[i] = (m &gt;= v[l] ? w[l] : 0);\n        else &#123;\n            int d = std::__lg(l ^ r);\n            t[d][r].push_back(&#123; i, l, m &#125;);\n        &#125;\n    &#125;\n    std::vector&lt;std::array&lt;int, 201&gt; &gt; f(n + 1);\n    std::function&lt;void(int, int)&gt; calc = [&amp;](int l, int r) &#123;\n        int d = std::__lg(r - l + 1) - 1;\n        if (l == r)\n            return;\n        int mid = (l + r) &gt;&gt; 1;\n        calc(l, mid), calc(mid + 1, r);\n        for (int i = 0; i &lt;= 200; ++i)\n            f[mid][i] = (i &gt;= v[mid] ? w[mid] : 0);\n        for (int i = mid - 1; i &gt;= l; --i)\n            for (int j = 0; j &lt;= 200; ++j) &#123;\n                f[i][j] = f[i + 1][j];\n                if (v[i] &lt;= j)\n                    f[i][j] = std::max(f[i][j], f[i + 1][j - v[i]] + w[i]);\n            &#125;\n        for (int i = 0; i &lt;= 200; ++i) &#123;\n            f[mid + 1][i] = (i &gt;= v[mid + 1] ? w[mid + 1] : 0);\n            for (auto [id, l, m] : t[d][mid + 1])\n                if (i &lt;= m)\n                    res[id] = std::max(res[id], f[mid + 1][i] + f[l][m - i]);\n        &#125;\n        for (int i = mid + 2; i &lt;= r; ++i)\n            for (int j = 0; j &lt;= 200; ++j) &#123;\n                f[i][j] = f[i - 1][j];\n                if (v[i] &lt;= j)\n                    f[i][j] = std::max(f[i][j], f[i - 1][j - v[i]] + w[i]);\n                for (auto [id, l, m] : t[d][i])\n                    if (j &lt;= m)\n                        res[id] = std::max(res[id], f[i][j] + f[l][m - j]);\n            &#125;\n        return;\n    &#125;;\n    calc(0, n - 1);\n    for (int i = 1; i &lt;= q; ++i)\n        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---子序列\">B - 子序列</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P8885\" class=\"uri\">https://www.luogu.com.cn/problem/P8885</a></p>\n<p>规范称呼：<strong>好子序列</strong>、<strong>好子串</strong>、<strong>好整串</strong>。</p>\n<p>考虑不含 <code>?</code> 的<strong>好子串</strong>判定，朴素 DP，令 <span class=\"math inline\">\\(f_{i,0/1}\\)</span> 表示 DP 到 <span class=\"math inline\">\\(i\\)</span>，子序列末尾为 <span class=\"math inline\">\\(0/1\\)</span> 时的子序列数量奇偶性。有：</p>\n<p><span class=\"math display\">\\[\nf_{i,0}=\\begin{cases}\nf_{i-1,0}+f_{i-1,1}+1&amp;a_i=0\\\\\nf_{i-1,0}&amp;a_i=1\n\\end{cases},\\\\f_{i,1}=\\begin{cases}\nf_{i-1,1}&amp;a_i=0\\\\\nf_{i-1,0}+f_{i-1,1}+1&amp;a_i=1\n\\end{cases}\n\\]</span></p>\n<p>观察发现 <span class=\"math inline\">\\(f_{0},f_{1}\\)</span> 中只有至多一个为 <span class=\"math inline\">\\(1\\)</span>。令 <span class=\"math inline\">\\(f_2\\)</span> 为一当且仅当 <span class=\"math inline\">\\(f_0,f_1\\)</span> 均不为 <span class=\"math inline\">\\(1\\)</span>。考虑 <span class=\"math inline\">\\(1\\)</span> 所在位置，建立 DFA：</p>\n<p><img src=\"image.png\" /></p>\n<p>如需加入 <code>?</code>，转化为 NFA。注意到只关心每个点上指针数量的奇偶性，故压缩为 <span class=\"math inline\">\\({c_0,c_1,c_2}\\)</span> 记录。考虑对<strong>好子串</strong>计数。每次在 <span class=\"math inline\">\\(2\\)</span> 处加入一个新的 <span class=\"math inline\">\\(1\\)</span> 表示空串，再令所有指针移动一步，并对当前点结尾的子串数量计数，也即 <span class=\"math inline\">\\(f_{a_i}\\)</span>。即完成对好子串的计数。</p>\n<p>考虑进一步 DP of DP，将计数变量 <span class=\"math inline\">\\(tot\\)</span> 的奇偶性放入状态。初始为 <span class=\"math inline\">\\(0,0,0,0\\)</span>，转移 <span class=\"math inline\">\\(dp_{f0,f1,f2,tot}\\to dp_{f2\\oplus1,f1,f0,tot\\oplus f0}\\)</span>，最后在 <span class=\"math inline\">\\(*,*,*,1\\)</span> 查答案。状态数共为 <span class=\"math inline\">\\(2^4=16\\)</span>，使用 DDP 维护动态询问即可。由于矩阵略大，需要用猫树替换线段树。然后就可以得到一个会 TLE 80 的做法（注意 <code>?</code> 的转移矩阵系数可能为 2）。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nstruct mat &#123;\n    long long a[16][16];\n    long long* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    mat() &#123;\n        return;\n    &#125;\n    mat operator* (mat &amp;q) const &#123;\n        mat res;\n        for (int i = 0; i &lt; 16; ++i)\n            for (int k = 0; k &lt; 16; ++k) &#123;\n                auto s = 0ll;\n                for (int j = 0; j &lt; 16; ++j)\n                    s += a[i][j] * q[j][k];\n                res[i][k] = s % mod;\n            &#125;\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125; m0, m1, ma;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    for (int f0 = 0; f0 &lt;= 1; ++f0)\n        for (int f1 = 0; f1 &lt;= 1; ++f1)\n            for (int f2 = 0; f2 &lt;= 1; ++f2)\n                for (int tot = 0; tot &lt;= 1; ++tot) &#123;\n                    m0[(f0 &lt;&lt; 3) + (f1 &lt;&lt; 2) + (f2 &lt;&lt; 1) + tot][((f2 ^ 1) &lt;&lt; 3) + (f1 &lt;&lt; 2) + (f0 &lt;&lt; 1) + (tot ^ f0)] = 1ll;\n                    ma[(f0 &lt;&lt; 3) + (f1 &lt;&lt; 2) + (f2 &lt;&lt; 1) + tot][((f2 ^ 1) &lt;&lt; 3) + (f1 &lt;&lt; 2) + (f0 &lt;&lt; 1) + (tot ^ f0)] = 1LL;\n                    m1[(f0 &lt;&lt; 3) + (f1 &lt;&lt; 2) + (f2 &lt;&lt; 1) + tot][(f0 &lt;&lt; 3) + ((f2 ^ 1) &lt;&lt; 2) + (f1 &lt;&lt; 1) + (tot ^ f1)] = 1ll;\n                    ++ma[(f0 &lt;&lt; 3) + (f1 &lt;&lt; 2) + (f2 &lt;&lt; 1) + tot][(f0 &lt;&lt; 3) + ((f2 ^ 1) &lt;&lt; 2) + (f1 &lt;&lt; 1) + (tot ^ f1)];\n                &#125;\n    int n, n1;\n    std::cin &gt;&gt; n;\n    n1 = 1 &lt;&lt; (std::__lg(n + 1) + 1);\n    std::vector&lt;char&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::vector&lt;mat&gt; f(std::vector&lt;mat&gt; (n + 1));\n    auto askmat = [&amp;](char t) -&gt; mat&amp; &#123;\n        if (t == &#39;0&#39;)\n            return m0;\n        if (t == &#39;1&#39;)\n            return m1;\n        return ma;\n    &#125;;\n    int m;\n    std::cin &gt;&gt; m;\n    std::vector&lt;long long&gt; res(m + 1);\n    std::vector&lt;std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; &gt; u(std::__lg(n1), std::vector&lt;std::vector&lt; std::pair&lt;int, int&gt; &gt; &gt; (n + 1));\n    for (int i = 1, l, r; i &lt;= m; ++i) &#123;\n        std::cin &gt;&gt; l &gt;&gt; r;\n        mat k;\n        if (l == r) &#123;\n            k = askmat(a[l]);\n            auto sum(0ll);\n            for (int s = 0; s &lt; 8; ++s)\n                sum += k[0][(s &lt;&lt; 1) + 1];\n            res[i] = sum % mod;\n        &#125;\n        else &#123;\n            int d = std::__lg(l ^ r);\n            u[d][r].emplace_back(l, i);\n        &#125;\n    &#125;\n    std::function&lt;void(int, int)&gt; calc = [&amp;](int l, int r) &#123;\n        if (l == r)\n            return;\n        int d = std::__lg(r - l + 1) - 1, mid = (l + r) &gt;&gt; 1;\n        calc(l, mid), calc(mid + 1, r);\n        if (mid &lt;= n &amp;&amp; mid) &#123;\n            f[mid] = askmat(a[mid]);\n            for (int i = mid - 1; i &gt;= l &amp;&amp; i; --i)\n                f[i] = askmat(a[i]) * f[i + 1];\n        &#125;\n        if (mid + 1 &lt;= n) &#123;\n            f[mid + 1] = askmat(a[mid + 1]);\n            for (auto [l, id] : u[d][mid + 1]) &#123;\n                auto sum(0ll);\n                auto k(f[l] * f[mid + 1]);\n                for (int s = 0; s &lt; 8; ++s)\n                    sum += k[0][(s &lt;&lt; 1) + 1];\n                res[id] = sum % mod;\n            &#125;\n            for (int i = mid + 2; i &lt;= r &amp;&amp; i &lt;= n; ++i) &#123;\n                f[i] = f[i - 1] * askmat(a[i]);\n                for (auto [l, id] : u[d][i]) &#123;\n                    auto sum(0ll);\n                    auto k(f[l] * f[i]);\n                    for (int s = 0; s &lt; 8; ++s)\n                        sum += k[0][(s &lt;&lt; 1) + 1];\n                    res[id] = sum % mod;\n                &#125;\n            &#125;\n        &#125;\n        return;\n    &#125;;\n    calc(0, n1 - 1);\n    for (int i = 1; i &lt;= m; ++i)\n        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<p>观察 <code>?</code> 的转移矩阵，发现其实很稀疏，有效边只有 28 条</p>\n<p><img src=\"image-1.png\" /></p>\n<p>那么完全可以抛弃矩阵这个概念，返璞归真用线性 DP 解决；枚举中间相接的位就可以合并。</p>\n<p>实际上另一种更数学的理解方式是在左侧乘一个 <span class=\"math inline\">\\([1,0,0,\\cdots,0]\\)</span> 就可以把左边的矩阵转化成向量；通过枚举中间相接的位，相当于在 <span class=\"math inline\">\\(mid\\)</span> 处乘一个 <span class=\"math inline\">\\([0,0,\\cdots,0,1,0,\\cdots,0]\\)</span> 的向量，右边的矩阵就也转化成了向量。接着，由于矩阵很稀疏，只有 28 个位置有值，故可以手动转移。</p>\n<p>这样就可以少一个 <span class=\"math inline\">\\(O(s)\\)</span>，可以通过。</p>\n<details>\n<p>贺了 <span class=\"citation\" data-cites=\"spdarkle\">@spdarkle</span> 的代码，但跑得没他快</p>\n<p><span class=\"citation\" data-cites=\"Rosmist\">@Rosmist</span> 又在表演卡常技能了，勇夺最优解</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    std::vector&lt;int&gt; m0(16), m1(16);\n    for (int f0 = 0; f0 &lt;= 1; ++f0)\n        for (int f1 = 0; f1 &lt;= 1; ++f1)\n            for (int f2 = 0; f2 &lt;= 1; ++f2)\n                for (int tot = 0; tot &lt;= 1; ++tot) &#123;\n                    m0[(f0 &lt;&lt; 3) + (f1 &lt;&lt; 2) + (f2 &lt;&lt; 1) + tot] = ((f2 ^ 1) &lt;&lt; 3) + (f1 &lt;&lt; 2) + (f0 &lt;&lt; 1) + (tot ^ f0);\n                    m1[(f0 &lt;&lt; 3) + (f1 &lt;&lt; 2) + (f2 &lt;&lt; 1) + tot] = (f0 &lt;&lt; 3) + ((f2 ^ 1) &lt;&lt; 2) + (f1 &lt;&lt; 1) + (tot ^ f1);\n                &#125;\n    int n, n1;\n    std::cin &gt;&gt; n;\n    n1 = 1 &lt;&lt; (std::__lg(n + 1) + 1);\n    std::vector&lt;char&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::vector&lt;int&gt; dp(n + 1);\n    std::vector&lt;std::array&lt;int, 16&gt; &gt; f(n + 1);\n    int m;\n    std::cin &gt;&gt; m;\n    std::vector&lt;long long&gt; res(m + 1);\n    std::vector&lt;std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; &gt; u(std::__lg(n1), std::vector&lt;std::vector&lt; std::pair&lt;int, int&gt; &gt; &gt; (n + 1));\n    for (int i = 1, l, r; i &lt;= m; ++i) &#123;\n        std::cin &gt;&gt; l &gt;&gt; r;\n        if (l != r) &#123;\n            int d = std::__lg(l ^ r);\n            u[d][r].emplace_back(l, i);\n        &#125;\n    &#125;\n    std::function&lt;void(int, int)&gt; calc = [&amp;](int l, int r) &#123;\n        if (l == r)\n            return;\n        int d = std::__lg(r - l + 1) - 1, mid = (l + r) &gt;&gt; 1;\n        calc(l, mid), calc(mid + 1, r);\n        for (int t = 0; t &lt; 16; ++t) &#123;\n            std::array&lt;int, 16&gt; la;\n            if (mid &lt;= n &amp;&amp; mid) &#123;\n                std::fill(la.begin(), la.end(), 0);\n                la[t] = 1ll;\n                for (int i = mid; i &gt;= l &amp;&amp; i; --i) &#123;\n                    std::fill(f[i].begin(), f[i].end(), 0);\n                    if (a[i] != &#39;1&#39;)\n                        for (int j = 0; j &lt; 16; ++j)\n                            f[i][j] = la[m0[j]];\n                    if (a[i] != &#39;0&#39;)\n                        for (int j = 0; j &lt; 16; ++j) &#123;\n                            f[i][j] += la[m1[j]];\n                            if (f[i][j] &gt;= mod)\n                                f[i][j] -= mod;\n                        &#125;\n                    dp[i] = f[i][0];\n                    la = f[i];\n                &#125;\n            &#125;\n            if (mid + 1 &lt;= n) &#123;\n                std::fill(la.begin(), la.end(), 0);\n                la[t] = 1ll;\n                for (int i = mid + 1; i &lt;= r &amp;&amp; i &lt;= n; ++i) &#123;\n                    std::fill(f[i].begin(), f[i].end(), 0);\n                    if (a[i] != &#39;1&#39;)\n                        for (int j = 0; j &lt; 16; ++j)\n                            f[i][m0[j]] = la[j];\n                    if (a[i] != &#39;0&#39;)\n                        for (int j = 0; j &lt; 16; ++j) &#123;\n                            f[i][m1[j]] += la[j];\n                            if (f[i][m1[j]] &gt;= mod)\n                                f[i][m1[j]] -= mod;\n                        &#125;\n                    dp[i] = 0ll;\n                    for (int s = 0; s &lt; 8; ++s) &#123;\n                        dp[i] += f[i][(s &lt;&lt; 1) + 1];\n                        if (dp[i] &gt;= mod)\n                            dp[i] -= mod;\n                    &#125;\n                    for (auto [l, id] : u[d][i])\n                        (res[id] += (long long)dp[l] * dp[i]) %= mod;\n                    la = f[i];\n                &#125;\n            &#125;\n        &#125;\n        return;\n    &#125;;\n    calc(0, n1 - 1);\n    for (int i = 1; i &lt;= m; ++i)\n        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "猫树"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250821/",
            "url": "https://xsc062.netlify.app/20250821/",
            "title": "带根号的一些题",
            "date_published": "2025-08-21T06:11:06.000Z",
            "content_html": "<p>和上上一篇独立开</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"分块\">分块</h2>\n<h3 id=\"minecraft-series平衡复杂度\">Minecraft Series（平衡复杂度）</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1753F\" class=\"uri\">https://www.luogu.com.cn/problem/CF1753F</a></p>\n<h2 id=\"莫队\">莫队</h2>\n<h3 id=\"参数要吉祥莫队-队列\">参数要吉祥（莫队 + 队列）</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P12598\" class=\"uri\">https://www.luogu.com.cn/problem/P12598</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(\\{a\\}\\)</span> 和 <span class=\"math inline\">\\(q\\)</span> 个询问，每次问 <span class=\"math inline\">\\([l,r]\\)</span> 中 <span class=\"math inline\">\\(c(x)\\times a_x\\)</span> 的最大值。其中 <span class=\"math inline\">\\(c(x)\\)</span> 为『出现次数为 <span class=\"math inline\">\\(x\\)</span> 的数』的种类。</p>\n</blockquote>\n<p><strong>莫队结合队列</strong>，每次更新一个数的 <span class=\"math inline\">\\(cnt\\)</span> 时，如果这个数没出现过就加入队列。查询的时候把队列过一遍，删除非最新版本的数据。<strong>队列长度和移动次数是一样的</strong>。</p>\n<p>考虑询问的复杂度，对于长度为 <span class=\"math inline\">\\(len\\)</span> 的区间，<span class=\"math inline\">\\(\\ge \\sqrt{len}\\)</span> 的 <span class=\"math inline\">\\(cnt\\)</span> 出现次数不超过 <span class=\"math inline\">\\(\\sqrt {len}\\)</span>；<span class=\"math inline\">\\(\\le \\sqrt{len}\\)</span> 的 <span class=\"math inline\">\\(cnt\\)</span> 出现次数更不会超过 <span class=\"math inline\">\\(len\\)</span>。过一遍队列就是 <span class=\"math inline\">\\(O(\\sqrt {len})\\)</span> 的。</p>\n<h3 id=\"八云蓝自动机-ⅰ\"># 八云蓝自动机 Ⅰ</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P7708\" class=\"uri\">https://www.luogu.com.cn/problem/P7708</a></p>\n",
            "tags": []
        },
        {
            "id": "https://xsc062.netlify.app/20250820/",
            "url": "https://xsc062.netlify.app/20250820/",
            "title": "杂题",
            "date_published": "2025-08-20T12:26:44.000Z",
            "content_html": "<p>困难</p>\n<span id=\"more\"></span>\n<hr />\n<h3 id=\"b.-beauty拆贡献\">B. beauty（拆贡献）</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/6513/problem/2\" class=\"uri\">http://222.180.160.110:61235/contest/6513/problem/2</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(n,V\\)</span>，求出对于所有长度为 <span class=\"math inline\">\\(n\\)</span>，值域为 <span class=\"math inline\">\\([1,V]\\)</span> 的序列 <span class=\"math inline\">\\(a_{1\\sim n}\\)</span>，<span class=\"math inline\">\\(\\sum_{i=1}^n |a_i-a_{n-i+1}|\\)</span> 的和。</p>\n<p><span class=\"math inline\">\\(n,V\\le 5000\\)</span>。</p>\n</blockquote>\n<ul>\n<li>容易想到算贡献，会有一个 <span class=\"math inline\">\\(O(n^2V)\\)</span> 的做法。但是想 <span class=\"math inline\">\\(O(nV)\\)</span> 做是很抽象的，和 <span class=\"math inline\">\\(O(n^2V)\\)</span> 的思路已经很不一样了</li>\n<li>经典 trick，<span class=\"math inline\">\\(a_{i+n/2}-a_i=\\sum\\limits_{x=0}^{+\\infty} [a_i\\le x&lt;a_{i+n/2}]\\)</span> 拆贡献 。故要算 <span class=\"math inline\">\\(a_{i}-a_{i+n/2}\\)</span>，只需要对于每个 <span class=\"math inline\">\\(x\\in[a_i,a_{i+n/2})\\)</span> 计算贡献。</li>\n<li>枚举 <span class=\"math inline\">\\(x\\in [1,V)\\)</span>，再枚举最大的 <span class=\"math inline\">\\(t\\)</span>，满足 <span class=\"math inline\">\\(a_t\\ge x\\)</span>。那么有 <span class=\"math inline\">\\(t\\)</span> 个 <span class=\"math inline\">\\(a_i\\le x\\)</span>，同时有 <span class=\"math inline\">\\(n-t\\)</span> 个 <span class=\"math inline\">\\(a_i&gt;x\\)</span>；满足 <span class=\"math inline\">\\(i\\le n/2\\)</span> 的 <span class=\"math inline\">\\(a_{i},a_{i+n/2}\\)</span> 对数应该是 <span class=\"math inline\">\\(\\min(t,n-t)\\)</span>。故对于一个确定的序列，<span class=\"math inline\">\\(x\\)</span> 共有 <span class=\"math inline\">\\(\\min(t,n-t)\\)</span> 的贡献。</li>\n<li>考虑计数满足 <span class=\"math inline\">\\(a_t\\le x\\)</span> 的 <span class=\"math inline\">\\(a\\)</span>，这要求第 <span class=\"math inline\">\\(t\\)</span> 大的数 <span class=\"math inline\">\\(\\le x\\)</span> 而第 <span class=\"math inline\">\\(t+1\\)</span> 大的数 <span class=\"math inline\">\\(&gt;x\\)</span>，也即在 <span class=\"math inline\">\\([1,x]\\)</span> 里找 <span class=\"math inline\">\\(t\\)</span> 个数再在 <span class=\"math inline\">\\((x,V]\\)</span> 里找 <span class=\"math inline\">\\(n-t\\)</span> 个数，注意还要再乘上这两种数拼起来的方案数。</li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;beauty.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;beauty.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    std::vector&lt;long long&gt; fac(5001), inv(5001);\n    std::vector&lt;std::vector&lt;long long&gt; &gt; pw(5001, std::vector&lt;long long&gt; (5001));\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= 5000; ++i) &#123;\n        fac[i] = fac[i - 1] * i % mod;\n        pw[i][0] = 1ll;\n        for (int j = 1; j &lt;= 5000; ++j)\n            pw[i][j] = pw[i][j - 1] * i % mod;\n    &#125;\n    auto qkp = [](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[5000] = qkp(fac[5000], mod - 2);\n    for (int i = 4999; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[m] % mod * inv[n - m] % mod;\n    &#125;;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, V;\n        std::cin &gt;&gt; n &gt;&gt; V;\n        auto res(0ll);\n        for (int x = 1; x &lt; V; ++x)\n            for (int t = 1; t &lt; n; ++t) &#123;\n                int k = std::min(t, n - t);\n                (res += k * pw[x][t] % mod * pw[V - x][n - t] % mod * C(n, t) % mod) %= mod;\n            &#125;\n        std::cout &lt;&lt; res * 2 % mod &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"c.-drink-bar容斥-偏序\">C. Drink Bar（容斥 + 偏序）</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_snuke21_j\" class=\"uri\">https://www.luogu.com.cn/problem/AT_snuke21_j</a></p>\n<ul>\n<li>三个属性都是排列，可以推理出只要两个三元组中，作出贡献的元素不完全相同，两个三元组就不同。讨论作出贡献的元素数量。</li>\n<li>只有一个元素作出贡献，答案为 <span class=\"math inline\">\\(n\\)</span>。</li>\n<li>有两个元素作出贡献，任选的话答案为 <span class=\"math inline\">\\(C_n^2\\)</span>，要减去一个元素严格优于另一个元素的情况，三维偏序即可。</li>\n<li><p>有三个元素作出贡献，是个有点复杂的容斥，不妨设三元组为 <span class=\"math inline\">\\((i,j,k)\\)</span>，其中贡献次数最多的为 <span class=\"math inline\">\\(i\\)</span></p>\n<ol type=\"1\">\n<li><span class=\"math inline\">\\(i\\)</span> 贡献了 <span class=\"math inline\">\\(\\ge 1\\)</span> 次，方案数为 <span class=\"math inline\">\\(C_n^3\\)</span></li>\n<li><span class=\"math inline\">\\(i\\)</span> 贡献了 <span class=\"math inline\">\\(\\ge 2\\)</span> 次，枚举作出两次贡献的属性，以 <span class=\"math inline\">\\(a,b\\)</span> 为例，那么有 <span class=\"math inline\">\\(a_j,a_k&lt;a_i\\)</span>，以及 <span class=\"math inline\">\\(b_j,b_k&lt;b_i\\)</span>，二维偏序即可</li>\n<li><span class=\"math inline\">\\(i\\)</span> 贡献了 <span class=\"math inline\">\\(\\ge 3\\)</span> 次，依然是三维偏序，可以用『两个元素做出贡献』中 cdq 得到的值算出答案。记得乘 2，因为被多减了 2 次。</li>\n</ol></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    struct node &#123; int a, b, c, res; &#125;;\n    std::vector&lt;node&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i].a &gt;&gt; a[i].b &gt;&gt; a[i].c;\n        a[i].res = 0;\n    &#125;\n    long long res = n;\n    res += (long long)n * (n - 1) / 2;\n    std::vector&lt;int&gt; bit(n + 1);\n    auto lowbit = [](int x) &#123;\n        return x &amp; -x;\n    &#125;;\n    auto add = [&amp;](int x, int v) &#123;\n        for (; x &lt;= n; x += lowbit(x))\n            bit[x] += v;\n        return;\n    &#125;;\n    auto ask = [&amp;](int x) &#123;\n        int res = 0;\n        for (; x; x -= lowbit(x))\n            res += bit[x];\n        return res;\n    &#125;;\n    std::function&lt;void(int, int)&gt; calc = [&amp;](int l, int r) &#123;\n        if (l == r)\n            return;\n        int mid = (l + r) &gt;&gt; 1;\n        calc(l, mid), calc(mid + 1, r);\n        int j = l;\n        for (int i = mid + 1; i &lt;= r; ++i) &#123;\n            for (; j &lt;= mid &amp;&amp; a[j].b &lt; a[i].b; ++j)\n                add(a[j].c, 1);\n            a[i].res += ask(a[i].c);\n        &#125;\n        for (int i = l; i &lt; j; ++i)\n            add(a[i].c, -1);\n        std::inplace_merge(a.begin() + l, a.begin() + mid + 1, a.begin() + r + 1, [&amp;](node x, node y) &#123; return x.b &lt; y.b; &#125;);\n        return;\n    &#125;;\n    std::sort(a.begin() + 1, a.end(), [&amp;](node x, node y) &#123; return x.a &lt; y.a; &#125;);\n    calc(1, n);\n    for (int i = 1; i &lt;= n; ++i)\n        res -= a[i].res;\n    res += (long long)n * (n - 1) * (n - 2) / 6;\n    for (int k = 0; k &lt; 3; ++k) &#123;\n        std::sort(a.begin() + 1, a.end(), [&amp;](node x, node y) &#123; return x.a &lt; y.a; &#125;);\n        std::fill(bit.begin() + 1, bit.end(), 0);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            int t = ask(a[i].b);\n            res -= (long long)t * (t - 1) / 2;\n            add(a[i].b, 1);\n            std::tie(a[i].a, a[i].b, a[i].c) = std::make_tuple(a[i].b, a[i].c, a[i].a);\n        &#125;\n    &#125;\n    for (int i = 1; i &lt;= n; ++i)\n        res += (long long)a[i].res * (a[i].res - 1);\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"c.-星白-by-ttpandas笛卡尔树-dsu-on-tree\">C. 星白 by TTpandaS（笛卡尔树 + dsu on tree）</h3>\n<p><a href=\"/20250819/#星白-by-ttpandas笛卡尔树-dsu-on-tree\">link</a></p>\n<hr />\n<h3 id=\"c.-isn\">C. isn</h3>\n<p><a href=\"https://hydro.ac/p/bzoj-P4361\" class=\"uri\">https://hydro.ac/p/bzoj-P4361</a></p>\n<ul>\n<li><p>最后一个删去的一定是连接 <code>&gt;</code> 的数，可以 DP 还剩一个数没删时可能的序列。</p>\n令 <span class=\"math inline\">\\(f_{i,j,0/1}\\)</span> 表示最后一个元素为 <span class=\"math inline\">\\(i\\)</span>，序列长为 <span class=\"math inline\">\\(j\\)</span>，最后一个被删去的数（未）被确定的方案数。<strong>注意确定最后一个被删去的数要在转移过程中进行，而不是作为一个 DP 节点</strong>，很容易发现后者是错的。</li>\n<li><p>优化的思路就不一样了。因为要乘上 <span class=\"math inline\">\\((n-j)!\\)</span>，所以 <span class=\"math inline\">\\(j\\)</span> 的这一维是省不掉的</p>\n考虑不管最后一个被删掉的数，直接令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示最后一个元素为 <span class=\"math inline\">\\(i\\)</span>，序列长为 <span class=\"math inline\">\\(j\\)</span> 的方案数。有 <span class=\"math inline\">\\(f_{i,j}=\\sum\\limits_{a_k\\le a_i}f_{k,j - 1}\\)</span>，可以 DS 优化。但这样会产生不合法的情况。</li>\n<li><p>考察什么样的序列合法，发现<strong>删去的最后一个数一定是非法的，也就是包含之的序列都是非法的；反之易得被合法序列包含的序列都非法</strong></p>\n<p>明白了这一点过后就会知道长度为 <span class=\"math inline\">\\(j\\)</span> 的合法序列系数都为 <span class=\"math inline\">\\((n-j)!\\)</span></p>\n<p>故容斥，令 <span class=\"math inline\">\\(g_i\\)</span> 表示序列长为 <span class=\"math inline\">\\(i\\)</span> 的方案数，<span class=\"math inline\">\\(h_i\\)</span> 表示序列长为 <span class=\"math inline\">\\(i\\)</span> 的合法方案数。从异或角度考虑，易得 <span class=\"math inline\">\\(h_i=g_i-\\sum\\limits_{j=i+1}h_j\\times (j-i)!\\times C_j^i\\)</span>。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;isn.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;isn.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1), l(1);\n    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i], l.push_back(a[i]);\n        fac[i] = fac[i - 1] * i % mod;\n    &#125;\n    auto qkp = [](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[n] = qkp(fac[n], mod - 2);\n    for (int i = n - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[m] % mod * inv[n - m] % mod;\n    &#125;;\n    std::sort(l.begin(), l.end());\n    l.erase(std::unique(l.begin(), l.end()), l.end());\n    for (int i = 0; i &lt;= n; ++i)\n        a[i] = std::lower_bound(l.begin(), l.end(), a[i]) - l.begin() + 1;\n    int m = (int)l.size();\n    std::vector&lt;std::vector&lt;long long&gt; &gt; bit(n + 1, std::vector&lt;long long&gt; (m + 1));\n    auto lowbit = [](int x) &#123;\n        return x &amp; -x;\n    &#125;;\n    auto add = [&amp;](int id, int x, long long v) &#123;\n        for (; x &lt;= m; x += lowbit(x))\n            (bit[id][x] += v) %= mod;\n        return;\n    &#125;;\n    auto ask = [&amp;](int id, int x) &#123;\n        auto res(0ll);\n        for (; x; x -= lowbit(x))\n            (res += bit[id][x]) %= mod;\n        return res;\n    &#125;;\n    std::vector&lt;long long&gt; g(n + 1), h(n + 1);\n    std::vector&lt;std::vector&lt;long long&gt; &gt; f(n + 1, std::vector&lt;long long&gt; (n + 1));\n    add(0, a[0], 1ll), f[0][0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = n; j; --j) &#123;\n            f[i][j] = ask(j - 1, a[i]);\n            add(j, a[i], f[i][j]);\n            (g[j] += f[i][j] * fac[n - j]) %= mod;\n        &#125;\n    auto res(0ll);\n    for (int i = n; i; --i) &#123;\n        h[i] = g[i];\n        for (int j = i + 1; j &lt;= n; ++j)\n            (h[i] += mod - h[j] * fac[j - i] % mod * C(j, i) % mod) %= mod;\n        (res += h[i]) %= mod;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"d.-thepowers\">D. ThePowers</h3>\n<p>TopCoder - 12185，原题交不了故不放链接了</p>\n<p><a href=\"http://222.180.160.110:61235/contest/6522/problem/4\" class=\"uri\">http://222.180.160.110:61235/contest/6522/problem/4</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(A,B\\)</span>，对于所有 <span class=\"math inline\">\\(X\\le A,Y\\le B\\)</span>，求 <span class=\"math inline\">\\(X^Y\\)</span> 的可能取值数量。<span class=\"math inline\">\\(A,B\\le10^9\\)</span>。</p>\n</blockquote>\n<ul>\n<li>考虑什么时候算重。发现当且仅当 <span class=\"math inline\">\\(x^a=y^b\\)</span>，此时记 <span class=\"math inline\">\\(a&#39;=a\\div\\gcd(a,b),b&#39;=b\\div \\gcd(a,b)\\)</span>，那么 <span class=\"math inline\">\\(t=\\sqrt[a&#39;]x=\\sqrt[b&#39;]y\\)</span> 为整（写成质因数乘积是易证的），则 <span class=\"math inline\">\\(x=t^b,y=t^a\\)</span>，是同一个数的不同次幂</li>\n<li><p>故把 <span class=\"math inline\">\\(A\\)</span> 内所有数分组，记 <span class=\"math inline\">\\(S_x\\)</span> 表示所有 <span class=\"math inline\">\\(x\\)</span> 的次幂，其中 <span class=\"math inline\">\\(x\\)</span> 不是其他数的次幂</p>\n发现一个对于 <span class=\"math inline\">\\(&gt;\\sqrt A\\)</span> 的数 <span class=\"math inline\">\\(y\\)</span>，只有可能属于 <span class=\"math inline\">\\(S_y\\)</span>，或一个 <span class=\"math inline\">\\(x\\le \\sqrt A\\)</span> 的 <span class=\"math inline\">\\(S_x\\)</span>。每组最多有 <span class=\"math inline\">\\(30\\)</span> 个，故扫一遍 <span class=\"math inline\">\\(\\le\\sqrt A\\)</span> 的数即可完成分组。</li>\n<li><p>这样就只用考虑同组内的计数。即对于 <span class=\"math inline\">\\(x\\)</span> 和 <span class=\"math inline\">\\(p\\le |S_x|,y\\le B\\)</span>，<span class=\"math inline\">\\(x^{py}\\)</span> 有多少种取值，也即 <span class=\"math inline\">\\(py\\)</span> 有多少种取值</p>\n发现因为值域是连续的，对于一个 <span class=\"math inline\">\\(p\\)</span>，只要 <span class=\"math inline\">\\(pB\\)</span> 范围内某个数是 <span class=\"math inline\">\\(p\\)</span> 的倍数就可以取到，枚举 <span class=\"math inline\">\\([(p-1)B+1,pB]\\)</span>，对于每个 <span class=\"math inline\">\\(p\\)</span> 容斥，就需要计算 <span class=\"math inline\">\\(p\\sim |S_x|\\)</span> 的每个子集，复杂度会爆炸。</li>\n<li><p>对于 <span class=\"math inline\">\\(x,y\\in[p,|S_x|]\\)</span>，如果 <span class=\"math inline\">\\(y\\)</span> 是 <span class=\"math inline\">\\(x\\)</span> 的倍数，就可以 skip，只在剩下的元素里枚举子集，可以代码验证一下 <span class=\"math inline\">\\(30\\)</span> 以内最多剩下 <span class=\"math inline\">\\(15\\)</span> 个数，可以接受，注意子集信息类似高维前缀和地 <span class=\"math inline\">\\(O(1)\\)</span> 求就行了</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;power.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;power.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    long long A, B, mx = 1ll;\n    std::cin &gt;&gt; A &gt;&gt; B;\n    if (A == 1) &#123;\n        std::cout &lt;&lt; 1 &lt;&lt; &#39;\\n&#39;;\n        return 0;\n    &#125;\n    int cnt = 1;\n    long long res = 1ll;\n    for (; (mx + 1) * (mx + 1) &lt;= A; ++mx);\n    std::vector&lt;int&gt; tag(mx + 1);\n    for (int i = 2; i &lt;= mx; ++i)\n        if (!tag[i]) &#123;\n            int siz = 1;\n            for (long long j = i; j &lt;= A; j *= i, ++siz)\n                if (j &lt;= mx)\n                    tag[j] = 1;\n            cnt += --siz;\n            for (int j = 1; j &lt;= siz; ++j) &#123;\n                std::vector&lt;int&gt; p(&#123; j &#125;);\n                for (int k = j + 1; k &lt;= siz; ++k) &#123;\n                    bool flag = 1;\n                    for (auto l : p)\n                        if (k % l == 0) &#123;\n                            flag = 0;\n                            break;\n                        &#125;\n                    if (flag)\n                        p.push_back(k);\n                &#125;\n                int m = (int)p.size(), s = 1 &lt;&lt; m;\n                std::vector&lt;long long&gt; mul(s);\n                mul[0] = 1ll;\n                auto lcm = [&amp;](long long x, long long y) &#123;\n                    return x / std::__gcd(x, y) * y;\n                &#125;;\n                for (int k = 1; k &lt; s; ++k) &#123;\n                    mul[k] = lcm(p[std::__lg(k ^ ((k - 1) &amp; k))], mul[(k - 1) &amp; k]);\n                    if (__builtin_popcount(k) &amp; 1)\n                        res += j * B / mul[k] - (j - 1) * B / mul[k];\n                    else\n                        res -= j * B / mul[k] - (j - 1) * B / mul[k];\n                &#125;\n            &#125;\n        &#125;\n    res += (A - cnt) * B;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<p>搜索做法本质上是一样的，就不赘述了</p>\n",
            "tags": [
                "DP",
                "容斥"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250819/",
            "url": "https://xsc062.netlify.app/20250819/",
            "title": "log 数据结构的一些题",
            "date_published": "2025-08-19T01:44:25.000Z",
            "content_html": "<p>线段树、树状数组、倍增、分治（朴素分治 / CDQ / 整体二分）、平衡树、字典树、笛卡尔树</p>\n<p>多乎哉？不多也。</p>\n<span id=\"more\"></span>\n<hr />\n<p>题目来源：</p>\n<ol type=\"1\">\n<li>llsw’s pdf</li>\n<li>洛谷文章广场题解区搜索对应算法</li>\n<li>自己以前的一些零散题解</li>\n</ol>\n<p>找了一些有数据结构方面思维难点的题，实现难度通常不会很大，也有少许粑粑夹杂其中</p>\n<hr />\n<p><code>#</code> 是缺题解，<code>*</code> 是缺代码</p>\n<hr />\n<h2 id=\"线段树\">线段树</h2>\n<h3 id=\"维护特殊信息\">维护特殊信息</h3>\n<h4 id=\"金鱼草区间覆盖信息\">金鱼草（区间覆盖信息）</h4>\n<p><a href=\"http://222.180.160.110:61235/contest/6051/problem/4\" class=\"uri\">http://222.180.160.110:61235/contest/6051/problem/4</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(n\\)</span> 个区间 <span class=\"math inline\">\\([l,r]\\)</span>，给出 <span class=\"math inline\">\\(q\\)</span> 个询问，每次询问 <span class=\"math inline\">\\([L,R]\\)</span> 是否能被表示为若干 <span class=\"math inline\">\\([l,r]\\)</span> 的并集。注意不能覆盖到 <span class=\"math inline\">\\([L,R]\\)</span> 之外的点。</p>\n<p><span class=\"math inline\">\\(n,q\\le 5\\times 10^5,|V|\\le 10^9\\)</span>。</p>\n</blockquote>\n<ul>\n<li>题目所求等价于 check 满足 <span class=\"math inline\">\\(l\\ge L\\land r\\le R\\)</span> 的所有区间是否能够覆盖 <span class=\"math inline\">\\([L,R]\\)</span></li>\n<li>这个很简单，需要区间修改的做法就不提了。可以想一下有没有只需要单点修改的做法</li>\n<li><p>发现权值线段树可以维护「一段连续左端点对应区间的并」是否是连续的：</p>\n维护位于区间内的左端点最后一个覆盖到的点 <span class=\"math inline\">\\(rv\\)</span>（可以在区间外；发现从区间左端点到 <span class=\"math inline\">\\(rv\\)</span> 会被连续覆盖），<strong>区间内</strong>最后一个没有被覆盖到的点 <span class=\"math inline\">\\(p\\)</span>，和表示区间是否能被完整覆盖的标记 <span class=\"math inline\">\\(flag\\)</span>。pushup 是容易的。</li>\n<li><p>容易发现如果我们在树上询问 <span class=\"math inline\">\\([L,R]\\)</span> 中所有左端点的 <span class=\"math inline\">\\(flag\\)</span>，无法保证参与覆盖的 <span class=\"math inline\">\\(r\\le R\\)</span>。故离线下来扫描线即可。</p>\n<p>实际上由于未知原因跑得很可能不如区间修改的方法快 TAT</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 5e5 + 5;\nstruct _ &#123;\n    bool flag;\n    int l, r, rv, p;\n&#125; t[maxn &lt;&lt; 2];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid pushup(int p) &#123;\n    t[p].rv = std::max(t[lt].rv, t[rt].rv);\n    if (!t[lt].flag) &#123;\n        t[p].flag = 0;\n        if (!t[rt].flag &amp;&amp; t[lt].rv &lt; t[rt].p)\n            t[p].p = t[rt].p;\n        else\n            t[p].p = t[lt].p;\n    &#125;\n    else if (!t[rt].flag &amp;&amp; t[lt].rv &lt; t[rt].p)\n        t[p].flag = 0, t[p].p = t[rt].p;\n    else\n        t[p].flag = 1, t[p].p = 0;\n    return;\n&#125;\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = t[p].p = r;\n    if (l == r)\n        return;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    return;\n&#125;\nvoid add(int p, int x, int v) &#123;\n    if(t[p].l == t[p].r) &#123;\n        t[p].flag = 1, t[p].p = 0;\n        t[p].rv = std::max(t[p].rv, v);\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        add(lt, x, v);\n    else\n        add(rt, x, v);\n    pushup(p);\n    return;\n&#125;\n_ ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p];\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (r &lt;= mid)\n        return ask(lt, l, r);\n    if (l &gt; mid)\n        return ask(rt, l, r);\n    auto ls(ask(lt, l, r)), rs(ask(rt, l, r));\n    if (!ls.flag) &#123;\n        if (!rs.flag &amp;&amp; ls.rv &lt; rs.p)\n            ls.p = rs.p;\n    &#125;\n    else if (!rs.flag &amp;&amp; ls.rv &lt; rs.p)\n        ls.flag = 0, ls.p = rs.p;\n    ls.rv = std::max(ls.rv, rs.rv);\n    return ls;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;snapdragon.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;snapdragon.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m, q;\n    std::cin &gt;&gt; m &gt;&gt; n &gt;&gt; q;\n    bld(1, 1, m);\n    std::vector&lt;std::vector&lt;int&gt; &gt; t(m + 1);\n    for (int i = 1, l, r; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; l &gt;&gt; r;\n        t[r].push_back(l);\n    &#125;\n    std::vector&lt;int&gt; res(q + 1);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; tq(m + 1);\n    for (int i = 1, l, r; i &lt;= q; ++i) &#123;\n        std::cin &gt;&gt; l &gt;&gt; r;\n        tq[r].emplace_back(l, i);\n    &#125;\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        for (auto l : t[i])\n            add(1, l, i);\n        for (auto [l, id] : tq[i])\n            res[id] = ask(1, l, i).flag;\n    &#125;\n    for (int i = 1; i &lt;= q; ++i)\n        std::cout &lt;&lt; (res[i] ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<h4 id=\"题日-zapatak哈希\"># 题日 Zapatak（哈希）</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P11262\" class=\"uri\">https://www.luogu.com.cn/problem/P11262</a></p>\n<h4 id=\"简单数据结构带一点递推性质\">简单数据结构（带一点递推性质）</h4>\n<p><a href=\"https://pjudge.ac/problem/21636\" class=\"uri\">https://pjudge.ac/problem/21636</a></p>\n<blockquote>\n<p>给定初始为空的多重集 <span class=\"math inline\">\\(p\\)</span>, <span class=\"math inline\">\\(q\\)</span>，这两个多重集中的元素都有 <span class=\"math inline\">\\(a,b\\)</span> 两种属性。需要需要维护 <span class=\"math inline\">\\(p\\)</span> 和 <span class=\"math inline\">\\(q\\)</span> 的加点和删点操作，询问 <span class=\"math inline\">\\(\\forall \\,i\\in p,j\\in q\\)</span>，<span class=\"math inline\">\\(\\max(i_x + j_x, i_y + j_y)\\)</span> 的最小值。</p>\n<p><span class=\"math inline\">\\(m\\le 10^6,V\\le 10^9\\)</span>。</p>\n</blockquote>\n<ul>\n<li>考虑<strong>对不等式恒等变形，转化为偏序问题</strong>。若 <span class=\"math inline\">\\(a_{i,0}+b_{j,0}\\ge a_{i,1}+b_{j,1}\\)</span>，则 <span class=\"math inline\">\\(a_{i,0}-a_{i,1}\\ge b_{j,1}-b_{j,0}\\)</span>。</li>\n<li><p>把 <span class=\"math inline\">\\(a\\)</span> 按照 <span class=\"math inline\">\\(a_{i,0}-a_{i,1}\\)</span> 排序、把 <span class=\"math inline\">\\(b\\)</span> 按照 <span class=\"math inline\">\\(b_{j,1}-b_{j,0}\\)</span> 排序。</p>\n<p>要求某个时刻的答案，需要对于每一个 <span class=\"math inline\">\\(i\\)</span> 找到最小的 <span class=\"math inline\">\\(b_{j,0}\\)</span>，使得 <span class=\"math inline\">\\(b_{j,1}-b_{j,0}\\)</span> 在 <span class=\"math inline\">\\([-\\infty, a_{i,0}-a_{i,1}]\\)</span> 中，同时找到最小的 <span class=\"math inline\">\\(b_{j,1}\\)</span>，使得 <span class=\"math inline\">\\(b_{j,1}-b_{j,0}\\)</span> 在 <span class=\"math inline\">\\([a_{i, 0}-a_{i,1},+\\infty]\\)</span> 中。</p>\n<p>这个带有一点递推的性质，在线段树 pushup 的时候，用左边的 <span class=\"math inline\">\\(b_{j,0}\\)</span> 结合右边的答案得到父亲的答案。</p></li>\n</ul>\n<p><em>听说我之前赛时切了这题？怎么没印象。llsw 讲题的时候说要离线，但是没想到离线做法 orz</em></p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int inf = 2e9 + 1;\nstruct _ &#123; long long aa, ab, ba, bb, u; int l, r, id; &#125;;\nstd::vector&lt;_&gt; t(1);\nstd::vector&lt;std::multiset&lt;long long&gt; &gt; aa(1), ab(1), ba(1), bb(1);\nint tot, cnt;\n#define lt t[p].l\n#define rt t[p].r\nvoid pushup(int p) &#123;\n    t[p].aa = t[p].ab = t[p].ba = t[p].bb = t[p].u = inf;\n    if (lt) &#123;\n        t[p].u = t[lt].u;\n        t[p].aa = t[lt].aa, t[p].ab = t[lt].ab, t[p].ba = t[lt].ba, t[p].bb = t[lt].bb;\n    &#125;\n    if (rt) &#123;\n        t[p].u = std::min(t[p].u, t[rt].u);\n        t[p].aa = std::min(t[p].aa, t[rt].aa);\n        t[p].ab = std::min(t[p].ab, t[rt].ab);\n        t[p].ba = std::min(t[p].ba, t[rt].ba);\n        t[p].bb = std::min(t[p].bb, t[rt].bb);\n    &#125;\n    if (lt &amp;&amp; rt)\n        t[p].u = std::min(&#123; t[p].u, t[lt].ba + t[rt].aa, t[lt].ab + t[rt].bb &#125;);\n    return;\n&#125;\nint adda(int p, long long l, long long r, int x, int a, int b) &#123;\n    if (!p)\n        p = ++tot, t.emplace_back(), t[p].aa = t[p].ab = t[p].ba = t[p].bb = t[p].u = inf;\n    if (l == r) &#123;\n        if (!t[p].id)\n            t[p].id = ++cnt, aa.emplace_back(), ab.emplace_back(), ba.emplace_back(), bb.emplace_back();\n        int id = t[p].id;\n        aa[id].insert(a), ab[id].insert(b);\n        t[p].aa = *aa[id].begin(), t[p].ab = *ab[id].begin();\n        if (!aa[id].empty() &amp;&amp; !ba[id].empty())\n            t[p].u = std::min(*aa[id].begin() + *ba[id].begin(), *ab[id].begin() + *bb[id].begin());\n        else\n            t[p].u = inf;\n        return p;\n    &#125;\n    long long mid = (l + r) &gt;&gt; 1;\n    if (x &lt;= mid) &#123;\n        auto s(adda(lt, l, mid, x, a, b));\n        lt = s;\n    &#125;\n    else &#123;\n        auto s(adda(rt, mid + 1, r, x, a, b));\n        rt = s;\n    &#125;\n    pushup(p);\n    return p;\n&#125;\nint addb(int p, long long l, long long r, int x, int a, int b) &#123;\n    if (!p)\n        p = ++tot, t.emplace_back(), t[p].aa = t[p].ab = t[p].ba = t[p].bb = t[p].u = inf;\n    if (l == r) &#123;\n        if (!t[p].id)\n            t[p].id = ++cnt, aa.emplace_back(), ab.emplace_back(), ba.emplace_back(), bb.emplace_back();\n        int id = t[p].id;\n        ba[id].insert(a), bb[id].insert(b);\n        t[p].ba = *ba[id].begin(), t[p].bb = *bb[id].begin();\n        if (!aa[id].empty() &amp;&amp; !ba[id].empty())\n            t[p].u = std::min(*aa[id].begin() + *ba[id].begin(), *ab[id].begin() + *bb[id].begin());\n        else\n            t[p].u = inf;\n        return p;\n    &#125;\n    long long mid = (l + r) &gt;&gt; 1;\n    if (x &lt;= mid) &#123;\n        auto s(addb(lt, l, mid, x, a, b));\n        lt = s;\n    &#125;\n    else &#123;\n        auto s(addb(rt, mid + 1, r, x, a, b));\n        rt = s;\n    &#125;\n    pushup(p);\n    return p;\n&#125;\nvoid dela(int p, long long l, long long r, int x, int a, int b) &#123;\n    if (l == r) &#123;\n        int id = t[p].id;\n        aa[id].erase(aa[id].find(a)), ab[id].erase(ab[id].find(b));\n        t[p].aa = (aa[id].empty() ? inf : *aa[id].begin());\n        t[p].ab = (ab[id].empty() ? inf : *ab[id].begin());\n        if (!aa[id].empty() &amp;&amp; !ba[id].empty())\n            t[p].u = std::min(*aa[id].begin() + *ba[id].begin(), *ab[id].begin() + *bb[id].begin());\n        else\n            t[p].u = inf;\n        return;\n    &#125;\n    long long mid = (l + r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        dela(lt, l, mid, x, a, b);\n    else\n        dela(rt, mid + 1, r, x, a, b);\n    pushup(p);\n    return;\n&#125;\nvoid delb(int p, long long l, long long r, int x, int a, int b) &#123;\n    if (l == r) &#123;\n        int id = t[p].id;\n        ba[id].erase(ba[id].find(a)), bb[id].erase(bb[id].find(b));\n        t[p].ba = (ba[id].empty() ? inf : *ba[id].begin());\n        t[p].bb = (bb[id].empty() ? inf : *bb[id].begin());\n        if (!aa[id].empty() &amp;&amp; !ba[id].empty())\n            t[p].u = std::min(*aa[id].begin() + *ba[id].begin(), *ab[id].begin() + *bb[id].begin());\n        else\n            t[p].u = inf;\n        return;\n    &#125;\n    long long mid = (l + r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        delb(lt, l, mid, x, a, b);\n    else\n        delb(rt, mid + 1, r, x, a, b);\n    pushup(p);\n    return;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;set.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;set.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int q, rt = 0;\n    std::cin &gt;&gt; q;\n    for (int i = 1; i &lt;= q; ++i) &#123;\n        int op, d, a, b;\n        std::cin &gt;&gt; op &gt;&gt; d &gt;&gt; a &gt;&gt; b;\n        if (op == 0 &amp;&amp; d == 0)\n            dela(rt, -inf, inf, a - b, a, b);\n        else if (op == 0)\n            delb(rt, -inf, inf, b - a, a, b);\n        else if (d == 0)\n            rt = adda(rt, -inf, inf, a - b, a, b);\n        else\n            rt = addb(rt, -inf, inf, b - a, a, b);\n        std::cout &lt;&lt; (t[1].u == inf ? -1 : t[1].u) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h4 id=\"命运利用线段树的分治结构递推\"># 命运（利用线段树的分治结构递推）</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P6773\" class=\"uri\">https://www.luogu.com.cn/problem/P6773</a></p>\n<hr />\n<h4 id=\"对数据结构的爱维护函数\">* 对数据结构的爱（维护函数）</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P5609\" class=\"uri\">https://www.luogu.com.cn/problem/P5609</a></p>\n<blockquote>\n<p>给定长度为 <span class=\"math inline\">\\(n\\)</span> 的数组 <span class=\"math inline\">\\(a\\)</span> 和模数 <span class=\"math inline\">\\(p\\)</span>（<span class=\"math inline\">\\(a_i\\)</span> 初始可能比 <span class=\"math inline\">\\(p\\)</span> 大很多，还有可能为负），给定 <span class=\"math inline\">\\(m\\)</span> 次询问，每次问区间 <span class=\"math inline\">\\([l,r]\\)</span>，进行这样的操作：</p>\n<p>初始 <span class=\"math inline\">\\(sum=0\\)</span>，从 <span class=\"math inline\">\\(l\\)</span> 到 <span class=\"math inline\">\\(r\\)</span>，依次令 <span class=\"math inline\">\\(sum\\gets sum+a_i\\)</span>，当且仅当 <span class=\"math inline\">\\(sum\\ge p\\)</span> 时令 <span class=\"math inline\">\\(sum\\gets sum-p\\)</span>（注意这不是取模，减完之后还是可能 <span class=\"math inline\">\\(\\ge p\\)</span>）。</p>\n<p>问最终 <span class=\"math inline\">\\(sum\\)</span> 的值。<span class=\"math inline\">\\(n\\le 10^6,m\\le 2\\times 10^5\\)</span>。</p>\n</blockquote>\n<p>考虑线段树维护函数。定义 <span class=\"math inline\">\\(f(x)\\)</span> 表示区间上想要减去 <span class=\"math inline\">\\(x\\)</span> 次 <span class=\"math inline\">\\(p\\)</span> 需要的最小初始值（这样才能让定义域和区间长有关），查询时直接二分即可；考虑初始化时如何合并。</p>\n<p>首先思考较为暴力的做法，对于左侧点 <span class=\"math inline\">\\(a\\)</span> 和右侧点 <span class=\"math inline\">\\(b\\)</span>，若 <span class=\"math inline\">\\(f(a+1)-1+s_l-a\\cdot p\\ge f(b)\\)</span>，也即可以减去 <span class=\"math inline\">\\(a+b\\)</span> 次，就可以用 <span class=\"math inline\">\\(\\max(f(a),f(b)-s_l+a\\cdot p)\\)</span> 来更新 <span class=\"math inline\">\\(f(a+b)\\)</span>。</p>\n<p>发现 <span class=\"math inline\">\\((a,b)\\)</span> 的贡献一定小于 <span class=\"math inline\">\\((a+1,b-1)\\)</span> 的贡献；具体地，发现 <span class=\"math inline\">\\(f(x+1)-f(x)\\ge p\\)</span> 后就很显然了。采用双指针，优先移动 <span class=\"math inline\">\\(b\\)</span>，就能把最短区间扫一遍。</p>\n<details>\n<p><summary>关于线段树维护函数</summary></p>\n<p>维护一个函数，形如 <span class=\"math inline\">\\(f_{[l,r]}(x)\\)</span> 表示在 <span class=\"math inline\">\\([l,r]\\)</span> 区间上，<span class=\"math inline\">\\(x\\)</span> 的一个映射</p>\n<p>如果相邻区间的函数可以用某种方式合并，就可以用线段树来维护</p>\n<p>把树建在值域上，就可以在节点内把这段区间每个点对应的函数值存下来。一般来说是静态的，因为这是一个类前缀和的形式，没办法修改</p>\n<p>每个点的点值数组会在当前层被扫一遍，上一层被扫一遍，如果合并能够做到线性，总复杂度就是单 <span class=\"math inline\">\\(\\log\\)</span> 的。</p>\n<p>实际情形下函数本身可能很隐秘、很抽象，怎么优化到线性合并也不太好想</p>\n</details>\n<hr />\n<h4 id=\"compounds模意义下问题\">* COmPoUNdS（模意义下问题）</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P12389\" class=\"uri\">https://www.luogu.com.cn/problem/P12389</a></p>\n<blockquote>\n<p>给定常数模数，维护模意义下的区间加、区间哈希。<span class=\"math inline\">\\(n\\le 10^6\\)</span>。</p>\n</blockquote>\n<p><strong>线段树哈希是可以维护区间加的</strong>，但是没办法维护区间取模</p>\n<p>类似 <a href=\"/20250816/#e---subarray-sum-divisibility\">ABC419E</a> 里面用到的，模意义下序列全等可以转化成差分全等，区间修改就可以简化成单点修改了</p>\n<p>额外判一下开头的元素（维护原数组或者是差分数组之和）是否相等就可以了</p>\n<hr />\n<h4 id=\"改进代码模意义下问题\">* 改进代码（模意义下问题）</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P4635\" class=\"uri\">https://www.luogu.com.cn/problem/P4635</a></p>\n<blockquote>\n<p>给定序列 <span class=\"math inline\">\\(a_{1\\sim n}\\)</span> 和常数 <span class=\"math inline\">\\(p\\)</span>，维护:</p>\n<ul>\n<li>修改：模 <span class=\"math inline\">\\(p\\)</span> 意义下区间加；</li>\n<li>询问：区间中 <span class=\"math inline\">\\(\\sum\\limits_{i=l}^{r-1}[a_i&gt;a_{i+1}]\\)</span>。</li>\n</ul>\n<p><span class=\"math inline\">\\(n\\le 10^5,p\\le 10^6\\)</span>。</p>\n</blockquote>\n<p>询问也和模意义差分有关系，假如 <span class=\"math inline\">\\(s\\)</span> 为当前差分数组前缀和模 <span class=\"math inline\">\\(p\\)</span> 的值（也就是原数），发现<strong>前一个数 <span class=\"math inline\">\\(&gt;\\)</span> 后一个数当且仅当 <span class=\"math inline\">\\(s\\)</span> 加爆了</strong>。维护原数组用来确定 <span class=\"math inline\">\\(s\\)</span> 的初值。再维护区间内差分数组之和（不取模），<strong>在这个和里有多少个 <span class=\"math inline\">\\(p\\)</span> 就会爆多少次</strong>。</p>\n<hr />\n<h4 id=\"黑白树很新的东西\">黑白树（很新的东西）</h4>\n<p><a href=\"http://222.180.160.110:61235/problem/46907\" class=\"uri\">http://222.180.160.110:61235/problem/46907</a></p>\n<hr />\n<h3 id=\"以楼房重建为代表的-log2-一类前缀信息维护\">以楼房重建为代表的 <span class=\"math inline\">\\(\\log^2\\)</span> 一类前缀信息维护</h3>\n<p>特点：pushup 时需要先获得一边的信息，在另一边进行线段树上二分，单次操作是 <span class=\"math inline\">\\(O(\\log^2)\\)</span> 的</p>\n<p>本质是一类具有<strong>单调性</strong>的前 / 后缀信息，<strong>区间对全局的贡献</strong>和<strong>区间外的信息</strong>有关，故不能直接维护对全局的贡献，只能维护区间内的答案。但由于两个子区间答案可以合并出大区间答案（通过线段树上二分得到需要的信息），所以只需要逐层向上合并就可以得到全局答案</p>\n<p>一个名字是『线段树维护前缀信息』，感觉不很精确。log 方线段树又是什么鬼名字？更多还是叫的楼房重建线段树吧</p>\n<hr />\n<h4 id=\"楼房重建\">楼房重建</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P4198\" class=\"uri\">https://www.luogu.com.cn/problem/P4198</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(a_{1\\sim n}\\)</span>，维护 <span class=\"math inline\">\\(q\\)</span> 次操作：</p>\n<ul>\n<li>单点修改；</li>\n<li>查询 <span class=\"math inline\">\\(\\dfrac{a_i}i\\)</span> 的前缀最大值序列长度。</li>\n</ul>\n<p><span class=\"math inline\">\\(n,q\\le 10^5\\)</span>。</p>\n</blockquote>\n<p>Fractures 说当年（初一）是他力荐 gm 给我们拉这个题的。dashena！</p>\n<ul>\n<li>线段树维护单调栈，或者说前缀最值，维护方式过于经典，使得『楼房重建』成为该 trick 称呼之一</li>\n<li><p>考虑 pushup。保留左边整段区间，对于左区间序列末的元素 <code>l.rv</code>，我们在右区间内找到第一个大于之的元素 <span class=\"math inline\">\\(x\\)</span>，从它开始的序列就是答案。</p>\n反证法易得 <span class=\"math inline\">\\(x\\)</span> 一定在右区间答案序列内：若 <span class=\"math inline\">\\(x\\)</span> 不在答案序列内，则右区间内存在一个 <span class=\"math inline\">\\(&gt;x\\)</span> 且位于 <span class=\"math inline\">\\(x\\)</span> 之前的元素，那么 <span class=\"math inline\">\\(x\\)</span> 就不是第一个 <code>&gt; l.rv</code> 的元素，矛盾。</li>\n<li><p>故在右区间中二分能够接上去的区间长度，加起来即可。</p>\n<p>题目只要求总区间答案，故不需要查询。动态开点可能需要小心处理一下。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e5 + 5;\nstruct &#123;\n    int l, r, u;\n    double lv, rv, mv;\n&#125; t[maxn &lt;&lt; 2];\nint tot;\n#define lt t[p].l\n#define rt t[p].r\nint askt(int p, int l, int r, double v) &#123;\n    if (l == r)\n        return t[p].u;\n    int mid = (l + r) &gt;&gt; 1;\n    if (lt &amp;&amp; t[p].mv &gt; v)\n        return t[p].u - t[lt].u + askt(lt, l, mid, v);\n    return askt(rt, mid + 1, r, v);\n&#125;\nvoid pushup(int p, int l, int r) &#123;\n    t[p].mv = t[lt].rv;\n    if (lt &amp;&amp; rt) &#123;\n        t[p].lv = t[lt].lv;\n        t[p].rv = std::max(t[lt].rv, t[rt].rv);\n        if (t[lt].rv &lt; t[rt].lv)\n            t[p].u = t[lt].u + t[rt].u;\n        else if (t[lt].rv &gt;= t[rt].rv)\n            t[p].u = t[lt].u;\n        else &#123;\n            int mid = (l + r) &gt;&gt; 1;\n            t[p].u = t[lt].u + askt(rt, mid + 1, r, t[lt].rv);\n        &#125;\n    &#125;\n    else &#123;\n        t[p].u = t[lt + rt].u;\n        t[p].lv = t[lt + rt].lv, t[p].rv = t[lt + rt].rv;\n    &#125;\n    return;\n&#125;\nvoid upd(int &amp;p, int l, int r, int x, double v) &#123;\n    if (!p)\n        p = ++tot;\n    if (l == r) &#123;\n        t[p].lv = t[p].rv = v, t[p].u = 1;\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        upd(lt, l, mid, x, v);\n    else\n        upd(rt, mid + 1, r, x, v);\n    pushup(p, l, r);\n    return;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;P4198_2.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m, rt = 0;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;double&gt; a(n + 1);\n    for (int x; m--; ) &#123;\n        double y;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        a[x] = y / x;\n        upd(rt, 1, n, x, y / x);\n        std::cout &lt;&lt; t[1].u &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h4 id=\"二叉搜索树\">二叉搜索树</h4>\n<p><a href=\"https://pjudge.ac/problem/21889\" class=\"uri\">https://pjudge.ac/problem/21889</a></p>\n<blockquote>\n<p>给定一个大小为 <span class=\"math inline\">\\(n\\)</span> 的树，树上每个元素是一个 BST，你需要维护 <span class=\"math inline\">\\(q\\)</span> 次操作：</p>\n<ol type=\"1\">\n<li>对于树上的一条路径 <span class=\"math inline\">\\((u,v)\\)</span>，在经过的所有节点上的 BST 插入 <span class=\"math inline\">\\(x\\)</span>，保证任意时刻 BST 中无相同值</li>\n<li>在点 <span class=\"math inline\">\\(u\\)</span> 查找 <span class=\"math inline\">\\(x\\)</span>，如果 <span class=\"math inline\">\\(x\\)</span> 存在则返回其到 BST 根的元素和，否则返回查找时最远走到的那个点，到 BST 根的元素和。</li>\n</ol>\n<p><span class=\"math inline\">\\(n,q\\le 2\\times 10^5\\)</span>。</p>\n</blockquote>\n<ul>\n<li>考虑链上问题。差分，把更新 <span class=\"math inline\">\\([l, r]\\)</span> 看作在差分数组 <span class=\"math inline\">\\(l\\)</span> 处插入，在 <span class=\"math inline\">\\(r+1\\)</span> 处删除，离线下来再从左到右扫一遍操作就能更新。</li>\n<li>考虑查询。<span class=\"math inline\">\\(i\\)</span> 树上存在过的所有元素是已知的，考虑如何基于此获取 <span class=\"math inline\">\\(i\\)</span> 树上 <span class=\"math inline\">\\(t_0\\)</span> 时刻，<span class=\"math inline\">\\(x\\)</span> 的所有祖先。</li>\n<li><p>对于比 <span class=\"math inline\">\\(x\\)</span> 大的元素，考虑祖先 <span class=\"math inline\">\\(p_a\\)</span> 和非祖先 <span class=\"math inline\">\\(p\\)</span> 的区别：</p>\n<p>根据 BST 的性质易得，对于最低的右侧祖先 <span class=\"math inline\">\\({p_a}_0\\)</span>，其是 <span class=\"math inline\">\\(\\ge x\\)</span> 的最小的元素（加入时刻 <span class=\"math inline\">\\(t_a&lt;t_0\\)</span>）；</p>\n同理可以找到 <span class=\"math inline\">\\({p_a}_0\\)</span> 右侧最低的祖先（其左侧的祖先显然也在 <span class=\"math inline\">\\(x\\)</span> 左侧），该祖先满足 <span class=\"math inline\">\\(t&lt;t_a\\)</span>。从左右两边分别得到 <span class=\"math inline\">\\(x\\)</span> 的所有祖先。容易证明该过程对于不在树上的 <span class=\"math inline\">\\(x\\)</span> 也是正确的。</li>\n<li>具体地，需要能够求出 <span class=\"math inline\">\\(\\ge x\\)</span> 的元素中，以 <span class=\"math inline\">\\(t_0\\)</span> 为起点的前缀最小值序列的区间和。线段树维护单调栈容易解决不带 <span class=\"math inline\">\\(t_0\\)</span> 限制的答案；再次利用性质就能满足限制。</li>\n<li><p>对于树的情况，把差分放到树上，线段树合并即可。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int lim = 2e5;\nconst int maxn = 2e7 + 5;\nconst int inf = 0x3f3f3f3f;\nstruct &#123;\n    int l, r, rv;\n    long long u;\n&#125; t[maxn];\nstd::vector&lt;int&gt; tr;\n#define lt t[p].l\n#define rt t[p].r\nint newnode(void) &#123;\n    static int tot = 0;\n    if (tr.empty())\n        return ++tot;\n    auto p(tr.back());\n    t[p].l = t[p].r = 0;\n    tr.pop_back();\n    return p;\n&#125;\nlong long askv(int p, int l, int r, int v) &#123;\n    if (l == r)\n        return t[p].rv &lt; v ? t[p].u : 0;\n    int mid = (l + r) &gt;&gt; 1;\n    if (v &gt; t[lt].rv)\n        return t[p].u - t[lt].u + askv(lt, l, mid, v);\n    return askv(rt, mid + 1, r, v);\n&#125;\nvoid pushup(int p, int l, int r) &#123;\n    t[p].rv = std::min(t[lt].rv, t[rt].rv);\n    int mid = (l + r) &gt;&gt; 1;\n    t[p].u = t[lt].u + askv(rt, mid + 1, r, t[lt].rv);\n    return;\n&#125;\nvoid upd(int &amp;p, int l, int r, int x, int v, int u) &#123;\n    if (!p)\n        p = newnode();\n    if (l == r) &#123;\n        t[p].rv = v, t[p].u = u;\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        upd(lt, l, mid, x, v, u);\n    else\n        upd(rt, mid + 1, r, x, v, u);\n    pushup(p, l, r);\n    return;\n&#125;\nvoid merge(int &amp;p, int q, int l, int r) &#123;\n    if (!p || !q) &#123;\n        p += q;\n        return;\n    &#125;\n    if (l == r) &#123;\n        t[p].rv = std::min(t[p].rv, t[q].rv);\n        t[p].u = std::max(t[p].u, t[q].u);\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    merge(t[p].l, t[q].l, l, mid), merge(t[p].r, t[q].r, mid + 1, r);\n    pushup(p, l, r), tr.push_back(q);\n    return;\n&#125;\nint qv = inf;\nlong long ask(int p, int l, int r, int ql, int qr) &#123;\n    if (ql &lt;= l &amp;&amp; r &lt;= qr) &#123;\n        auto s(askv(p, l, r, qv));\n        qv = std::min(qv, t[p].rv);\n        return s;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    long long res = 0ll;\n    if (ql &lt;= mid)\n        res = ask(lt, l, mid, ql, qr);\n    if (qr &gt; mid)\n        res += ask(rt, mid + 1, r, ql, qr);\n    return res;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;ex_problem4.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; top(n + 1), fa(n + 1), siz(n + 1), son(n + 1), dep(n + 1);\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int faa) &#123;\n        siz[x] = 1;\n        for (auto i : g[x])\n            if (i != faa) &#123;\n                fa[i] = x, dep[i] = dep[x] + 1;\n                DFS(i, x), siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1, -1);\n    DFS = [&amp;](int x, int topp) &#123;\n        top[x] = topp;\n        if (son[x])\n            DFS(son[x], topp);\n        for (auto i : g[x])\n            if (i != fa[x] &amp;&amp; i != son[x])\n                DFS(i, i);\n        return;\n    &#125;;\n    DFS(1, 1);\n    auto getLCA = [&amp;](int x, int y) &#123;\n        for (; top[x] != top[y]; x = fa[top[x]])\n            if (dep[top[y]] &gt; dep[top[x]])\n                std::swap(x, y);\n        return (dep[x] &lt; dep[y] ? x : y);\n    &#125;;\n    std::vector&lt;std::vector&lt;int&gt; &gt; d(n + 1);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; u(n + 1);\n    std::vector&lt;std::vector&lt;std::tuple&lt;int, int, int&gt; &gt; &gt; q(n + 1);\n    int cnt = 0;\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        int op;\n        std::cin &gt;&gt; op;\n        if (op == 0) &#123;\n            int x, v;\n            std::cin &gt;&gt; x &gt;&gt; v;\n            q[x].emplace_back(++cnt, i, v);\n        &#125; else &#123;\n            int x, y, v;\n            std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; v;\n            int faa = getLCA(x, y);\n            u[x].emplace_back(i, v), u[y].emplace_back(i, v);\n            if (fa[faa])\n                d[fa[faa]].emplace_back(v);\n        &#125;\n    &#125;\n    std::vector&lt;long long&gt; res(cnt + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; rt(2, std::vector&lt;int&gt; (n + 1));\n    t[0].rv = inf;\n    DFS = [&amp;](int x, int fa) &#123;\n        for (auto i : g[x])\n            if (i != fa) &#123;\n                DFS(i, x);\n                merge(rt[0][x], rt[0][i], 1, lim);\n                merge(rt[1][x], rt[1][i], 1, lim);\n            &#125;\n        for (auto [t, v] : u[x]) &#123;\n            upd(rt[0][x], 1, lim, v, t, v);\n            upd(rt[1][x], 1, lim, lim - v + 1, t, v);\n        &#125;\n        for (auto v : d[x]) &#123;\n            upd(rt[0][x], 1, lim, v, inf, 0);\n            upd(rt[1][x], 1, lim, lim - v + 1, inf, 0);\n        &#125;\n        for (auto [id, t, v] : q[x]) &#123;\n            qv = t, res[id] = ask(rt[0][x], 1, lim, v, lim);\n            qv = t, res[id] += ask(rt[1][x], 1, lim, lim - v + 1, lim);\n            qv = t, res[id] -= ask(rt[0][x], 1, lim, v, v);\n        &#125;\n    &#125;;\n    DFS(1, -1);\n    for (int i = 1; i &lt;= cnt; ++i)\n        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h4 id=\"nastya-and-cbs\">Nastya and CBS</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1340F\" class=\"uri\">https://www.luogu.com.cn/problem/CF1340F</a></p>\n<blockquote>\n<p>给定长度为 <span class=\"math inline\">\\(n\\)</span> 的括号序列，由 <span class=\"math inline\">\\(k\\)</span> 种括号对（<span class=\"math inline\">\\(-i,i\\)</span> 表示第 <span class=\"math inline\">\\(i\\)</span> 种左、右括号）组成，你需要维护单点修改元素、区间查询是否为合法括号序列。</p>\n<p><span class=\"math inline\">\\(1\\le k\\le n\\le 10^5,q\\le 10^5\\)</span>。</p>\n</blockquote>\n<ul>\n<li>考虑不带修且允许 <span class=\"math inline\">\\(O(n)\\)</span> 询问的情景，经典题，扫一遍，用栈维护即可；</li>\n<li><p><span class=\"math inline\">\\(k=1\\)</span> 时是线段树经典题，可以类比这个经典题，从刻画合法的条件入手。</p>\n如果存在相邻且可以匹配的可以直接消掉，一直重复这样的操作，此时要么包含不能匹配的子串，如 <code>&#123;[)&#125;</code>，要么是 <code>)]&#125; (&#123;[&#123;&#123;</code> 的形式。</li>\n<li>考虑怎么 pushup，发现中间生成的一段 <code>([()])</code> 必须完全匹配，消掉它们之后，大区间又变成 <code>)]&#125; (&#123;[&#123;&#123;</code> 的形式。</li>\n<li>每次 pushup 要合并的区间很长，考虑怎么快速地做『消除相邻匹配括号』这一步。容易想到记录一段括号（例：<code>([&#123;</code>）及其对应反括号（例：<code>&#125;])</code>）的哈希值，check 是否相等，然后就可以不管它们了，并不是真的要删去。</li>\n<li><p>线段树不能维护每个前后缀的哈希值，但需要的只是在<strong>删除连续匹配括号后</strong>长度为 <span class=\"math inline\">\\(len\\)</span> 的哈希值，可以线段树上二分。</p>\n这个过程有点困难，需要在询问的同时匹配、消除；但发现所谓消除就是对位相减，注意一下什么时候移位，还是好写的。</li>\n<li><p>询问看似不太可做，因为中途的答案不是线段树的节点；如果把询问看成一次修改，就可以用类似可持久化的方式实现。</p>\n<p>由于并不是真的要可持久化，询问新建的点可以重复利用。如果不重复利用，每次询问最多新建 <span class=\"math inline\">\\(O(\\log n)\\)</span> 个点，空间复杂度 <span class=\"math inline\">\\(O(q\\log n)\\)</span>，在 CF 上有点卡，也是能过的。</p></li>\n</ul>\n<details>\n<p>Hint：有卡 998244353 的 Hack，故可以用 1e9 + 7 当模数；WA on 7 是正确性有巨大问题，WA on 8 可能是 long long 没开完 / 数组开小了 / 哈希方向有问题 / 线段树上二分写挂了（通常是消括号消错了）。前人踩坑后人嘲笑。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nconst int base = 1e5 + 3;\nconst int maxn = 7e5 + 5;\nstruct Node &#123;\n    bool flag;\n    long long hr0, hl1;\n    int l, r, lc, rc, ll, rl;\n    Node&amp; operator= (const Node &amp;q) &#123;\n        flag = q.flag, hr0 = q.hr0, hl1 = q.hl1;\n        l = q.l, r = q.r, ll = q.ll, rl = q.rl;\n        return *this;\n    &#125;\n    Node operator+ (const Node &amp;q) const;\n&#125; t[maxn &lt;&lt; 2];\nint tot;\nint a[maxn];\nlong long bpow[maxn], inv[maxn];\nlong long askhl1(const Node &amp;p, int k) &#123;\n    if (k == 0)\n        return 0ll;\n    if (k &gt; p.ll)\n        return -1ll;\n    if (p.ll == k)\n        return p.hl1;\n    int ll = t[p.lc].ll, rl = t[p.lc].rl;\n    if (ll &gt;= k)\n        return askhl1(t[p.lc], k);\n    k -= ll, k += rl;\n    auto hl1 = askhl1(t[p.rc], k);\n    hl1 = ((hl1 + mod - t[p.lc].hr0) * inv[rl] % mod * bpow[ll] % mod + t[p.lc].hl1) % mod;\n    return hl1;\n&#125;\nlong long askhr0(const Node &amp;p, int k) &#123;\n    if (k == 0)\n        return 0ll;\n    if (k &gt; p.rl)\n        return -1ll;\n    if (p.rl == k)\n        return p.hr0;\n    int rl = t[p.rc].rl, ll = t[p.rc].ll;\n    if (rl &gt;= k)\n        return askhr0(t[p.rc], k);\n    k -= rl, k += ll;\n    auto hr0 = askhr0(t[p.lc], k);\n    hr0 = ((hr0 + mod - t[p.rc].hl1) * inv[ll] % mod * bpow[rl] % mod + t[p.rc].hr0) % mod;\n    return hr0;\n&#125;\nNode Node::operator+ (const Node &amp;q) const  &#123;\n    Node res;\n    res.l = l, res.r = q.r;\n    if (flag || q.flag)\n        res.flag = 1;\n    else &#123;\n        if (rl == q.ll) &#123;\n            if (hr0 == q.hl1) &#123;\n                res.flag = 0;\n                res.ll = ll, res.rl = q.rl;\n                res.hl1 = hl1, res.hr0 = q.hr0;\n            &#125;\n            else\n                res.flag = 1;\n        &#125;\n        else if (rl &lt; q.ll) &#123;\n            auto qhl1 = askhl1(q, rl);\n            if (hr0 == qhl1) &#123;\n                res.flag = 0;\n                res.ll = ll + q.ll - rl, res.rl = q.rl;\n                res.hl1 = ((q.hl1 + mod - qhl1) % mod * inv[rl] % mod * bpow[ll] % mod + hl1) % mod;\n                res.hr0 = q.hr0;\n            &#125;\n            else\n                res.flag = 1;\n        &#125;\n        else &#123;\n            auto phr0 = askhr0(*this, q.ll);\n            if (phr0 == q.hl1) &#123;\n                res.flag = 0;\n                res.ll = ll, res.rl = rl - q.ll + q.rl;\n                res.hl1 = hl1;\n                res.hr0 = ((hr0 + mod - phr0) % mod * inv[q.ll] % mod * bpow[q.rl] % mod + q.hr0) % mod;\n            &#125;\n            else\n                res.flag = 1;\n        &#125;\n    &#125;\n    return res;\n&#125;\nvoid bld(int &amp;p, int l, int r) &#123;\n    p = ++tot;\n    if (l == r) &#123;\n        t[p].l = t[p].r = l;\n        if (a[l] &lt; 0)\n            t[p].ll = 1, t[p].hl1 = -a[l];\n        else\n            t[p].rl = 1, t[p].hr0 = a[l];\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(t[p].lc, l, mid), bld(t[p].rc, mid + 1, r);\n    t[p] = t[t[p].lc] + t[t[p].rc];\n    return;\n&#125;\nvoid add(int p, int x, int v) &#123;\n    if (t[p].l == t[p].r) &#123;\n        if (v &lt; 0) &#123;\n            t[p].rl = 0, t[p].hr0 = 0ll;\n            t[p].ll = 1, t[p].hl1 = -v;\n        &#125;\n        else &#123;\n            t[p].ll = 0, t[p].hl1 = 0ll;\n            t[p].rl = 1, t[p].hr0 = v;\n        &#125;\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        add(t[p].lc, x, v);\n    else\n        add(t[p].rc, x, v);\n    t[p] = t[t[p].lc] + t[t[p].rc];\n    return;\n&#125;\nint ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return p;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (r &lt;= mid)\n        return ask(t[p].lc, l, r);\n    if (l &gt; mid)\n        return ask(t[p].rc, l, r);\n    int q = ++tot;\n    t[q].lc = ask(t[p].lc, l, r);\n    t[q].rc = ask(t[p].rc, l, r);\n    t[q] = t[t[q].lc] + t[t[q].rc];\n    return q;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, k, rt = 0;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    bpow[0] = inv[0] = 1ll;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[1] = qkp(base, mod - 2);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        bpow[i] = bpow[i - 1] * base % mod;\n        if (i &gt;= 2)\n            inv[i] = inv[i - 1] * inv[1] % mod;\n    &#125;\n    bld(rt, 1, n);\n    int q;\n    std::cin &gt;&gt; q;\n    for (int op; q--; ) &#123;\n        std::cin &gt;&gt; op;\n        if (op == 1) &#123;\n            int x, v;\n            std::cin &gt;&gt; x &gt;&gt; v;\n            add(1, x, v);\n        &#125;\n        else &#123;\n            int l, r;\n            std::cin &gt;&gt; l &gt;&gt; r;\n            if ((r - l + 1) &amp; 1)\n                std::cout &lt;&lt; &quot;No&quot; &lt;&lt; &#39;\\n&#39;;\n            else &#123;\n                auto s(ask(1, l, r));\n                std::cout &lt;&lt; ((!t[s].flag &amp;&amp; !t[s].ll &amp;&amp; !t[s].rl) ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; &#39;\\n&#39;;\n            &#125;\n        &#125;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h4 id=\"hungry-cow-p\"># Hungry Cow P</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P9130\" class=\"uri\">https://www.luogu.com.cn/problem/P9130</a></p>\n<hr />\n<h4 id=\"牛半仙的妹子序列\"># 牛半仙的妹子序列</h4>\n<p><a href=\"http://222.180.160.110:61235/problem/29550\" class=\"uri\">http://222.180.160.110:61235/problem/29550</a></p>\n<hr />\n<h4 id=\"organizing-a-race\"># Organizing a Race</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/CF671E\" class=\"uri\">https://www.luogu.com.cn/problem/CF671E</a></p>\n<p>这个题不太应该放在这里的，因为存在只用一只 log 的纯线段树上二分做法，用楼房重建显得有点唐了</p>\n<hr />\n<h4 id=\"转盘\"># 转盘</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P4425\" class=\"uri\">https://www.luogu.com.cn/problem/P4425</a></p>\n<hr />\n<h4 id=\"前进四楼房重建-ver\"># 前进四（楼房重建 ver）</h4>\n<p><a href=\"https://uoj.ac/problem/515\" class=\"uri\">https://uoj.ac/problem/515</a></p>\n<p>另见 <a href=\"#-前进四segment-tree-beats-ver\">segment tree beats ver</a></p>\n<h3 id=\"可持久化线段树\">可持久化线段树</h3>\n<h4 id=\"card-game\"># Card Game</h4>\n<p><a href=\"https://qoj.ac/problem/8240\" class=\"uri\">https://qoj.ac/problem/8240</a></p>\n<hr />\n<h3 id=\"历史信息\">历史信息</h3>\n<h4 id=\"比赛\"># 比赛</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P8868\" class=\"uri\">https://www.luogu.com.cn/problem/P8868</a></p>\n<hr />\n<h4 id=\"v\"># V</h4>\n<p><a href=\"https://uoj.ac/problem/164\" class=\"uri\">https://uoj.ac/problem/164</a></p>\n<hr />\n<h4 id=\"cartesian-tree\"># Cartesian Tree</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1290E\" class=\"uri\">https://www.luogu.com.cn/problem/CF1290E</a></p>\n<hr />\n<h4 id=\"rprmq1\"># rprmq1</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P6109\" class=\"uri\">https://www.luogu.com.cn/problem/P6109</a></p>\n<hr />\n<h4 id=\"rpfrdtzls\"># rpfrdtzls</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P9057\" class=\"uri\">https://www.luogu.com.cn/problem/P9057</a></p>\n<hr />\n<h4 id=\"test_90\"># TEST_90</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P9990\" class=\"uri\">https://www.luogu.com.cn/problem/P9990</a></p>\n<hr />\n<h3 id=\"线段树合并\">线段树合并</h3>\n<p>树上的线段树合并都很熟悉了，利用了线段树合并是线性的，以及 dsu on tree</p>\n<p>不如说绝大多数线段树合并都有树上背景，因为自带合并顺序和复杂度保证</p>\n<p>Tip：树上合并的背景下，线段树合并的表现会比主席树优秀很多，因为前者跑不满</p>\n<p>不在树上的问题，题目可能会通过各种方式保证复杂度，比如保证每个点只会被合并一次之类</p>\n<hr />\n<h4 id=\"迁移计划-migration-plan\"># 迁移计划 / Migration Plan</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P11993\" class=\"uri\">https://www.luogu.com.cn/problem/P11993</a></p>\n<hr />\n<h4 id=\"永无乡\"># 永无乡</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P3224\" class=\"uri\">https://www.luogu.com.cn/problem/P3224</a></p>\n<hr />\n<h4 id=\"语言\"># 语言</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P5327\" class=\"uri\">https://www.luogu.com.cn/problem/P5327</a></p>\n<hr />\n<h4 id=\"梦幻布丁\"># 梦幻布丁</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P3201\" class=\"uri\">https://www.luogu.com.cn/problem/P3201</a></p>\n<hr />\n<p>还有两个比较屎的 P7563 和 P7963</p>\n<h3 id=\"扫描线\">扫描线</h3>\n<p>离线，按照下标排序，扫一遍处理询问，就可以利用『所有更靠前的下标都以被计算过』来处理问题</p>\n<p>不只局限于区间询问，单点的可能反而更难一点，需要发现和下标大小有关的性质</p>\n<h4 id=\"等差子序列\">等差子序列</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P2757\" class=\"uri\">https://www.luogu.com.cn/problem/P2757</a></p>\n<blockquote>\n<p>给定一个 <span class=\"math inline\">\\(n\\)</span> 的排列，问是否能找到 <span class=\"math inline\">\\(len\\ge 3\\)</span> 的子序列，使得其是等差的。</p>\n<p><span class=\"math inline\">\\(n\\le 5\\times 10^5\\)</span>。</p>\n</blockquote>\n<p>根据单调性，可以简化为 <span class=\"math inline\">\\(len=3\\)</span> 时的答案</p>\n<p>也就是对于中项 <span class=\"math inline\">\\(j\\)</span>，能不能找到 <span class=\"math inline\">\\(i&lt;j&lt;k\\)</span>，使得 <span class=\"math inline\">\\(a_j-a_i=a_k-a_j\\)</span>。从下标出发，差值是不好维护的；注意到是排列，可以从值出发，转化成是否存在一个 <span class=\"math inline\">\\(d\\)</span>，使得 <span class=\"math inline\">\\(a_j-d\\)</span> 在之前出现，<span class=\"math inline\">\\(a_j+d\\)</span> 在之后出现。</p>\n<p>利用下标『之前』和『之后』的限制，做扫描线，查看是否存在 <span class=\"math inline\">\\(d\\)</span> 使 <span class=\"math inline\">\\(a_j-d\\)</span> 出现过但是 <span class=\"math inline\">\\(a_j+d\\)</span> 没有出现过；还是因为是排列，数量只会为 <span class=\"math inline\">\\(0\\)</span> 或 <span class=\"math inline\">\\(1\\)</span>，如果非法说明 <span class=\"math inline\">\\(a_j-d\\)</span> 和 <span class=\"math inline\">\\(a_j+d\\)</span> 都是 <span class=\"math inline\">\\(0\\)</span> 或者都是 <span class=\"math inline\">\\(1\\)</span>，发现是关于 <span class=\"math inline\">\\(a_j\\)</span> 的回文，故权值线段树维护哈希，如果 <span class=\"math inline\">\\(a_j\\)</span> 两侧全部回文，说明 <span class=\"math inline\">\\(j\\)</span> 不是合法中项。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nnamespace fastIO &#123;\nconst int LEN = (1 &lt;&lt; 20);\n#ifdef ONLINE_JUDGE\ninline int nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf)\n            return EOF;\n        p = buf;\n    &#125;\n    return *p++;\n&#125;\n#else\n#define nec getchar\n#endif\ninline bool read(int &amp;x) &#123;\n    x = 0;\n    bool f = 0;\n    char ch = nec();\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF)\n            return 0;\n        if (ch == &#39;-&#39;)\n            f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f)\n        x = -x;\n    return 1;\n&#125;\nvoid print(int x) &#123;\n    if (x &lt; 0) &#123;\n        putchar(&#39;-&#39;);\n        x = -x;\n    &#125;\n    if (x &gt;= 10)\n        print(x / 10);\n    putchar(x % 10 + &#39;0&#39;);\n    return;\n&#125;\nvoid print(int x, char ch) &#123;\n    print(x);\n    putchar(ch);\n    return;\n&#125;\n&#125; // namespace fastIO\nnamespace XSC062 &#123;\nusing namespace fastIO;\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nusing sc = unsigned long long;\nconst int p = 13331; // 0103 ¿É°®µÎÄó \nconst int lim = 5e5;\nconst int maxn = 5e5 + 5;\nstruct _ &#123;\n    int l, r;\n    sc lh, rh;\n&#125;;\nint T, n;\nint a[maxn];\nsc base[maxn];\n_ t[maxn &lt;&lt; 2];\nint min(int x, int y) &#123;\n    return x &lt; y ? x : y;\n&#125;\nint max(int x, int y) &#123;\n    return x &gt; y ? x : y;\n&#125;\nvoid pushup(int p) &#123;\n    int ll = t[lt].r - t[lt].l + 1;\n    int rl = t[rt].r - t[rt].l + 1;\n    t[p].lh = t[lt].lh * base[rl] + t[rt].lh;\n    t[p].rh = t[rt].rh * base[ll] + t[lt].rh;\n    return;\n&#125;\nvoid bld(int p, int l, int r) &#123;\n    t[p].lh = t[p].rh = 0;\n    t[p].l = l, t[p].r = r;\n    if (l == r)\n        return;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid);\n    bld(rt, mid + 1, r);\n    return;\n&#125;\nvoid upd(int p, int x, int v) &#123;\n    if (t[p].l == t[p].r) &#123;\n        t[p].lh = t[p].rh = v;\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        upd(lt, x, v);\n    else upd(rt, x, v);\n    pushup(p);\n    return;\n&#125;\nsc qryl(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].lh;\n    sc ans = 0;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid)\n        ans = qryl(lt, l, r);\n    if (r &gt; mid) &#123;\n        ans *= base[min(r, t[p].r) - mid];\n        ans += qryl(rt, l, r);\n    &#125;\n    return ans;\n&#125;\nsc qryr(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].rh;\n    sc ans = 0;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (r &gt; mid)\n        ans = qryr(rt, l, r);\n    if (l &lt;= mid) &#123;\n        ans *= base[mid - max(l, t[p].l) + 1];\n        ans += qryr(lt, l, r);\n    &#125;\n    return ans;\n&#125;\nint main() &#123;\n    read(T);\n    base[0] = 1;\n    for (int i = 1; i &lt;= lim; ++i)\n        base[i] = base[i - 1] * p;\n    while (T--) &#123;\n        read(n);\n        bld(1, 1, n);\n        for (int i = 1; i &lt;= n; ++i)\n            read(a[i]);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            int len = min(n - a[i], a[i] - 1);\n            if (i &gt; 1) &#123;\n                upd(1, a[i - 1], 1);\n            &#125;\n            if (len == 0)\n                continue;\n            int l = a[i] - len;\n            int r = a[i] + len;\n            if (qryl(1, l, a[i] - 1) !=\n                qryr(1, a[i] + 1, r)) &#123;\n                puts(&quot;Y&quot;);\n                goto isSol;\n            &#125;\n        &#125;\n        puts(&quot;N&quot;);\n        isSol: ;\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062\nint main() &#123;\n    XSC062::main();\n    return 0;\n&#125;</code></pre>\n</details>\n<h4 id=\"小奇的糖果\">小奇的糖果</h4>\n<p><a href=\"https://hydro.ac/p/bzoj-P4548\" class=\"uri\">https://hydro.ac/p/bzoj-P4548</a></p>\n<blockquote>\n<p>有 <span class=\"math inline\">\\(N\\)</span> 个有颜色（<span class=\"math inline\">\\(M\\)</span> 种）的点在平面上，在平面上取一条水平的线段，可以选择线段上方的所有点，也可以选择下方的所有点。找出一条线段和选取的方向，使得在选取的点不包含所有颜色的前提下，最大化选到点的数量。</p>\n<p><span class=\"math inline\">\\(N,M\\le 10^6,|x|,|y|\\le 10^9\\)</span>。</p>\n</blockquote>\n<p>先离散化 + 按 <span class=\"math inline\">\\(y\\)</span> 排序降一维，贪心地枚举某种颜色 <span class=\"math inline\">\\(c\\)</span> 不选。考虑线段在平面最底部时的答案，取出所有颜色为 <span class=\"math inline\">\\(c\\)</span> 的点的 <span class=\"math inline\">\\(x\\)</span> 坐标，只能选择相邻的 <span class=\"math inline\">\\(x\\)</span> 之间的所有点。枚举每一对相邻的点计算答案。把线段上移，如果碰到了一个颜色为 <span class=\"math inline\">\\(c\\)</span> 的点，就说明这个点不再参与限制，删去即可，该点原前驱和后继围出来的区间就能够更新答案。用链表 / 单调栈就能很快地维护。</p>\n<p>先枚举颜色再跑扫描线是 <span class=\"math inline\">\\(O(n^2\\log n)\\)</span> 的，考虑优化。注意到数据结构里存在当前颜色没有影响，因为一定不在询问区间内。整体做扫描线，复杂度 <span class=\"math inline\">\\(O(n\\log n)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 2e5 + 5;\nstruct _ &#123;\n    int x, y, c;\n    bool operator&lt; (const _ &amp;q) const &#123;\n        return y &lt; q.y;\n    &#125;\n&#125;;\n_ a[maxn];\nint s[maxn], t[maxn];\nint ls[maxn], rs[maxn];\nint cp[maxn], cn[maxn];\nint pre[maxn], nex[maxn];\nstd::vector&lt;int&gt; g[maxn];\nint div[maxn], Bit[maxn];\nint T, n, k, tot, cnt, now, res;\nint max(int x, int y) &#123; return x &gt; y ? x : y; &#125;\nint lowbit(int x) &#123; return x &amp; -x; &#125;\nvoid add(int x, int v) &#123;\n    for (; x &lt;= n; x += lowbit(x)) Bit[x] += v;\n    return;\n&#125;\nint ask(int x) &#123;\n    int res = 0;\n    for (; x; x -= lowbit(x)) res += Bit[x];\n    return res;\n&#125;\nint ask(int l, int r) &#123;\n    if (l &gt; r) return 0;\n    return ask(r) - ask(l - 1);\n&#125;\nint main() &#123;\n//  freopen(&quot;1.in&quot;, &quot;r&quot;, stdin); \n    read(T);\n    while (T--) &#123;\n        read(n), read(k), now = res = 0;\n        for (int i = 1; i &lt;= k; ++i) &#123;\n            s[i] = ++now, t[i] = ++now;\n            div[s[i]] = 0, div[t[i]] = n + 1;\n            nex[s[i]] = t[i], pre[t[i]] = s[i];\n            pre[s[i]] = nex[t[i]] = 0;\n        &#125;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            read(a[i].x), read(a[i].y), read(a[i].c);\n            ls[i] = a[i].x, rs[i] = a[i].y;\n        &#125;\n        std::sort(a + 1, a + n + 1, [&amp;](_ x, _ y) &#123; return x.x &lt; y.x; &#125;);\n        std::sort(ls + 1, ls + n + 1);\n        std::sort(rs + 1, rs + n + 1);\n        tot = std::unique(ls + 1, ls + n + 1) - ls - 1;\n        cnt = std::unique(rs + 1, rs + n + 1) - rs - 1;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            a[i].x = std::lower_bound(ls + 1, ls + tot + 1, a[i].x) - ls;\n            a[i].y = std::lower_bound(rs + 1, rs + cnt + 1, a[i].y) - rs;\n        &#125;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            div[++now] = a[i].x;\n            add(a[i].x, 1), g[a[i].y].push_back(now);\n            pre[now] = pre[t[a[i].c]], nex[pre[t[a[i].c]]] = now;\n            pre[t[a[i].c]] = now, nex[now] = t[a[i].c];\n        &#125;\n        memcpy(cp, pre, sizeof (cp));\n        memcpy(cn, nex, sizeof (cn));\n        for (int i = 1; i &lt;= k; ++i) &#123;\n            for (int j = s[i]; j != t[i]; j = nex[j])\n                res = max(res, ask(div[j] + 1, div[nex[j]] - 1));\n        &#125;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            for (auto j : g[i]) add(div[j], -1);\n            for (auto j : g[i]) &#123;\n                res = max(res, ask(div[pre[j]] + 1, div[nex[j]] - 1));\n                nex[pre[j]] = nex[j], pre[nex[j]] = pre[j];\n            &#125;\n        &#125;\n        for (int i = 1; i &lt;= n; ++i) add(a[i].x, 1);\n        for (int i = n; i; --i) &#123;\n            for (auto j : g[i]) add(div[j], -1);\n            for (auto j : g[i]) &#123;\n                res = max(res, ask(div[cp[j]] + 1, div[cn[j]] - 1));\n                cn[cp[j]] = cn[j], cp[cn[j]] = cp[j];\n            &#125;\n        &#125;\n        print(res, &#39;\\n&#39;);\n        for (int i = 1; i &lt;= n; ++i)\n            g[i].clear(), g[i].shrink_to_fit();\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h4 id=\"rmscne\">rmscne</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P7907\" class=\"uri\">https://www.luogu.com.cn/problem/P7907</a></p>\n<blockquote>\n<p>给定长为 <span class=\"math inline\">\\(n\\)</span> 的序列，<span class=\"math inline\">\\(q\\)</span> 次询问 <span class=\"math inline\">\\([l,r]\\)</span> 中的最短子区间 <span class=\"math inline\">\\([l&#39;,r&#39;]\\)</span>，使得其包含 <span class=\"math inline\">\\([l,r]\\)</span> 中出现的全部值。输出长度即可。</p>\n<p><span class=\"math inline\">\\(n,q,V\\le 2\\times 10^6\\)</span>。</p>\n</blockquote>\n<p>区间里面找子区间也是扫描线经典问题。</p>\n<p>区间种类数会有几种思路：集合哈希、前驱后继、莫队之类。PS：这个题用 ODT 可以拿到最优解</p>\n<p>对于 <span class=\"math inline\">\\(i=1\\sim n\\)</span>，依次考虑 <span class=\"math inline\">\\(i\\)</span> 作为右端点的情况。线段树维护每个 <span class=\"math inline\">\\(j\\)</span> 作为左端点时的 <span class=\"math inline\">\\(i-r_j\\)</span>，其中 <span class=\"math inline\">\\([j, r_j]\\)</span> 是与 <span class=\"math inline\">\\([j,i]\\)</span> 种类相同的最小区间。</p>\n<p>询问的时候，只需要找到最大的 <span class=\"math inline\">\\(j&#39;\\)</span>，满足 <span class=\"math inline\">\\([j, r]\\)</span> 与 <span class=\"math inline\">\\([l, r]\\)</span> 种类相同，求 <span class=\"math inline\">\\([l, j&#39;]\\)</span> 的区间和即可。找 <span class=\"math inline\">\\(j&#39;\\)</span> 可以记录前驱后继，初始每个 <span class=\"math inline\">\\(l\\)</span> 对应的 <span class=\"math inline\">\\(j&#39;\\)</span> 就是自己。若加入了一个与 <span class=\"math inline\">\\(l\\)</span> 相同的新元素，那么 <span class=\"math inline\">\\(l\\)</span> 就不再有贡献，此时 <span class=\"math inline\">\\(l\\)</span> 的 <span class=\"math inline\">\\(j&#39;\\)</span> 就会继承 <span class=\"math inline\">\\(l+1\\)</span> 的 <span class=\"math inline\">\\(j&#39;\\)</span>，这个过程用并查集即可简单维护。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int lim = 2e6;\nconst int maxn = 2e6 + 5;\nconst int maxm = 5e7 + 5;\nconst int inf = 0x3f3f3f3f;\nstruct &#123; int l, r, u, d; &#125; t[maxn &lt;&lt; 2];\nint tot;\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid pushdown(int p) &#123;\n    if (~t[p].d) &#123;\n        t[lt].d = t[rt].d = t[p].d;\n        t[lt].u = t[p].d - t[lt].r + 1;\n        t[rt].u = t[p].d - t[rt].r + 1;\n        t[p].d = -1;\n    &#125;\n    return;\n&#125;\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r, t[p].d = -1;\n    if (l == r)\n        return;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    return;\n&#125;\nvoid upd(int p, int l, int r, int v) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        t[p].d = v, t[p].u = v - t[p].r + 1;\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid)\n        upd(lt, l, r, v);\n    if (r &gt; mid)\n        upd(rt, l, r, v);\n    t[p].u = std::min(t[lt].u, t[rt].u);\n    return;\n&#125;\nint ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].u;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1, res = inf;\n    if (l &lt;= mid)\n        res = ask(lt, l, r);\n    if (r &gt; mid)\n        res = std::min(res, ask(rt, l, r));\n    return res;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, q;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1), la(lim + 1), pre(n + 1), f(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        pre[i] = la[a[i]], la[a[i]] = i, f[i] = i;\n    &#125;\n    std::cin &gt;&gt; q;\n    std::vector&lt;int&gt; res(q + 1);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; t(n + 1);\n    for (int i = 1, l, r; i &lt;= q; ++i) &#123;\n        std::cin &gt;&gt; l &gt;&gt; r;\n        t[r].emplace_back(l, i);\n    &#125;\n    bld(1, 1, n);\n    std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;\n        return x == f[x] ? x : f[x] = find(f[x]);\n    &#125;;\n    auto merge = [&amp;](int x, int y) &#123;\n        x = find(x), y = find(y);\n        f[std::min(x, y)] = std::max(x, y);\n        return;\n    &#125;;\n    for (int r = 1; r &lt;= n; ++r) &#123;\n        if (pre[r])\n            merge(pre[r], pre[r] + 1);\n        upd(1, pre[r] + 1, r, r);\n        for (auto [l, i] : t[r])\n            res[i] = ask(1, l, find(l));\n    &#125;\n    for (int i = 1; i &lt;= q; ++i)\n        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h4 id=\"颜色\"># 颜色</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P4065\" class=\"uri\">https://www.luogu.com.cn/problem/P4065</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(n\\)</span> 个元素，每个元素有一个颜色。选择若干颜色（不能全选或全不选），问有多少种选取方案使得拥有这些颜色的点是一段连续的区间。</p>\n<p><span class=\"math inline\">\\(n\\le 3\\times 10^5\\)</span>。</p>\n</blockquote>\n<hr />\n<h3 id=\"势能线段树\">势能线段树</h3>\n<h4 id=\"市场\"># 市场</h4>\n<p><a href=\"https://loj.ac/p/6029\" class=\"uri\">https://loj.ac/p/6029</a></p>\n<hr />\n<h4 id=\"segment-tree-beats\"># Segment Tree Beats!</h4>\n<blockquote>\n<p>维护区间取 min，区间求和。</p>\n</blockquote>\n<p>pdf P57</p>\n<hr />\n<h4 id=\"segment-tree-beats-plus\"># Segment Tree Beats! Plus</h4>\n<blockquote>\n<p>维护区间加，区间取 min，区间求和。</p>\n</blockquote>\n<p>pdf P60</p>\n<hr />\n<h4 id=\"最假女选手\"># 最假女选手</h4>\n<p><a href=\"https://loj.ac/p/6565\" class=\"uri\">https://loj.ac/p/6565</a></p>\n<hr />\n<h4 id=\"mzl-loves-segment-tree\"># Mzl loves segment tree</h4>\n<p><a href=\"http://222.180.160.110:61235/problem/10203\" class=\"uri\">http://222.180.160.110:61235/problem/10203</a></p>\n<p>pdf P66</p>\n<hr />\n<h4 id=\"ctsn-loves-segment-tree\"># CTSN loves segment tree</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/U180387\" class=\"uri\">https://www.luogu.com.cn/problem/U180387</a></p>\n<hr />\n<h4 id=\"前进四segment-tree-beats-ver\"># 前进四（segment tree beats ver）</h4>\n<p><a href=\"https://uoj.ac/problem/515\" class=\"uri\">https://uoj.ac/problem/515</a></p>\n<p>另见 <a href=\"#-前进四楼房重建-ver\">楼房重建 ver</a></p>\n<hr />\n<h4 id=\"基础数据结构练习题\"># 基础数据结构练习题</h4>\n<p><a href=\"https://uoj.ac/problem/228\" class=\"uri\">https://uoj.ac/problem/228</a></p>\n<hr />\n<h4 id=\"线段树-3\"># 线段树 3</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P6242\" class=\"uri\">https://www.luogu.com.cn/problem/P6242</a></p>\n<hr />\n<h4 id=\"赛格蒙特彼茨\"># 赛格蒙特彼茨</h4>\n<p>pdf P70</p>\n<hr />\n<h4 id=\"堕天作战-test_98\"># 堕天作战 TEST_98</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P9069\" class=\"uri\">https://www.luogu.com.cn/problem/P9069</a></p>\n<hr />\n<h3 id=\"线段树分治\">线段树分治</h3>\n<h4 id=\"八纵八横\"># 八纵八横</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P3733\" class=\"uri\">https://www.luogu.com.cn/problem/P3733</a></p>\n<h2 id=\"笛卡尔树\">笛卡尔树</h2>\n<p>一些思考方式和 trick 吧</p>\n<h3 id=\"由乃救爷爷\">* 由乃救爷爷</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P3793\" class=\"uri\">https://www.luogu.com.cn/problem/P3793</a></p>\n<blockquote>\n<p>尽可能快地维护随机序列区间最值。</p>\n</blockquote>\n<p>随机序列笛卡尔树期望深度是 <span class=\"math inline\">\\(\\log\\)</span>。就可以做了。</p>\n<p>来自 <a href=\"https://www.luogu.com/article/hj9ci08q\">UnyieldingTrilobite 的文章</a>：同样可以用悬线！<a href=\"/20231117/#随机序列悬线结合分块\">悬线 + 分块</a> 就可以做了。</p>\n<hr />\n<h3 id=\"情景剧最值的性质维护方式的取舍\">* 情景剧（最值的性质，维护方式的取舍）</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4273/problem/1\" class=\"uri\">http://222.180.160.110:61235/contest/4273/problem/1</a></p>\n<blockquote>\n<p>给定长度为 <span class=\"math inline\">\\(n\\)</span> 的序列 <span class=\"math inline\">\\(a_{1\\sim n}\\)</span>，找到一个区间，使得 区间长度 <span class=\"math inline\">\\(\\times\\)</span> 区间最大值 <span class=\"math inline\">\\(\\times\\)</span> 区间最小值 最大。输出最大值。</p>\n<p><span class=\"math inline\">\\(n\\le 10^6,V\\le 10^9\\)</span>。</p>\n</blockquote>\n<ul>\n<li>容易想到建笛卡尔树。这里的 最大值 和 最小值 地位相等吗？为什么？</li>\n<li>如果我们是钦定最大值，再去最大化『最小值 <span class=\"math inline\">\\(\\times\\)</span> 区间长』，好像没办法做，因为这个最大贡献没什么性质</li>\n<li><p>但如果钦定最小值，能取到的最长区间就是在小根笛卡尔树上的管辖区间，显然区间越长取到的最大值也越大，直接取这里的最大值即可</p>\n所以最大值和最小值地位不等是因为，区间长和最大值大小是正相关的，所以只需要最大化区间长，最大值也就最大化了</li>\n<li><p>所以在小根笛卡尔树上维护区间最大值即可</p></li>\n</ul>\n<hr />\n<h3 id=\"小蓝的好友\"># 小蓝的好友</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P2611\" class=\"uri\">https://www.luogu.com.cn/problem/P2611</a></p>\n<hr />\n<h3 id=\"星白-by-ttpandas笛卡尔树-dsu-on-tree\">星白 by TTpandaS（笛卡尔树 + dsu on tree）</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/6517/problem/3\" class=\"uri\">http://222.180.160.110:61235/contest/6517/problem/3</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(n\\)</span> 的排列 <span class=\"math inline\">\\(a_{1\\sim n}\\)</span>，回答 <span class=\"math inline\">\\(q\\)</span> 个询问：</p>\n<ul>\n<li><p>给定 <span class=\"math inline\">\\([l,r]\\)</span>，是否存在 <span class=\"math inline\">\\(l\\le x&lt;y\\le r\\)</span>，使得：</p>\n<ul>\n<li><span class=\"math inline\">\\(a_x&lt;a_y\\)</span>，且 <span class=\"math inline\">\\(a_x\\)</span> 不为 <span class=\"math inline\">\\([x,y]\\)</span> 中最小值；</li>\n<li>令 <span class=\"math inline\">\\(a_i\\)</span> 为 <span class=\"math inline\">\\([x, y]\\)</span> 中最小值，则 <span class=\"math inline\">\\(a_i\\mid (a_x\\cdot a_y)\\)</span>。</li>\n</ul></li>\n</ul>\n<p><span class=\"math inline\">\\(n\\le 3\\times 10^5,q\\le10^6\\)</span>。</p>\n</blockquote>\n<ul>\n<li>容易想到对于 <span class=\"math inline\">\\(i\\)</span> 反过来找 <span class=\"math inline\">\\([x,y]\\)</span>。如果建立小根笛卡尔树，在 <span class=\"math inline\">\\(i\\)</span> 的左边找 <span class=\"math inline\">\\(x\\)</span>、右边找 <span class=\"math inline\">\\(y\\)</span>。</li>\n<li><p>一个自然的想法是对于左侧的每个 <span class=\"math inline\">\\(x\\)</span>，维护最近的合法 <span class=\"math inline\">\\(y\\)</span>；或是对于右侧的每个 <span class=\"math inline\">\\(y\\)</span>，维护最近的合法 <span class=\"math inline\">\\(x\\)</span>。</p>\n做一个 DSU on Tree，哪边区间短就维护哪边，是单 <span class=\"math inline\">\\(\\log\\)</span> 的。</li>\n<li><p>需要解决点内预处理，以 <span class=\"math inline\">\\(x\\)</span> 为例，对于每个 <span class=\"math inline\">\\(x\\)</span> 和当前点 <span class=\"math inline\">\\((p,l,r)\\)</span>，需要查询 <span class=\"math inline\">\\((p, r]\\)</span> 中最小的 <span class=\"math inline\">\\(y\\)</span>，使得 <span class=\"math inline\">\\(a_y\\)</span> 是 <span class=\"math inline\">\\(\\dfrac {a_p}{\\gcd(a_x,a_p)}\\)</span> 的倍数。离线下来扫描线，<del>开 <span class=\"math inline\">\\(n\\)</span> 棵线段树</del>，跑 <span class=\"math inline\">\\(n\\)</span> 次树状数组，用 <span class=\"math inline\">\\(y\\)</span> 更新所有 <span class=\"math inline\">\\(a_y\\)</span> 因数在 <span class=\"math inline\">\\(a_y\\)</span> 处的 min / max，可以在两个 log 内获得支配对类似物。</p>\n不是很理解为什么题目要再加一个偏序限制，除了增加代码量和用时外似乎并没有什么作用？</li>\n<li><p>查询时直接 rmq（这里唐了写了 st 表，实际上只需要前后缀）即可。整体复杂度 <span class=\"math inline\">\\(O(n\\log^2 n)\\)</span>。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int LEN = (1 &lt;&lt; 20);\n#ifdef ONLINE_JUDGE\nint nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF;\n        p = buf;\n    &#125;\n    return *p++;\n&#125;\n#else\n#define nec getchar\n#endif\nbool read(int &amp;x) &#123;\n    x = 0;\n    bool f = 0;\n    char ch = nec();\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    read(n);\n    std::vector&lt;std::vector&lt;int&gt; &gt; mul(n + 1);\n    std::vector&lt;int&gt; a(n + 1), l(n + 1), r(n + 1), pos(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        read(a[i]), pos[a[i]] = i;\n        for (l[i] = i; l[i] != 1 &amp;&amp; a[i] &lt; a[l[i] - 1]; l[i] = l[l[i] - 1]);\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = i; j &lt;= n; j += i)\n            mul[i].push_back(pos[j]);\n        std::sort(mul[i].begin(), mul[i].end());\n    &#125;\n    for (int i = n; i; --i)\n        for (r[i] = i; r[i] != n &amp;&amp; a[i] &lt; a[r[i] + 1]; r[i] = r[r[i] + 1]);\n    struct query &#123; int id, l, r; &#125;;\n    std::vector&lt;std::vector&lt;query&gt; &gt; ql(n + 1), qr(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        if (i - l[i] &lt; r[i] - i)\n            for (int j = l[i]; j &lt; i; ++j)\n                qr[a[i] / std::__gcd(a[i], a[j])].push_back(&#123; j, i + 1, r[i] &#125;);\n        else\n            for (int j = i + 1; j &lt;= r[i]; ++j)\n                ql[a[i] / std::__gcd(a[i], a[j])].push_back(&#123; j, l[i], i - 1 &#125;);\n    std::vector&lt;int&gt; u(n + 1), rt(n + 1), bit(n + 1);\n    auto lowbit = [](int x) &#123;\n        return x &amp; -x;\n    &#125;;\n    auto add = [&amp;](int x, int v) &#123;\n        for (; x &lt;= n; x += lowbit(x))\n            bit[x] = v;\n        return;\n    &#125;;\n    std::function&lt;int(int)&gt; ask = [&amp;](int x) &#123;\n        int res = 0;\n        for (; x; x -= lowbit(x))\n            res = std::max(res, bit[x]);\n        return res;\n    &#125;;\n    for (int fac = 1; fac &lt;= n; ++fac) &#123;\n        std::sort(ql[fac].begin(), ql[fac].end(), [&amp;](query x, query y) &#123; return x.r &lt; y.r; &#125;);\n        auto i = mul[fac].begin();\n        for (auto [id, l, r] : ql[fac]) &#123;\n            for (; i != mul[fac].end() &amp;&amp; *i &lt;= r; ++i)\n                add(a[*i], *i);\n            auto mx(ask(a[id]));\n            if (mx &gt;= l)\n                u[id] = std::max(u[id], mx);\n        &#125;\n        for (auto i : mul[fac])\n            add(a[i], 0);\n    &#125;\n    bit.assign(n + 1, 0x3f3f3f3f);\n    ask = [&amp;](int x) &#123;\n        int res = 0x3f3f3f3f;\n        for (; x; x -= lowbit(x))\n            res = std::min(res, bit[x]);\n        return res;\n    &#125;;\n    for (int fac = 1; fac &lt;= n; ++fac) &#123;\n        std::sort(qr[fac].begin(), qr[fac].end(), [&amp;](query x, query y) &#123; return x.l &gt; y.l; &#125;);\n        std::reverse(mul[fac].begin(), mul[fac].end());\n        auto i = mul[fac].begin();\n        for (auto [id, l, r] : qr[fac]) &#123;\n            for (; i != mul[fac].end() &amp;&amp; *i &gt;= l; ++i)\n                add(n - a[*i] + 1, *i);\n            auto mn(ask(n - a[id] + 1));\n            if (mn &lt;= r)\n                u[mn] = std::max(u[mn], id);\n        &#125;\n        for (auto i : mul[fac])\n            add(n - a[i] + 1, 0x3f3f3f3f);\n    &#125;\n    std::vector&lt;std::vector&lt;int&gt; &gt; st(20, std::vector&lt;int&gt; (n + 1));\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        // if (u[i] != 0)\n        //     printf(&quot;%d %d\\n&quot;, u[i], i);\n        st[0][i] = u[i];\n    &#125;\n    for (int j = 1; (1 &lt;&lt; j) &lt;= n; ++j)\n        for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i)\n            st[j][i] = std::max(st[j - 1][i], st[j - 1][i + (1 &lt;&lt; (j - 1))]);\n    auto askmx = [&amp;](int l, int r) &#123;\n        int k = std::__lg(r - l + 1);\n        return std::max(st[k][l], st[k][r - (1 &lt;&lt; k) + 1]);\n    &#125;;\n    int q;\n    read(q);\n    for (int l, r; q--; ) &#123;\n        read(l), read(r);\n        std::cout &lt;&lt; (askmx(l, r) &gt;= l ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"periodni\"># PERIODNI</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P6453\" class=\"uri\">https://www.luogu.com.cn/problem/P6453</a></p>\n<hr />\n<h2 id=\"cdq-分治\">CDQ 分治</h2>\n<h3 id=\"coloring-nodes偏序很隐秘\"># Coloring Nodes（偏序很隐秘）</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P12423\" class=\"uri\">https://www.luogu.com.cn/problem/P12423</a></p>\n<hr />\n<h2 id=\"字典树\">字典树</h2>\n<p>字典树作为 log 数据结构的时候，等价权值线段树，而且支持合并、分裂（权值线段树 also OK，强调一下而已）</p>\n<p>有些情景 Trie 写起来会比权值线段树舒服一些，比如值域操作、二进制操作之类</p>\n<h3 id=\"异或粽子\"># 异或粽子</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P5283\" class=\"uri\">https://www.luogu.com.cn/problem/P5283</a></p>\n<hr />\n<h3 id=\"friends\"># Friends</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/CF241B\" class=\"uri\">https://www.luogu.com.cn/problem/CF241B</a></p>\n",
            "tags": [
                "线段树"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250818/",
            "url": "https://xsc062.netlify.app/20250818/",
            "title": "学习笔记 平衡树",
            "date_published": "2025-08-18T00:18:48.000Z",
            "content_html": "<p>线段树 plus</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"概览\">概览</h2>\n<p>定义：BST，且对于任意点，其左右子树树高差不超过 <span class=\"math inline\">\\(1\\)</span>，这样所有 <span class=\"math inline\">\\(O(h)\\)</span> 复杂度的 BST 操作都能在 <span class=\"math inline\">\\(O(\\log n)\\)</span> 内解决。</p>\n<ul>\n<li><p>维护值：<code>__gnu_pbds::tree&lt;&gt;</code> / 权值线段树</p>\n<p>需要意识到线段树就是 leafy 的平衡树，且是静态的，不支持对树结构的操作；</p>\n这也是为什么树上的 GBT 总是可以用线段树代替 BST 做 DDP，因为树是静态的，重链也是静态的，不可能有结构变化的需求。但序列上的 DDP 不一定是静态的，比如 <a href=\"\">密码箱</a> 就只能用平衡树做。</li>\n<li><p>维护序列：fhq treap</p></li>\n</ul>\n<hr />\n<h3 id=\"例普通平衡树\">例：普通平衡树</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P3369\" class=\"uri\">https://www.luogu.com.cn/problem/P3369</a></p>\n<p>pbds / 权值线段树。</p>\n<hr />\n<h2 id=\"fhq-treap\">FHQ Treap</h2>\n<p>把 Treap 的旋转操作改成了好想好写的 split 和 merge，其余不变；额外带来了维护序列结构的功能。</p>\n<p>这里就只探讨维护序列了，维护的是对于序列结构上的操作（也可以维护值的操作，方式和线段树类似），这里的点值就和线段树维护的值一样，对于操作是没有影响的；点的 id 和对应的下标并没有关系；点的 rank（可以 <span class=\"math inline\">\\(O(1)\\)</span> 维护）才对应下标。</p>\n<ul>\n<li><p><code>split</code>：把树在某个值下标处分为两个 Treap。考虑怎么解决这种情况：</p>\n<p><img src=\"image.png\" /></p>\n自底向上递归处理，考虑到处理 <span class=\"math inline\">\\(4\\)</span> 的时候 <span class=\"math inline\">\\(4\\)</span> 接了完整的一个 BST，直接把 <span class=\"math inline\">\\(4\\)</span> 接到 <span class=\"math inline\">\\(3\\)</span> 的右儿子即可。显然是不会影响 priority 的。</li>\n<li><p><code>merge</code>：是为了配合 split 而产生的操作，将树 split 出去并操作后需要 merge 回来。难点在于需要考虑 priority。相似地，考虑这种情况：</p>\n<figure>\n<img src=\"image-2.png\" alt=\"蓝色数字是 priority\" /><figcaption>蓝色数字是 priority</figcaption>\n</figure>\n从最右边一条链向下走到可以插入的位置（显然是唯一的），将点插入，该处原本的子树和新点的左子树递归合并。</li>\n<li><p>结构操作（以区间 reverse 为例）：两次 split 得到操作区间的 Treap，打一个懒标记，再合并回去。</p>\n类似线段树，递归经过一个点时，如果存在 lazy，就可以交换左右儿子然后下传标记。</li>\n<li><p><span class=\"math inline\">\\(O(n)\\)</span> 建树：Treap 是笛卡尔树，然后就可以用悬线或者单调栈建树了。</p>\n<p>反过来可以得到在随机数据下笛卡尔树是平衡的，参考 <a href=\"https://www.luogu.com.cn/problem/P2611\">ZJOI2011 小蓝的好友</a>，利用了这个性质。</p></li>\n</ul>\n<hr />\n<h3 id=\"例文艺平衡树\">例：文艺平衡树</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P3391\" class=\"uri\">https://www.luogu.com.cn/problem/P3391</a></p>\n<p>区间 reverse 乍看会带来可以用线段树做的错觉</p>\n<p>实际上考虑一下 reverse 区间有交的情况，就会发现线段树确实做不了，只能真正地去实现 reverse 这个过程，就只有平衡树了能做了。</p>\n<details>\n<pre data-line=\"37\" class=\"cpp language-cpp\"><code data-line=\"37\" class=\"cpp language-cpp\">#include &lt;bits/stdc++.h>\nconst int maxn = 1e5 + 5;\nunsigned pr[maxn];\nint lc[maxn], rc[maxn], d[maxn], siz[maxn];\nvoid pushup(int p) &#123;\n    if (p)\n        siz[p] = siz[lc[p]] + 1 + siz[rc[p]];\n    return;\n&#125;\nvoid pushdown(int p) &#123;\n    if (p && d[p]) &#123;\n        std::swap(lc[p], rc[p]);\n        d[lc[p]] ^= 1, d[rc[p]] ^= 1;\n        d[p] = 0;\n    &#125;\n    return;\n&#125;\nvoid init(int p) &#123;\n    if (lc[p])\n        init(lc[p]);\n    if (rc[p])\n        init(rc[p]);\n    pushup(p);\n    return;\n&#125;\nint split(int &p, int rk) &#123;\n    if (!p)\n        return 0;\n    pushdown(p);\n    int q = 0;\n    if (siz[lc[p]] + 1 == rk)\n        q = rc[p], rc[p] = 0;\n    else if (rk <= siz[lc[p]])\n        q = p, p = lc[p], lc[q] = split(p, rk);\n    else\n        q = split(rc[p], rk - siz[lc[p]] - 1);\n    pushdown(q);  // 易错：这里要 pushdown\n    pushup(p), pushup(q);\n    return q;\n&#125;\nvoid merge(int &p, int q) &#123;\n    pushdown(p), pushdown(q);\n    if (!p || !q) &#123;\n        p += q;\n        return;\n    &#125;\n    if (pr[p] > pr[q])\n        merge(p, lc[q]), lc[q] = p, p = q;\n    else\n        merge(rc[p], q);\n    pushup(p);\n    return;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(\".in\", \"r\", stdin);\n    std::freopen(\".out\", \"w\", stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m;\n    std::cin >> n >> m;\n    std::vector&lt;int> l(n + 1), r(n + 1);\n    std::mt19937 rand(time(nullptr));\n    for (int i = 1; i <= n; ++i) &#123;\n        pr[i] = rand();\n        for (l[i] = i; l[i] != 1 && pr[l[i] - 1] > pr[i]; l[i] = l[l[i] - 1]);\n        if (l[i] != 1)\n            rc[l[i] - 1] = i;\n    &#125;\n    for (int i = n; i; --i) &#123;\n        for (r[i] = i; r[i] != n && pr[r[i] + 1] > pr[i]; r[i] = r[r[i] + 1]);\n        if (r[i] != n)\n            lc[r[i] + 1] = i;\n    &#125;\n    std::function&lt;void(int)> print = [&](int p) &#123;\n        pushdown(p);\n        if (lc[p])\n            print(lc[p]);\n        std::cout << p << ' ';\n        if (rc[p])\n            print(rc[p]);\n        return;\n    &#125;;\n    int rt = std::min_element(pr + 1, pr + n + 1) - pr;\n    init(rt);\n    for (int l, r, i = 1; i <= m; ++i) &#123;\n        std::cin >> l >> r;\n        int rt1 = split(rt, l - 1), rt2 = split(rt1, r - l + 1);\n        d[rt1] ^= 1;\n        merge(rt1, rt2), merge(rt, rt1);\n    &#125;\n    print(rt), std::cout << '\\n';\n#ifndef ONLINE_JUDGE\n    std::cerr << std::fixed << std::setprecision(6) << std::chrono::duration&lt;double> (std::chrono::steady_clock::now() - stime).count() << \"s\\n\";\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"习题\">习题</h2>\n<p>有点难，难点不在平衡树</p>\n<p>平衡树反而是简单的，只需要发现序列和序列操作就可以了。</p>\n<hr />\n<h3 id=\"c---密码箱\">C - 密码箱</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P7739\" class=\"uri\">https://www.luogu.com.cn/problem/P7739</a></p>\n<p>经过思考后，发现比较合理的转化方式是<strong>跳过具体数值，直接用对应操作表示函数值</strong>。</p>\n<p>将数列转化为最终函数值，用矩阵很好操作（右乘）；考虑将操作转化为数值，利用结合律，容易发现只需要把操作对应的矩阵加在末端（前端）即可，这样就可以只用操作来表示函数值。</p>\n<p>要做的话最好只让矩阵维护最后一项，<code>W</code> 显然，<code>E</code> 的第二种亦显然（加两个矩阵），考虑乘起来方便维护，乘起来之后发现和 <code>E</code> 的第一种是等价的，平衡树维护四个矩阵即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 2e5 + 5;\nconst int mod = 998244353;\nusing ll = long long;\nstruct mat &#123;\n    ll a[2][2];\n    ll* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    bool operator== (mat &amp;q) const &#123;\n        return a[0][0] == q[0][0] &amp;&amp; a[0][1] == q[0][1] &amp;&amp; a[1][0] == q[1][0] &amp;&amp; a[1][1] == q[1][1];\n    &#125;\n    mat operator* (mat &amp;q) const &#123;\n        mat res;\n        res[0][0] = (a[0][0] * q[0][0] + a[0][1] * q[1][0]) % mod;\n        res[0][1] = (a[0][0] * q[0][1] + a[0][1] * q[1][1]) % mod;\n        res[1][0] = (a[1][0] * q[0][0] + a[1][1] * q[1][0]) % mod;\n        res[1][1] = (a[1][0] * q[0][1] + a[1][1] * q[1][1]) % mod;\n        return res;\n    &#125;\n&#125; u[maxn][2], s[maxn][4], W, E, A, B, C;\nunsigned pr[maxn];\nint siz[maxn], d1[maxn], d2[maxn], lc[maxn], rc[maxn];\n#define lt lc[p]\n#define rt rc[p]\nvoid pushup(int p) &#123;\n    if (p) &#123;\n        siz[p] = siz[lc[p]] + 1 + siz[rc[p]];\n        s[p][0b00] = s[lc[p]][0b00] * u[p][0] * s[rc[p]][0b00];\n        s[p][0b01] = s[lc[p]][0b01] * u[p][1] * s[rc[p]][0b01];\n        s[p][0b10] = s[rc[p]][0b10] * u[p][0] * s[lc[p]][0b10];\n        s[p][0b11] = s[rc[p]][0b11] * u[p][1] * s[lc[p]][0b11];\n    &#125;\n    return;\n&#125;\nvoid pushdown(int p) &#123;\n    if (p &amp;&amp; d1[p]) &#123;\n        d1[lt] ^= 1, d1[rt] ^= 1;\n        std::swap(u[lt][0], u[lt][1]);\n        std::swap(s[lt][0b00], s[lt][0b01]);\n        std::swap(s[lt][0b10], s[lt][0b11]);\n        std::swap(u[rt][0], u[rt][1]);\n        std::swap(s[rt][0b00], s[rt][0b01]);\n        std::swap(s[rt][0b10], s[rt][0b11]);\n        d1[p] = 0;\n    &#125;\n    if (p &amp;&amp; d2[p]) &#123;\n        d2[lt] ^= 1, d2[rt] ^= 1;\n        std::swap(lc[lt], rc[lt]);\n        std::swap(s[lt][0b00], s[lt][0b10]);\n        std::swap(s[lt][0b01], s[lt][0b11]);\n        std::swap(lc[rt], rc[rt]);\n        std::swap(s[rt][0b00], s[rt][0b10]);\n        std::swap(s[rt][0b01], s[rt][0b11]);\n        d2[p] = 0;\n    &#125;\n    return;\n&#125;\nint split(int &amp;p, int rk) &#123;\n    if (!p)\n        return 0;\n    pushdown(p);\n    int q = 0;\n    if (siz[lc[p]] + 1 == rk)\n        q = rc[p], rc[p] = 0;\n    else if (rk &lt;= siz[lc[p]])\n        q = p, p = lc[p], lc[q] = split(p, rk);\n    else\n        q = split(rc[p], rk - siz[lc[p]] - 1);\n    pushdown(q);\n    pushup(p), pushup(q);\n    return q;\n&#125;\nvoid merge(int &amp;p, int q) &#123;\n    if (!p || !q) &#123;\n        p += q;\n        return;\n    &#125;\n    pushdown(p), pushdown(q);\n    if (pr[p] &gt; pr[q])\n        merge(p, lc[q]), lc[q] = p, p = q;\n    else\n        merge(rc[p], q);\n    pushup(p);\n    return;\n&#125;\nvoid init(int p) &#123;\n    if (lc[p])\n        init(lc[p]);\n    if (rc[p])\n        init(rc[p]);\n    pushup(p);\n    return;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;code3.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    s[0][0][0][0] = s[0][0][1][1] = s[0][1][0][0] = s[0][1][1][1] = s[0][2][0][0] = s[0][2][1][1] = s[0][3][0][0] = s[0][3][1][1] = 1ll;\n    W[0][0] = W[0][1] = W[1][1] = 1ll;\n    E[0][1] = mod - 1ll, E[1][0] = 1ll, E[1][1] = 2ll;\n    A[0][1] = A[1][0] = 1ll, B[0][1] = B[1][0] = B[1][1] = 1ll;\n    int n, q, rt;\n    std::cin &gt;&gt; n &gt;&gt; q;\n    std::mt19937 rand(time(nullptr));\n    for (int i = 1; i &lt;= n + q; ++i)\n        pr[i] = rand();\n    std::vector&lt;char&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        if (a[i] == &#39;W&#39;)\n            u[i][0] = W, u[i][1] = E;\n        else\n            u[i][0] = E, u[i][1] = W;\n    &#125;\n    &#123;\n        std::vector&lt;int&gt; l(n + 1), r(n + 1);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            for (l[i] = i; l[i] != 1 &amp;&amp; pr[l[i] - 1] &gt; pr[i]; l[i] = l[l[i] - 1]);\n            if (l[i] != 1)\n                rc[l[i] - 1] = i;\n        &#125;\n        for (int i = n; i; --i) &#123;\n            for (r[i] = i; r[i] != n &amp;&amp; pr[r[i] + 1] &gt; pr[i]; r[i] = r[r[i] + 1]);\n            if (r[i] != n)\n                lc[r[i] + 1] = i;\n        &#125;\n        rt = std::min_element(pr + 1, pr + n + 1) - pr;\n        init(rt);\n    &#125;\n    auto print = [&amp;](int rt) &#123;\n        auto res = A * B * s[rt][0];\n        ll p = res[0][1], q = res[1][1];\n        std::cout &lt;&lt; q &lt;&lt; &#39; &#39;  &lt;&lt; p &lt;&lt; &#39;\\n&#39;;\n        return;\n    &#125;;\n    print(rt);\n    for (std::string op; q--; ) &#123;\n        std::cin &gt;&gt; op;\n        if (op == &quot;APPEND&quot;) &#123;\n            char t;\n            std::cin &gt;&gt; t, ++n;\n            if (t == &#39;W&#39;)\n                u[n][0] = W, u[n][1] = E;\n            else\n                u[n][0] = E, u[n][1] = W;\n            pushup(n), merge(rt, n);\n        &#125;\n        else if (op == &quot;FLIP&quot;) &#123;\n            int l, r;\n            std::cin &gt;&gt; l &gt;&gt; r;\n            int rt1 = split(rt, l - 1), rt2 = split(rt1, r - l + 1);\n            d1[rt1] ^= 1;\n            std::swap(u[rt1][0], u[rt1][1]);\n            std::swap(s[rt1][0b00], s[rt1][0b01]);\n            std::swap(s[rt1][0b10], s[rt1][0b11]);\n            merge(rt1, rt2), merge(rt, rt1);\n        &#125;\n        else &#123;\n            int l, r;\n            std::cin &gt;&gt; l &gt;&gt; r;\n            int rt1 = split(rt, l - 1), rt2 = split(rt1, r - l + 1);\n            d2[rt1] ^= 1;\n            std::swap(lc[rt1], rc[rt1]);\n            std::swap(s[rt1][0b00], s[rt1][0b10]);\n            std::swap(s[rt1][0b01], s[rt1][0b11]);\n            merge(rt1, rt2), merge(rt, rt1);\n        &#125;\n        print(rt);\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"a---bridge\">A - Bridge</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P9358\" class=\"uri\">https://www.luogu.com.cn/problem/P9358</a></p>\n<p>如果把桥视作元素，假设对于下面的情形：</p>\n<p><img src=\"image-1.png\" /></p>\n<p>容易发现如果 <span class=\"math inline\">\\(b\\)</span> 不存在，那么 <span class=\"math inline\">\\(y\\)</span> 和 <span class=\"math inline\">\\(x\\)</span> 的后继都是 <span class=\"math inline\">\\(a\\)</span>，但只保留 <span class=\"math inline\">\\(y\\to a\\)</span> 的路径是不劣的</p>\n<p>如果 <span class=\"math inline\">\\(b\\)</span> 存在，就要连 <span class=\"math inline\">\\(b\\)</span> 和 <span class=\"math inline\">\\(x\\)</span>，也就说每个点连到当前行和下一行中最近的后继点就可以了，每个点只对应两条边，最后会形成若干个链，看成序列就可以用平衡树维护。查询<strong>跳到树顶再跳到最右的儿子就可以了，复杂度 <span class=\"math inline\">\\(O(\\log n)\\)</span></strong>。连边则可以直接用 set 维护。</p>\n",
            "tags": [
                "平衡树"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250816/",
            "url": "https://xsc062.netlify.app/20250816/",
            "title": "近期杂题 II",
            "date_published": "2025-08-16T08:14:12.000Z",
            "content_html": "<p>和 Aug 9th 的杂题不太能合并，所以分开了</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"b.-gas-fire-extinguishers\">B. GAS-Fire Extinguishers</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P3479\" class=\"uri\">https://www.luogu.com.cn/problem/P3479</a></p>\n<p>显然可以贪心，不妨从下到上，记录当前遍历过的、空余出来的灭火器（其实算的是可以供给的房间数）和还未分配灭火器的房间，按距离为 <span class=\"math inline\">\\(0\\sim k\\)</span> 分组。</p>\n<p>不难发现如果在某个点 <span class=\"math inline\">\\(u\\)</span> 处存在距离为 <span class=\"math inline\">\\(k\\)</span> 的空闲灭火器，可以贪心地分配给 <span class=\"math inline\">\\(u\\)</span>；如果存在距离为 <span class=\"math inline\">\\(k\\)</span> 的未分配房间，也可以在 <span class=\"math inline\">\\(u\\)</span> 处放置灭火器并分配给这些房间。类似地，进行两两配对一定是不劣的。</p>\n<p>发现同子树内距离为 <span class=\"math inline\">\\(k-1\\)</span> 的点对留到 <span class=\"math inline\">\\(fa\\)</span> 再匹配是不行的，因为这时距离会变成 <span class=\"math inline\">\\(k+1\\)</span>，不能匹配上；可以感受到这样是更劣的。</p>\n<p>然后就可以做了，根节点特殊乱贪心一下就行了。记得开 long long。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\n#define int long long\nsigned main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, s, k, res = 0;\n    std::cin &gt;&gt; n &gt;&gt; s &gt;&gt; k;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1), p(n + 1, std::vector&lt;int&gt; (k + 1)), q(n + 1, std::vector&lt;int&gt; (k + 1));\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        for (auto i : g[x])\n            if (i != fa)  &#123;\n                DFS(i, x);\n                for (int j = 0; j &lt; k; ++j)\n                    p[x][j + 1] += p[i][j], q[x][j + 1] += q[i][j];\n            &#125;\n        ++q[x][0];\n        if (x != 1) &#123;\n            int v = (q[x][k] + s - 1) / s;\n            p[x][0] = v * s, res += v;\n            for (int i = 0; i &lt;= k; ++i) &#123;\n                int v = std::min(p[x][i], q[x][k - i]);\n                p[x][i] -= v, q[x][k - i] -= v;\n            &#125;\n            for (int i = 0; i &lt; k; ++i) &#123;\n                int v = std::min(p[x][i], q[x][k - 1 - i]);\n                p[x][i] -= v, q[x][k - 1 - i] -= v;\n            &#125;\n        &#125;\n        else &#123;\n            // std::cerr &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n            int sum = 0ll, r = 0;\n            for (int i = k; ~i; --i) &#123;\n                sum += p[x][k - i];\n                // std::cerr &lt;&lt; sum &lt;&lt; &#39;\\n&#39;;\n                int v = std::min(sum, q[x][i]);\n                sum -= v, q[x][i] -= v;\n                r += q[x][i];\n            &#125;\n            res += (r + s - 1) / s;\n        &#125;\n        return;\n    &#125;;\n    DFS(1, -1);\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c.-扫地机器人\">C. 扫地机器人</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6502/problem/3\" class=\"uri\">http://222.180.160.110:61235/contest/6502/problem/3</a></p>\n<blockquote>\n<p>题意：给定 <span class=\"math inline\">\\(n\\)</span> 堆货物，每堆货物有重量 <span class=\"math inline\">\\(v_i\\)</span> 和一个参数 <span class=\"math inline\">\\(a_i\\)</span>。有一个初始负载为 <span class=\"math inline\">\\(0\\)</span>、负载上限为 <span class=\"math inline\">\\(c\\)</span> 的机器人，从 <span class=\"math inline\">\\(1\\)</span> 到 <span class=\"math inline\">\\(n\\)</span> 遍历这些货物，对每一处货物执行以下操作，直到清空这堆货物：</p>\n<ul>\n<li>当前负载未满：可以选择进行装载直到达到负载上限，或货物清空。花费 <span class=\"math inline\">\\(a_i\\)</span> 的代价。</li>\n<li>不管当前负载满没满：可以选择清空当前负载，花费 <span class=\"math inline\">\\(b\\)</span> 的代价。</li>\n</ul>\n<p>每一处可以任意操作，要求遍历完之后机器人负载为 <span class=\"math inline\">\\(0\\)</span>，问最小代价。<span class=\"math inline\">\\(n\\le 2\\times 10^5,c\\le 10^9\\)</span>。</p>\n</blockquote>\n<p><em>题面是重构过的，原来的题面太有歧义了。绝大多数人没做出来就是因为没看懂题吧！</em></p>\n<p>考虑暴力，可以想到令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示处理完 <span class=\"math inline\">\\(i\\)</span> 过后负载为 <span class=\"math inline\">\\(j\\)</span> 的最小代价（显然 <span class=\"math inline\">\\(f_{i,c}\\)</span> 和 <span class=\"math inline\">\\(f_{i,0}\\)</span> 是等效的，故舍弃前者）。记 <span class=\"math inline\">\\(k=\\left\\lceil\\dfrac {v_i}c\\right\\rceil,w=(v_i\\bmod c - 1)\\bmod c+1\\)</span>，那么有：</p>\n<p><span class=\"math display\">\\[\nf_{i,(j+v_i)\\bmod c}\\gets f_{i-1,j}+k\\cdot a_i+(k-1)\\cdot b +\n\\begin{cases}\nb&amp;j+w=c\\\\\na_i+b&amp;j+w&gt; c\\\\\n0&amp;\\text{otherwise}\n\\end{cases}\\\\\nf_{i,0}\\gets f_{i,j}+b\n\\]</span></p>\n<p>发现 <span class=\"math inline\">\\(f_{i-1}\\)</span> 和 <span class=\"math inline\">\\(f_i\\)</span> 之间是存在对应关系的，所以考虑直接继承（真实的 <span class=\"math inline\">\\(0\\)</span> 应该位于 <span class=\"math inline\">\\(-s_i\\)</span> 的位置），再做全局加、区间加，<span class=\"math inline\">\\(f_{i,0}\\)</span> 的转移是全局 min，线段树维护即可；每次只会新增一个状态，动态开点即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 5e6 + 5;\nconst __int128 inf = 1e18;\nstruct &#123;\n    int l, r;\n    __int128 u, d;\n&#125; t[maxn];\n#define lt t[p].l\n#define rt t[p].r\nint tot;\nvoid pushdown(int p) &#123;\n    if (t[p].d) &#123;\n        t[lt].d += t[p].d, t[lt].u += t[p].d;\n        t[rt].d += t[p].d, t[rt].u += t[p].d;\n        t[p].d = 0ll;\n    &#125;\n    return;\n&#125;\nvoid upd(int &amp;p, int l, int r, int x, __int128 v) &#123;\n    if (!p)\n        p = ++tot, t[p].u = v;\n    else\n        t[p].u = std::min(t[p].u, v);\n    if (l == r)\n        return;\n    pushdown(p);\n    int mid = (l + r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        upd(lt, l, mid, x, v);\n    else\n        upd(rt, mid + 1, r, x, v);\n    return;\n&#125;\nvoid add(int p, int l, int r, int ql, int qr, __int128 v) &#123;\n    if (!p)\n        return;\n    if (ql &lt;= l &amp;&amp; r &lt;= qr) &#123;\n        t[p].d += v, t[p].u += v;\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    pushdown(p);\n    if (ql &lt;= mid)\n        add(lt, l, mid, ql, qr, v);\n    if (qr &gt; mid)\n        add(rt, mid + 1, r, ql, qr, v);\n    t[p].u = std::min(t[lt].u, t[rt].u);\n    return;\n&#125;\n__int128 ask(int p, int l, int r, int x) &#123;\n    if (l == r)\n        return t[p].u;\n    int mid = (l + r) &gt;&gt; 1;\n    pushdown(p);\n    if (x &lt;= mid)\n        return ask(lt, l, mid, x);\n    return ask(rt, mid + 1, r, x);\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;robot.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;robot.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;ex_robot4.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    t[0].u = inf;\n    int n, b, c, p0 = 0, rt = 0;\n    std::cin &gt;&gt; n &gt;&gt; c &gt;&gt; b;\n    std::vector&lt;int&gt; a(n + 1), v(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; v[i];\n    upd(rt, 0, c - 1, 0, 0ll);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        __int128 k = (v[i] + c - 1) / c, w = (v[i] % c == 0 ? c : v[i] % c);\n        t[rt].d += k * a[i] + (k - 1) * b;\n        t[rt].u += k * a[i] + (k - 1) * b;\n        if (w &lt;= c)\n            add(rt, 0, c - 1, (c - w + p0) % c, (c - w + p0) % c, b);\n        if (w != 1) &#123;\n            int l = (c - w + p0 + 1) % c, r = (p0 + c - 1) % c;\n            if (l &lt;= r)\n                add(rt, 0, c - 1, l, r, a[i] + b);\n            else &#123;\n                add(rt, 0, c - 1, 0, r, a[i] + b);\n                add(rt, 0, c - 1, l, c - 1, a[i] + b);\n            &#125;\n        &#125;\n        p0 = (p0 + c - v[i] % c) % c;\n        upd(rt, 0, c - 1, p0, t[rt].u + b);\n    &#125;\n    std::cout &lt;&lt; (long long)ask(rt, 0, c - 1, p0) &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d.-套娃\">D. 套娃</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6502/problem/4\" class=\"uri\">http://222.180.160.110:61235/contest/6502/problem/4</a></p>\n<blockquote>\n<p>题意：给定初始为全 <span class=\"math inline\">\\(0\\)</span> 的数组 <span class=\"math inline\">\\(a_{1\\sim n + 1}\\)</span> 和 <span class=\"math inline\">\\(n\\)</span> 次单点 +1 操作，每次操作后，求解：</p>\n<p>令 <span class=\"math inline\">\\(a\\)</span> 的前缀和数组为 <span class=\"math inline\">\\(s\\)</span>，找到一个最小的 <span class=\"math inline\">\\(k\\)</span>，使得对于每个 <span class=\"math inline\">\\(i\\)</span>，均有 <span class=\"math inline\">\\(k\\cdot i\\ge s_i\\)</span> 成立。</p>\n<p><span class=\"math inline\">\\(n\\le 10^6\\)</span>，时限 0.5s。</p>\n</blockquote>\n<details>\n<p><summary>趣事一则</summary></p>\n<p>考场上最后 10min 拿到题，憋了一个能拿到 96pts 的假做法：注意到前缀和是单增的，需要维护最大的 <span class=\"math inline\">\\(\\dfrac {s_i}i\\)</span>，由于后缀 +1 带来的影响很小，所以可以猜测在大多数情况下最大的 <span class=\"math inline\">\\(i\\)</span> 只会在原来的和修改的点之间变化。只用 10 行的核心代码就能拿到很多分。但是居然有这么多，可能出题人都没有想到真有人敢交这种做法吧。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n    std::freopen(&quot;doll.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;doll.out&quot;, &quot;w&quot;, stdout);\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    auto stime = std::chrono::steady_clock::now();\n    int n, res = 0;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; bit(n + 2);\n    auto lowbit = [](int x) &#123;\n        return x &amp; -x;\n    &#125;;\n    auto add = [&amp;](int x) &#123;\n        for (; x &lt;= n + 1; x += lowbit(x))\n            ++bit[x];\n        return;\n    &#125;;\n    auto ask = [&amp;](int x) &#123;\n        int res = 0;\n        for (; x; x -= lowbit(x))\n            res += bit[x];\n        return res;\n    &#125;;\n    int p = 1;\n    for (int i = 1, x; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; x, add(++x);\n        long long s = ask(x), t = ask(p);\n        if (s * p == t * x ? x &gt; p : s * p &gt; t * x)\n            p = x;\n        else\n            s = t;\n        if (s &gt; p * res)\n            ++res;\n        std::cout &lt;&lt; res &lt;&lt; &#39; &#39;;\n    &#125;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n    std::cerr &lt;&lt; std::chrono::duration&lt;double&gt;(std::chrono::steady_clock::now() - stime).count() &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<p>很容易写出暴力，观察样例就能发现每次修改后答案最多增加 <span class=\"math inline\">\\(1\\)</span>。记当前答案为 <span class=\"math inline\">\\(res\\)</span>，线段树维护 <span class=\"math inline\">\\(s_i-res\\cdot i\\)</span> 的最小值，若其为负则 res++，然后重构线段树（等差数列和 min 不兼容）。</p>\n<p>怎么又有不等式 😱</p>\n<p>目的是在本来合法的范围里找到新的不合法值。考虑合法范围：<span class=\"math inline\">\\(s_i-res\\cdot i\\ge 0\\)</span>，解一下得到 <span class=\"math inline\">\\(i\\le \\dfrac {s_i}{res}\\)</span>，放缩得到 <span class=\"math inline\">\\(i\\le\\dfrac {n}{res}\\)</span>，每次 <span class=\"math inline\">\\(res\\)</span> 变化时只重构 <span class=\"math inline\">\\(\\dfrac {n}{res}\\)</span> 以前的位置，重构的总长是 <span class=\"math inline\">\\(O(n\\ln n)\\)</span> 的。（线段树建树是线性的）</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e6 + 5;\nconst int inf = 0x3f3f3f3f;\nstruct &#123;\n    int l, r, u, d;\n&#125; t[maxn &lt;&lt; 2];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid bld(int p, int l, int r) &#123;\n    t[p].u = t[p].l = l, t[p].r = r;\n    if (l == r)\n        return;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    return;\n&#125;\nvoid pushdown(int p) &#123;\n    if (t[p].d) &#123;\n        t[lt].d += t[p].d, t[rt].d += t[p].d;\n        t[lt].u -= t[p].d, t[rt].u -= t[p].d;\n        t[p].d = 0;\n    &#125;\n    return;\n&#125;\nvoid add(int p, int x) &#123;\n    if (x &lt;= t[p].l) &#123;\n        ++t[p].d, --t[p].u;\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        add(lt, x);\n    add(rt, x);\n    t[p].u = std::min(t[lt].u, t[rt].u);\n    // printf(&quot;[%d, %d]: %d, [%d, %d]: %d\\n&quot;, t[p].l, mid, t[lt].u, mid + 1, t[p].r, t[rt].u);\n    return;\n&#125;\nvoid rem(int p, int r) &#123;\n    if (t[p].l == t[p].r) &#123;\n        t[p].u += t[p].l;\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (r &lt;= mid)\n        rem(lt, r), t[rt].u = inf;\n    else\n        rem(lt, r), rem(rt, r);\n    t[p].u = std::min(t[lt].u, t[rt].u);\n    return;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;doll.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;doll.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    bld(1, 1, n + 1);\n    for (int i = 1, x, res = 1, now = n; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; x;\n        if (x &lt;= now)\n            add(1, ++x);\n        if (t[1].u &lt; 0) &#123;\n            std::cout &lt;&lt; ++res &lt;&lt; &#39; &#39;;\n            rem(1, now = n / res);\n        &#125;\n        else\n            std::cout &lt;&lt; res &lt;&lt; &#39; &#39;;\n        // puts(&quot;&quot;);\n    &#125;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"e---subarray-sum-divisibility\">E - Subarray Sum Divisibility</h2>\n<p><a href=\"https://atcoder.jp/contests/abc419/tasks/abc419_e\" class=\"uri\">https://atcoder.jp/contests/abc419/tasks/abc419_e</a></p>\n<p>模意义下的数列全等，可以对应原数组全等、差分全等、前缀和全等（都是模意义下的，还有其他的一些线性和非线性的变换也可以）</p>\n<p>本着修改的点尽量少的想法，如果题目给定单点修改就可以在原数组上做文章，给定区间修改可以考虑差分数组，前缀和对于一些区间查询有优势</p>\n<p>其他两种用得也很多，像这题只需要用原数组全等就可以做了</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int inf = 0x3f3f3f3f;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m, l;\n    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; l;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::vector&lt;std::vector&lt;int&gt; &gt; u(l + 1, std::vector&lt;int&gt; (m));\n    for (int i = 1; i &lt;= l; ++i)\n        for (int j = 0; j &lt; m; ++j)\n            for (int k = i; k &lt;= n; k += l)\n                u[i][j] += (j + m - a[k]) % m;\n    std::vector&lt;std::vector&lt;int&gt; &gt; f(l + 1, std::vector&lt;int&gt; (m, inf));\n    f[0][0] = 0;\n    for (int i = 1; i &lt;= l; ++i)\n        for (int j = 0; j &lt; m; ++j)\n            for (int k = 0; k &lt; m; ++k)\n                f[i][(j + k) % m] = std::min(f[i][(j + k) % m], f[i - 1][j] + u[i][k]);\n    std::cout &lt;&lt; f[l][0] &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;\n</code></pre>\n</details>\n<hr />\n<h2 id=\"f---all-included\">F - All Included</h2>\n<p><a href=\"https://atcoder.jp/contests/abc419/tasks/abc419_f\" class=\"uri\">https://atcoder.jp/contests/abc419/tasks/abc419_f</a></p>\n<p>原题意转化为在 AC 自动机上走 <span class=\"math inline\">\\(L\\)</span> 步，要求经过 <span class=\"math inline\">\\(n\\)</span> 个叶子的方案数。不太可做，转化成容斥（令字符串终点不可达）。在外层枚举步数暴力游走。</p>\n<p>要求恰好走 <span class=\"math inline\">\\(L\\)</span> 步，也可以用矩阵；但原图很稀疏，所以矩阵并没有优势。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint tot = 1, T[805][26], fail[805];\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, l;\n    std::cin &gt;&gt; n &gt;&gt; l;\n    std::vector&lt;std::string&gt; a;\n    &#123;\n        std::vector&lt;std::string&gt; s(n + 1);\n        for (int i = 1; i &lt;= n; ++i)\n            std::cin &gt;&gt; s[i];\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            bool flag = 1;\n            for (int j = 1; j &lt;= n; ++j)\n                if (j != i)\n                    if (s[j].find(s[i]) != std::string::npos) &#123;\n                        flag = 0;\n                        break;\n                    &#125;\n            if (flag)\n                a.push_back(s[i]);\n        &#125;\n        n = (int)a.size();\n    &#125;\n    std::vector&lt;int&gt; pos(n);\n    for (int i = 0; i &lt; n; ++i) &#123;\n        int &amp;p = pos[i];\n        for (auto j : a[i]) &#123;\n            if (!T[p][j - &#39;a&#39;])\n                T[p][j - &#39;a&#39;] = tot++;\n            p = T[p][j - &#39;a&#39;];\n        &#125;\n    &#125;\n    &#123;\n        std::queue&lt;int&gt; q;\n        for (int i = 0; i &lt; 26; ++i)\n            if (T[0][i])\n                q.push(T[0][i]);\n        for (; !q.empty(); ) &#123;\n            int u = q.front();\n            q.pop();\n            for (int i = 0; i &lt; 26; ++i)\n                if (T[u][i]) &#123;\n                    int v = T[u][i];\n                    fail[v] = T[fail[u]][i];\n                    q.push(v);\n                &#125;\n                else\n                    T[u][i] = T[fail[u]][i];\n        &#125;\n    &#125;\n    auto res = 0ll;\n    int siz = 1 &lt;&lt; n;\n    for (int i = 0; i &lt; siz; ++i) &#123;\n        std::vector&lt;int&gt; tag(tot);\n        for (int j = 0; j &lt; n; ++j)\n            if ((i &gt;&gt; j) &amp; 1)\n                tag[pos[j]] = 1;\n        std::vector&lt;std::vector&lt;long long&gt; &gt; f(l + 1, std::vector&lt;long long&gt; (tot));\n        f[0][0] = 1ll;\n        for (int j = 0; j &lt; l; ++j)\n            for (int k = 0; k &lt; tot; ++k)\n                for (int a = 0; a &lt; 26; ++a) &#123;\n                    if (!tag[T[k][a]])\n                        (f[j + 1][T[k][a]] += f[j][k]) %= mod;\n                &#125;\n        int k = (__builtin_popcount(i) &amp; 1 ? mod - 1 : 1);\n        auto s = 0ll;\n        for (int j = 0; j &lt; tot; ++j)\n            if (!tag[j])\n                (s += f[l][j]) %= mod;\n        (res += k * s) %= mod;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"g---count-simple-paths-2\">G - Count Simple Paths 2</h2>\n<p><a href=\"https://atcoder.jp/contests/abc419/tasks/abc419_g\" class=\"uri\">https://atcoder.jp/contests/abc419/tasks/abc419_g</a></p>\n<p>很新的性质。考虑『以 <span class=\"math inline\">\\(1\\)</span> 为起点的简单路径数』和反祖边数量的关系：选定一条反祖边必须被经过时（显然只有一种可能的经过方向），树的形态发生变化：</p>\n<p><img src=\"image.png\" /></p>\n<p>也就是说，一种反祖边的选取方案对应一种树，遍历其从 <span class=\"math inline\">\\(1\\)</span> 开始的简单路径复杂度为 <span class=\"math inline\">\\(O(n)\\)</span>。设反祖边数量为 <span class=\"math inline\">\\(k\\)</span>，那么合法的方案数不超过 <span class=\"math inline\">\\(2^k\\)</span>，暴力 DFS 的整个图复杂度为 <span class=\"math inline\">\\(O(2^k\\cdot n)\\)</span>。</p>\n<p>发现很多跟反祖边无关的遍历是不必要的（只有一种走法，可以设成边权），考虑对所有连接反祖边的点建立虚树，并把原树上的反祖边也移到虚树上，就能 <span class=\"math inline\">\\(O(2^k\\cdot k)\\)</span> 解决问题。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1), g1(n + 1);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g2(n + 1);\n    for (int x, y; m--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; tag(n + 1), vis(n + 1);\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; be;\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        static int now = 0;\n        tag[x] = 1, vis[x] = ++now;\n        for (auto i : g[x])\n            if (!tag[i]) &#123;\n                // fprintf(stderr, &quot;%d -&gt; %d\\n&quot;, x, i);\n                g1[x].push_back(i), DFS(i, x);\n            &#125;\n            else if (i != fa &amp;&amp; vis[i] &lt; vis[x])\n                be.emplace_back(i, x);\n        return;\n    &#125;;\n    DFS(1, -1);\n    &#123; // 求虚树\n        std::vector&lt;int&gt; dep(n + 1), fa(n + 1), top(n + 1), siz(n + 1), son(n + 1), dfn(n + 1), rfn(n + 1);\n        std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n            siz[x] = 1;\n            for (auto i : g1[x]) &#123;\n                dep[i] = dep[x] + 1;\n                fa[i] = x, DFS(i);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n            return;\n        &#125;;\n        DFS(1);\n        DFS = [&amp;](int x) &#123;\n            static int now = 0;\n            dfn[x] = ++now;\n            if (son[x])\n                top[son[x]] = top[x], DFS(son[x]);\n            for (auto i : g1[x])\n                if (i != son[x])\n                    top[i] = i, DFS(i);\n            rfn[x] = now;\n            // printf(&quot;%d: [%d, %d]\\n&quot;, x, dfn[x], rfn[x]);\n            return;\n        &#125;;\n        top[1] = 1, DFS(1);\n        auto getLCA = [&amp;](int x, int y) &#123;\n            for (; top[x] != top[y]; x = fa[top[x]])\n                if (dep[top[x]] &lt; dep[top[y]])\n                    std::swap(x, y);\n            return dep[x] &lt; dep[y] ? x : y;\n        &#125;;\n        tag.assign(n + 1, 0);\n        tag[1] = tag[n] = 1;\n        for (auto [u, v] : be)\n            tag[u] = 1, tag[v] = 1;\n        std::vector&lt;int&gt; p;\n        for (int i = 1; i &lt;= n; ++i)\n            if (tag[i])\n                p.push_back(i);\n        std::sort(p.begin(), p.end(), [&amp;](int i, int j) &#123; return dfn[i] &lt; dfn[j]; &#125;);\n        for (int i = 1; i &lt; (int)p.size(); ++i) &#123;\n            int fa = getLCA(p[i], p[i - 1]);\n            if (!tag[fa])\n                tag[fa] = 1;\n        &#125;\n        p.clear();\n        for (int i = 1; i &lt;= n; ++i)\n            if (tag[i])\n                p.push_back(i);\n        std::sort(p.begin(), p.end(), [&amp;](int i, int j) &#123; return dfn[i] &lt; dfn[j]; &#125;);\n        std::vector&lt;int&gt; st;\n        for (auto i : p) &#123;\n            if (st.empty())\n                st.push_back(i);\n            else &#123;\n                for (; rfn[st.back()] &lt; dfn[i]; st.pop_back());\n                g2[st.back()].emplace_back(i, dep[i] - dep[st.back()]);\n                g2[i].emplace_back(st.back(), dep[i] - dep[st.back()]);\n                // printf(&quot;add (%d, %d): %d\\n&quot;, st.back(), i, dep[i] - dep[st.back()]);\n                st.push_back(i);\n            &#125;\n        &#125;\n        for (auto [u, v] : be) &#123;\n            g2[u].emplace_back(v, 1), g2[v].emplace_back(u, 1);\n            // printf(&quot;# add(%d, %d): 1\\n&quot;, u, v);\n        &#125;\n    &#125;\n    tag.assign(n + 1, 0);\n    std::vector&lt;int&gt; res(n + 1);\n    DFS = [&amp;](int x, int s) &#123;\n        if (x == n)\n            ++res[s];\n        tag[x] = 1;\n        for (auto [i, w] : g2[x])\n            if (!tag[i])\n                DFS(i, s + w);\n        tag[x] = 0;\n        return;\n    &#125;;\n    DFS(1, 0);\n    for (int i = 1; i &lt; n; ++i)\n        std::cout &lt;&lt; res[i] &lt;&lt; &#39; &#39;;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "线段树",
                "AC 自动机",
                "贪心",
                "DP 优化",
                "虚树"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250814/",
            "url": "https://xsc062.netlify.app/20250814/",
            "title": "DDP 与 GBT 练习",
            "date_published": "2025-08-14T09:08:21.000Z",
            "content_html": "<p>线段树是对的（存疑）</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a---数据传输\">A - 数据传输</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P8820\" class=\"uri\">https://www.luogu.com.cn/problem/P8820</a></p>\n<p>我在上一篇文章中提到了 <a href=\"/20250812/#树上路径查询\">DDP &amp; 路径查询问题</a>，在这个题中就有体现。</p>\n<p>设 <span class=\"math inline\">\\(f_{u,0/1/2}\\)</span> 表示数据保存在 <span class=\"math inline\">\\(u\\)</span> 往下数 <span class=\"math inline\">\\(0/1/2\\)</span> 个点处的最小代价，手玩容易发现 <span class=\"math inline\">\\(k=3\\)</span> 时<strong>最优路径可能会往某个 <span class=\"math inline\">\\(x\\)</span> 或 <span class=\"math inline\">\\(fa\\)</span> 处的最小代价儿子处绕一圈来避免这个 <span class=\"math inline\">\\(x\\)</span> 或 <span class=\"math inline\">\\(fa\\)</span> 的代价</strong>。但该值是定值，问题还是纯路径问题，就可以 DDP 了。</p>\n<figure>\n<img src=\"image.png\" alt=\"共两种可能性（任意一个箭头长度不为 3 时绕一圈一定不比直接走更优）\" /><figcaption>共两种可能性（任意一个箭头长度不为 <span class=\"math inline\">\\(3\\)</span> 时绕一圈一定不比直接走更优）</figcaption>\n</figure>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nstruct mat &#123;\n    long long a[3][3];\n    long long* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    mat() &#123;\n        memset(a, 0x3f, sizeof (a));\n        return;\n    &#125;\n    mat(int flag) &#123;\n        memset(a, 0x3f, sizeof (a));\n        a[0][0] = a[1][1] = a[2][2] = 0ll;\n        return;\n    &#125;\n    mat operator* (mat &amp;q) const &#123;\n        mat res;\n        for (int i = 0; i &lt; 3; ++i)\n            for (int k = 0; k &lt; 3; ++k)\n                for (int j = 0; j &lt; 3; ++j)\n                    res[i][k] = std::min(res[i][k], a[i][j] + q[j][k]);\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, q, k;\n    std::cin &gt;&gt; n &gt;&gt; q &gt;&gt; k;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::vector&lt;int&gt; mx(n + 1, 0x3f3f3f3f);\n    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        mx[x] = std::min(mx[x], a[y]);\n        mx[y] = std::min(mx[y], a[x]);\n        g1[x].push_back(y), g1[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; dep(n + 1);\n    std::vector&lt;std::array&lt;int, 18&gt; &gt; f(n + 1);\n    std::vector&lt;std::array&lt;mat, 18&gt; &gt; u(n + 1), d(n + 1);\n    u[0][0] = d[0][0] = mat(1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        for (auto i : g1[x])\n            if (i != f[x][0]) &#123;\n                f[i][0] = x;\n                &#123;\n                    mat s;\n                    s[0][0] = a[x];\n                    if (k &gt;= 2) &#123;\n                        s[0][1] = 0;\n                        s[1][0] = a[x];\n                    &#125;\n                    if (k &gt;= 3) &#123;\n                        s[1][2] = 0;\n                        s[2][0] = a[x];\n                        s[1][1] = mx[x];\n                        s[2][2] = mx[i];\n                    &#125;\n                    u[i][0] = s; \n                    s[0][0] = a[i];\n                    if (k &gt;= 2)\n                        s[1][0] = a[i];\n                    if (k &gt;= 3) &#123;\n                        s[2][0] = a[i];\n                        s[1][1] = mx[i];\n                        s[2][2] = mx[x];\n                    &#125;\n                    d[i][0] = s; \n                &#125;\n                for (int j = 1; j &lt; 18; ++j) &#123;\n                    f[i][j] = f[f[i][j - 1]][j - 1];\n                    u[i][j] = u[i][j - 1] * u[f[i][j - 1]][j - 1];\n                    d[i][j] = d[f[i][j - 1]][j - 1] * d[i][j - 1];\n                &#125;\n                dep[i] = dep[x] + 1;\n                DFS(i);\n            &#125;\n        return;\n    &#125;;\n    dep[1] = 1, DFS(1);\n    for (int x, y; q--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        long long res = a[x];\n        mat r1(1), r2(1);\n        if (dep[x] &gt; dep[y]) &#123;\n            for (int i = 17; ~i; --i)\n                if (dep[f[x][i]] &gt;= dep[y]) &#123;\n                    r1 = r1 * u[x][i];\n                    x = f[x][i];\n                &#125;\n        &#125;\n        else if (dep[y] &gt; dep[x]) &#123;\n            for (int i = 17; ~i; --i)\n                if (dep[f[y][i]] &gt;= dep[x]) &#123;\n                    r2 = d[y][i] * r2;\n                    y = f[y][i];\n                &#125;\n        &#125;\n        if (x != y) &#123;\n            for (int i = 17; ~i; --i)\n                if (f[x][i] != f[y][i]) &#123;\n                    r1 = r1 * u[x][i];\n                    r2 = d[y][i] * r2;\n                    x = f[x][i], y = f[y][i];\n                &#125;\n            r1 = r1 * u[x][0], r2 = d[y][0] * r2;\n        &#125;\n        std::cout &lt;&lt; res + (r1 * r2)[0][0] &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---the-silk-road-with-robots\">B - The Silk Road … with Robots!</h2>\n<p><a href=\"https://qoj.ac/problem/10410\" class=\"uri\">https://qoj.ac/problem/10410</a></p>\n<blockquote>\n<p>题意：初始有一个长为 <span class=\"math inline\">\\(10^8\\)</span> 的空数轴，给定 <span class=\"math inline\">\\(n\\)</span> 次操作，每次操作在数轴上的一个空位放一个 A 类点或 B 类点。每个 A 类点有其<strong>价值</strong>。</p>\n<p>任意在数轴上移动这些 B 类点，<strong>总价值</strong>为所有被经过的 A 类点的<strong>价值</strong> - B 类点移动总路程。每次操作后输出最大<strong>总价值</strong>，重复经过的 A 类点只计一次。</p>\n<p><span class=\"math inline\">\\(n\\le 2\\times 10^5\\)</span>。</p>\n</blockquote>\n<p>这个题确实可以带来很多启发，我一开始直接设 <span class=\"math inline\">\\(f_j\\)</span> 为状态，这样对于暴力是可做的，但是会出现一些需要被区间修改的系数，比如<strong>前缀和</strong>。最好设计状态，让转移的时候只需要用到常数、差分值等修改次数很少的系数。</p>\n<p>设 <span class=\"math inline\">\\(f_{i,0/1/2/3}\\)</span> 分别表示：</p>\n<p><img src=\"image-1.png\" /></p>\n<p>那么可以写出转移式：</p>\n<p><span class=\"math display\">\\[\nf_{i,0}=\\max(mx+a_i+x_i,f_{i-1,0}+a_i)\\\\\nf_{i,1}=\\max(mx+a_i+2x_i,f_{i-1,1}+a_i)\\\\\nf_{i,2}=f_{i-1,2}-(x_i-x_{i-1}) + a_i\\\\\nf_{i,3}=f_{i-1,3}-2(x_i-x_{i-1})+a_i\n\\]</span></p>\n<p>其中 <span class=\"math inline\">\\(mx\\)</span> 为 <span class=\"math inline\">\\(f_{i,2/3}\\)</span> 的前缀最大值。在 B 类点处可以让 <span class=\"math inline\">\\(f_{2/3}\\)</span> 继承对应的 <span class=\"math inline\">\\(f_{0/1}\\)</span>，新开一维记录 <span class=\"math inline\">\\(mx\\)</span> 就可以维护矩乘了。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int lim = 1e8;\nconst int maxn = 5e6 + 5;\nconst long long inf = 1e12;\nstruct mat &#123;\n    long long a[5][5];\n    mat() &#123;&#125;\n    long long* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    mat operator* (mat &amp;q) const &#123;\n        mat res;\n        for (int i = 0; i &lt; 5; ++i)\n            for (int k = 0; k &lt; 5; ++k) &#123;\n                auto u(-inf);\n                for (int j = 0; j &lt; 5; ++j)\n                    u = std::max(u, a[i][j] + q[j][k]);\n                res[i][k] = u;\n            &#125;\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nstruct &#123; int l, r; mat u; &#125; t[maxn];\n#define lt t[p].l\n#define rt t[p].r\nvoid add(int &amp;p, int l, int r, int x, mat &amp;v) &#123;\n    static int tot = 0;\n    if (!p)\n        p = ++tot;\n    if (l == r) &#123;\n        t[p].u = v;\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        add(lt, l, mid, x, v);\n    else\n        add(rt, mid + 1, r, x, v);\n    t[p].u = t[lt].u * t[rt].u;\n    return;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    &#123;\n        mat &amp;u = t[0].u;\n        for (int i = 0; i &lt; 5; ++i)\n            for (int j = 0; j &lt; 5; ++j)\n                u[i][j] = -inf;\n        u[0][0] = u[1][1] = u[2][2] = u[3][3] = u[4][4] = 0ll;\n    &#125;\n    int m, rt = 0;\n    std::cin &gt;&gt; m;\n    std::vector&lt;mat&gt; a(m + 1);\n    std::vector&lt;int&gt; ty(m + 1);\n    std::set&lt;std::pair&lt;long long, int&gt; &gt; s;\n    s.emplace(-inf, 0);\n    for (int op, x, i = 1; i &lt;= m; ++i) &#123;\n        std::cin &gt;&gt; op &gt;&gt; x;\n        auto &amp;u = a[i];\n        for (int i = 0; i &lt; 5; ++i)\n            for (int j = 0; j &lt; 5; ++j)\n                u[i][j] = -inf;\n        auto p = --s.lower_bound(std::make_pair(x, 0)), q = s.upper_bound(std::make_pair(x, 0));\n        int v = 0;\n        if (op == 2)\n            std::cin &gt;&gt; v;\n        u[0][0] = v, u[1][1] = v, u[4][0] = v + x, u[4][1] = v + 2 * x;\n        if (op == 1) &#123;\n            ty[i] = 0;\n            u[4][2] = u[4][1] - 2 * x;\n            u[1][2] = u[1][1] - 2 * x;\n            u[4][3] = u[4][0] - x;\n            u[0][3] = u[0][0] - x;\n        &#125;\n        else &#123;\n            ty[i] = 1;\n            u[2][2] = v - (x - p-&gt;first);\n            u[3][3] = v - 2 * (x - p-&gt;first);\n        &#125;\n        u[4][4] = std::max(&#123; 0ll, u[4][2], u[4][3] &#125;);\n        u[1][4] = u[1][2], u[0][4] = u[0][3], u[2][4] = u[2][2], u[3][4] = u[3][3];\n        add(rt, 0, lim, x, u);\n        if (q != s.end() &amp;&amp; ty[q-&gt;second] == 1) &#123;\n            auto &amp;u = a[q-&gt;second];\n            u[2][2] -= p-&gt;first, u[2][2] += x;\n            u[3][3] -= 2 * p-&gt;first, u[3][3] += 2 * x;\n            u[2][4] = u[2][2], u[3][4] = u[3][3];\n            add(rt, 0, lim, q-&gt;first, a[q-&gt;second]);\n        &#125;\n        s.emplace(x, i);\n        std::cout &lt;&lt; t[1].u[4][4] &lt;&lt; &#39;\\n&#39;;\n        // for (int i = 0; i &lt; 5; ++i, puts(&quot;&quot;))\n        //     for (int j = 0; j &lt; 5; ++j)\n        //         if (t[1].u[i][j] &lt; -200)\n        //             printf(&quot;  x &quot;);\n        //         else\n        //             printf(&quot;%3lld &quot;, t[1].u[i][j]);\n        // puts(&quot;=============&quot;);\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---密码箱\">C - 密码箱</h2>\n<p><a href=\"/20250818/#c---%E5%AF%86%E7%A0%81%E7%AE%B1\">link</a>;</p>\n",
            "tags": [
                "线段树",
                "DDP"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250812/",
            "url": "https://xsc062.netlify.app/20250812/",
            "title": "DDP 与全局平衡二叉树",
            "date_published": "2025-08-12T00:16:52.000Z",
            "content_html": "<p>其实动态 DP 不是动态树 DP 的同义词</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"动态-dp\">动态 DP</h2>\n<p>对于转移只依赖前几项的 DP，可以放进矩阵。</p>\n<p>默认转移范围是 <span class=\"math inline\">\\([1,n]\\)</span>；如果我们需要改变求解范围，发现如果能获取转移矩阵的乘积就很快了。考虑存下来。</p>\n<p>如果需要单点修改，等价于修改其所在矩阵，则想要尽可能少地修改存储的答案，考虑使用线段树优化该过程。</p>\n<h3 id=\"例海报\">例：海报</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P9790\" class=\"uri\">https://www.luogu.com.cn/problem/P9790</a></p>\n<p>容易列出暴力 DP 式：令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示枚举到 <span class=\"math inline\">\\(i\\)</span> 时，包含 <span class=\"math inline\">\\(i\\)</span> 在内已经有 <span class=\"math inline\">\\(j\\)</span> 个连续的人举起海报，易得：</p>\n<p><span class=\"math display\">\\[\nf_{i,0}=\\max(f_{i-1,0},f_{i-1,1},f_{i-1,2},f_{i-1,3})\\\\\nf_{i,j}=f_{i-1,j-1}+a_i \\forall 1\\le j\\le 3\n\\]</span></p>\n<p>发现满足 + / max <strong>矩阵乘法</strong> 的形式；想到用线段树保存每段区间对应矩阵（对应性质：结合律），每次修改 / 查询就能在 <span class=\"math inline\">\\(O(\\log n)\\)</span> 之内完成。</p>\n<p>原问题是环形的，可以再加一维 <span class=\"math inline\">\\(k\\)</span> 表示钦定选了前 <span class=\"math inline\">\\(k\\)</span> 个且不选第 <span class=\"math inline\">\\(k+1\\)</span> 个时的答案。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 4e4 + 5;\nconst long long inf = 1e18;\nstruct mat &#123;\n    int n, m;\n    long long a[4][4];\n    mat() &#123;&#125;\n    mat(int n1, int m1): n(n1), m(m1) &#123;\n        for (int i = 0; i &lt; n; ++i)\n            for (int j = 0; j &lt; m; ++j)\n                a[i][j] = -inf;\n        return;\n    &#125;\n    long long* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    mat operator* (mat &amp;q) const &#123;\n        mat res(n, q.m);\n        for (int i = 0; i &lt; n; ++i)\n            for (int k = 0; k &lt; q.m; ++k)\n                for (int j = 0; j &lt; m; ++j)\n                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nstruct &#123; int l, r; mat u[4]; &#125; t[maxn &lt;&lt; 2];\nint a[maxn];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\n#define c t[p].u[i]\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        for (int i = 0; i &lt;= 3; ++i) &#123;\n            c = mat(4, 4);\n            if (l &gt; i + 1) &#123;\n                c[0][0] = c[1][0] = c[2][0] = c[3][0] = 0;\n                c[0][1] = c[1][2] = c[2][3] = a[l];\n            &#125;\n            else if (l == i + 1)\n                c[0][0] = c[1][0] = c[2][0] = c[3][0] = 0;\n            else\n                c[0][1] = c[1][2] = c[2][3] = a[l];\n        &#125;\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    for (int i = 0; i &lt;= 3; ++i)\n        t[p].u[i] = t[lt].u[i] * t[rt].u[i];\n    return;\n&#125;\nvoid add(int p, int x, int v) &#123;\n    if (t[p].l == t[p].r) &#123;\n        for (int i = 0; i &lt;= 3; ++i)\n            if (t[p].l != i + 1) \n                c[0][1] = c[1][2] = c[2][3] = v;\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        add(lt, x, v);\n    else\n        add(rt, x, v);\n    for (int i = 0; i &lt;= 3; ++i)\n        t[p].u[i] = t[lt].u[i] * t[rt].u[i];\n    return;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    bld(1, 1, n);\n    auto calc = [&amp;](void) &#123;\n        mat f(1, 4);\n        f[0][0] = 0;\n        auto res = -inf;\n        for (int i = 0; i &lt;= 3; ++i) &#123;\n            auto r = (f * t[1].u[i]);\n            for (int j = 0; j &lt;= 3; ++j)\n                if (i + j &lt;= 3) &#123;\n                    res = std::max(res, r[0][j]);\n                    // printf(&quot;f[%d][%d] = %lld\\n&quot;, i, j, f[i][j]);\n                &#125;\n        &#125;\n        return res;\n    &#125;;\n    std::cout &lt;&lt; calc() &lt;&lt; &#39;\\n&#39;;\n    int q;\n    std::cin &gt;&gt; q;\n    for (int x, v; q--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; v;\n        add(1, x, v);\n        std::cout &lt;&lt; calc() &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<p>发现矩阵本身和 <span class=\"math inline\">\\(k\\)</span> 无关，还可以可以共用一个线段树上的信息，就可以只开一个线段树了。</p>\n<details>\n<p>我写这一版本的原因是 <code>maxn</code> 开大了导致 MLE，实际上四个线段树是没有任何空间压力的 😅</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 4e5 + 5;\nconst long long inf = 1e18;\nstruct mat &#123;\n    int n, m;\n    long long a[4][4];\n    mat() &#123;&#125;\n    mat(int n1, int m1): n(n1), m(m1) &#123;\n        for (int i = 0; i &lt; n; ++i)\n            for (int j = 0; j &lt; m; ++j)\n                a[i][j] = -inf;\n        return;\n    &#125;\n    long long* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    mat operator* (mat q) const &#123;\n        mat res(n, q.m);\n        for (int i = 0; i &lt; n; ++i)\n            for (int k = 0; k &lt; q.m; ++k)\n                for (int j = 0; j &lt; m; ++j)\n                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nstruct &#123; int l, r; mat u; &#125; t[maxn &lt;&lt; 2];\nint a[maxn];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        t[p].u = mat(4, 4);\n        t[p].u[0][0] = t[p].u[1][0] = t[p].u[2][0] = t[p].u[3][0] = 0;\n        t[p].u[0][1] = t[p].u[1][2] = t[p].u[2][3] = a[l];\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    t[p].u = t[lt].u * t[rt].u;\n    return;\n&#125;\nvoid add(int p, int x, int v) &#123;\n    if (t[p].l == t[p].r) &#123;\n        t[p].u[0][1] = t[p].u[1][2] = t[p].u[2][3] = v;\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        add(lt, x, v);\n    else\n        add(rt, x, v);\n    t[p].u = t[lt].u * t[rt].u;\n    return;\n&#125;\nmat ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].u;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (r &lt;= mid)\n        return ask(lt, l, r);\n    if (l &gt; mid)\n        return ask(rt, l, r);\n    return ask(lt, l, r) * ask(rt, l, r);\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    bld(1, 1, n);\n    auto calc = [&amp;](void) &#123;\n        mat f(1, 4);\n        f[0][0] = 0, f[0][1] = f[0][2] = f[0][3] = -inf;\n        auto r(f * ask(1, 2, n));\n        auto res(*std::max_element(r[0], r[0] + 4));\n        mat z(4, 4);\n        z[0][0] = z[1][0] = z[2][0] = z[3][0] = 0ll;\n        for (int i = 1; i &lt;= 3; ++i) &#123;\n            mat op(4, 4);\n            op[0][1] = op[1][2] = op[2][3] = a[i];\n            f *= op;\n            if (i + 2 &lt;= n)\n                r = f * z * ask(1, i + 2, n);\n            else\n                r = f * z;\n            res = std::max(res, *std::max_element(r[0], r[0] + 4 - i));\n        &#125;\n        return res;\n    &#125;;\n    std::cout &lt;&lt; calc() &lt;&lt; &#39;\\n&#39;;\n    int q;\n    std::cin &gt;&gt; q;\n    for (int x, v; q--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; v, a[x] = v;\n        add(1, x, v);\n        std::cout &lt;&lt; calc() &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"经典题gss3\">经典题：GSS3</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/SP1716\" class=\"uri\">https://www.luogu.com.cn/problem/SP1716</a></p>\n<p>怎么是子段和 😓</p>\n<p>同样列出能够矩阵乘法的 DP 式，发现限制在于至少要选一个数。设 <span class=\"math inline\">\\(f_{i}\\)</span> 表示选了 <span class=\"math inline\">\\(i\\)</span> 的最大值，<span class=\"math inline\">\\(g_i\\)</span> 表示历史最大值，则：</p>\n<p><span class=\"math display\">\\[\nf_i=\\max(f_{i-1}+a_i,0+a_i)\\\\\ng_i=\\max(g_{i-1}+0,f_{i-1}+a_i,0+a_i)\n\\]</span></p>\n<p>容易发现是一个 + / max 矩乘，线段树维护即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 4e5 + 5;\nconst long long inf = 1e18;\nstruct mat &#123;\n    int n, m;\n    long long a[3][3];\n    mat() &#123;&#125;\n    mat(int n1, int m1): n(n1), m(m1) &#123;\n        for (int i = 0; i &lt; n; ++i)\n            for (int j = 0; j &lt; m; ++j)\n                a[i][j] = -inf;\n        return;\n    &#125;\n    long long* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    mat operator* (mat q) const &#123;\n        mat res(n, q.m);\n        for (int i = 0; i &lt; n; ++i)\n            for (int k = 0; k &lt; q.m; ++k)\n                for (int j = 0; j &lt; m; ++j)\n                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nstruct &#123; int l, r; mat u; &#125; t[maxn &lt;&lt; 2]; \nint a[maxn];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        t[p].u = mat(3, 3);\n        t[p].u[0][0] = t[p].u[2][0] = a[l];\n        t[p].u[0][1] = a[l], t[p].u[1][1] = 0ll, t[p].u[2][1] = a[l];\n        t[p].u[2][2] = 0ll;\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    t[p].u = t[lt].u * t[rt].u;\n    return;\n&#125;\nvoid add(int p, int x, int v) &#123;\n    if (t[p].l == t[p].r) &#123;\n        t[p].u[0][0] = t[p].u[2][0] = t[p].u[0][1] = t[p].u[2][1] = v;\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        add(lt, x, v);\n    else\n        add(rt, x, v);\n    t[p].u = t[lt].u * t[rt].u;\n    return;\n&#125;\nmat ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].u;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (r &lt;= mid)\n        return ask(lt, l, r);\n    if (l &gt; mid)\n        return ask(rt, l, r);\n    return ask(lt, l, r) * ask(rt, l, r);\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    bld(1, 1, n);\n    auto calc = [&amp;](int l, int r) &#123;\n        mat f(1, 3);\n        f[0][2] = 0ll;\n        auto res(f * ask(1, l, r));\n        return res[0][1];\n    &#125;;\n    int q;\n    std::cin &gt;&gt; q;\n    for (int op; q--; ) &#123;\n        std::cin &gt;&gt; op;\n        if (op == 1) &#123;\n            int l, r;\n            std::cin &gt;&gt; l &gt;&gt; r;\n            std::cout &lt;&lt; calc(l, r) &lt;&lt; &#39;\\n&#39;;\n        &#125;\n        else &#123;\n            int x, v;\n            std::cin &gt;&gt; x &gt;&gt; v;\n            a[x] = v, add(1, x, v);\n        &#125;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"动态树-dp\">动态树 DP</h2>\n<p>把上述过程放到树上，很容易想到树剖 + 线段树。</p>\n<p>由于认为线段树上的矩乘只能进行从重儿子到父亲的转移，轻儿子的转移会被合并为一个新函数（同时是矩阵的系数），在跳重链的时候被单独更新。</p>\n<p>由于两个函数相互依赖，需要思考清楚更新的先后顺序。</p>\n<h3 id=\"模板动态-dp\">【模板】动态 DP</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P4719\" class=\"uri\">https://www.luogu.com.cn/problem/P4719</a></p>\n<p>令 <span class=\"math inline\">\\(f_{u,0/1}\\)</span> 表示在 <span class=\"math inline\">\\(u\\)</span> 上，选 / 不选 <span class=\"math inline\">\\(u\\)</span> 的最大价值。容易得出转移：</p>\n<p><span class=\"math display\">\\[\nf_{u,0}=\\sum\\max(f_{v,0},f_{v,1})\\\\\nf_{u,1}=a_i+\\sum f_{v,0}\n\\]</span></p>\n<p>把转移矩阵放到树剖上后，考虑更新，发现求和这一步很困难。解决方案是<strong>直接将求和用另一个函数代替</strong>。定义 <span class=\"math inline\">\\(g_{u,0}\\)</span> 表示取 <span class=\"math inline\">\\(u\\)</span>、不取 <span class=\"math inline\">\\(u\\)</span> 的所有轻儿子的答案，<span class=\"math inline\">\\(g_{u,1}\\)</span> 不取 <span class=\"math inline\">\\(u\\)</span>，轻儿子可选可不选的答案。</p>\n<p><span class=\"math inline\">\\(g\\)</span> 是可求的，且只需要在跳重链的时候更新 <span class=\"math inline\">\\(g\\)</span>。具体更新起来非常绞，因为 <span class=\"math inline\">\\(g\\)</span> 和 <span class=\"math inline\">\\(f\\)</span> 是相互依赖的，需要分清楚先后关系。</p>\n<p>首先 <span class=\"math inline\">\\(g_u\\)</span> 和 <span class=\"math inline\">\\(f_u\\)</span> 都会被更新；接着，重链上其它的 <span class=\"math inline\">\\(g\\)</span> 不会被影响，而链顶的 <span class=\"math inline\">\\(f\\)</span> 需要被新的 <span class=\"math inline\">\\(g_u\\)</span> 更新；由此链顶父亲的 <span class=\"math inline\">\\(g\\)</span> 被更新；依次类推。注意到对于一个链顶，其 <span class=\"math inline\">\\(f\\)</span> 值是整条重链的乘积，故需要记录链底。</p>\n<p>复杂度 <span class=\"math inline\">\\(O(q\\log ^2n)\\)</span>。注意很重要的一点是线段树内乘法应从右往左。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e5 + 5;\nconst int inf = 0x3f3f3f3f;\nstruct mat &#123;\n    int n, m, a[2][2];\n    mat() &#123;&#125;\n    mat(int n1, int m1): n(n1), m(m1) &#123;\n        for (int i = 0; i &lt; n; ++i)\n            for (int j = 0; j &lt; m; ++j)\n                a[i][j] = -inf;\n        return;\n    &#125;\n    int* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    mat operator* (mat q) const &#123;\n        mat res(n, q.m);\n        for (int i = 0; i &lt; n; ++i)\n            for (int k = 0; k &lt; q.m; ++k)\n                for (int j = 0; j &lt; m; ++j)\n                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nstruct &#123; int l, r; mat u; &#125; t[maxn &lt;&lt; 2]; \nint g[maxn][2], tab[maxn];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        int u = tab[l];\n        t[p].u = mat(2, 2);\n        t[p].u[0][0] = t[p].u[1][0] = g[u][1];\n        t[p].u[0][1] = g[u][0];\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\nvoid add(int p, int x) &#123;\n    if (t[p].l == t[p].r) &#123;\n        int u = tab[x];\n        t[p].u[0][0] = t[p].u[1][0] = g[u][1];\n        t[p].u[0][1] = g[u][0];\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        add(lt, x);\n    else\n        add(rt, x);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\nmat ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].u;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (r &lt;= mid)\n        return ask(lt, l, r);\n    if (l &gt; mid)\n        return ask(rt, l, r);\n    return ask(rt, l, r) * ask(lt, l, r);\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, q;\n    std::cin &gt;&gt; n &gt;&gt; q;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g1[x].push_back(y), g1[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; siz(n + 1), son(n + 1), fa(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        siz[x] = 1;\n        for (auto i : g1[x])\n            if (i != fa[x]) &#123;\n                fa[i] = x, DFS(i);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1);\n    std::vector&lt;std::array&lt;int, 2&gt; &gt; f(n + 1);\n    std::vector&lt;int&gt; top(n + 1), bot(n + 1), dfn(n + 1);\n    DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        dfn[x] = ++now, tab[now] = x;\n        if (son[x]) &#123;\n            top[son[x]] = top[x], DFS(son[x]);\n            bot[x] = bot[son[x]];\n            g[x][0] = a[x];\n            for (auto i : g1[x])\n                if (i != son[x] &amp;&amp; i != fa[x]) &#123;\n                    top[i] = i, DFS(i);\n                    g[x][0] += f[i][0];\n                    g[x][1] += std::max(f[i][1], f[i][0]);\n                &#125;\n            f[x][0] = g[x][1] + std::max(f[son[x]][0], f[son[x]][1]);\n            f[x][1] = g[x][0] + f[son[x]][0];\n        &#125;\n        else\n            f[x][1] = g[x][0] = a[x], bot[x] = x;\n        return;\n    &#125;;\n    top[1] = 1, DFS(1);\n    bld(1, 1, n);\n    for (int x, v; q--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; v;\n        g[x][0] -= a[x], g[x][0] += v, a[x] = v;\n        for (; top[x] != 1; ) &#123;\n            auto r = ask(1, dfn[top[x]], dfn[bot[x]]);\n            f[top[x]][0] = r[0][0], f[top[x]][1] = r[0][1];\n            g[fa[top[x]]][0] -= f[top[x]][0];\n            g[fa[top[x]]][1] -= std::max(f[top[x]][0], f[top[x]][1]);\n            add(1, dfn[x]);\n            r = ask(1, dfn[top[x]], dfn[bot[x]]);\n            f[top[x]][0] = r[0][0], f[top[x]][1] = r[0][1];\n            g[fa[top[x]]][0] += f[top[x]][0];\n            g[fa[top[x]]][1] += std::max(f[top[x]][0], f[top[x]][1]);\n            x = fa[top[x]];\n        &#125;\n        add(1, dfn[x]);\n        auto r = ask(1, dfn[1], dfn[bot[1]]);\n        f[1][0] = r[0][0], f[1][1] = r[0][1];\n        std::cout &lt;&lt; std::max(f[1][0], f[1][1]) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"全局平衡二叉树\">全局平衡二叉树</h2>\n<p>回顾树剖（重剖），功能在于解决路径问题，单次操作能够在 <span class=\"math inline\">\\(O(\\log^2 n)\\)</span> 的时间内完成。这个功能可以被<strong>全局平衡二叉树（GBT）</strong>上位替代。GBT 能够在单次 <span class=\"math inline\">\\(O(\\log n)\\)</span> 的复杂度内完成链操作、子树操作。<em><a href=\"QTREE解法的一些研究.pdf\">Yang Zhe - SPOJ375 QTREE 解法的一些研究</a> 中更为详细严谨地对 GBT 进行了说明，我传了份文件上来。</em></p>\n<p>考虑树剖能被卡的原因：每次线段树询问都会卡满 <span class=\"math inline\">\\(O(\\log n)\\)</span>，找一条卡得满 <span class=\"math inline\">\\(O(\\log n)\\)</span> 次跳重链次数的路径一直薅，就可以卡到 <span class=\"math inline\">\\(O(\\log^2 n)\\)</span>。</p>\n<p>在实现线段树时发现，对于<strong>路径操作</strong>和<strong>单点操作</strong>，树剖只需要维护同一条重链的信息，建一个大线段树会产生许多重链间的无效维护。故一种经典的树剖卡常技巧是对于每一条重链建出线段树。</p>\n<p>在本文中定义<strong>全局二叉树</strong>：将单个线段树按照在原树上重链顶的相对祖孙关系连边得到的模型。这里为了和<strong>全局平衡二叉树</strong>形成照应而命名，实际上模型并不是二叉树。容易发现<strong>修改某个点花费的操作次数和其在全局二叉树中的深度相同</strong>。</p>\n<p>考虑本方法理论上仍可卡到 <span class=\"math inline\">\\(O(\\log^2 n)\\)</span> 单次操作的原因，虽然单个线段树平衡，但<strong>全局二叉树</strong>并不平衡；能够构造数据使得树高达到 <span class=\"math inline\">\\(\\log^2 n\\)</span>。考虑使得全局二叉树平衡，即调整线段树结构使得任何一个点在全局二叉树上的左右儿子大小最接近。发现是易做的，只需在建线段树时移动左右儿子分割点使得两边子树大小均为全树的一半即可。</p>\n<p>法一：求出每个点的轻子树大小 <span class=\"math inline\">\\(ls_u=1+\\sum siz_v\\)</span>，作为加权在线段树上找 mid 就能满足全局平衡；证明可以见上面的论文。这里用线段树代替了 BST，常数很大。</p>\n<p>法二：用一个 BST 实现上述功能，需要满足：任意子树的根为子树的带权 mid；BST 的中序遍历为原重链。显然有：树高为 log 级别。这就决定了所有问题都可以通过暴力爬山解决。</p>\n<p>GBT 能够快速维护<strong>普通树剖操作</strong>和 <strong>DDP 信息</strong>。</p>\n<hr />\n<h3 id=\"维护-ddp模板动态-dp加强版\">维护 DDP：【模板】动态 DP（加强版）</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P4751\" class=\"uri\">https://www.luogu.com.cn/problem/P4751</a></p>\n<p>和未加强版类似，把所有线段树操作替换为 BST 即可。如果写得丑可能需要一些额外的卡常技巧。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e6 + 5;\nconst int inf = 0x3f3f3f3f;\nconst int LEN = (1 &lt;&lt; 20);\nint nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF;\n        p = buf;\n    &#125;\n    return *p++;\n&#125;\nbool read(int &amp;x) &#123;\n    x = 0;\n    bool f = 0;\n    char ch = nec();\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nvoid print(int x) &#123;\n    if (x &lt; 0)\n        putchar(&#39;-&#39;), x = -x;\n    if (x &gt;= 10) print(x / 10);\n    putchar(x % 10 + &#39;0&#39;);\n    return;\n&#125;\nvoid print(int x, char ch) &#123;\n    print(x), putchar(ch);\n    return;\n&#125;\nstruct mat &#123;\n    int a[2][2];\n    int* operator[] (const int q) &#123; \n        return a[q];\n    &#125;\n    mat operator* (mat &amp;q) const &#123;\n        mat res;\n        res[0][0] = res[0][1] = res[1][0] = res[1][1] = -inf;\n        for (int i = 0; i &lt; 2; ++i)\n            for (int k = 0; k &lt; 2; ++k)\n                for (int j = 0; j &lt; 2; ++j)\n                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nstruct &#123; int lc, rc, fa; mat u; &#125; t[maxn]; \nint g[maxn][2], tab[maxn], ls[maxn];\nmat p[maxn];\nvoid pushup(int x) &#123;\n    t[x].u = t[t[x].rc].u * p[x] * t[t[x].lc].u;\n    return;\n&#125;\nvoid bld(int &amp;x, int l, int r) &#123;\n    if (l &gt; r)\n        return;\n    int s = 0, k = 0;\n    for (int i = l; i &lt;= r; ++i)\n        s += ls[tab[i]];\n    for (int i = l; i &lt;= r; ++i, k += ls[tab[i]])\n        if ((k + ls[tab[i]]) * 2 &gt; s) &#123;\n            x = tab[i];\n            bld(t[x].lc, l, i - 1), t[t[x].lc].fa = x;\n            bld(t[x].rc, i + 1, r), t[t[x].rc].fa = x;\n            pushup(x);\n            break;\n        &#125;\n    return;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    t[0].u[0][0] = t[0].u[1][1] = 0, t[0].u[0][1] = t[0].u[1][0] = -inf;\n    int n, q;\n    read(n), read(q);\n    std::vector&lt;int&gt; a(n + 1), rt(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        read(a[i]);\n    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        read(x), read(y);\n        g1[x].push_back(y), g1[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; son(n + 1), fa(n + 1), siz(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        siz[x] = 1;\n        for (auto i : g1[x])\n            if (i != fa[x]) &#123;\n                fa[i] = x, DFS(i);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1);\n    std::vector&lt;std::array&lt;int, 2&gt; &gt; f(n + 1);\n    std::vector&lt;int&gt; top(n + 1), bot(n + 1), dfn(n + 1);\n    DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        dfn[x] = ++now, tab[now] = x, ls[x] = 1;\n        if (son[x]) &#123;\n            top[son[x]] = top[x], DFS(son[x]);\n            bot[x] = bot[son[x]];\n            g[x][0] = a[x];\n            for (auto i : g1[x])\n                if (i != son[x] &amp;&amp; i != fa[x]) &#123;\n                    top[i] = i, DFS(i), t[rt[i]].fa = x;\n                    ls[x] += siz[i];\n                    g[x][0] += f[i][0];\n                    g[x][1] += std::max(f[i][1], f[i][0]);\n                &#125;\n            f[x][0] = g[x][1] + std::max(f[son[x]][0], f[son[x]][1]);\n            f[x][1] = g[x][0] + f[son[x]][0];\n        &#125;\n        else\n            f[x][1] = g[x][0] = a[x], bot[x] = x;\n        p[x][0][0] = p[x][1][0] = g[x][1];\n        p[x][0][1] = g[x][0], p[x][1][1] = -inf;\n        if (x == top[x])\n            bld(rt[x], dfn[x], dfn[bot[x]]);\n        return;\n    &#125;;\n    top[1] = 1, DFS(1);\n    for (int x, v, la = 0; q--; ) &#123;\n        read(x), read(v), x ^= la;\n        p[x][0][1] += v - a[x], a[x] = v;\n        for (; x; ) &#123;\n            int fa = t[x].fa;\n            if (fa &amp;&amp; x != t[fa].lc &amp;&amp; x != t[fa].rc) &#123;\n                int f0 = t[x].u[0][0], f1 = std::max(f0, t[x].u[0][1]);\n                pushup(x);\n                int F0 = t[x].u[0][0], F1 = std::max(F0, t[x].u[0][1]);\n                p[fa][0][0] += F1 - f1, p[fa][1][0] += F1 - f1;\n                p[fa][0][1] += F0 - f0;\n            &#125;\n            else\n                pushup(x);\n            x = fa;\n        &#125;\n        print(la = std::max(t[rt[1]].u[0][0], t[rt[1]].u[0][1]), &#39;\\n&#39;);\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<p>也给出一个线段树版本的</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e6 + 5;\nconst int inf = 0x3f3f3f3f;\nconst int LEN = (1 &lt;&lt; 20);\nint nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF;\n        p = buf;\n    &#125;\n    return *p++;\n&#125;\nbool read(int &amp;x) &#123;\n    x = 0;\n    bool f = 0;\n    char ch = nec();\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nvoid print(int x) &#123;\n    if (x &lt; 0)\n        putchar(&#39;-&#39;), x = -x;\n    if (x &gt;= 10) print(x / 10);\n    putchar(x % 10 + &#39;0&#39;);\n    return;\n&#125;\nvoid print(int x, char ch) &#123;\n    print(x), putchar(ch);\n    return;\n&#125;\nstruct mat &#123;\n    int a[2][2];\n    int* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    mat operator* (mat q) const &#123;\n        mat res;\n        res[0][0] = res[0][1] = res[1][0] = res[1][1] = -inf;\n        for (int i = 0; i &lt; 2; ++i)\n            for (int k = 0; k &lt; 2; ++k)\n                for (int j = 0; j &lt; 2; ++j)\n                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nstruct &#123; int lc, rc, l, r, mid; mat u; &#125; t[maxn &lt;&lt; 2]; \nint g[maxn][2], tab[maxn], ls[maxn];\n#define lt t[p].lc\n#define rt t[p].rc\nvoid bld(int &amp;p, int l, int r) &#123;\n    static int tot = 0;\n    p = ++tot, t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        int u = tab[l];\n        t[p].u[0][0] = t[p].u[1][0] = g[u][1];\n        t[p].u[0][1] = g[u][0], t[p].u[1][1] = -inf;\n        return;\n    &#125;\n    int s = 0, u = ls[tab[l]];\n    for (int i = l; i &lt;= r; ++i)\n        s += ls[tab[i]];\n    s &gt;&gt;= 1;\n    t[p].mid = r - 1;\n    for (int i = l + 1; i &lt; r; ++i) &#123;\n        u += ls[tab[i]];\n        if (u + ls[tab[i + 1]] &gt; s) &#123;\n            t[p].mid = i;\n            break;\n        &#125;\n    &#125;\n    bld(lt, l, t[p].mid), bld(rt, t[p].mid + 1, r);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\nvoid add(int p, int x) &#123;\n    if (t[p].l == t[p].r) &#123;\n        int u = tab[x];\n        t[p].u[0][0] = t[p].u[1][0] = g[u][1];\n        t[p].u[0][1] = g[u][0];\n        return;\n    &#125;\n    if (x &lt;= t[p].mid)\n        add(lt, x);\n    else\n        add(rt, x);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\nmat ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].u;\n    if (r &lt;= t[p].mid)\n        return ask(lt, l, r);\n    if (l &gt; t[p].mid)\n        return ask(rt, l, r);\n    return ask(rt, l, r) * ask(lt, l, r);\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, q;\n    read(n), read(q);\n    std::vector&lt;int&gt; a(n + 1), rt(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        read(a[i]);\n    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        read(x), read(y);\n        g1[x].push_back(y), g1[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; siz(n + 1), son(n + 1), fa(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        siz[x] = 1;\n        for (auto i : g1[x])\n            if (i != fa[x]) &#123;\n                fa[i] = x, DFS(i);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1);\n    std::vector&lt;std::array&lt;int, 2&gt; &gt; f(n + 1);\n    std::vector&lt;int&gt; top(n + 1), bot(n + 1), dfn(n + 1);\n    DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        dfn[x] = ++now, tab[now] = x;\n        ls[x] = 1;\n        if (son[x]) &#123;\n            top[son[x]] = top[x], DFS(son[x]);\n            bot[x] = bot[son[x]];\n            g[x][0] = a[x];\n            for (auto i : g1[x])\n                if (i != son[x] &amp;&amp; i != fa[x]) &#123;\n                    top[i] = i, DFS(i);\n                    ls[x] += siz[i];\n                    g[x][0] += f[i][0];\n                    g[x][1] += std::max(f[i][1], f[i][0]);\n                &#125;\n            f[x][0] = g[x][1] + std::max(f[son[x]][0], f[son[x]][1]);\n            f[x][1] = g[x][0] + f[son[x]][0];\n        &#125;\n        else\n            f[x][1] = g[x][0] = a[x], bot[x] = x;\n        if (x == top[x])\n            bld(rt[x], dfn[x], dfn[bot[x]]);\n        return;\n    &#125;;\n    top[1] = 1, DFS(1);\n    for (int x, v, la = 0; q--; ) &#123;\n        read(x), read(v), x ^= la;\n        g[x][0] -= a[x], g[x][0] += v, a[x] = v;\n        for (; top[x] != 1; ) &#123;\n            auto r = t[rt[top[x]]].u;\n            f[top[x]][0] = r[0][0], f[top[x]][1] = r[0][1];\n            g[fa[top[x]]][0] -= f[top[x]][0];\n            g[fa[top[x]]][1] -= std::max(f[top[x]][0], f[top[x]][1]);\n            add(rt[top[x]], dfn[x]);\n            r = t[rt[top[x]]].u;\n            f[top[x]][0] = r[0][0], f[top[x]][1] = r[0][1];\n            g[fa[top[x]]][0] += f[top[x]][0];\n            g[fa[top[x]]][1] += std::max(f[top[x]][0], f[top[x]][1]);\n            x = fa[top[x]];\n        &#125;\n        add(rt[1], dfn[x]);\n        auto r =  t[rt[1]].u;\n        f[1][0] = r[0][0], f[1][1] = r[0][1];\n        std::cout &lt;&lt; (la = std::max(f[1][0], f[1][1])) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"树上路径问题染色\">树上路径问题：染色</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P2486\" class=\"uri\">https://www.luogu.com.cn/problem/P2486</a></p>\n<p>GBT 上的<strong>路径问题</strong>。</p>\n<p>BST：首先暴力爬山到 LCA，统计一路上的答案；然后跳到当前 BST 的根。由于本题有标记，所以需要在跳的同时想办法把标记问题解决一下。</p>\n<p>线段树：把树剖的线段树略改一下就过了。从上一行模棱两可的描述就可以看出来 BST 实现起来不太轻松；还是线段树更轮椅啊！</p>\n<details>\n<p>跑得没纯树剖快，因为数据没有刻意构造导致树高很低，再加上常数的影响吧。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e5 + 5;\nconst int LEN = (1 &lt;&lt; 20);\nint nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF;\n        p = buf;\n    &#125;\n    return *p++;\n&#125;\nbool read(int &amp;x) &#123;\n    x = 0;\n    bool f = 0;\n    char ch = nec();\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nvoid read(char &amp;x) &#123;\n    for (x = nec(); x != &#39;C&#39; &amp;&amp; x != &#39;Q&#39;; x = nec());\n    return;\n&#125;\nvoid print(int x) &#123;\n    if (x &lt; 0)\n        putchar(&#39;-&#39;), x = -x;\n    if (x &gt;= 10) print(x / 10);\n    putchar(x % 10 + &#39;0&#39;);\n    return;\n&#125;\nvoid print(int x, char ch) &#123;\n    print(x), putchar(ch);\n    return;\n&#125;\nclass node &#123;\nprivate:\n    int lt, rt;\npublic:\n    int l, r, mid, lc, rc, u, d;\n    node(): u(-1) &#123;&#125;\n    inline int&amp; ls(void) &#123; return lt; &#125;\n    inline int&amp; rs(void) &#123; return rt; &#125;\n    node&amp; operator= (const node &amp;q) &#123;\n        lc = q.lc, rc = q.rc, u = q.u;\n        return *this;\n    &#125;\n    node operator+ (const node &amp;q) const &#123;\n        if (u == -1)\n            return q;\n        if (q.u == -1)\n            return *this;\n        node res;\n        res.lc = lc, res.rc = q.rc, res.u = u + q.u - (rc == q.lc);\n        return res;\n    &#125;\n    inline void swap(void) &#123;\n        if (~u)\n            lc ^= rc ^= lc ^= rc;\n        return;\n    &#125;\n&#125; t[maxn &lt;&lt; 2]; \nint tab[maxn], ls[maxn], a[maxn];\n#define lt t[p].ls()\n#define rt t[p].rs()\nvoid bld(int &amp;p, int l, int r) &#123;\n    static int tot = 0;\n    p = ++tot, t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        t[p].u = 1;\n        t[p].lc = t[p].rc = a[tab[l]];\n        return;\n    &#125;\n    int s = 0, u = ls[tab[l]];\n    for (int i = l; i &lt;= r; ++i)\n        s += ls[tab[i]];\n    s &gt;&gt;= 1;\n    t[p].mid = r - 1;\n    for (int i = l + 1; i &lt; r; ++i) &#123;\n        u += ls[tab[i]];\n        if (u + ls[tab[i + 1]] &gt; s) &#123;\n            t[p].mid = i;\n            break;\n        &#125;\n    &#125;\n    bld(lt, l, t[p].mid), bld(rt, t[p].mid + 1, r);\n    t[p] = t[lt] + t[rt];\n    return;\n&#125;\nvoid pushdown(int p) &#123;\n    if (t[p].d) &#123;\n        t[lt].d = t[lt].lc = t[lt].rc = t[rt].d = t[rt].lc = t[rt].rc = t[p].d;\n        t[lt].u = t[rt].u = 1;\n        t[p].d = 0;\n    &#125;\n    return;\n&#125;\nvoid add(int p, int l, int r, int v) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        t[p].u = 1;\n        t[p].lc = t[p].rc = t[p].d = v;\n        return;\n    &#125;\n    pushdown(p);\n    if (l &lt;= t[p].mid)\n        add(lt, l, r, v);\n    if (r &gt; t[p].mid)\n        add(rt, l, r, v);\n    t[p] = t[lt] + t[rt];\n    return;\n&#125;\nnode ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p];\n    pushdown(p);\n    if (r &lt;= t[p].mid)\n        return ask(lt, l, r);\n    if (l &gt; t[p].mid)\n        return ask(rt, l, r);\n    return ask(lt, l, r) + ask(rt, l, r);\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n#else\n    std::freopen(&quot;paint17.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, q;\n    read(n), read(q);\n    std::vector&lt;int&gt; rt(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        read(a[i]);\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        read(x), read(y);\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; siz(n + 1), son(n + 1), fa(n + 1), dep(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        siz[x] = 1;\n        for (auto i : g[x])\n            if (i != fa[x]) &#123;\n                dep[i] = dep[x] + 1;\n                fa[i] = x, DFS(i);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1);\n    std::vector&lt;std::array&lt;int, 2&gt; &gt; f(n + 1);\n    std::vector&lt;int&gt; top(n + 1), bot(n + 1), dfn(n + 1);\n    DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        dfn[x] = ++now, tab[now] = x, ls[x] = 1;\n        if (son[x]) &#123;\n            top[son[x]] = top[x], DFS(son[x]);\n            bot[x] = bot[son[x]];\n        &#125;\n        else\n            bot[x] = x;\n        for (auto i : g[x])\n            if (i != son[x] &amp;&amp; i != fa[x]) &#123;\n                top[i] = i;\n                DFS(i);\n                ls[x] += siz[i];\n            &#125;\n        if (x == top[x])\n            bld(rt[x], dfn[x], dfn[bot[x]]);\n        return;\n    &#125;;\n    top[1] = 1, DFS(1);\n    for (char op; q--; ) &#123;\n        read(op);\n        if (op == &#39;C&#39;) &#123;\n            int x, y, c;\n            read(x), read(y), read(c);\n            for (; top[x] != top[y]; x = fa[top[x]]) &#123;\n                if (dep[top[x]] &lt; dep[top[y]])\n                    std::swap(x, y);\n                add(rt[top[x]], dfn[top[x]], dfn[x], c);\n            &#125;\n            if (dep[x] &gt; dep[y])\n                std::swap(x, y);\n            add(rt[top[x]], dfn[x], dfn[y], c);\n        &#125;\n        else &#123;\n            int x, y;\n            read(x), read(y);\n            node res1, res2;\n            for (; top[x] != top[y]; )\n                if (dep[top[x]] &lt; dep[top[y]]) &#123;\n                    res2 = ask(rt[top[y]], dfn[top[y]], dfn[y]) + res2;\n                    y = fa[top[y]];\n                &#125;\n                else &#123;\n                    res1 = ask(rt[top[x]], dfn[top[x]], dfn[x]) + res1;\n                    x = fa[top[x]];\n                &#125;\n            if (dep[x] &gt; dep[y])\n                res1 = ask(rt[top[y]], dfn[y], dfn[x]) + res1;\n            else\n                res2 = ask(rt[top[x]], dfn[x], dfn[y]) + res2;\n            res1.swap();\n            print((res1 + res2).u, &#39;\\n&#39;);\n        &#125;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"树上路径查询\">树上路径查询？</h3>\n<p>做题的时候可以感受到，路径询问的存在很诡异，因为只需要一条链的操作，更偏向链上 DDP 而非树上的；<strong>轻儿子的信息是不用维护的</strong>，形式上更像树剖（DS）；当成链上的 DDP 就可以解决了。</p>\n<p>可以用倍增维护 DDP（不用考虑轻重儿子，只用维护父子关系，进一步向序列 DDP 靠近），就不用打 GBT 了，常数也会小一些。</p>\n<hr />\n<h2 id=\"习题\">习题</h2>\n<p>GBT 就统一用线段树了。DDP 也就可以顺带用 GBT 优化了。</p>\n<hr />\n<h3 id=\"e---猫或狗-cats-or-dogs\">E - 猫或狗 / Cats or Dogs</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P9597\" class=\"uri\">https://www.luogu.com.cn/problem/P9597</a></p>\n<p>设 <span class=\"math inline\">\\(f_{u,0/1}\\)</span> 表示从根上颜色为 <span class=\"math inline\">\\(0/1\\)</span> 时的最小断边数，显然无色可以视作任选一个颜色。那么有：</p>\n<p><span class=\"math display\">\\[\nf_{u,a}=\\sum\\limits_v\\min\\limits_{b\\in\\{0,1\\}}\\{f_{v,b}+[a\\ne b]\\}\n\\]</span></p>\n<p>直接把轻儿子的项提出来，记 <span class=\"math inline\">\\(g_{u,0/1}\\)</span> 表示 <span class=\"math inline\">\\(f_{u,0/1}\\)</span> 对应的轻儿子贡献即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e5 + 5;\nconst int inf = 0x3f3f3f3f;\nstruct mat &#123;\n    int a[2][2];\n    int* operator[] (const int q) &#123; \n        return a[q];\n    &#125;\n    mat operator* (mat &amp;q) const &#123;\n        mat res;\n        res[0][0] = res[0][1] = res[1][0] = res[1][1] = inf;\n        for (int i = 0; i &lt; 2; ++i)\n            for (int k = 0; k &lt; 2; ++k)\n                for (int j = 0; j &lt; 2; ++j)\n                    res[i][k] = std::min(res[i][k], a[i][j] + q[j][k]);\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125; p[maxn];\nstruct &#123; int lc, rc, l, r, mid; mat u; &#125; t[maxn &lt;&lt; 2]; \nint ls[maxn], tab[maxn], g[maxn][2], rt[maxn], top[maxn], dfn[maxn], fa[maxn];\nstd::vector&lt;int&gt; a;\n#define lt t[p].lc\n#define rt t[p].rc\nvoid bld(int &amp;p, int l, int r) &#123;\n    static int tot = 0;\n    p = ++tot, t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        t[p].u[0][1] = t[p].u[1][0] = 1;\n        return;\n    &#125;\n    int s = 0, u = ls[tab[l]];\n    for (int i = l; i &lt;= r; ++i)\n        s += ls[tab[i]];\n    s &gt;&gt;= 1;\n    t[p].mid = r - 1;\n    for (int i = l + 1; i &lt; r; ++i) &#123;\n        u += ls[tab[i]];\n        if (u + ls[tab[i + 1]] &gt; s) &#123;\n            t[p].mid = i;\n            break;\n        &#125;\n    &#125;\n    bld(lt, l, t[p].mid), bld(rt, t[p].mid + 1, r);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\nvoid add(int p, int x) &#123;\n    if (t[p].l == t[p].r) &#123;\n        int u = tab[x], g0 = (a[u] == 1 ? inf : g[u][0]), g1 = (a[u] == 0 ? inf : g[u][1]);\n        t[p].u[0][0] = g0, t[p].u[0][1] = g1 + 1;\n        t[p].u[1][0] = g0 + 1, t[p].u[1][1] = g1;\n        return;\n    &#125;\n    if (x &lt;= t[p].mid)\n        add(lt, x);\n    else\n        add(rt, x);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\n#undef lt\n#undef rt\nvoid initialize(int n, std::vector&lt;int&gt; A, std::vector&lt;int&gt; B) &#123;\n    a.assign(n + 1, -1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);\n    for (int i = 0; i &lt; n - 1; ++i)\n        g1[A[i]].push_back(B[i]), g1[B[i]].push_back(A[i]);\n    std::vector&lt;int&gt; siz(n + 1), son(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        siz[x] = 1;\n        for (auto i : g1[x])\n            if (i != fa[x]) &#123;\n                fa[i] = x, DFS(i);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1);\n    std::vector&lt;int&gt; bot(n + 1);\n    DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        dfn[x] = ++now, tab[now] = x, ls[x] = 1;\n        if (son[x]) &#123;\n            top[son[x]] = top[x], DFS(son[x]);\n            bot[x] = bot[son[x]];\n            for (auto i : g1[x])\n                if (i != son[x] &amp;&amp; i != fa[x]) &#123;\n                    top[i] = i, DFS(i);\n                    ls[x] += siz[i];\n                &#125;\n        &#125;\n        else\n            bot[x] = x;\n        if (x == top[x])\n            bld(rt[x], dfn[x], dfn[bot[x]]);\n        return;\n    &#125;;\n    top[1] = 1, DFS(1);\n    return;\n&#125;\nint upd(int x) &#123;\n    for (; top[x] != 1; ) &#123;\n        int faa = fa[top[x]];\n        auto &amp;id = t[rt[top[x]]].u;\n        int f0 = std::min(id[0][0], id[1][0]), f1 = std::min(id[0][1], id[1][1]);\n        g[faa][0] -= std::min(f0, f1 + 1);\n        g[faa][1] -= std::min(f0 + 1, f1);\n        add(rt[top[x]], dfn[x]);\n        f0 = std::min(id[0][0], id[1][0]), f1 = std::min(id[0][1], id[1][1]);\n        // printf(&quot;%d: f0 = %d, f1 = %d\\n&quot;, top[x], f0, f1);\n        g[faa][0] += std::min(f0, f1 + 1);\n        g[faa][1] += std::min(f0 + 1, f1);\n        x = faa;\n    &#125;\n    add(rt[1], dfn[x]);\n    auto &amp;id = t[rt[1]].u;\n    int f0 = std::min(id[0][0], id[1][0]), f1 = std::min(id[0][1], id[1][1]);\n    // printf(&quot;%d: f0 = %d, f1 = %d\\n&quot;, 1, f0, f1);\n    return std::min(f0, f1);\n&#125;\nint cat(int x) &#123;\n    a[x] = 0;\n    return upd(x);\n&#125;\nint dog(int x) &#123;\n    a[x] = 1;\n    return upd(x);\n&#125;\nint neighbor(int x) &#123;\n    a[x] = -1;\n    return upd(x);\n&#125;\n#ifndef ONLINE_JUDGE\nint main() &#123;\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; A(n - 1), B(n - 1);\n    for (int i = 0; i &lt; n - 1; ++i)\n        std::cin &gt;&gt; A[i] &gt;&gt; B[i];\n    initialize(n, A, B);\n    int q;\n    std::cin &gt;&gt; q;\n    for (int op, x; q--; ) &#123;\n        std::cin &gt;&gt; op &gt;&gt; x;\n        std::cout &lt;&lt; (op == 1 ? cat(x) : (op == 2 ? dog(x) : neighbor(x))) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n    return 0;\n&#125;\n#endif</code></pre>\n</details>\n<hr />\n<h3 id=\"f---hash-on-tree\">F - Hash on Tree</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_abc351_g\" class=\"uri\">https://www.luogu.com.cn/problem/AT_abc351_g</a></p>\n<p>记 <span class=\"math inline\">\\(g_x\\)</span> 为轻儿子的哈希值之积，则 <span class=\"math inline\">\\(f_u=A_u+f_{son}\\cdot g_u\\)</span>。</p>\n<p>然后开一个常数维即可。快速幂的 log 省不掉，所以是双 log 的。</p>\n<p>初值和修改都有可能为 <span class=\"math inline\">\\(0\\)</span>，需要维护实际哈希值和去掉 <span class=\"math inline\">\\(0\\)</span> 的哈希值。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e6 + 5;\nconst int LEN = (1 &lt;&lt; 20);\nconst int mod = 998244353;\nint nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF;\n        p = buf;\n    &#125;\n    return *p++;\n&#125;\nbool read(int &amp;x) &#123;\n    x = 0;\n    bool f = 0;\n    char ch = nec();\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nvoid print(int x) &#123;\n    if (x &lt; 0)\n        putchar(&#39;-&#39;), x = -x;\n    if (x &gt;= 10) print(x / 10);\n    putchar(x % 10 + &#39;0&#39;);\n    return;\n&#125;\nvoid print(int x, char ch) &#123;\n    print(x), putchar(ch);\n    return;\n&#125;\nstruct mat &#123;\n    int n, m;\n    long long a[2][2];\n    long long* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    mat operator* (mat &amp;q) const &#123;\n        mat res;\n        res.n = n, res.m = q.m;\n        res[0][0] = res[0][1] = res[1][0] = res[1][1] = 0ll;\n        for (int i = 0; i &lt; n; ++i)\n            for (int k = 0; k &lt; q.m; ++k) &#123;\n                for (int j = 0; j &lt; m; ++j)\n                    res[i][k] += a[i][j] * q[j][k];\n                res[i][k] %= mod;\n            &#125;\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nstruct &#123; int lc, rc, l, r, mid; mat u; &#125; t[maxn &lt;&lt; 2]; \nlong long g[maxn];\nint tab[maxn], ls[maxn], a[maxn];\n#define lt t[p].lc\n#define rt t[p].rc\nvoid bld(int &amp;p, int l, int r) &#123;\n    static int tot = 0;\n    p = ++tot, t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        int u = tab[l];\n        t[p].u.n = t[p].u.m = 2;\n        t[p].u[0][0] = g[u];\n        t[p].u[0][1] = 0ll;\n        t[p].u[1][0] = a[u];\n        t[p].u[1][1] = 1ll;\n        return;\n    &#125;\n    int s = 0, u = ls[tab[l]];\n    for (int i = l; i &lt;= r; ++i)\n        s += ls[tab[i]];\n    s &gt;&gt;= 1;\n    t[p].mid = r - 1;\n    for (int i = l + 1; i &lt; r; ++i) &#123;\n        u += ls[tab[i]];\n        if (u + ls[tab[i + 1]] &gt; s) &#123;\n            t[p].mid = i;\n            break;\n        &#125;\n    &#125;\n    bld(lt, l, t[p].mid), bld(rt, t[p].mid + 1, r);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\nvoid add(int p, int x) &#123;\n    if (t[p].l == t[p].r) &#123;\n        int u = tab[x];\n        t[p].u[0][0] = g[u];\n        t[p].u[1][0] = a[u];\n        return;\n    &#125;\n    if (x &lt;= t[p].mid)\n        add(lt, x);\n    else\n        add(rt, x);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, q;\n    read(n), read(q);\n    std::vector&lt;int&gt; rt(n + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);\n    for (int i = 2, x; i &lt;= n; ++i) &#123;\n        read(x);\n        g1[i].push_back(x), g1[x].push_back(i);\n    &#125;\n    for (int i = 1; i &lt;= n; ++i)\n        read(a[i]);\n    std::vector&lt;int&gt; siz(n + 1), son(n + 1), fa(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        siz[x] = 1;\n        for (auto i : g1[x])\n            if (i != fa[x]) &#123;\n                fa[i] = x, DFS(i);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1);\n    std::vector&lt;long long&gt; f(n + 1);\n    std::vector&lt;int&gt; top(n + 1), bot(n + 1), dfn(n + 1), la(n + 1), cnt(n + 1);\n    DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        dfn[x] = ++now, tab[now] = x, ls[x] = 1;\n        if (son[x]) &#123;\n            top[son[x]] = top[x], DFS(son[x]);\n            bot[x] = bot[son[x]];\n            g[x] = 1ll;\n            for (auto i : g1[x])\n                if (i != son[x] &amp;&amp; i != fa[x]) &#123;\n                    top[i] = i, DFS(i);\n                    ls[x] += siz[i];\n                    if (f[i] == 0ll)\n                        ++cnt[x];\n                    else\n                        (la[x] *= f[i]) %= mod;\n                    (g[x] *= f[i]) %= mod;\n                &#125;\n            f[x] = (a[x] + g[x] * f[son[x]]) % mod;\n        &#125;\n        else\n            f[x] = a[x], bot[x] = x;\n        // printf(&quot;f[%d] = %lld\\n&quot;, x, f[x]);\n        if (x == top[x])\n            bld(rt[x], dfn[x], dfn[bot[x]]);\n        return;\n    &#125;;\n    top[1] = 1, DFS(1);\n    mat init;\n    init.n = 1, init.m = 2;\n    init[0][0] = 0ll, init[0][1] = 1ll;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    auto inv = [&amp;](int x) &#123;\n        return qkp(x, mod - 2);\n    &#125;;\n    for (int x, v; q--; ) &#123;\n        read(x), read(v);\n        a[x] = v;\n        for (; top[x] != 1; ) &#123;\n            int faa = fa[top[x]];\n            auto &amp;id = t[rt[top[x]]].u;\n            int f = (init * id)[0][0];\n            if (f == 0) &#123;\n                if (--cnt[faa] == 0)\n                    g[faa] = la[faa];\n            &#125;\n            else &#123;\n                f = inv(f);\n                (g[faa] *= f) %= mod;\n                (la[faa] *= f) %= mod;\n            &#125;\n            add(rt[top[x]], dfn[x]);\n            f = (init * id)[0][0];\n            if (f == 0) &#123;\n                if (cnt[faa]++ == 0)\n                    la[faa] = g[faa];\n                g[faa] = 0ll;\n            &#125;\n            else &#123;\n                (g[faa] *= f) %= mod;\n                (la[faa] *= f) %= mod;\n            &#125;\n            x = faa;\n        &#125;\n        add(rt[1], dfn[x]);\n        auto &amp;id = t[rt[1]].u;\n        int f = (init * id)[0][0];\n        std::cout &lt;&lt; f &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"g---考试-2\">G - 考试 2</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P10626\" class=\"uri\">https://www.luogu.com.cn/problem/P10626</a></p>\n<p>运算均是线性的，容易想到『按位』维护，即只维护某个特定点值。如果将询问离线下来排序，每个函数的点值只会变化 <span class=\"math inline\">\\(O(1)\\)</span> 次。</p>\n<p>建出符号二叉树，进行 DDP 即可。具体地，令 <span class=\"math inline\">\\(f_u\\)</span> 表示在运算 <span class=\"math inline\">\\(u\\)</span> 处的答案，计算 <span class=\"math inline\">\\(g_u\\)</span> 为轻儿子的答案，按照 <span class=\"math inline\">\\(u\\)</span> 处的符号写矩阵即可。叶子不是一次运算，应该直接填入点值（注意线段树上的叶子不一定是原树上的叶子）。</p>\n<p>建树和矩阵更新有点史，适当封装一下感觉会好一点</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e6 + 5;\nconst char mp[] = &quot;x!&amp;|^&quot;;\nconst int LEN = (1 &lt;&lt; 20);\n#define nec getchar\ninline bool read(int &amp;x) &#123;\n    x = 0;\n    bool f = 0;\n    char ch = nec();\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nvoid print(int x) &#123;\n    if (x &lt; 0)\n        putchar(&#39;-&#39;), x = -x;\n    if (x &gt;= 10) print(x / 10);\n    putchar(x % 10 + &#39;0&#39;);\n    return;\n&#125;\nvoid print(int x, char ch) &#123;\n    print(x), putchar(ch);\n    return;\n&#125;\nstruct mat &#123;\n    int n, m;\n    int a[2][2];\n    int* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    inline mat operator* (mat &amp;q) const &#123;\n        mat res;\n        res.n = n, res.m = q.m;\n        res[0][0] = res[0][1] = res[1][0] = res[1][1] = 0ll;\n        for (int i = 0; i &lt; n; ++i)\n            for (int k = 0; k &lt; q.m; ++k)\n                for (int j = 0; j &lt; m; ++j)\n                    res[i][k] += a[i][j] * q[j][k];\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nstruct &#123; int lc, rc, l, r, mid; mat u; &#125; t[maxn &lt;&lt; 2]; \nint g1[maxn][2];\nint g[maxn], ty[maxn];\nint tab[maxn], ls[maxn], lim[maxn];\n#define lt t[p].lc\n#define rt t[p].rc\nvoid fillmat(mat &amp;a, int op, int g) &#123;\n    if (op == 0) &#123;\n        a.n = 1, a.m = 2;\n        a[0][!g] = 0, a[0][g] = 1;\n        return;\n    &#125;\n    a.n = 2, a.m = 2;\n    switch (op) &#123;\n    case 1: // !\n        a[0][0] = 0, a[0][1] = 1;\n        a[1][0] = 1, a[1][1] = 0;\n        break;\n    case 2: // &amp;\n        a[0][0] = 1, a[0][1] = 0;\n        a[1][0] = !g, a[1][1] = g;\n        break;\n    case 3: // |\n        a[0][0] = !g, a[0][1] = g;\n        a[1][0] = 0, a[1][1] = 1;\n        break;\n    case 4: // ^\n        a[0][0] = !g, a[0][1] = g;\n        a[1][0] = g, a[1][1] = !g;\n        break;\n    default:\n        assert(0);\n    &#125;\n    return;\n&#125;\nvoid bld(int &amp;p, int l, int r) &#123;\n    static int tot = 0;\n    p = ++tot, t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        fillmat(t[p].u, ty[tab[l]], g[tab[l]]);\n        return;\n    &#125;\n    int s = 0, u = ls[tab[l]];\n    for (int i = l; i &lt;= r; ++i)\n        s += ls[tab[i]];\n    s &gt;&gt;= 1;\n    t[p].mid = r - 1;\n    for (int i = l + 1; i &lt; r; ++i) &#123;\n        u += ls[tab[i]];\n        if (u + ls[tab[i + 1]] &gt; s) &#123;\n            t[p].mid = i;\n            break;\n        &#125;\n    &#125;\n    bld(lt, l, t[p].mid), bld(rt, t[p].mid + 1, r);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\nvoid add(int p, int x) &#123;\n    if (t[p].l == t[p].r) &#123;\n        fillmat(t[p].u, ty[tab[t[p].l]], g[tab[t[p].l]]);\n        return;\n    &#125;\n    if (x &lt;= t[p].mid)\n        add(lt, x);\n    else\n        add(rt, x);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifndef ONLINE_JUDGE\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n = 0, q, p;\n    read(q), read(q);\n    &#123;\n        std::string s;\n        std::cin &gt;&gt; s;\n        std::stringstream in(s);\n        std::stack&lt;char&gt; op;\n        std::stack&lt;int&gt; id;\n        auto trans = [&amp;](char t) &#123;\n            switch (t) &#123;\n            case &#39;!&#39;:\n                return 1;\n            case &#39;&amp;&#39;:\n                return 2;\n            case &#39;|&#39;:\n                return 3;\n            case &#39;^&#39;:\n                return 4;\n            &#125;\n            assert(0);\n            return -1;\n        &#125;;\n        auto calcNot = [&amp;](void) &#123;\n            for (; !op.empty() &amp;&amp; op.top() == &#39;!&#39;; ) &#123;\n                ty[++n] = trans(op.top());\n                g1[n][0] = id.top(), id.pop(), id.push(n);\n                op.pop();\n            &#125;\n            return;\n        &#125;;\n        auto opt = [&amp;](void) &#123;\n            ty[++n] = trans(op.top());\n            g1[n][0] = id.top(), id.pop();\n            g1[n][1] = id.top(), id.pop();\n            id.push(n), op.pop();\n            return;\n        &#125;;\n        for (char t; in &gt;&gt; t; )\n            if (t == &#39;[&#39;) &#123;\n                int x;\n                in &gt;&gt; x, in &gt;&gt; t;\n                lim[++n] = x - 1;\n                id.push(n), calcNot();\n            &#125;\n            else if (t == &#39;(&#39;)\n                op.push(t);\n            else if (t == &#39;)&#39;) &#123;\n                for (; op.top() != &#39;(&#39;; opt());\n                op.pop(), calcNot();\n            &#125;\n            else if (t == &#39;&amp;&#39;)\n                op.push(t);\n            else if (t == &#39;^&#39;) &#123;\n                for (; !op.empty() &amp;&amp; op.top() == &#39;&amp;&#39;; opt());\n                op.push(t);\n            &#125;\n            else if (t == &#39;|&#39;) &#123;\n                for (; !op.empty() &amp;&amp; (op.top() == &#39;&amp;&#39; || op.top() == &#39;^&#39;); opt());\n                op.push(t);\n            &#125;\n            else &#123;\n                assert(t == &#39;!&#39;);\n                op.push(t);\n            &#125;\n        for (; !op.empty(); opt());\n        p = id.top();\n    &#125;\n    std::vector&lt;int&gt; rt(n + 1);\n    std::vector&lt;int&gt; siz(n + 1), son(n + 1), fa(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        siz[x] = 1;\n        for (auto i : g1[x])\n            if (i != 0) &#123;\n                fa[i] = x, DFS(i);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(p);\n    std::vector&lt;long long&gt; f(n + 1);\n    std::vector&lt;int&gt; top(n + 1), bot(n + 1), dfn(n + 1);\n    DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        dfn[x] = ++now, tab[now] = x, ls[x] = 1;\n        if (son[x]) &#123;\n            top[son[x]] = top[x], DFS(son[x]);\n            bot[x] = bot[son[x]];\n            for (auto i : g1[x])\n                if (i != son[x] &amp;&amp; i != 0) &#123;\n                    top[i] = i, DFS(i);\n                    ls[x] += siz[i], g[x] = f[i];\n                &#125;\n            switch (ty[x]) &#123;\n            case 1:\n                f[x] = !f[son[x]];\n                break;\n            case 2:\n                f[x] = g[x] &amp; f[son[x]];\n                break;\n            case 3:\n                f[x] = g[x] | f[son[x]];\n                break;\n            case 4:\n                f[x] = g[x] ^ f[son[x]];\n                break;\n            default:\n                assert(0);\n                break;\n            &#125;\n        &#125;\n        else\n            assert(!ty[x]), f[x] = g[x] = 0, bot[x] = x;\n        if (x == top[x])\n            bld(rt[x], dfn[x], dfn[bot[x]]);\n        return;\n    &#125;;\n    top[p] = p, DFS(p);\n    std::vector&lt;int&gt; a(q + 1), res(q + 1);\n    for (int i = 1; i &lt;= q; ++i)\n        read(a[i]);\n    std::vector&lt;int&gt; qid(q), nid;\n    for (int i = 1; i &lt;= n; ++i)\n        if (ty[i] == 0)\n            nid.push_back(i);\n    std::iota(qid.begin(), qid.end(), 1);\n    std::sort(qid.begin(), qid.end(), [&amp;](int x, int y) &#123; return a[x] &lt; a[y]; &#125;);\n    std::sort(nid.begin(), nid.end(), [&amp;](int x, int y) &#123; return lim[x] &gt; lim[y]; &#125;);\n    for (auto i : qid) &#123;\n        for (; !nid.empty() &amp;&amp; lim[nid.back()] &lt; a[i]; ) &#123;\n            int x = nid.back();\n            nid.pop_back();\n            g[x] = 1;\n            for (; top[x] != p; ) &#123;\n                add(rt[top[x]], dfn[x]);\n                g[fa[top[x]]] = t[rt[top[x]]].u[0][1];\n                x = fa[top[x]];\n            &#125;\n            add(rt[p], dfn[x]);\n        &#125;\n        res[i] = t[rt[p]].u[0][1];\n    &#125;\n    for (int i = 1; i &lt;= q; ++i)\n        if (res[i])\n            std::cout &lt;&lt; &quot;True\\n&quot;;\n        else\n            std::cout &lt;&lt; &quot;False\\n&quot;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "线段树",
                "DDP"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250809/",
            "url": "https://xsc062.netlify.app/20250809/",
            "title": "近期杂题",
            "date_published": "2025-08-09T04:33:17.000Z",
            "content_html": "<p>这段时间比赛的一些题 和 nKessi、duanyu 讲的题目。太偏计数、数学的基本上没办法做了。</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a.-出关\">A. 出关</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6462/problem/1\" class=\"uri\">http://222.180.160.110:61235/contest/6462/problem/1</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(s\\)</span>，对于一个空串，任意利用下列三种操作，使其变为 <span class=\"math inline\">\\(s\\)</span>，求最小代价：</p>\n<ol type=\"1\">\n<li>在末尾添加字符 <span class=\"math inline\">\\(c\\)</span>，代价为 <span class=\"math inline\">\\(t_{0,c}\\)</span>；</li>\n<li>复制整个字符串并粘贴在末尾，代价为 <span class=\"math inline\">\\(t_1\\)</span>；</li>\n<li>删除末尾字符，代价为 <span class=\"math inline\">\\(t_2\\)</span>。</li>\n</ol>\n<p><span class=\"math inline\">\\(|s|\\le 10^6\\)</span>。</p>\n</blockquote>\n<p>可以预处理出对于每个 <span class=\"math inline\">\\(i\\)</span> 结尾，最多可以复制到哪个地方，发现要求 <span class=\"math inline\">\\(z_i=lcp(s_{1\\dots n},s_{i+1\\dots n})\\)</span>。那么一个 <span class=\"math inline\">\\(i\\)</span> 的最远转移点 <span class=\"math inline\">\\(r_i=i+z_{i+1}\\)</span>，用单调队列就能维护，会 exkmp 就能线性；</p>\n<p>否则可以二分 + 哈希多个 log，后面也有理由偷懒用优先队列了。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int p = 31;\nconst int mod = 998244353;\nint main() &#123;\n    std::freopen(&quot;laozi.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;laozi.out&quot;, &quot;w&quot;, stdout);\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::string s;\n    std::cin &gt;&gt; s;\n    int n = (int)s.length(), t1, t2;\n    std::vector&lt;long long&gt; h(n + 1), base(n + 1);\n    std::vector&lt;int&gt; a(n + 1), t0(27), z(n + 1), r(n + 1);\n    base[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        a[i] = s[i - 1] - &#39;a&#39; + 1;\n        h[i] = (h[i - 1] * p + a[i]) % mod;\n        base[i] = base[i - 1] * p % mod;\n    &#125;\n    auto gethash = [&amp;](int l, int r) &#123;\n        return (h[r] - h[l - 1] * base[r - l + 1] % mod + mod) % mod;\n    &#125;;\n    for (int i = 1; i &lt;= n; ++i)\n        for (int l = 1, r = std::min(i - 1, n - i + 1), mid; l &lt;= r; ) &#123;\n            mid = (l + r) &gt;&gt; 1;\n            if (gethash(1, mid) == gethash(i, i + mid - 1))\n                z[i] = mid, l = mid + 1;\n            else\n                r = mid - 1;\n        &#125;\n    for (int i = 1; i &lt; n; ++i)\n        r[i] = i + std::min(i, z[i + 1]);\n    for (int i = 1; i &lt;= 26; ++i)\n        std::cin &gt;&gt; t0[i];\n    std::cin &gt;&gt; t1 &gt;&gt; t2;\n    std::vector&lt;long long&gt; f(n + 1);\n    std::priority_queue&lt;std::pair&lt;long long, int&gt; &gt; q;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        f[i] = f[i - 1] + t0[a[i]];\n        for (; !q.empty() &amp;&amp; r[q.top().second] &lt; i; q.pop());\n        if (!q.empty())\n            f[i] = std::min(f[i], t1 - q.top().first - (long long)t2 * i);\n        if (i != n)\n            q.emplace(-(f[i] + 2ll * t2 * i), i);\n    &#125;\n    std::cout &lt;&lt; f[n] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d.-非攻\">D. 非攻</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6462/problem/4\" class=\"uri\">http://222.180.160.110:61235/contest/6462/problem/4</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(n\\)</span>，对于一个 <span class=\"math inline\">\\(1\\sim n\\)</span> 的排列，使用最小的交换次数使得其单增。在该前提下，定义代价为每次交换的两个数之积。对于所有 <span class=\"math inline\">\\(n!\\)</span> 个排列，计算最小代价之和。</p>\n<p><span class=\"math inline\">\\(n\\le 10^7\\)</span>。</p>\n</blockquote>\n<p>转化成，把 <span class=\"math inline\">\\(1\\sim n\\)</span> 分成无标号的若干组，每组的代价是 最小值 <span class=\"math inline\">\\(\\times\\)</span> 其他元素的和，还有一个项链问题的系数，发现组间的符号是求和，考虑计算贡献。</p>\n<p>枚举 <span class=\"math inline\">\\(i,j\\)</span> 并钦定两个同属一个环，且 <span class=\"math inline\">\\(i\\)</span> 为最小值，枚举环大小 <span class=\"math inline\">\\(s+2\\)</span>，那么有：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nres&amp;=\\sum_{i=1}^{n-1}\\sum_{j=i+1}^n i\\cdot j \\cdot \\sum_{s=0}^{n-i-1}\\binom{n-i-1}s \\cdot (s+1)!\\cdot (n-s-2)!\\\\\n&amp;=\\sum_{i=1}^{n-1}i\\cdot \\dfrac {(i+n+1)(n-i)}2 \\cdot \\sum_{s=0}^{n-i-1}\\binom{n-i-1}s\\cdot (s+1)!\\cdot (n-s-2)!\\\\\n&amp;=\\frac 12\\times\\sum_{i=1}^{n-1}i\\cdot (i+n+1)\\cdot (n-i)!\\cdot\\sum_{s=0}^{n-i-1}\\dfrac {(s + 1)\\cdot (n-s-2)!}{(n-i-1-s)!}\\\\\n\\end{aligned}\n\\]</span></p>\n<p>令 <span class=\"math inline\">\\(T=n-i-1\\)</span>，发现我们需要快速计算 <span class=\"math inline\">\\(f_T=\\sum\\limits_{i=0}^T \\dfrac{(i+1)\\cdot (n-i-2)!}{(T-i)!}\\)</span>。记 <span class=\"math inline\">\\(m=n-2\\)</span>，变形得 <span class=\"math inline\">\\(f_T=(m-T)!\\cdot \\sum\\limits_{i=0}^{T} (i+1) \\binom{m-i}{m-T}\\)</span>，发现似乎可以简化，令 <span class=\"math inline\">\\(k=m-T,t=T+1\\)</span>，则 <span class=\"math inline\">\\(f_T=\\sum\\limits_{i=1}^T i\\cdot \\binom {k+t-i}k\\)</span>。</p>\n<p>然后是经典的组合意义保平安环节，即从 <span class=\"math inline\">\\(k+t\\)</span> 个有标号小球中选择一条分界线，分界线左边选一个球、右边选 <span class=\"math inline\">\\(k\\)</span> 个球的方案数。发现分界线的存在很诡异，故用分界线后方的第一个球代替，在 <span class=\"math inline\">\\(t+1\\)</span> 处新建一个虚球，规定在前 <span class=\"math inline\">\\(t+1\\)</span> 个球中选两个球，并令后一个为分界线，且令前 <span class=\"math inline\">\\(t+1\\)</span> 个中的其他球为实球，就能建立双射。在分界线后再选 <span class=\"math inline\">\\(k\\)</span> 个球，容易发现直接在范围内选 <span class=\"math inline\">\\(k+2\\)</span> 个球就能满足条件，故 <span class=\"math inline\">\\(f_T=(n-T-2)!\\cdot \\binom{t+k+1}{k+2}\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;mozi.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;mozi.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1), f(n + 1);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[n] = qkp(fac[n], mod - 2);\n    for (int i = n - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    int m = n - 2;\n    for (int T = 0; T &lt;= n - 2; ++T) &#123;\n        int k = m - T, t = T + 1;\n        f[T] = C(t + k + 1, k + 2) * fac[m - T] % mod;\n    &#125;\n    auto res = 0ll;\n    for (int i = 1; i &lt;= n - 1; ++i)\n        (res += (long long)i * (i + n + 1) % mod * fac[n - i] % mod * f[n - i - 1] % mod) %= mod;\n    std::cout &lt;&lt; res * inv[2] % mod &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---destruction-of-walls\">C - Destruction of Walls</h2>\n<p><a href=\"https://atcoder.jp/contests/arc203/tasks/arc203_c\" class=\"uri\">https://atcoder.jp/contests/arc203/tasks/arc203_c</a></p>\n<hr />\n<h2 id=\"d---insert-xor\">D - Insert XOR</h2>\n<p><a href=\"https://atcoder.jp/contests/arc203/tasks/arc203_d\" class=\"uri\">https://atcoder.jp/contests/arc203/tasks/arc203_d</a></p>\n<hr />\n<h2 id=\"a---记忆\">A - 记忆</h2>\n<p><a href=\"https://ac.nowcoder.com/acm/problem/274793\" class=\"uri\">https://ac.nowcoder.com/acm/problem/274793</a></p>\n<p>需要意识到问题是静态的，并且不能用线段树之类维护；故考虑离线下来，想办法在 LCA 处统计答案。</p>\n<p>这个时候发现需要合并子树状态、整体异或、整体 +1，很容易想到 Trie。把 <span class=\"math inline\">\\(u\\to\\)</span> LCA 的答案保存在 LCA 处，然后再用 DFS + 回溯统计 LCA <span class=\"math inline\">\\(\\to v\\)</span> 的答案。想了半天没想到把上下拆开来做也是神了 😅</p>\n<p>可能比较考验对字典树的理解？做个比喻，字典树的 id 就相当于对这个点上信息的『引用』。</p>\n<details>\n<p>字典树合并的时候可以考虑回收废弃点，不然可能有点卡。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int X = 50;\nconst int maxn = 2e7 + 5;\nlong long d[maxn];\nint tot, T[maxn][2], f[maxn], fa[maxn];\n#define lc(p) T[p][0]\n#define rc(p) T[p][1]\nint find(int x) &#123; return x == f[x] ? x : f[x] = find(f[x]); &#125;\nint newnode(void) &#123;\n    int p = ++tot;\n    assert(p &lt; maxn);\n    d[p] = lc(p) = rc(p) = 0, f[p] = p;\n    return p;\n&#125;\nvoid pushdown(int p) &#123;\n    if (d[p]) &#123;\n        if (d[p] &amp; 1)\n            std::swap(lc(p), rc(p));\n        d[p] &gt;&gt;= 1;\n        if (lc(p))\n            d[lc(p)] ^= d[p];\n        if (rc(p))\n            d[rc(p)] ^= d[p];\n        d[p] = 0;\n    &#125;\n    return;\n&#125;\nint ins(int p, long long x) &#123;\n    for (int i = 0; i &lt; X; ++i) &#123;\n        pushdown(p);\n        if (!T[p][(x &gt;&gt; i) &amp; 1]) &#123;\n            T[p][(x &gt;&gt; i) &amp; 1] = newnode();\n            fa[T[p][(x &gt;&gt; i) &amp; 1]] = p;\n        &#125;\n        p = T[p][(x &gt;&gt; i) &amp; 1];\n    &#125;\n    return p;\n&#125;\nvoid merge(int &amp;p, int q) &#123;\n    if (!q)\n        return;\n    if (!p) &#123;\n        p = q;\n        return;\n    &#125;\n    pushdown(p), pushdown(q);\n    fa[lc(q)] = p, fa[rc(q)] = p;\n    merge(lc(p), lc(q)), merge(rc(p), rc(q));\n    assert(f[p] == p), assert(f[q] == q), f[q] = p;\n    return;\n&#125;\nlong long ask(int p) &#123;\n    std::vector&lt;int&gt; st;\n    for (int i = 0, j = p; i &lt; X; ++i)\n        st.push_back(fa[j]), j = fa[j];\n    for (int i = 0; i &lt; X; ++i)\n        pushdown(st.back()), st.pop_back();\n    long long x = 0;\n    for (int i = 0; i &lt; X; ++i) &#123;\n        x = x * 2 + (p == rc(fa[p]));\n        p = fa[p];\n    &#125;\n    return x;\n&#125;\nvoid add(int p) &#123;\n    for (int i = 0; p &amp;&amp; i &lt; X; ++i) &#123;\n        pushdown(p);\n        std::swap(lc(p), rc(p));\n        p = lc(p);\n    &#125;\n    return;\n&#125;\nvoid del(int p) &#123;\n    for (int i = 0; p &amp;&amp; i &lt; X; ++i) &#123;\n        pushdown(p);\n        std::swap(lc(p), rc(p));\n        p = rc(p);\n    &#125;\n    return;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; siz(n + 1), son(n + 1), top(n + 1), fa(n + 1), dep(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        siz[x] = 1;\n        for (auto i : g[x])\n            if (i != fa[x]) &#123;\n                dep[i] = dep[x] + 1;\n                fa[i] = x, DFS(i);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1);\n    DFS = [&amp;](int x) &#123;\n        if (son[x])\n            top[son[x]] = top[x], DFS(son[x]);\n        for (auto i : g[x])\n            if (i != son[x] &amp;&amp; i != fa[x])\n                top[i] = i, DFS(i);\n        return;\n    &#125;;\n    top[1] = 1, DFS(1);\n    auto askLCA = [&amp;](int x, int y) &#123;\n        for (; top[x] != top[y]; x = fa[top[x]])\n            if (dep[top[x]] &lt; dep[top[y]])\n                std::swap(x, y);\n        return dep[x] &lt; dep[y] ? x : y;\n    &#125;;\n    struct node &#123; long long x; int u, v; &#125;;\n    std::vector&lt;node&gt; q(m + 1);\n    std::vector&lt;int&gt; id(m + 1);\n    std::vector&lt;long long&gt; res(m + 1), ans(m + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; up(n + 1), dn(n + 1), ed(n + 1);\n    for (int i = 1, x, u, v; i &lt;= m; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; u &gt;&gt; v;\n        q[i] = &#123; x, u, v &#125;;\n        up[u].push_back(i), dn[askLCA(u, v)].push_back(i), ed[v].push_back(i);\n    &#125;\n    std::vector&lt;int&gt; rt(n + 1);\n    DFS = [&amp;](int x) &#123;\n        rt[x] = newnode();\n        for (auto i : g[x])\n            if (i != fa[x]) &#123;\n                DFS(i);\n                merge(rt[x], rt[i]);\n            &#125;\n        add(rt[x]);\n        for (auto i : up[x])\n            id[i] = ins(rt[x], q[i].x);\n        d[rt[x]] ^= a[x];\n        for (auto i : dn[x])\n            res[i] = ask(find(id[i]));\n        return;\n    &#125;;\n    DFS(1);\n    tot = 0, rt[0] = newnode();\n    std::fill(id.begin() + 1, id.end(), 0);\n    DFS = [&amp;](int x) &#123;\n        d[rt[0]] ^= a[x];\n        for (auto i : dn[x])\n            id[i] = ins(rt[0], res[i]);\n        for (auto i : ed[x])\n            ans[i] = ask(id[i]);\n        add(rt[0]);\n        for (auto i : g[x])\n            if (i != fa[x])\n                DFS(i);\n        del(rt[0]);\n        d[rt[0]] ^= a[x];\n        return;\n    &#125;;\n    DFS(1);\n    for (int i = 1; i &lt;= m; ++i)\n        std::cout &lt;&lt; ans[i] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---ビーバーの会合-2-meetings-2\">B - ビーバーの会合 2 (Meetings 2)</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_joisc2021_j\" class=\"uri\">https://www.luogu.com.cn/problem/AT_joisc2021_j</a></p>\n<p>定义所求点为『局部重心』；类似树的重心，容易发现当关键点数量为奇时，只存在一个局部重心；否则，局部重心组成一条链。</p>\n<p>即对于每一个 <span class=\"math inline\">\\(i\\)</span>，需要找到一条最长链，使得其两端存在大小为 <span class=\"math inline\">\\(i\\)</span> 的子树（容易发现取后缀 max 即可得到真实答案）。使用点分治，精细实现容易做到 <span class=\"math inline\">\\(O(n\\log n)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; mx(n + 1), siz(n + 1), p, tag(n + 1), res(n + 1, 1);\n    std::function&lt;void(int, int)&gt; DFS1 = [&amp;](int x, int fa) &#123;\n        p.push_back(x);\n        siz[x] = 1, mx[x] = 0;\n        for (auto i : g[x])\n            if (!tag[i] &amp;&amp; i != fa) &#123;\n                DFS1(i, x);\n                siz[x] += siz[i];\n                mx[x] = std::max(mx[x], siz[i]);\n            &#125;\n        return;\n    &#125;;\n    auto findrt = [&amp;](int x) &#123;\n        p.clear(), DFS1(x, -1);\n        int n = (int)p.size();\n        for (auto i : p)\n            if (mx[i] &lt;= n / 2 &amp;&amp; n - siz[i] &lt;= n / 2)\n                return i;\n        assert(0);\n        return -1;\n    &#125;;\n    struct node &#123;\n        int u1, u2, id1, id2;\n        node(): u1(0), u2(0), id1(0), id2(0) &#123;&#125;\n        void upd(int u, int id) &#123;\n            if (id1 == id)\n                u1 = std::max(u1, u);\n            else if (u &gt;= u1)\n                u2 = u1, id2 = id1, u1 = u, id1 = id;\n            else if (u &gt;= u2)\n                u2 = u, id2 = id;\n            return;\n        &#125;\n    &#125;;\n    std::vector&lt;node&gt; s(n + 1);\n    std::function&lt;void(int, int, int, int)&gt; DFS2 = [&amp;](int x, int fa, int dep, int anc) &#123;\n        s[siz[x]].upd(dep, anc);\n        for (auto i : g[x])\n            if (!tag[i] &amp;&amp; i != fa)\n                DFS2(i, x, dep + 1, anc);\n        return;\n    &#125;;\n    std::function&lt;void(int, int, int, int)&gt; DFS3 = [&amp;](int x, int fa, int dep, int anc) &#123;\n        int v = ((s[siz[x]].id1 == anc) ? s[siz[x]].u2 : s[siz[x]].u1);\n        res[2 * siz[x]] = std::max(res[2 * siz[x]], dep + 1 + v);\n        for (auto i : g[x])\n            if (!tag[i] &amp;&amp; i != fa)\n                DFS3(i, x, dep + 1, anc);\n        return;\n    &#125;;\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        x = findrt(x), p.clear(), DFS1(x, -1);\n        // printf(&quot;rt = %d\\n&quot;, x);\n        for (auto i : g[x])\n            if (!tag[i])\n                DFS2(i, x, 1, i);\n        for (int i = siz[x] - 1; i; --i) &#123;\n            s[i].upd(s[i + 1].u1, s[i + 1].id1);\n            s[i].upd(s[i + 1].u2, s[i + 1].id2);\n        &#125;\n        for (auto i : g[x])\n            if (!tag[i])\n                DFS3(i, x, 1, i);\n        tag[x] = 1;\n        for (int i = 1; i &lt; siz[x]; ++i)\n            s[i] = node();\n        for (auto i : g[x])\n            if (!tag[i])\n                DFS(i);\n        return;\n    &#125;;\n    DFS(1);\n    for (int i = (n &gt;&gt; 1) * 2; i; --i)\n        if (i + 2 &lt;= n)\n            res[i] = std::max(res[i], res[i + 2]);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---the-closest-pair\">C - The Closest Pair</h2>\n<p><a href=\"https://ac.nowcoder.com/acm/problem/262593\" class=\"uri\">https://ac.nowcoder.com/acm/problem/262593</a></p>\n<p><strong>常规方法</strong>：考虑<strong>支配对</strong>，对于每个 <span class=\"math inline\">\\(a_i\\)</span>，找到所有合法的 <span class=\"math inline\">\\(a_j\\)</span>。容易想到枚举 <span class=\"math inline\">\\(a_i\\div a_j\\)</span> 来做；假设存在 <span class=\"math inline\">\\(a_k\\div a_i=a_j\\div a_i\\)</span> 且 <span class=\"math inline\">\\(k&gt;j\\)</span>。</p>\n<p>不妨设 <span class=\"math inline\">\\(a_j=K\\cdot a_i+p,a_k=K\\cdot a_i+q\\)</span>，<span class=\"math inline\">\\((a_i,a_j),(a_i,a_k)\\)</span> 均合法当且仅当下列条件全部成立：</p>\n<ul>\n<li><span class=\"math inline\">\\(a_j\\bmod a_i&gt;a_k\\bmod a_i\\)</span>； 则 <span class=\"math inline\">\\(a_j&gt;a_k\\)</span>。</li>\n<li><span class=\"math inline\">\\(a_j\\bmod a_k&gt;a_k\\bmod a_i\\)</span>；又 <span class=\"math inline\">\\(p-q\\ge a_j\\bmod a_k\\)</span>（<strong>太牛了这一步</strong>），即 <span class=\"math inline\">\\(p-q&gt;q\\iff p&gt;2q\\)</span>。</li>\n</ul>\n<p>证得只关心同一个 <span class=\"math inline\">\\(a_j\\div a_i\\)</span> 时的支配对数量为 <span class=\"math inline\">\\(\\log n\\)</span> 级别；总对数 <span class=\"math inline\">\\(O(n\\log n\\ln n)\\)</span>。离线下来扫描线就行了。</p>\n<details>\n<p>对着 单点修改 区间最值 想了 1h 的单 log 做法 😰 果然小脑掉线太可怕了，第二天早上重置大脑 1s 发现自己是斯波 😓</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int LEN = (1 &lt;&lt; 20);\nint nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF;\n        p = buf;\n    &#125;\n    return *p++;\n&#125;\nbool read(int &amp;x) &#123;\n    x = 0;\n    bool f = 0;\n    char ch = nec();\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nvoid print(int x) &#123;\n    if (x &lt; 0)\n        putchar(&#39;-&#39;), x = -x;\n    if (x &gt;= 10) print(x / 10);\n    putchar(x % 10 + &#39;0&#39;);\n    return;\n&#125;\nvoid print(int x, char ch) &#123;\n    print(x), putchar(ch);\n    return;\n&#125;\nconst int maxn = 4e6 + 5;\nstruct &#123; int l, r, u[2]; &#125; t[maxn];\n#define lt (t[p].l)\n#define rt (t[p].r)\nint tot[2];\nvoid add(int &amp;p, int l, int r, int x, int v, int i) &#123;\n    if (!p)\n        p = ++tot[i], t[p].u[0] = -1, t[p].u[1] = 0x3f3f3f3f;\n    if (i == 0)\n        t[p].u[0] = std::max(t[p].u[0], v);\n    else\n        t[p].u[1] = std::min(t[p].u[1], v);\n    if (l == r)\n        return;\n    int mid = (l + r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        add(lt, l, mid, x, v, i);\n    else\n        add(rt, mid + 1, r, x, v, i);\n    return;\n&#125;\nint ask(int p, int l, int r, int ql, int qr, int i) &#123;\n    if (!p || (ql &lt;= l &amp;&amp; r &lt;= qr))\n        return t[p].u[i];\n    int mid = (l + r) &gt;&gt; 1;\n    if (qr &lt;= mid)\n        return ask(lt, l, mid, ql, qr, i);\n    if (ql &gt; mid)\n        return ask(rt, mid + 1, r, ql, qr, i);\n    if (i == 0)\n        return std::max(ask(lt, l, mid, ql, qr, 0), ask(rt, mid + 1, r, ql, qr, 0));\n    return std::min(ask(lt, l, mid, ql, qr, 1), ask(rt, mid + 1, r, ql, qr, 1));\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifndef ONLINE_JUDGE\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    const int m = 1e6;\n    int rt[2] = &#123; 0 &#125;, n;\n    t[0].u[0] = -1, t[0].u[1] = 0x3f3f3f3f;\n    read(n);\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        read(a[i]);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; t(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        if (i != 1) &#123;\n            for (int K = a[i]; K &lt;= m; K += a[i]) &#123;\n                for (int mx = std::min(a[i] - 1, m - K); ; ) &#123;\n                    int k = ask(rt[0], 1, m, K, K + mx, 0);\n                    if (k == -1)\n                        break;\n                    t[i].emplace_back(k, a[k] - K);\n                    if (k == 1 || !(a[k] - K))\n                        break;\n                    mx = (a[k] - K - 1) / 2;\n                &#125;\n            &#125;\n        &#125;\n        add(rt[0], 1, m, a[i], i, 0);\n    &#125;\n    for (int i = n; i; --i) &#123;\n        if (i != n)\n            for (int K = a[i]; K &lt;= m; K += a[i])\n                for (int mx = std::min(a[i] - 1, m - K); ; ) &#123;\n                    int k = ask(rt[1], 1, m, K, K + mx, 1);\n                    if (k == 0x3f3f3f3f)\n                        break;\n                    t[k].emplace_back(i, a[k] - K);\n                    if (k == n || !(a[k] - K))\n                        break;\n                    mx = (a[k] - K - 1) / 2;\n                &#125;\n        add(rt[1], 1, m, a[i], i, 1);\n    &#125;\n    int q;\n    read(q);\n    std::vector&lt;int&gt; res(q + 1);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; u(n + 1);\n    for (int i = 1, l, r; i &lt;= q; ++i) &#123;\n        read(l), read(r);\n        if (l &gt; r)\n            std::swap(l, r);\n        u[r].emplace_back(l, i);\n    &#125;\n    std::vector&lt;int&gt; bit(n + 1, 0x3f3f3f3f);\n    auto lowbit = [&amp;](int x) &#123; return x &amp; -x; &#125;;\n    auto add = [&amp;](int x, int v) &#123;\n        for (; x &lt;= n; x += lowbit(x))\n            bit[x] = std::min(bit[x], v);\n        return;\n    &#125;;\n    auto ask = [&amp;](int x) &#123;\n        auto res = 0x3f3f3f3f;\n        for (; x; x -= lowbit(x))\n            res = std::min(res, bit[x]);\n        return res;\n    &#125;;\n    for (int r = 1; r &lt;= n; ++r) &#123;\n        for (auto [l, v] : t[r])\n            add(n - l + 1, v);\n        for (auto [l, i] : u[r])\n            res[i] = ask(n - l + 1);\n    &#125;\n    for (int i = 1; i &lt;= q; ++i)\n        print(res[i], &#39;\\n&#39;);\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<p>求支配对的过程也要带 log（线段树），再加上扫描线的 3log，总共是常数比较大的 3log（卡了一个上午的常也是有了）。所以接下来讲解另一种奇技淫巧。</p>\n<p><strong>暴力分治</strong>：注意到对于比较长（<span class=\"math inline\">\\(len&gt; B\\)</span>）的区间，答案比较小；故考虑分治。</p>\n<ul>\n<li>对于长询问（<span class=\"math inline\">\\(len&gt;B\\)</span>），从小到大枚举答案并 check；预处理某个范围（<span class=\"math inline\">\\(V\\)</span>）内的 <span class=\"math inline\">\\(res\\)</span> 出现的所有位置，平衡的时候还要算上调和级数和 bit。</li>\n<li>对于短询问（<span class=\"math inline\">\\(len\\le B\\)</span>），发现每次区间内暴力是 <span class=\"math inline\">\\(O(B^2q)\\)</span> 的；把询问离线下来，精细实现，利用询问的公共部分使得<strong>每一对数只被枚举一次</strong>就能达到 <span class=\"math inline\">\\(O(B^2 + Bq)\\)</span>。</li>\n</ul>\n<p>最优解取 <span class=\"math inline\">\\(B=333,V=483\\)</span>，不自己实现一遍了。</p>\n<hr />\n<h2 id=\"d---仙人掌\">D - 仙人掌</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P3687\" class=\"uri\">https://www.luogu.com.cn/problem/P3687</a></p>\n<p>把边双从图中删除、问题转化为树上<strong>边</strong>不交的链覆盖，使得<strong>所有链长 <span class=\"math inline\">\\(\\ge 2\\)</span></strong> 的方案数。发现由于<strong>边可以不被覆盖</strong>，常规 DP 会使得在父节点处合并时需要额外的数量维，参考树上背包，复杂度 <span class=\"math inline\">\\(O(n^2)\\)</span>。</p>\n<p>思考时会注意到两个限制可以抵消——如果认为长为 <span class=\"math inline\">\\(1\\)</span> 的链就是不被覆盖的边，覆盖所有树边，显然可以建立和合法解的双射。此时合并是非常方便的，注意到每个儿子的系数一定都参与『分步』，只需要求出『分类』的系数。这个可以预处理（和 <a href=\"/20250407/#a.-二分图染色\">二分图染色</a> 这个题有点像），令 <span class=\"math inline\">\\(f_i\\)</span> 表示一个点度数为 <span class=\"math inline\">\\(i\\)</span> 时的答案，参考错排的思路，则 <span class=\"math inline\">\\(i\\)</span> 可以不参与配对，也可以乱选一个点配对，如果选中了已配对的点就令其和 <span class=\"math inline\">\\(i-1\\)</span> 交换，可以建立和合法解的双射。则 <span class=\"math inline\">\\(f_i=f_{i-1}+(n-1)f_{i-2}\\)</span>。</p>\n<p>首先需要 check 原图是否为仙人掌，顺带回忆一下连通性的知识——在 DFS 树上差分，检查是否有边被覆盖两次即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, m;\n        std::cin &gt;&gt; n &gt;&gt; m;\n        std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);\n        for (int x, y; m--; ) &#123;\n            std::cin &gt;&gt; x &gt;&gt; y;\n            g1[x].push_back(y), g1[y].push_back(x);\n        &#125;\n        bool flag = 1;\n        int now = 0, cnt = 0;\n        std::vector&lt;int&gt; st, dfn(n + 1), low(n + 1), col(n + 1), diff(n + 1);\n        std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n            st.push_back(x);\n            dfn[x] = low[x] = ++now;\n            for (auto i : g1[x])\n                if (!dfn[i]) &#123;\n                    // printf(&quot;x = %d, %d -&gt; %d\\n&quot;, x, x, i);\n                    DFS(i, x);\n                    diff[x] += diff[i];\n                    // printf(&quot;x = %d, diff[%d] += diff[%d]\\n&quot;, x, x, i);\n                    low[x] = std::min(low[x], low[i]);\n                &#125;\n                else if (i != fa &amp;&amp; dfn[i] &lt; dfn[x]) &#123;\n                    low[x] = std::min(low[x], dfn[i]);\n                    ++diff[x], --diff[i];\n                    // printf(&quot;x = %d, ++diff[%d], --diff[%d]\\n&quot;, x, x, i);\n                &#125;\n            if (diff[x] &gt;= 2)\n                flag = 0;\n            // printf(&quot;x = %d, diff[%d] = %d\\n&quot;, x, x, diff[x]);\n            if (low[x] == dfn[x]) &#123;\n                ++cnt;\n                for (int p = -1; p != x; ) &#123;\n                    p = st.back(), st.pop_back();\n                    col[p] = cnt;\n                &#125;\n            &#125;\n            return;\n        &#125;;\n        DFS(1, -1);\n        if (!flag) &#123;\n            std::cout &lt;&lt; 0 &lt;&lt; &#39;\\n&#39;;\n            continue;\n        &#125;\n        std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n        for (int i = 1; i &lt;= n; ++i)\n            for (auto j : g1[i])\n                if (col[i] != col[j])\n                    g[i].push_back(j);\n        std::vector&lt;long long&gt; f(n + 1), dp(n + 1);\n        dp[0] = 1ll, dp[1] = 1ll;\n        for (int i = 2; i &lt;= n; ++i)\n            dp[i] = (dp[i - 1] + (i - 1) * dp[i - 2]) % mod;\n        std::vector&lt;int&gt; tag(n + 1);\n        DFS = [&amp;](int x, int fa) &#123;\n            f[x] = 1ll, tag[x] = 1;\n            for (auto i : g[x])\n                if (i != fa) &#123;\n                    DFS(i, x);\n                    (f[x] *= f[i]) %= mod;\n                &#125;\n            (f[x] *= dp[(int)g[x].size()]) %= mod;\n            return;\n        &#125;;\n        auto res(1ll);\n        for (int i = 1; i &lt;= n; ++i)\n            if (!tag[i])\n                DFS(i, -1), (res *= f[i]) %= mod;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<p>E. Many Minimizations 是数学题，跳了。</p>\n<hr />\n<hr />\n<h2 id=\"无名题\">无名题</h2>\n<blockquote>\n<p>背景：给定 <span class=\"math inline\">\\(n,k\\)</span>，对于 <span class=\"math inline\">\\(\\forall\\, 1\\le i\\le n\\)</span>，令 <span class=\"math inline\">\\(a_i=i\\bmod k\\)</span>，问一共有多少个本质不同的子序列？对于 <span class=\"math inline\">\\(k=1,2,\\cdots,n\\)</span> 分别求出答案。</p>\n</blockquote>\n<hr />\n<h2 id=\"maimai\">maimai</h2>\n<p><a href=\"https://ac.nowcoder.com/acm/contest/66112/F\" class=\"uri\">https://ac.nowcoder.com/acm/contest/66112/F</a></p>\n",
            "tags": [
                "字典树",
                "字符串",
                "组合数学",
                "支配对"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250807/",
            "url": "https://xsc062.netlify.app/20250807/",
            "title": "学习笔记：分拆数与 Ferrers 图",
            "date_published": "2025-08-07T08:20:45.000Z",
            "content_html": "<p>需要知道概念和求法，有一定的用处</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"分拆数与互异分拆数\">分拆数与互异分拆数</h2>\n<p>要求：给定一个正整数 <span class=\"math inline\">\\(n\\)</span>，要求将其划分为 <span class=\"math inline\">\\(m\\)</span> 个可重 / 不可重的正整数，问本质不同的方案数。（显然 <span class=\"math inline\">\\(m\\)</span> 与 <span class=\"math inline\">\\(\\sqrt n\\)</span> 同阶。）</p>\n<p>不妨令划分结果单调不降，则有两种 DP 路径：</p>\n<ul>\n<li><p>法一：令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示把 <span class=\"math inline\">\\(i\\)</span> 分成 <span class=\"math inline\">\\(j\\)</span> 个正整数的方案数。</p>\n<ul>\n<li>不可重：考虑将这 <span class=\"math inline\">\\(j\\)</span> 个数减去 <span class=\"math inline\">\\(1\\)</span>。最多一个元素由 <span class=\"math inline\">\\(1\\)</span> 变为 <span class=\"math inline\">\\(0\\)</span>，组数减少 <span class=\"math inline\">\\(1\\)</span>；其他时候还是 <span class=\"math inline\">\\(j\\)</span> 组。故云 <span class=\"math inline\">\\(f_{i,j}=f_{i-j,j-1}+f_{i-j,j}\\)</span>。</li>\n<li>可重：如果存在 <span class=\"math inline\">\\(1\\)</span>，可以删除之然后转移；否则仍整体减 <span class=\"math inline\">\\(1\\)</span> 转移。故曰 <span class=\"math inline\">\\(f_{i,j}=f_{i-1,j-1}+f_{i-j,j}\\)</span>。</li>\n</ul>\n该转移方法唯一性很显然。<strong>注意到第二维只和 <span class=\"math inline\">\\(j,j-1\\)</span> 有关；可以交换前后两维顺序然后滚动。</strong></li>\n<li><p>法二：令 <span class=\"math inline\">\\(n=\\sum a_i\\)</span>，建立 <span class=\"math inline\">\\(a\\)</span> 的差分数组 <span class=\"math inline\">\\(d\\)</span>，则有 <span class=\"math inline\">\\(n=\\sum\\limits_{i=1}^m \\sum\\limits_{j=1}^i c_j=\\sum\\limits_{i=1}^m (n-i+1)\\times a_i\\)</span>。发现 <span class=\"math inline\">\\(a_i\\)</span> 每增大 <span class=\"math inline\">\\(1\\)</span>，答案会增大 <span class=\"math inline\">\\(n-i+1\\)</span>。故转化为『第 <span class=\"math inline\">\\(i\\)</span> 个物品重量为 <span class=\"math inline\">\\(n-i+1\\)</span>』的完全背包。</p>\n<ul>\n<li>不可重：要求每个物品至少选一次。</li>\n<li>可重：无限制。</li>\n</ul>\n<p>该方法唯一性更显然。</p></li>\n</ul>\n<p>复杂度均为 <span class=\"math inline\">\\(O(nm)\\)</span>，即 <span class=\"math inline\">\\(O(V\\sqrt V)\\)</span>。</p>\n<h3 id=\"例sets-of-complementary-sums\">例：Sets of Complementary Sums</h3>\n<p><a href=\"/20250723/#e.-sets-of-complementary-sums\">link</a></p>\n<h2 id=\"ferrers-图\">Ferrers 图</h2>\n<p>将 <span class=\"math inline\">\\(k\\)</span> 个分拆出来的数用横向柱状图表示并单调不增排列，得到 Ferrers 图。</p>\n<figure>\n<img src=\"image-1.png\" alt=\"例：12=5+4+2+1 的 Ferrers 图（图源 OI Wiki）\" /><figcaption>例：<span class=\"math inline\">\\(12=5+4+2+1\\)</span> 的 Ferrers 图（图源 OI Wiki）</figcaption>\n</figure>\n<p>将图像斜向翻折得到一组共轭解，原图中的 <span class=\"math inline\">\\(k\\)</span> 即为共轭解中的元素最值。故亦可限定分拆结果的最值为 <span class=\"math inline\">\\(k\\)</span>，则结果仍为 <span class=\"math inline\">\\(f_{n,k}\\)</span>。同时适用于分拆数与互异分拆数。</p>\n<p>顺带提一嘴杨表：把点替换成 <span class=\"math inline\">\\(1\\sim n\\)</span>，并使得一个点同时大于左侧和上方的值。</p>\n<p>似乎就不是很有用了。计数题可能会考。</p>\n",
            "tags": [
                "DP"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250805/",
            "url": "https://xsc062.netlify.app/20250805/",
            "title": "状压 DP",
            "date_published": "2025-08-05T06:33:55.000Z",
            "content_html": "<p>没补完（1/3），动作还是太慢了</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a---只不过是长的领带-2-just-long-neckties-2\">A - 只不过是长的领带 2 / Just Long Neckties 2</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P11665\" class=\"uri\">https://www.luogu.com.cn/problem/P11665</a></p>\n<p>需要观察到，任意时刻 <span class=\"math inline\">\\(B\\)</span> 中不存在重复元素。把 <span class=\"math inline\">\\(B\\)</span> 压出来，令 <span class=\"math inline\">\\(f_{i,S}\\)</span> 表示选了 <span class=\"math inline\">\\(i\\)</span>，当前 <span class=\"math inline\">\\(B\\)</span> 为 <span class=\"math inline\">\\(S\\)</span> 是否可行，能够 <span class=\"math inline\">\\(O(n\\cdot 2^V)\\)</span>。对于某个 <span class=\"math inline\">\\(S\\)</span>，只关心它最远能到达哪个 <span class=\"math inline\">\\(i\\)</span>，故令 <span class=\"math inline\">\\(f_S\\)</span> 记录之。对于每一个 <span class=\"math inline\">\\(S\\)</span>，都可以找到 <span class=\"math inline\">\\(f_S\\)</span> 后第一对 <span class=\"math inline\">\\(a_i,a_{i+1}\\notin S\\)</span>，用其刷表。</p>\n<p>发现『找 <span class=\"math inline\">\\(f_S\\)</span> 后第一对非法元素』是很慢的，考虑优化；对于每个 <span class=\"math inline\">\\(i\\)</span> 维护 <span class=\"math inline\">\\(p\\)</span> 在其后第一次出现的位置 <span class=\"math inline\">\\(x\\)</span>，对于每个 <span class=\"math inline\">\\(a_x=p\\)</span> 维护 <span class=\"math inline\">\\(x\\)</span> 后方 <span class=\"math inline\">\\(a_y=p,a_{y+1}=q\\)</span> 第一次出现的位置，相当于<strong>先找 <span class=\"math inline\">\\(p\\)</span> 再找 <span class=\"math inline\">\\((p,q)\\)</span></strong>，就可以做到 <span class=\"math inline\">\\(O(V^2\\cdot 2^V+n\\cdot V)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1);\n    int V = 0;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        V = std::max(V, a[i]--);\n    &#125;\n    std::vector&lt;std::vector&lt;int&gt; &gt; tx(n + 1, std::vector&lt;int&gt; (V)), ty(n + 1, std::vector&lt;int&gt; (V));\n    std::vector&lt;int&gt; lp(V);\n    std::vector&lt;std::vector&lt;int&gt; &gt; lpq(V, std::vector&lt;int&gt; (V));\n    for (int i = n; ~i; --i) &#123;\n        if (i &amp;&amp; i != n)\n            lpq[a[i]][a[i + 1]] = i;\n        for (int j = 0; j &lt; V; ++j) &#123;\n            tx[i][j] = lp[j];\n            if (i != n)\n                ty[i][j] = lpq[a[i]][j];\n        &#125;\n        if (i != 0)\n            lp[a[i]] = i;\n    &#125;\n    int siz = 1 &lt;&lt; V, res = 21;\n    std::vector&lt;int&gt; f(siz);\n    for (int i = 0; i &lt; siz; ++i) &#123;\n        std::vector&lt;int&gt; p0, p1;\n        for (int j = 0; j &lt; V; ++j)\n            if ((i &gt;&gt; j) &amp; 1)\n                p1.push_back(j);\n            else\n                p0.push_back(j);\n        int j = n;\n        for (auto p : p0)\n            if (tx[f[i]][p])\n                for (auto q : p0)\n                    if (ty[tx[f[i]][p]][q])\n                        j = std::min(j, ty[tx[f[i]][p]][q]);\n        if (j != n) &#123;\n            f[i ^ (1 &lt;&lt; a[j])] = std::max(f[i ^ (1 &lt;&lt; a[j])], j);\n            f[i ^ (1 &lt;&lt; a[j + 1])] = std::max(f[i ^ (1 &lt;&lt; a[j + 1])], j + 1);\n            for (auto k : p1) &#123;\n                f[i ^ (1 &lt;&lt; k) ^ (1 &lt;&lt; a[j])] = std::max(f[i ^ (1 &lt;&lt; k) ^ (1 &lt;&lt; a[j])], j);\n                f[i ^ (1 &lt;&lt; k) ^ (1 &lt;&lt; a[j + 1])] = std::max(f[i ^ (1 &lt;&lt; k) ^ (1 &lt;&lt; a[j + 1])], j + 1);\n            &#125;\n        &#125;\n        else\n            res = std::min(res, __builtin_popcount(i));\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---cut-and-reorder\">B - Cut and Reorder</h2>\n<p><a href=\"https://atcoder.jp/contests/abc328/tasks/abc328_g\" class=\"uri\">https://atcoder.jp/contests/abc328/tasks/abc328_g</a></p>\n<p>不妨先重排再修改，令 <span class=\"math inline\">\\(f_{i,S}\\)</span> 表示已经重排好新序列的前 <span class=\"math inline\">\\(i\\)</span> 个元素，对应原序列状态 <span class=\"math inline\">\\(S\\)</span> 的最小代价。枚举新区间容易转移。可以发现枚举 <span class=\"math inline\">\\(i,S\\)</span> 的实际复杂度为 <span class=\"math inline\">\\(O(2^n)\\)</span>（空间也可以这么优化），预处理之后总时间复杂度 <span class=\"math inline\">\\(O(n^2\\cdot 2^n)\\)</span>，跑不满，可以通过。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst long long inf = 1e18;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    long long c;\n    std::cin &gt;&gt; n &gt;&gt; c;\n    std::vector&lt;long long&gt; a(n), b(n);\n    for (int i = 0; i &lt; n; ++i)\n        std::cin &gt;&gt; a[i];\n    for (int i = 0; i &lt; n; ++i)\n        std::cin &gt;&gt; b[i];\n    using arr = std::vector&lt;long long&gt;;\n    using brr = std::vector&lt;arr&gt;;\n    using crr = std::vector&lt;brr&gt;;\n    brr p(n, arr(n));\n    crr g(n, brr(n, arr(n)));\n    for (int l = 0; l &lt; n; ++l)\n        for (int r = l; r &lt; n; ++r) &#123;\n            for (int k = l; k &lt;= r; ++k)\n                p[l][r] ^= (1 &lt;&lt; k);\n            for (int R = r - l; R &lt; n; ++R)\n                for (int L = R, j = r; j &gt;= l; --L, --j)\n                    g[l][r][R] += std::abs(b[L] - a[j]);\n        &#125;\n    int siz = 1 &lt;&lt; n;\n    std::vector&lt;long long&gt; f(siz, inf);\n    f[0] = 0ll;\n    for (int j = 1; j &lt; siz; ++j) &#123;\n        int i = __builtin_popcount(j) - 1;\n        for (int r = 0; r &lt; n; ++r)\n            for (int l = r; ~l &amp;&amp; ((j &gt;&gt; l) &amp; 1); --l)\n                f[j] = std::min(f[j], f[j ^ p[l][r]] + g[l][r][i] + c);\n    &#125;\n    std::cout &lt;&lt; f[siz - 1] - c &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---electric-circuit\">C - Electric Circuit</h2>\n<p><a href=\"https://atcoder.jp/contests/abc321/tasks/abc321_g\" class=\"uri\">https://atcoder.jp/contests/abc321/tasks/abc321_g</a></p>\n<p>很像<a href=\"/20250430/#有标号无向图计数\">无向图容斥</a>？令 <span class=\"math inline\">\\(f_S\\)</span> 表示让 <span class=\"math inline\">\\(S\\)</span> 内部完成配对，可以不连通的方案数，那么当且仅当 <span class=\"math inline\">\\(S\\)</span> 内部点出、入度之和相等（记为 <span class=\"math inline\">\\(cnt\\)</span>）时，<span class=\"math inline\">\\(f_S\\)</span> 有值 <span class=\"math inline\">\\(cnt!\\)</span>。相似地，设 <span class=\"math inline\">\\(g_S\\)</span> 表示让 <span class=\"math inline\">\\(S\\)</span> 完成配对，成为一个连通块的方案数，得到 <span class=\"math inline\">\\(g_S=f_S-\\sum\\limits_{v\\in S} f_{S\\oplus v}\\cdot g_v\\)</span>。让 <span class=\"math inline\">\\(v\\)</span> 必须包含 <span class=\"math inline\">\\(S\\)</span> 中编号最小的点就可以去重。</p>\n<p>从贡献的角度出发，<span class=\"math inline\">\\(S\\)</span> 带来的贡献就是 <span class=\"math inline\">\\(g_S\\cdot f_{U\\oplus S}\\)</span>，其中 <span class=\"math inline\">\\(U\\)</span> 是全集。最后除以 <span class=\"math inline\">\\(M!\\)</span> 求出期望。</p>\n<p>复杂度 <span class=\"math inline\">\\(O(3^n)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;int&gt; ci(n), co(n);\n    for (int i = 1, x; i &lt;= m; ++i)\n        std::cin &gt;&gt; x, ++ci[x - 1];\n    for (int i = 1, x; i &lt;= m; ++i)\n        std::cin &gt;&gt; x, ++co[x - 1];\n    std::vector&lt;long long&gt; fac(m + 1);\n    fac[0] = 1ll;\n    for (int i = 1; i &lt;= m; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    int siz = 1 &lt;&lt; n;\n    std::vector&lt;long long&gt; f(siz), g(siz);\n    for (int i = 1; i &lt; siz; ++i) &#123;\n        int si = 0, so = 0;\n        for (int j = 0; j &lt; n; ++j)\n            if ((i &gt;&gt; j) &amp; 1)\n                si += ci[j], so += co[j];\n        if (si == so)\n            f[i] = fac[si];\n    &#125;\n    auto res(0ll);\n    for (int i = 1; i &lt; siz; ++i) &#123;\n        g[i] = f[i];\n        int mn = 0;\n        for (int j = 0; j &lt; n; ++j)\n            if ((i &gt;&gt; j) &amp; 1) &#123;\n                mn = j;\n                break;\n            &#125;\n        int s = i ^ (1 &lt;&lt; mn);\n        (g[i] += mod - g[1 &lt;&lt; mn] * f[s] % mod) %= mod;\n        for (int j = (s - 1) &amp; s; j; j = (j - 1) &amp; s)\n            (g[i] += mod - g[j ^ (1 &lt;&lt; mn)] * f[s ^ j] % mod) %= mod;\n        if (i != siz - 1)\n            (res += g[i] * f[(siz - 1) ^ i]) %= mod;\n        else\n            (res += g[i]) %= mod;\n    &#125;\n    std::cout &lt;&lt; res * qkp(fac[m], mod - 2) % mod &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d---count-grid-3-coloring\">D - Count Grid 3-coloring</h2>\n<p><a href=\"https://atcoder.jp/contests/abc379/tasks/abc379_g\" class=\"uri\">https://atcoder.jp/contests/abc379/tasks/abc379_g</a></p>\n<p>轮廓线 DP。把每一列已经确定的最靠下的元素压起来，每行逐个确定即可。</p>\n<p>发现有效状态中只能容许最多一对相邻相同元素，这样复杂度就能降下来了。注意特判 <span class=\"math inline\">\\(1\\times 1\\)</span> 的情况。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::array&lt;int, 15&gt; p;\n    p[0] = 1;\n    for (int i = 1; i &lt; 15; ++i)\n        p[i] = p[i - 1] * 3;\n    std::vector&lt;std::vector&lt;int&gt; &gt; a;\n    if (n &gt;= m) &#123;\n        a.assign(n + 1, std::vector&lt;int&gt; (m + 1));\n        for (int i = 1; i &lt;= n; ++i) \n            for (int j = 1; j &lt;= m; ++j) &#123;\n                char t;\n                std::cin &gt;&gt; t, a[i][j] = (t == &#39;?&#39; ? -1 : t - &#39;1&#39;);\n            &#125;\n    &#125;\n    else &#123;\n        std::swap(n, m);\n        a.assign(n + 1, std::vector&lt;int&gt; (m + 1));\n        for (int i = 1; i &lt;= m; ++i)\n            for (int j = 1; j &lt;= n; ++j) &#123;\n                char t;\n                std::cin &gt;&gt; t, a[j][i] = (t == &#39;?&#39; ? -1 : t - &#39;1&#39;);\n            &#125;\n    &#125;\n    int siz = p[m];\n    using arr = std::vector&lt;long long&gt;;\n    using brr = std::vector&lt;arr&gt;;\n    using crr = std::vector&lt;brr&gt;;\n    std::vector&lt;int&gt; s, tab(siz, -1);\n    auto getv_1 = [&amp;](int j, int i) &#123;\n        return (j / p[i - 1]) % 3;\n    &#125;;\n    auto getv = [&amp;](int j, int i) &#123;\n        return (s[j] / p[i - 1]) % 3;\n    &#125;;\n    auto chg = [&amp;](int j, int i, int v) &#123;\n        return tab[s[j] - p[i - 1] * getv(j, i) + p[i - 1] * v];\n    &#125;;\n    auto out = [&amp;](int i) &#123;\n        std::string s;\n        for (int j = 1; j &lt;= m; ++j)\n            s += &#39;1&#39; + getv_1(i, j);\n        return s.c_str();\n    &#125;;\n    for (int i = 0; i &lt; siz; ++i) &#123;\n        s.push_back(i);\n        int cnt = 0;\n        for (int j = 2; j &lt;= m; ++j)\n            if (getv_1(i, j - 1) == getv_1(i, j) &amp;&amp; ++cnt &gt;= 2) &#123;\n                s.pop_back();\n                break;\n            &#125;\n    &#125;\n    for (int i = 0; i &lt; (int)s.size(); ++i)\n        tab[s[i]] = i;\n    siz = (int)s.size();\n    if (n == 1) &#123;\n        std::cout &lt;&lt; (a[1][1] == -1 ? 3 : 1) &lt;&lt; &#39;\\n&#39;;\n        return 0;\n    &#125;\n    crr f(n + 1, brr(m + 1, arr(siz)));\n    for (int i = 0; i &lt; siz; ++i)\n        if ([&amp;](int i, int s) &#123;\n            for (int j = 1; j &lt;= m; ++j) &#123;\n                if (a[i][j] != -1 &amp;&amp; a[i][j] != getv(s, j))\n                    return false;\n                if (j != 1 &amp;&amp; getv(s, j) == getv(s, j - 1))\n                    return false;\n            &#125;\n            return true;\n        &#125; (1, i)) &#123;\n            for (int p = 0; p &lt; 3; ++p)\n                if ((a[2][1] == -1 || a[2][1] == p) &amp;&amp; getv(i, 1) != p &amp;&amp; ~chg(i, 1, p))\n                    (++f[2][1][chg(i, 1, p)]) %= mod;\n        &#125;\n    for (int i = 2; i &lt;= n; ++i) &#123;\n        for (int k = 1; k &lt; m; ++k)\n            for (int j = 0; j &lt; siz; ++j)\n                if (f[i][k][j]) &#123;\n                    // printf(&quot;f[%d][%d][%s] = %lld\\n&quot;, i, k, out(s[j]), f[i][k][j]);\n                    for (int p = 0; p &lt; 3; ++p)\n                        if ((a[i][k + 1] == -1 || a[i][k + 1] == p) &amp;&amp; getv(j, k) != p &amp;&amp; getv(j, k + 1) != p &amp;&amp; ~chg(j, k + 1, p))\n                            (f[i][k + 1][chg(j, k + 1, p)] += f[i][k][j]) %= mod;\n                &#125;\n        for (int j = 0; j &lt; siz; ++j)\n            if (i != n &amp;&amp; f[i][m][j])\n                for (int p = 0; p &lt; 3; ++p)\n                    if ((a[i + 1][1] == -1 || a[i + 1][1] == p) &amp;&amp; getv(j, 1) != p &amp;&amp; ~chg(j, 1, p))\n                        (f[i + 1][1][chg(j, 1, p)] += f[i][m][j]) %= mod;\n    &#125;\n    auto res = 0ll;\n    for (int i = 0; i &lt; siz; ++i)\n        (res += f[n][m][i]) %= mod;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"e---pure-straight\">E - Pure Straight</h2>\n<p><a href=\"https://atcoder.jp/contests/arc126/tasks/arc126_d\" class=\"uri\">https://atcoder.jp/contests/arc126/tasks/arc126_d</a></p>\n<p>手玩发现只要最终序列确定，那么移动的顺序不影响答案。故考虑确定目标位置和移动序列。考虑绝对值的几何意义，不妨令目标子序列中元素集中到被选中位置的中间元素，此时的代价可以计算。用点二进制技巧和库函数可以 <span class=\"math inline\">\\(O(1)\\)</span> 算代价。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    int siz = 1 &lt;&lt; k;\n    std::vector&lt;int&gt; a(n + 1), f(siz, 0x3f3f3f3f);\n    auto out = [&amp;](int j) &#123;\n        std::string s;\n        for (int i = 0; i &lt; k; ++i)\n            s += (&#39;0&#39; + ((j &gt;&gt; i) &amp; 1));\n        return s.c_str();\n    &#125;;\n    f[0] = 0;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i], --a[i];\n        for (int j = siz - 1; j &gt;= 0; --j) &#123;\n            if (!((j &gt;&gt; a[i]) &amp; 1))\n                f[j | (1 &lt;&lt; a[i])] = std::min(f[j | (1 &lt;&lt; a[i])], f[j] + __builtin_popcount(j &amp; (~((1 &lt;&lt; a[i]) - 1))));\n            f[j] += std::min(__builtin_popcount(j), k - __builtin_popcount(j));\n        &#125;\n    &#125;\n    std::cout &lt;&lt; f[siz - 1] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"f---123-set\">F - 123 Set</h2>\n<p><a href=\"https://atcoder.jp/contests/arc184/tasks/arc184_b\" class=\"uri\">https://atcoder.jp/contests/arc184/tasks/arc184_b</a></p>\n<p>做过 <a href=\"https://www.luogu.com.cn/problem/P3226\">集合选数</a>（这个 trick 见过很多次了，应该不只这一道，但我想不起来了）很容易想到画一个表格或者 DAG 出来，其实都能做</p>\n<p>对于表格左上角和 DAG 的源点，肯定是一个 <span class=\"math inline\">\\(x\\)</span>，其不是 <span class=\"math inline\">\\(2\\)</span> 或 <span class=\"math inline\">\\(3\\)</span> 的倍数。如果画表，横乘 3 竖乘 2，观察一下是包含了 <span class=\"math inline\">\\(1\\sim n\\)</span> 恰好一次的很多个杨表（没什么用，提一嘴而已），考虑转化目标，发现是用一个不可旋转的倒 L 形骨牌可叠放地铺满异形表格，可以考虑轮廓线 DP</p>\n<p>具体地，用 1 来表示拐角处，0 表示其他，叠放的时候 1 的优先级比 0 高，然后就可以做了。以 3 为行，悲观估计单个表格大概有 <span class=\"math inline\">\\(31\\times 2^{19}\\)</span> 个状态，运算次数差不多 <span class=\"math inline\">\\(31\\times 19\\times 2^{19}\\)</span>；再发现长得一模一样的表格肯定方案数是一样的，如果把任意一个表格全部除以 <span class=\"math inline\">\\(x\\)</span>，就会得到 <span class=\"math inline\">\\(n=10^9\\div x\\)</span> 时 <span class=\"math inline\">\\(1\\)</span> 为左上角的杨表，就是说长相只和 <span class=\"math inline\">\\(10^9\\div x\\)</span> 的值有关，可以整除分块 😱 可预计的跑得非常不满，实践下来是可以过的（但是很慢）</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    auto calc = [&amp;](int r) &#123;\n        return r - r / 2 - r / 3 + r / 6;\n    &#125;;\n    auto dp = [&amp;](int lim) &#123;\n        if (lim == 1) &#123;\n            // printf(&quot;lim = 1, ret 1&quot;);\n            return 1;\n        &#125;\n        int n = 1, m = 1;\n        for (int k = 1; k * 2 &lt;= lim; ++n, k *= 2);\n        for (int k = 1; k * 3 &lt;= lim; ++m, k *= 3);\n        int siz = 1 &lt;&lt; m;\n        std::vector&lt;std::vector&lt;std::vector&lt;int&gt; &gt; &gt; f(2, std::vector&lt;std::vector&lt;int&gt; &gt; (2, std::vector&lt;int&gt; (siz))), p(n + 1, std::vector&lt;std::vector&lt;int&gt; &gt; (m));\n        std::vector&lt;std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; &gt; t(2, std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; (2, std::vector&lt;std::pair&lt;int, int&gt; &gt; (siz))); // sb\n        auto upd = [&amp;](int i, int k, int j, int v) &#123;\n            if (t[i &amp; 1][k &amp; 1][j] != std::make_pair(i, k)) &#123;\n                p[i][k].push_back(j);\n                t[i &amp; 1][k &amp; 1][j] = &#123; i, k &#125;, f[i &amp; 1][k &amp; 1][j] = v;\n            &#125;\n            else\n                f[i &amp; 1][k &amp; 1][j] = std::min(f[i &amp; 1][k &amp; 1][j], v);\n            return;\n        &#125;;\n        auto chg = [&amp;](int i, int j, int v) &#123;\n            return i ^ (((i &gt;&gt; j) &amp; 1) &lt;&lt; j) ^ (v &lt;&lt; j);\n        &#125;;\n        for (int i = 0; i &lt; siz; ++i) &#123;\n            bool flag = 0;\n            for (int j = 0; j &lt; m; ++j)\n                if (((i &gt;&gt; j) &amp; 1) || (j &amp;&amp; ((i &gt;&gt; (j - 1)) &amp; 1)));\n                else &#123;\n                    flag = 1;\n                    break;\n                &#125;\n            if (!flag)\n                upd(1, m - 1, i, __builtin_popcount(i));\n        &#125;\n        for (int i = 2; i &lt;= n; i++) &#123;\n            int m1 = 1;\n            for (int x = (1 &lt;&lt; (i - 1)); x * 3ll &lt;= lim; ++m1, x *= 3);\n            int siz1 = 1 &lt;&lt; m1;\n            for (auto j : p[i - 1][m - 1]) &#123;\n                if (j &amp; 1)\n                    upd(i, 0, chg(j &amp; (siz1 - 1), 0, 0), f[(i - 1) &amp; 1][(m - 1) &amp; 1][j]);\n                upd(i, 0, chg(j &amp; (siz1 - 1), 0, 1), f[(i - 1) &amp; 1][(m - 1) &amp; 1][j] + 1);\n            &#125;\n            m = m1, siz = siz1;\n            for (int k = 0; k &lt; m - 1; ++k)\n                for (auto j : p[i][k]) &#123;\n                    if (((j &gt;&gt; k) &amp; 1) || ((j &gt;&gt; (k + 1)) &amp; 1))\n                        upd(i, k + 1, chg(j, k + 1, 0), f[i &amp; 1][k &amp; 1][j]);\n                    upd(i, k + 1, chg(j, k + 1, 1), f[i &amp; 1][k &amp; 1][j] + 1);\n                &#125;\n        &#125;\n        int res = 0x3f3f3f3f;\n        for (auto i : p[n][m - 1])\n            res = std::min(res, f[n &amp; 1][(m - 1) &amp; 1][i]);\n        return res;\n    &#125;;\n    int res = 0;\n    for (int l = 1, r; l &lt;= n; l = r + 1) &#123;\n        r = n / (n / l);\n        if (calc(r) - calc(l - 1))\n            res += (calc(r) - calc(l - 1)) * dp(n / l);\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "DP",
                "状压 DP"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250803/",
            "url": "https://xsc062.netlify.app/20250803/",
            "title": "树 DP",
            "date_published": "2025-08-03T03:44:54.000Z",
            "content_html": "<p>树上的 DP 以及 和树有关的 DP</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a---svjetlo\">A - Svjetlo</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P7163\" class=\"uri\">https://www.luogu.com.cn/problem/P7163</a></p>\n<p>很容易想到一种状态设计，即令 <span class=\"math inline\">\\(f_{x,0/1/2}\\)</span> 分别表示有 <span class=\"math inline\">\\(0/1/2\\)</span> 个端点在子树内部的情况；然后就开始思考，如何满足对于开关状态的要求？</p>\n<p>还是想少了。如果再加一维，从『状态为开或关』思考就会轻松很多，令 <span class=\"math inline\">\\(f_{x,0/1/2,0/1}\\)</span> 表示有 <span class=\"math inline\">\\(0/1/2\\)</span> 个端点再子树外部，且子树内操作完后 <span class=\"math inline\">\\(x\\)</span> 为关 / 开的最少步数。然后分类讨论转移方式即可。</p>\n<p>一个比较方便的讨论方式是，先确定某种情况下，访问 <span class=\"math inline\">\\(u\\)</span> 与 <span class=\"math inline\">\\(v\\)</span> 的次数，然后就可以得到它们原本的状态。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, rt = -1;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        char t;\n        std::cin &gt;&gt; t;\n        a[i] = t - &#39;0&#39;;\n        if (!a[i])\n            rt = i;\n    &#125;\n    if (rt == -1) &#123;\n        std::cout &lt;&lt; 0 &lt;&lt; &#39;\\n&#39;;\n        return 0;\n    &#125;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; tag(n + 1);\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        tag[x] = a[x];\n        for (auto i : g[x])\n            if (i != fa)\n                DFS(i, x), tag[x] &amp;= tag[i];\n        return;\n    &#125;;\n    DFS(rt, -1);\n    std::vector&lt;std::vector&lt;std::vector&lt;int&gt; &gt; &gt; f(n + 1, std::vector&lt;std::vector&lt;int&gt; &gt; (3, std::vector&lt;int&gt; (2, 0x3f3f3f3f)));\n    DFS = [&amp;](int x, int fa) &#123;\n        f[x][0][a[x]] = 0;\n        for (auto i : g[x])\n            if (i != fa &amp;&amp; !tag[i]) &#123;\n                DFS(i, x);\n                auto g = f[x];\n                f[x][0][0] = std::min(g[0][0] + f[i][0][1] + 4, g[0][1] + f[i][0][0] + 2);\n                f[x][0][1] = std::min(g[0][1] + f[i][0][1] + 4, g[0][0] + f[i][0][0] + 2);\n                f[x][1][0] = std::min(&#123; g[1][0] + f[i][0][1] + 4, g[1][1] + f[i][0][0] + 2, g[0][0] + f[i][1][0] + 3, g[0][1] + f[i][1][1] + 1 &#125;);\n                f[x][1][1] = std::min(&#123; g[1][1] + f[i][0][1] + 4, g[1][0] + f[i][0][0] + 2, g[0][1] + f[i][1][0] + 3, g[0][0] + f[i][1][1] + 1 &#125;);\n                f[x][2][0] = std::min(&#123; g[2][0] + f[i][0][1] + 4, g[2][1] + f[i][0][0] + 2, g[1][0] + f[i][1][1], g[1][1] + f[i][1][0] + 2, g[0][0] + f[i][2][1] + 4, g[0][1] + f[i][2][0] + 2 &#125;);\n                f[x][2][1] = std::min(&#123; g[2][1] + f[i][0][1] + 4, g[2][0] + f[i][0][0] + 2, g[1][1] + f[i][1][1], g[1][0] + f[i][1][0] + 2, g[0][1] + f[i][2][1] + 4, g[0][0] + f[i][2][0] + 2 &#125;);\n            &#125;\n        f[x][1][0] = std::min(f[x][1][0], f[x][0][1] + 1);\n        f[x][1][1] = std::min(f[x][1][1], f[x][0][0] + 1);\n        f[x][2][0] = std::min(f[x][2][0], f[x][1][0]);\n        f[x][2][1] = std::min(f[x][2][1], f[x][1][1]);\n        // for (int i = 0; i &lt; 3; ++i)\n        //     for (int j = 0; j &lt; 2; ++j)\n        //         printf(&quot;f[%d][%d][%d] = %d\\n&quot;, x, i, j, f[x][i][j]);\n        return;\n    &#125;;\n    DFS(rt, -1);\n    std::cout &lt;&lt; f[rt][2][1] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---one-to-one\">B - One to One</h2>\n<p><a href=\"https://atcoder.jp/contests/arc140/tasks/arc140_d\" class=\"uri\">https://atcoder.jp/contests/arc140/tasks/arc140_d</a></p>\n<p>观察原图上连通块，发现要么是没有未确定边的基环树，要么是有恰好一条未确定边的树。缩点，任意为未确定边赋值，考察最后得到的连通块，发现要么是以『基环树点』为根的树，要么是不包含『基环树点』的（内向）基环树。</p>\n<p>这里要用到贡献的思想。考虑将全局划分为若干个部分，保证每部分的单步价值是可确定的。将第一步，即对树和基环树的讨论拆开，对于树，其数量确定；对于基环树，发现环的数量即为基环树的数量，进一步将所有步中的『环』这一类分开，统计成环的方案数就可以得到基环树的贡献。具体地，令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 为在前 <span class=\"math inline\">\\(i\\)</span> 个点中选择 <span class=\"math inline\">\\(j\\)</span> 个成一个环的方案数，则有：</p>\n<p><span class=\"math display\">\\[\nf_{i,j}=f_{i-1,j}+f_{i-1,j-1}\\times siz_i\n\\]</span></p>\n<p>最后计算每个环的贡献即可。注意还要算上环内部的排列（注意循环位移）。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1), tag(n + 1), s(n + 1, 1), fa(n + 1), siz(n + 1);\n    std::iota(fa.begin() + 1, fa.end(), 1);\n    std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;\n        return x == fa[x] ? x : fa[x] = find(fa[x]);\n    &#125;;\n    auto merge = [&amp;](int x, int y) &#123;\n        x = find(x), y = find(y);\n        if (x != y) &#123;\n            tag[y] += tag[x];\n            s[y] += s[x];\n            fa[x] = y;\n        &#125;\n        return;\n    &#125;;\n    for (int i = 1; i &lt;= n; ++i)  &#123;\n        std::cin &gt;&gt; a[i], fa[i] = i;\n        if (a[i] == -1)\n            tag[i] = 1;\n        else\n            merge(i, a[i]);\n    &#125;\n    int cnt1 = 0, cnt2 = 0;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        cnt1 += (fa[i] == i &amp;&amp; !tag[i]);\n        if (fa[i] == i &amp;&amp; tag[i])\n            siz[++cnt2] = s[i];\n    &#125;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    auto res(cnt1 * qkp(n, cnt2) % mod);\n    std::vector&lt;std::vector&lt;long long&gt; &gt; f(cnt2 + 1, std::vector&lt;long long&gt; (cnt2 + 1));\n    f[0][0] = 1ll;\n    for (int i = 1; i &lt;= cnt2; ++i) &#123;\n        // printf(&quot;i = %d, siz = %d: \\n&quot;, i, siz[i]);\n        for (int j = 0; j &lt;= i; ++j) &#123;\n            f[i][j] = f[i - 1][j];\n            if (j != 0)\n                (f[i][j] += f[i - 1][j - 1] * siz[i]) %= mod;\n            // printf(&quot;  f[%d][%d] = %lld\\n&quot;, i, j, f[i][j]);\n        &#125;\n    &#125;\n    for (int i = 1; i &lt;= cnt2; ++i) &#123;\n        static auto fac(1ll);\n        (res += f[cnt2][i] * fac % mod * qkp(n, cnt2 - i) % mod) %= mod;\n        (fac *= i) %= mod;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---diameter-cuts\">C - Diameter Cuts</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1499/F\" class=\"uri\">https://codeforces.com/problemset/problem/1499/F</a></p>\n<p>令 <span class=\"math inline\">\\(f_{x,i}\\)</span> 表示 <span class=\"math inline\">\\(x\\)</span> 上的最长链长为 <span class=\"math inline\">\\(i\\)</span> 的方案数，就可以用一个类似背包的过程求答案了。发现这个背包满足可以被优化的形式，故能在 <span class=\"math inline\">\\(O(nk)\\)</span> 内解决问题。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k, ++k;\n    if (k == 0) &#123;\n        std::cout &lt;&lt; 1 &lt;&lt; &#39;\\n&#39;;\n        return 0;\n    &#125;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; h(n + 1);\n    std::vector&lt;std::vector&lt;long long&gt; &gt; f(n + 1, std::vector&lt;long long&gt; (k + 1));\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        f[x][1] = 1ll, h[x] = 1;\n        for (auto i : g[x])\n            if (i != fa) &#123;\n                DFS(i, x);\n                std::vector&lt;long long&gt; g(k + 1);\n                g.swap(f[x]);\n                for (int j = std::min(h[x], k); j; --j)\n                    for (int l = std::min(h[i], k - j); ~l; --l)\n                        (f[x][std::max(j, l + 1)] += g[j] * f[i][l] % mod) %= mod;\n                h[x] = std::max(h[x], h[i] + 1);\n            &#125;\n        for (int i = 1; i &lt;= h[x] &amp;&amp; i &lt;= k; ++i)\n            (f[x][0] += f[x][i]) %= mod;\n        // for (int i = 0; i &lt;= h[x] &amp;&amp; i &lt;= k; ++i)\n        //     printf(&quot;f[%d][%d] = %lld\\n&quot;, x, i, f[x][i]);\n        return;\n    &#125;;\n    DFS(1, -1);\n    auto res(0ll);\n    for (int i = 1; i &lt;= k; ++i)\n        (res += f[1][i]) %= mod;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d---leaf-partition\">D - Leaf Partition</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1146/F\" class=\"uri\">https://codeforces.com/problemset/problem/1146/F</a></p>\n<p>假设已经完成分组，欲判定这种方式是否合法，容易想到对每一组叶子建立虚树，则该分组方式合法，当且仅当没有一个点被多个虚树占用。也即，我们需要在总的虚树上选出一些点，让它们可以覆盖所有叶子。</p>\n<p>虚树上 DP，容易发现当且仅当存在 <span class=\"math inline\">\\(\\ge 2\\)</span> 个儿子想要分进同一个虚树时，<span class=\"math inline\">\\(i\\)</span> 会被选到。故令 <span class=\"math inline\">\\(f_{i, 0/1/2}\\)</span> 表示当前有 <span class=\"math inline\">\\(0/1/\\ge 2\\)</span> 个儿子想要选择 <span class=\"math inline\">\\(i\\)</span> 时的方案数，DP 即可。</p>\n<p>在实现的过程中就会发现根本不需要求虚树，原树上 DP 就可以了。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; fa(n + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 2; i &lt;= n; ++i)\n        std::cin &gt;&gt; fa[i], g[fa[i]].push_back(i);\n    std::vector&lt;std::array&lt;long long, 3&gt; &gt; f(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        if (g[x].empty())\n            f[x][2] = 1ll;\n        else\n            f[x][0] = 1ll;\n        for (auto i : g[x]) &#123;\n            DFS(i);\n            auto F0 = (f[i][0] + f[i][2]) % mod, F1 = (f[i][1] + f[i][2]) % mod;\n            f[x][2] = (f[x][2] * F0 % mod + f[x][2] * F1 % mod + f[x][1] * F1 % mod) % mod;\n            f[x][1] = (f[x][1] * F0 % mod + f[x][0] * F1 % mod) % mod;\n            (f[x][0] *= F0) %= mod;\n        &#125;\n        // printf(&quot;%d: %lld / %lld / %lld\\n&quot;, x, f[x][0], f[x][1], f[x][2]);\n        return;\n    &#125;;\n    DFS(1);\n    std::cout &lt;&lt; (f[1][0] + f[1][2]) % mod &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"e---uniformly-branched-trees\">E - Uniformly Branched Trees</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/724/F\" class=\"uri\">https://codeforces.com/problemset/problem/724/F</a></p>\n<p>感觉是很常见的套路，但是我不会 😱</p>\n<p>在手玩样例的时候可以感性认知到，每个树会被每种点作为根的情况统计一次。且如果固定以某种（化学环境）的点为根，可以通过按 siz 从小到大排列唯一求解出该树。</p>\n<p>发现以重心为根（即钦定根为重心）可以带来很多优美的性质。因为 siz 是好确定的，且是儿子的排序依据，所以选重心便于统计，同时满足每种树最多被统计两次（当且仅当有两个重心）。</p>\n<p>发现这就变成了多重集的组合数，设 <span class=\"math inline\">\\(f_{i,j,k}\\)</span> 表示已经花费 <span class=\"math inline\">\\(i\\)</span> 个点组成一个子树，子树的根节点当前已经确认了 <span class=\"math inline\">\\(j\\)</span> 个儿子，最靠右的一个 siz <span class=\"math inline\">\\(\\le k\\)</span> 的方案数。得到 <span class=\"math inline\">\\(f_{i,j,k}=\\sum_{x=0} f_{i-x\\cdot k,j-x,k-1}\\cdot \\binom{f_{k,d-1,k}+x-1}{x}\\)</span>（相当于将 <span class=\"math inline\">\\(x\\)</span> 个无标号的位置 / 球分配给 <span class=\"math inline\">\\(f_{k,d-1,k}\\)</span> 个有标号的选项 / 盒子，插板即可）。</p>\n<p>若 <span class=\"math inline\">\\(n\\)</span> 为奇数，则可直接输出 <span class=\"math inline\">\\(f_{n,d,\\lfloor\\frac n2\\rfloor}\\)</span>；若 <span class=\"math inline\">\\(n\\)</span> 为偶数，则可能存在两个重心，即需要统计拥有两个重心，且以两个重心分别为根时长相不同的树种类。这种情况下显然存在一条边，左右两边 siz 相同且长相不同。故数量为 <span class=\"math inline\">\\(\\binom{f_{\\lfloor \\frac n2\\rfloor, d-1,\\lfloor \\frac n2\\rfloor}}{2}\\)</span>，容斥掉即可。</p>\n<p>需要特判 <span class=\"math inline\">\\(n\\le2\\)</span> 的情况。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, d, mod;\n    std::cin &gt;&gt; n &gt;&gt; d &gt;&gt; mod;\n    if (n &lt;= 2) &#123;\n        std::cout &lt;&lt; 1 &lt;&lt; &#39;\\n&#39;;\n        return 0;\n    &#125;\n    using arr = std::vector&lt;long long&gt;;\n    using brr = std::vector&lt;arr&gt;;\n    using crr = std::vector&lt;brr&gt;;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    arr inv(d + 1);\n    inv[0] = inv[1] = 1ll;\n    auto fac = 1ll;\n    for (int i = 2; i &lt;= d; ++i) &#123;\n        (fac *= i) %= mod;\n        inv[i] = qkp(fac, mod - 2);\n    &#125;\n    auto C = [&amp;](long long n, int m) &#123;\n        if (m == 0)\n            return 1ll;\n        if (m &gt; n)\n            return 0ll;\n        auto res(1ll);\n        for (auto i = 0; i &lt; m; ++i)\n            (res *= n - i) %= mod;\n        return res * inv[m] % mod;\n    &#125;;\n    crr f(n + 1, brr(d + 1, arr(n / 2 + 1)));\n    f[1][0][0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = 0; j &lt;= d &amp;&amp; 1 + j &lt;= i; ++j) &#123;\n            for (int x = 0; x &lt;= j &amp;&amp; x &lt;= i; ++x)\n                f[i][j][1] += f[i - x][j - x][0];\n            f[i][j][1] %= mod;\n            for (int k = 2; k &lt;= n / 2; ++k) &#123;\n                // bool flag = (i == 10 &amp;&amp; j == 3 &amp;&amp; k == 3);\n                for (int x = 0; x &lt;= j &amp;&amp; x * k &lt;= i; ++x) &#123;\n                    f[i][j][k] += f[i - x * k][j - x][k - 1] * C(f[k][d - 1][k - 1] + x - 1, x);\n                    // if (flag)\n                    //     printf(&quot;x = %d, f[%d][%d][%d](%lld) * C(%lld, %d)(%lld)\\n&quot;, x, i - x * k, j - x, k - 1, f[i - x * k][j - x][k - 1], f[k][d - 1][k - 1] + x - 1, x, C(f[k][d - 1][k - 1] + x - 1, x));\n                &#125;\n                f[i][j][k] %= mod;\n            &#125;\n        &#125;\n    // for (int i = 1; i &lt;= n; ++i)\n    //     for (int j = 0; j &lt;= d &amp;&amp; j &lt;= i - 1; ++j, puts(&quot;&quot;))\n    //         for (int k = 0; k &lt;= n / 2; ++k) &#123;\n    //             printf(&quot;f[%d][%d][%d] = %lld\\n&quot;, i, j, k, f[i][j][k]);\n    //         &#125;\n    if (n &amp; 1)\n        std::cout &lt;&lt; f[n][d][n / 2] &lt;&lt; &#39;\\n&#39;;\n    else &#123;\n        auto res(f[n][d][n / 2]);\n        res = (res + mod - C(f[n / 2][d - 1][n / 2 - 1], 2)) % mod;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"a---dominant-indices\">A - Dominant Indices</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1009/F\" class=\"uri\">https://codeforces.com/problemset/problem/1009/F</a></p>\n<p>长剖板子；难点在于可能要复习一下长剖怎么写。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; h(n + 1), son(n + 1);\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        h[x] = 1;\n        for (auto i : g[x])\n            if (i != fa) &#123;\n                DFS(i, x);\n                h[x] = std::max(h[x], h[i] + 1);\n                if (h[i] &gt; h[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1, -1);\n    std::vector&lt;int&gt; _f(2 * n + 1), res(n + 1);\n    auto pos(_f.begin());\n    std::vector&lt;decltype(pos)&gt; f(n + 1);\n    DFS = [&amp;](int x, int fa) &#123;\n        ++f[x][0];\n        if (!son[x]) &#123;\n            res[x] = 0;\n            return;\n        &#125;\n        f[son[x]] = std::next(f[x]);\n        DFS(son[x], x);\n        int mx = -std::max(std::make_pair(f[x][res[son[x]] + 1], -(res[son[x]] + 1)), std::make_pair(1, 0)).second;\n        for (auto i : g[x])\n            if (i != fa &amp;&amp; i != son[x]) &#123;\n                f[i] = pos, pos = std::next(pos, h[i] + 1);\n                DFS(i, x);\n                for (int j = 0; j &lt;= h[i]; ++j) &#123;\n                    f[x][j + 1] += f[i][j];\n                    if (j + 1 != mx &amp;&amp; std::make_pair(f[x][j + 1], -(j + 1)) &gt; std::make_pair(f[x][mx], -mx))\n                        mx = j + 1;\n                &#125;\n            &#125;\n        // printf(&quot;%d: &quot;, x);\n        // for (int i = 0; i &lt;= h[x]; ++i)\n        //     printf(&quot;%d &quot;, f[x][i]);\n        // puts(&quot;&quot;);\n        res[x] = mx;\n        return;\n    &#125;;\n    f[1] = pos, pos = std::next(pos, h[1]);\n    DFS(1, -1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---树上异或\">B - 树上异或</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P9745\" class=\"uri\">https://www.luogu.com.cn/problem/P9745</a></p>\n<p>和 <a href=\"#a---svjetlo\">Svjetlo</a> 很像，把连通块的异或和放到状态里，拆位后令 <span class=\"math inline\">\\(f_{i,j,0/1}\\)</span> 表示点 <span class=\"math inline\">\\(i\\)</span> 所在的连通块在第 <span class=\"math inline\">\\(j\\)</span> 位异或和为 <span class=\"math inline\">\\(0/1\\)</span> 的权值（<strong>不计 <span class=\"math inline\">\\(i\\)</span> 所在连通块</strong>），转移即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;long long&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 2, x; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; x;\n        g[x].push_back(i), g[i].push_back(x);\n    &#125;\n    std::vector&lt;long long&gt; dp(n + 1);\n    std::vector&lt;std::array&lt;std::array&lt;long long, 2&gt;, 60&gt; &gt; f(n + 1);\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        for (int i = 0; i &lt; 60; ++i)\n            f[x][i][(a[x] &gt;&gt; i) &amp; 1] = 1ll;\n        for (auto i : g[x])\n            if (i != fa) &#123;\n                DFS(i, x);\n                for (int j = 0; j &lt; 60; ++j) &#123;\n                    auto f1 = f[x][j];\n                    f[x][j][0] = (f1[0] * dp[i] % mod + f1[0] * f[i][j][0] % mod + f1[1] * f[i][j][1] % mod) % mod;\n                    f[x][j][1] = (f1[1] * dp[i] % mod + f1[0] * f[i][j][1] % mod + f1[1] * f[i][j][0] % mod) % mod;\n                &#125;\n            &#125;\n        for (int i = 0; i &lt; 60; ++i)\n            dp[x] += (1ll &lt;&lt; i) % mod * f[x][i][1] % mod;\n        dp[x] %= mod;\n        return;\n    &#125;;\n    DFS(1, -1);\n    std::cout &lt;&lt; dp[1] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---一个网的路\">C - 一个网的路</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P8595\" class=\"uri\">https://www.luogu.com.cn/problem/P8595</a></p>\n<p>首先需要意识到，树和链的边数是一样的，炸掉了多少条边，在之后就会花多少代价补回来。故炸一个点的代价为度数 +1。对于一个点 <span class=\"math inline\">\\(u\\)</span>，分为四种可能性：</p>\n<ul>\n<li>被炸了，单独作为一个连通块。</li>\n<li>没被炸，儿子全部被炸了。</li>\n<li>没被炸，有 1 个儿子没被炸。</li>\n<li>没被炸，有 2 个儿子没被炸。</li>\n</ul>\n<p>分别用 <span class=\"math inline\">\\(f_{u,0/1/2/3}\\)</span> 代表上面四种可能性，转移即可。</p>\n<p>贺了个 fread，擦边跑过了。这个不是 <span class=\"math inline\">\\(O(n)\\)</span> 的吗？</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int LEN = (1 &lt;&lt; 20);\n#ifdef ONLINE_JUDGE\nint nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF;\n        p = buf;\n    &#125;\n    return *p++;\n&#125;\n#else\n#define nec getchar\n\n#endif\nbool read(int &amp;x) &#123;\n    x = 0;\n    bool f = 0;\n    char ch = nec();\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nvoid print(int x) &#123;\n    if (x &lt; 0)\n        putchar(&#39;-&#39;), x = -x;\n    if (x &gt;= 10) print(x / 10);\n    putchar(x % 10 + &#39;0&#39;);\n    return;\n&#125;\nvoid print(int x, char ch) &#123;\n    print(x), putchar(ch);\n    return;\n&#125;\nint main() &#123;\n    int n, m;\n    read(n), read(m);\n    int res = (n - 1) - m;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int x, y; m--; ) &#123;\n        read(x), read(y);\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; tag(n + 1);\n    std::vector&lt;std::array&lt;int, 4&gt; &gt; f(n + 1);\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        tag[x] = 1;\n        f[x][0] = (fa != -1) + 1;\n        f[x][2] = f[x][3] = 0x3f3f3f3f;\n        for (auto i : g[x])\n            if (i != fa) &#123;\n                DFS(i, x);\n                f[x][3] = std::min(f[x][3] + f[i][0], f[x][2] + std::min(f[i][1], f[i][2]));\n                f[x][2] = std::min(f[x][2] + f[i][0], f[x][1] + std::min(f[i][1], f[i][2]));\n                f[x][1] += f[i][0];\n                f[x][0] += std::min(&#123; f[i][0] - 1, f[i][1], f[i][2], f[i][3] &#125;) + 1;\n            &#125;\n        return;\n    &#125;;\n    for (int i = 1; i &lt;= n; ++i)\n        if (!tag[i]) &#123;\n            DFS(i, -1);\n            res += *std::min_element(f[i].begin(), f[i].end());\n        &#125;\n    print(res, &#39;\\n&#39;);\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d---随机树\">D - 随机树</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P3830\" class=\"uri\">https://www.luogu.com.cn/problem/P3830</a></p>\n<p>对于第一问，令 <span class=\"math inline\">\\(f_x\\)</span> 表示共有 <span class=\"math inline\">\\(x\\)</span> 个叶子时的期望深度，两个新叶子的期望深度为 <span class=\"math inline\">\\(f_{x-1}+1\\)</span>，delta 为 <span class=\"math inline\">\\(f_{x-1}+2\\)</span>，故有 <span class=\"math inline\">\\(f_x=\\dfrac {(x-1)f_{x-1}+f_{x-1}+2}x\\)</span>，递推即可。</p>\n<p>对于第二问，令 <span class=\"math inline\">\\(f_{x,k}\\)</span> 表示有 <span class=\"math inline\">\\(x\\)</span> 个叶子，深度 <span class=\"math inline\">\\(\\ge k\\)</span> 的概率（一种理解是从整数概率公式的角度出发）。则考虑枚举左、右叶子数，对于左侧叶子数为 <span class=\"math inline\">\\(i\\)</span> 的情况，<strong>为了去重，只选择深度为 <span class=\"math inline\">\\(k-1\\)</span> 的叶子展开</strong>。只考虑某种组合的出现概率，为 <span class=\"math inline\">\\(f_{i,k-1}+f_{x-i,k-1}-f_{i,k-1}\\cdot f_{x-i,k-1}\\)</span>。数归可以证明，对于任意 <span class=\"math inline\">\\(i\\)</span>，深度为 <span class=\"math inline\">\\(k-1\\)</span> 的叶子被选中的概率均为 <span class=\"math inline\">\\(\\dfrac 1{x-1}\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int q, n;\n    std::cin &gt;&gt; q &gt;&gt; n;\n    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(6);\n    if (q == 1) &#123;\n        std::vector&lt;double&gt; f(n + 1);\n        for (int i = 2; i &lt;= n; ++i)\n            f[i] = (f[i - 1] * (i - 1) + f[i - 1] + 2.) / i;\n        std::cout &lt;&lt; f[n] &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    else &#123;\n        std::vector&lt;std::vector&lt;double&gt; &gt; f(n + 1, std::vector&lt;double&gt; (n + 1));\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            f[i][0] = 1.;\n            for (int j = 1; j &lt; i; ++j) &#123;\n                auto s(0.);\n                for (int k = 1; k &lt; i; ++k)\n                    s += f[k][j - 1] + f[i - k][j - 1] - f[k][j - 1] * f[i - k][j - 1];\n                f[i][j] = s / (i - 1);\n            &#125;\n        &#125;\n        auto res(0.);\n        for (int i = 1; i &lt; n; ++i)\n            res += f[n][i];\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"e---complete-compress\">E - Complete Compress</h2>\n<p><a href=\"https://atcoder.jp/contests/agc034/tasks/agc034_e\" class=\"uri\">https://atcoder.jp/contests/agc034/tasks/agc034_e</a></p>\n<p>对于链，发现可以枚举最后聚集的点，答案与配对方式无关，check 是否能配对即可。</p>\n<p>如果不是链，则相比链，还可以选择同一子树中不存在祖孙关系的两个点，将它们都向 LCA 移一步。</p>\n<p>故而，可以在链的做法上打一个补丁，观察到先『内部消化』，再在子树间配对一定不劣，且答案仍然和配对方式无关。故令 <span class=\"math inline\">\\(f_x\\)</span> 表示点 <span class=\"math inline\">\\(x\\)</span> 内最多消掉多少对，就可以 check 了。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst long long inf = 1e18;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;line_02.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        char t;\n        std::cin &gt;&gt; t;\n        a[i] = t - &#39;0&#39;;\n    &#125;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    auto res(inf);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::vector&lt;int&gt; s(n + 1);\n        std::vector&lt;long long&gt; f(n + 1), cnt(n + 1);\n        std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n            s[x] = a[x];\n            int son = 0;\n            auto sum(0ll);\n            for (auto i : g[x])\n                if (i != fa) &#123;\n                    DFS(i, x), s[x] += s[i];\n                    sum += cnt[i];\n                    if (cnt[i] &gt; cnt[son])\n                        son = i;\n                &#125;\n            if (son) &#123;\n                if (cnt[son] * 2 &lt;= sum)\n                    f[x] = sum / 2;\n                else\n                    f[x] = sum - cnt[son] + std::min(f[son], (cnt[son] - (sum - cnt[son])) / 2);\n            &#125;\n            cnt[x] = sum;\n            if (x != i)\n                cnt[x] += s[x];\n            return;\n        &#125;;\n        DFS(i, -1);\n        if (cnt[i] % 2 == 0 &amp;&amp; f[i] == cnt[i] / 2)\n            res = std::min(res, cnt[i] / 2);\n    &#125;\n    if (res == inf)\n        std::cout &lt;&lt; -1 &lt;&lt; &#39;\\n&#39;;\n    else\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "DP",
                "树形 DP",
                "长链剖分"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250726/",
            "url": "https://xsc062.netlify.app/20250726/",
            "title": "解题报告 [GCJ 2018 #1B] Transmutation",
            "date_published": "2025-07-26T06:47:23.000Z",
            "content_html": "<p>对于『跑 <span class=\"math inline\">\\(n\\)</span> 遍』性质的利用。</p>\n<span id=\"more\"></span>\n<hr />\n<p><a href=\"https://www.luogu.com.cn/problem/P10805\" class=\"uri\">https://www.luogu.com.cn/problem/P10805</a></p>\n<p>容易注意到可以二分答案；但似乎没办法找到一种很好的方法在 <span class=\"math inline\">\\(O(n)\\)</span> 内完成一次 check。</p>\n<p>化用一下网络流中流量的概念；例如下面这个图，假如先从 <span class=\"math inline\">\\(0\\)</span> 开始跑，发现没办法很好地确定 <span class=\"math inline\">\\(8\\to 2\\)</span> 这条边的流量（原因：没办法确定 <span class=\"math inline\">\\(8\\)</span> 和 <span class=\"math inline\">\\(2\\)</span> 的搜索顺序）。</p>\n<p><img src=\"image.png\" /></p>\n<p>这个时候想到；如果是 <span class=\"math inline\">\\(2\\)</span> 先被搜到，自然很好；但如果是 <span class=\"math inline\">\\(8\\)</span> 先被搜到，可以忽略这条由它出发、且未确定的边，先由现在认为的流出量确定流入量。等搜到 <span class=\"math inline\">\\(2\\)</span> 的时候，再更新一下 <span class=\"math inline\">\\(8\\to 2\\)</span> 的流量。这样 <span class=\"math inline\">\\(8\\)</span> 的流入量就是错的；容易想到再搜一次来更新。</p>\n<p><strong>类比一下 SPFA，可以认为跑 <span class=\"math inline\">\\(n\\)</span> 遍就已经达到能更新的最终状态</strong>。此时 check 一下是否每个点都合法。</p>\n",
            "tags": [
                "二分",
                "暴力"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250723/",
            "url": "https://xsc062.netlify.app/20250723/",
            "title": "vp 记录 edu 181",
            "date_published": "2025-07-23T07:06:07.000Z",
            "content_html": "<p>tzl 太强了！真挚的膜拜</p>\n<span id=\"more\"></span>\n<p>lhy 太强了！真挚的膜拜</p>\n<hr />\n<h2 id=\"e.-sets-of-complementary-sums\">E. Sets of Complementary Sums</h2>\n<p><a href=\"https://codeforces.com/contest/2125/problem/E\" class=\"uri\">https://codeforces.com/contest/2125/problem/E</a></p>\n<p>分拆数、其实是个不牛的东西，但是写假了 😅</p>\n<p>令集合元素升序排列为 <span class=\"math inline\">\\(b_{1\\sim n}\\)</span>。显然有结论 <span class=\"math inline\">\\(\\sum b\\geqslant (n-1)(b_n+1)\\)</span>，化一下就有 <span class=\"math inline\">\\(b_n\\geqslant \\left(\\sum\\limits_{i=1}^{n-1} b_n-b_i\\right)+(n-1)\\)</span>。发现 RSH 取值对 LSH 无影响（从取等开始，RSH 不变，若 <span class=\"math inline\">\\(b_n\\gets b_n+1\\)</span>，只需将每个 <span class=\"math inline\">\\(b_i\\gets b_i+1\\)</span> 即可构造出一组解），故只用考虑 RSH 的每种取值下的方案。</p>\n<p>然后就可以做 <a href=\"/20250807/\">分拆数</a> 了。发现会 MLE，滚动即可。每次暴力 assign 会很慢，可以用一点巧思清空滚动数组。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        long long n, m;\n        std::cin &gt;&gt; n &gt;&gt; m;\n        if (n * (n - 1) / 2 &gt; m) &#123;\n            std::cout &lt;&lt; 0 &lt;&lt; &#39;\\n&#39;;\n            continue;\n        &#125;\n        if (n == 1) &#123;\n            std::cout &lt;&lt; m &lt;&lt; &#39;\\n&#39;;\n            continue;\n        &#125;\n        --n;\n        std::vector&lt;std::vector&lt;long long&gt; &gt; f(2, std::vector &lt;long long&gt; (m + 1));\n        f[0][0] = 1ll;\n        for (int j = 1, at = 1; j &lt;= n; ++j, at ^= 1)\n            for (int i = 0; i &lt;= m; ++i) &#123;\n                if (i &lt; j)\n                    f[at][i] = 0;\n                else\n                    f[at][i] = (f[at ^ 1][i - j] + f[at][i - j]) % mod;\n            &#125;\n        auto res(0ll);\n        for (int i = 1; i &lt;= m - n; ++i)\n            (res += f[n &amp; 1][i] * (m - (i + n) + 1)) %= mod;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"vp-记录\">vp 记录</h2>\n<h3 id=\"a\">A</h3>\n<p>1:43 切。打 <code>std::</code> 还是太费时间了。</p>\n<h3 id=\"b\">B</h3>\n<p>5:46 切，看完题没想到 gcd，输出的时候想到了。莼菜。</p>\n<h3 id=\"c\">C</h3>\n<p>11:23 切，原因是容斥符号乱写。</p>\n<h3 id=\"d\">D</h3>\n<p>24:21 切，中间重构了一次并且前缀和的部分考虑得有点问题。绅士（38:35）问我为啥做这么快。</p>\n<h3 id=\"e.0\">E.0</h3>\n<p>看了一眼感觉不太可做。quack 说 F 板板，故跳。</p>\n<h3 id=\"f\">F</h3>\n<p>01:13:41 草完。奇怪的 WQS 二分板板。吃了一发罚时，原因是没人合法的时候要输出 <span class=\"math inline\">\\(0\\)</span>。但和 maimai 的 30 发比起来还是相形见绌。绅士考虑了这个，但是没判目标 <span class=\"math inline\">\\(&lt;\\)</span> 当前的情况遗憾 4 题离场。</p>\n<p>场下看了 Diagnostics，发现其实第二发有个地方是 RE 了的（长度不足 <span class=\"math inline\">\\(6\\)</span> 我的 <code>*std::max_element</code> 会飞起来），但是不知道为啥就是 A 了。</p>\n<h3 id=\"e.1\">E.1</h3>\n<p>猜到结论之后止步于此。试着打了分拆数然后（实际上是）写挂了，怀疑自己结论出错直到 5 题招笑离场 😅</p>\n<h3 id=\"b.1\">B.1</h3>\n<p>哈哈 B 的 gcd 没开 <code>long long</code> 被 hack 了，rk55 to 6000+</p>\n",
            "tags": [
                "差分",
                "背包"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250721/",
            "url": "https://xsc062.netlify.app/20250721/",
            "title": "解题报告 CF1804F Approximate Diameter",
            "date_published": "2025-07-21T14:00:00.000Z",
            "content_html": "<p>唉确实没见过这种二分形式。</p>\n<span id=\"more\"></span>\n<hr />\n<p><a href=\"https://codeforces.com/problemset/problem/1804/F\" class=\"uri\">https://codeforces.com/problemset/problem/1804/F</a></p>\n<p>注意到这个范围基本上就是 <a href=\"/20231117/#树的直径图的直径\">图直径的这个性质</a>，但是我不认识 😅</p>\n<p>每次修改做一次 BFS 过于抽象，发现这个上界多了个 <span class=\"math inline\">\\(2\\)</span> 的系数，把主元换成 <span class=\"math inline\">\\(d\\)</span> 可以得到 <span class=\"math inline\">\\(d\\in[0.5s,2s]\\)</span>。有一个很牛的操作，假设在当前图上求出来了一个 <span class=\"math inline\">\\(s&#39;\\)</span>，显然一直加边，<span class=\"math inline\">\\(2s\\)</span> 这个上界是在变小的，但只要 <span class=\"math inline\">\\(s&#39;\\le 2s\\)</span> 成立，<span class=\"math inline\">\\(s&#39;\\)</span> 就一直可以作为区间里的一个估值。如果不成立，发现除以二就成立了。</p>\n<p>转化成二分 <span class=\"math inline\">\\(s&#39;\\)</span> 最远可以达到的距离即可。每次 <span class=\"math inline\">\\(s&#39;\\)</span> 除以二，共除了 <span class=\"math inline\">\\(\\log n\\)</span> 次；复杂度 <span class=\"math inline\">\\(O(n\\log^2 n)\\)</span>。</p>\n<p>然后注意不要每次 check 都复制一遍原数组然后加边；应该预先在原图上加好所有边，记录版本。原因是申请空间特别费时间。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m, q;\n    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(n + 1);\n    for (int x, y; m--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].emplace_back(y, 0), g[y].emplace_back(x, 0);\n    &#125;\n    for (int i = 1, x, y; i &lt;= q; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].emplace_back(y, i), g[y].emplace_back(x, i);\n    &#125;\n    std::vector&lt;int&gt; mem(q + 1, -1);\n    auto calc = [&amp;](int id) &#123;\n        if (~mem[id])\n            return mem[id];\n        std::queue&lt;std::pair&lt;int, int&gt; &gt; q;\n        std::vector&lt;int&gt; tag(n + 1);\n        q.emplace(1, 0), tag[1] = 1;\n        int mx = 0;\n        for (; !q.empty(); ) &#123;\n            auto [x, w] = q.front();\n            q.pop(), mx = w;\n            for (auto [i, ver] : g[x])\n                if (ver &lt;= id &amp;&amp; !tag[i]) &#123;\n                    tag[i] = 1;\n                    q.emplace(i, w + 1);\n                &#125;\n        &#125;\n        return mem[id] = mx;\n    &#125;;\n    int s = calc(0);\n    for (int i = 0; i &lt;= q; ) &#123;\n        int j = i;\n        for (int l = i + 1, r = q, mid; l &lt;= r; ) &#123;\n            mid = (l + r) &gt;&gt; 1;\n            if (s &lt;= 2 * calc(mid))\n                j = mid, l = mid + 1;\n            else\n                r = mid - 1;\n        &#125;\n        for (; i &lt;= j; ++i)\n            std::cout &lt;&lt; s &lt;&lt; &#39; &#39;;\n        s /= 2;\n    &#125;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "二分"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250720/",
            "url": "https://xsc062.netlify.app/20250720/",
            "title": "【通知】区间最值不满足四边形不等式",
            "date_published": "2025-07-20T11:30:21.000Z",
            "content_html": "<p>花费两天，特此通告。</p>\n<span id=\"more\"></span>\n<p>以上。</p>\n",
            "tags": [
                "DP",
                "DP 优化"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250717/",
            "url": "https://xsc062.netlify.app/20250717/",
            "title": "练习 树的各种性质 II",
            "date_published": "2025-07-17T13:09:13.000Z",
            "content_html": "<p>好像确实比斜优做着舒服。</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a---perfect-matching-on-a-tree\">A - Perfect Matching on a Tree</h2>\n<p><a href=\"https://atcoder.jp/contests/abc362/tasks/abc362_f\" class=\"uri\">https://atcoder.jp/contests/abc362/tasks/abc362_f</a></p>\n<p>肯定直接猜以重心为根。</p>\n<p>至于咋求答案，（显然值是所有点的深度之和），这个我去年在场上被卡住了，还是太菜了。现在看来不是很牛的。</p>\n<p>随便乱胡一下，发现就是把若干条线段陈列到两个上下对齐、长度为 <span class=\"math inline\">\\(n\\div 2\\)</span> 的盒子里。容易想到哪边更空放哪边的贪心策略，当最后还剩一条线段的时候，两个盒子都会剩下一截。</p>\n<p>如果直接塞进去肯定是非法的，这个时候想到把下面的这一节放到下面盒子的开头，其他的依次后移即可。由于重心的每个儿子大小不超过盒子长度，所以移了之后肯定不重合。且容易发现只会换行一次。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; siz(n + 1);\n    int rt = 0;\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        siz[x] = 1;\n        bool flag = 1;\n        for (auto i : g[x])\n            if (i != fa) &#123;\n                DFS(i, x);\n                siz[x] += siz[i];\n                if (siz[i] &gt; n / 2)\n                    flag = 0;\n            &#125;\n        if (flag &amp;&amp; n - siz[x] &lt;= n / 2)\n            rt = x;\n        return;\n    &#125;;\n    DFS(1, -1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; t(n + 1);\n    for (auto i : g[rt]) &#123;\n        DFS = [&amp;](int x, int fa) &#123;\n            t[i].push_back(x);\n            for (auto i : g[x])\n                if (i != fa)\n                    DFS(i, x);\n            return;\n        &#125;;\n        DFS(i, rt);\n    &#125;\n    std::deque&lt;int&gt; p1, p2;\n    int to = n / 2;\n    for (auto i : g[rt]) &#123;\n        auto &amp;q1 = (p1.size() &gt; p2.size() ? p2 : p1), &amp;q2 = (p1.size() &gt; p2.size() ? p1 : p2);\n        for (; !t[i].empty() &amp;&amp; (int)q1.size() &lt; to; q1.push_back(t[i].back()), t[i].pop_back());\n        for (; !t[i].empty() &amp;&amp; (int)q2.size() &lt; to; q2.push_front(t[i].back()), t[i].pop_back());\n    &#125;\n    if (n % 2 == 0)\n        (p1.size() &lt; p2.size() ? p1 : p2).push_back(rt);\n    for (; to--; ) &#123;\n        std::cout &lt;&lt; p1.back() &lt;&lt; &#39; &#39; &lt;&lt; p2.back() &lt;&lt; &#39;\\n&#39;;\n        p1.pop_back(), p2.pop_back();\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---miracle-tree\">B - Miracle Tree</h2>\n<p><a href=\"https://atcoder.jp/contests/arc117/tasks/arc117_d\" class=\"uri\">https://atcoder.jp/contests/arc117/tasks/arc117_d</a></p>\n<p>容易发现任取 <span class=\"math inline\">\\(a,b,c\\)</span> 三点，由于它们之间只有一条简单路径，可以视为一条线段，即退化的三角形。那么由三角形三边关系，任取两边之和都大于等于第三边。</p>\n<p>不妨令 <span class=\"math inline\">\\(E(a)&gt;E(b)&gt;E(c)\\)</span>，以 <span class=\"math inline\">\\(d(b,a)+d(b,c)\\ge d(a,c)\\)</span> 举例，有 <span class=\"math inline\">\\(E(a)-E(b)+E(b)-E(c)\\ge d(a,c)\\)</span> 成立；即，若 <span class=\"math inline\">\\((b,a)\\)</span> 和 <span class=\"math inline\">\\((b,c)\\)</span> 分别已经找到可行解，则 <span class=\"math inline\">\\((a,c)\\)</span> 合法。</p>\n<p>从而推断出，按点权将所有点从小到大排序后，只需让任意相邻两点合法，则全树合法。易发现答案是所有相邻两点 <span class=\"math inline\">\\(dis\\)</span> 之和；也即，从任意一点出发，经过全树所有点的路径和。这种问题我们很熟悉，由欧拉序可知是从 <span class=\"math inline\">\\(2(n-1)\\)</span> 个 <span class=\"math inline\">\\(w\\)</span> 中抠走一段路径长（终点到起点）。想要最小化答案就要最大化这段路径长，取直径即可。</p>\n<p>最后的答案序列按照欧拉序直接求即可（注意直径的端点要在序列两端），实现上应该可以有一些 <span class=\"math inline\">\\(O(n)\\)</span> 小巧思。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; dep(n + 1);\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        for (auto i : g[x])\n            if (i != fa) &#123;\n                dep[i] = dep[x] + 1;\n                DFS(i, x);\n            &#125;\n        return;\n    &#125;;\n    dep[1] = 1, DFS(1, -1);\n    int p = std::max_element(dep.begin() + 1, dep.end()) - dep.begin();\n    dep[p] = 1, DFS(p, -1);\n    int q = std::max_element(dep.begin() + 1, dep.end()) - dep.begin();\n    std::vector&lt;int&gt; tag(n + 1);\n    std::function&lt;bool(int, int)&gt; DFS1 = [&amp;](int x, int fa) &#123;\n        if (x == q) &#123;\n            tag[x] = 1;\n            return true;\n        &#125;\n        for (auto i : g[x])\n            if (i != fa &amp;&amp; DFS1(i, x)) &#123;\n                tag[x] = 1;\n                return true;\n            &#125;\n        return false;\n    &#125;;\n    DFS1(p, -1);\n    std::vector&lt;int&gt; res(n + 1);\n    DFS = [&amp;](int x, int fa) &#123;\n        static int now = 1;\n        int son = 0;\n        if (x != p)\n            res[x] = now;\n        for (auto i : g[x])\n            if (i != fa) &#123;\n                if (tag[i])\n                    son = i;\n                else\n                    ++now, DFS(i, x), ++now;\n            &#125;\n        if (son)\n            ++now, DFS(son, x); // 回不来了，故可以不加 ;-)\n        return;\n    &#125;;\n    res[p] = 1, DFS(p, -1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cout &lt;&lt; res[i] &lt;&lt; &#39; &#39;;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---树的计数\">C - 树的计数</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P1232\" class=\"uri\">https://www.luogu.com.cn/problem/P1232</a></p>\n<p>需要意识到 DFS 和 BFS 地位是不等价的：二者都有自己相应的性质，但 BFS 的深度性质更易于上手。</p>\n<p>不妨进行重标号，令 BFS 序为 <span class=\"math inline\">\\(1\\sim n\\)</span>。可以在 BFS 中不断进行『分层』得到点的深度信息。发现 <span class=\"math inline\">\\(1\\)</span> 后必须分割一次，除此之外没有 BFS 序本身带来的限制。考虑 DFS 序对深度带来的额外限制：</p>\n<ul>\n<li>对于 <span class=\"math inline\">\\(D_i\\)</span> 和 <span class=\"math inline\">\\(D_{i+1}\\)</span>，则 <span class=\"math inline\">\\(D_{i+1}\\)</span> 的插入位点位于 <span class=\"math inline\">\\(1\\sim D_i\\)</span> 的链上，则 <span class=\"math inline\">\\(dep_{D_{i+1}}\\le dep_{D_i}+1\\)</span>，即 BFS 序中，<span class=\"math inline\">\\([D_i,D_{i+1})\\)</span> 间有至多一个分段点。</li>\n<li>虽然题面没说，但是这里 BFS 和 DFS 遍历儿子的顺序是相同的；由于在 BFS 序中 <span class=\"math inline\">\\(i\\)</span> 先于 <span class=\"math inline\">\\(i+1\\)</span> 被遍历，（由于 <span class=\"math inline\">\\(dep_i\\le dep_{i+1}\\le dep_i+1\\)</span>），故而若 <span class=\"math inline\">\\(dep_i= dep_{i+1}\\)</span>，则 DFS 先遍历 <span class=\"math inline\">\\(i\\)</span>；反之，若 DFS 序中 <span class=\"math inline\">\\(i+1\\)</span> 早于 <span class=\"math inline\">\\(i\\)</span> 出现，BFS 序中 <span class=\"math inline\">\\(i\\)</span> 处必须分层。</li>\n</ul>\n<p>则得到若干条限制，形如某处必须断、某区间必须恰好断一次之类。发现比较难处理的是区间内没有要求『某个点必须断』的情况；<del>可以差分约束</del> 惊讶地发现，这种情况下有 <span class=\"math inline\">\\(D_{i+1}=D_i+1\\)</span>（可以考察第一个满足 <span class=\"math inline\">\\(D_i\\ne i\\)</span> 的点来思考）。这点其实是比较难论证的，所以我也没有想得很清楚；好在信息也不是很要求证明这一块就是了。</p>\n<p>用差分处理『恰好一次』的限制，标记某些点不能断。初始高度为 <span class=\"math inline\">\\(1\\)</span>；每次『必须分段』会带来 <span class=\"math inline\">\\(1\\)</span> 的高度；每次『可能分段』会带来 <span class=\"math inline\">\\(0.5\\)</span> 的高度。加起来就可以了。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;P1232_2.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; d(n + 1), b(n + 1), p(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; d[i];\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; b[i], p[b[i]] = i;\n    for (int i = 1; i &lt;= n; ++i)\n        d[i] = p[d[i]];\n    for (int i = 1; i &lt;= n; ++i)\n        p[d[i]] = i;\n    int res = 4;\n    std::vector&lt;int&gt; tag(n + 1), forbid(n + 1);\n    for (int i = 2; i &lt; n; ++i)\n        if (p[i + 1] &lt; p[i])\n            tag[i] = 1;\n    std::partial_sum(tag.begin() + 1, tag.end(), tag.begin() + 1);\n    for (int i = 2; i &lt; n; ++i)\n        if (d[i + 1] &gt; d[i] &amp;&amp; tag[d[i + 1] - 1] - tag[d[i] - 1]) &#123;\n            // fprintf(stderr, &quot;forbid [%d, %d)\\n&quot;, d[i], d[i + 1]);\n            forbid[d[i]] += 1, forbid[d[i + 1]] -= 1;\n        &#125;\n    std::partial_sum(forbid.begin() + 1, forbid.end(), forbid.begin() + 1);\n    for (int i = 2; i &lt; n; ++i)\n        if (p[i] &gt; p[i + 1])\n            res += 2;\n        else if (!forbid[i] &amp;&amp; p[i + 1] == p[i] + 1)\n            res += 1;\n    std::cout &lt;&lt; res / 2;\n    if (res &amp; 1)\n        std::cout &lt;&lt; &quot;.500&quot;;\n    else\n        std::cout &lt;&lt; &quot;.000&quot;;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d---alice-and-bob\">D - Alice and Bob</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P3971\" class=\"uri\">https://www.luogu.com.cn/problem/P3971</a></p>\n<p>一个很显然的想法是 BST；但是这个东西只能求可行解，求不了最优解。</p>\n<p>题解说观察到 <span class=\"math inline\">\\(i\\)</span> 的决策点一定是左侧最靠右的一个 <span class=\"math inline\">\\(a_j=a_i-1\\)</span>（可以假设 <span class=\"math inline\">\\(a_j&gt;a_i\\)</span> 然后反证）。如果把 <span class=\"math inline\">\\(j\\)</span> 向 <span class=\"math inline\">\\(i\\)</span> 连边可以建树；注意到共用一个父亲的点值是递减的。</p>\n<p>要往树上填值。容易想到一层一层填；可惜不最优（反例如下图）。</p>\n<figure>\n<img src=\"image.png\" alt=\"考察从 1 开始的最长下降子序列，发现按层倒序填不优。\" /><figcaption>考察从 1 开始的最长下降子序列，发现按层倒序填不优。</figcaption>\n</figure>\n<p>考虑『以 <span class=\"math inline\">\\(i\\)</span> 开头的最长下降子序列长度』在树上的内涵，发现：</p>\n<ol type=\"1\">\n<li>只能取 <span class=\"math inline\">\\(i\\)</span> 所在子树往右的部分；</li>\n<li>取了祖先就不能取儿子；儿子标号比祖先大；标号越大越能取；最优肯定取叶子。</li>\n</ol>\n<p><strong>想要尽量取满所有 <span class=\"math inline\">\\(i\\)</span> 子树右侧的所有比 <span class=\"math inline\">\\(i\\)</span> 标号大的叶子，就要让它们比 <span class=\"math inline\">\\(i\\)</span> 都小</strong>。这个问题是简单的；一种方法是按儿子标号从大到小，一边 DFS 一边赋值。暂时没想到不用还原序列、log 求答案的统计方法。</p>\n<figure>\n<img src=\"image-1.png\" alt=\"附：两种方式对比\" /><figcaption>附：两种方式对比</figcaption>\n</figure>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e5 + 5;\nstruct &#123; int l, r, u; &#125; t[maxn &lt;&lt; 2];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    if (l == r)\n        return;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    return;\n&#125;\nvoid add(int p, int x, int v) &#123;\n    t[p].u = std::max(t[p].u, v);\n    if (t[p].l == t[p].r)\n        return;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        add(lt, x, v);\n    else\n        add(rt, x, v);\n    return;\n&#125;\nint ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].u;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1, res = 0;\n    if (l &lt;= mid)\n        res = ask(lt, l, r);\n    if (r &gt; mid)\n        res = std::max(res, ask(rt, l, r));\n    return res;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    std::vector&lt;int&gt; a(n + 1), la(n + 1), deg(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        g[la[a[i] - 1]].push_back(i), ++deg[la[a[i] - 1]];\n        la[a[i]] = i;\n    &#125;\n    std::vector&lt;int&gt; u(n + 1), b(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        u[x] = now++;\n        std::reverse(g[x].begin(), g[x].end());\n        for (auto i : g[x])\n            DFS(i);\n        return;\n    &#125;;\n    DFS(0);\n    bld(1, 1, n);\n    for (int i = n; i; --i) &#123;\n        b[i] = ask(1, 1, u[i] - 1) + 1;\n        add(1, u[i], b[i]);\n    &#125;\n    // for (int i = 1; i &lt;= n; ++i)\n    //     std::cout &lt;&lt; b[i] &lt;&lt; &#39; &#39;;\n    // std::cout &lt;&lt; &#39;\\n&#39;;\n    std::cout &lt;&lt; std::accumulate(b.begin() + 1, b.end(), 0ll) &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"e---tree-factory\">E - Tree Factory</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1225/F\" class=\"uri\">https://codeforces.com/problemset/problem/1225/F</a></p>\n<p>首先把题意转化为『每次可以把一个子树下移，要求把一个树转化为一条链』。可以进行一些观察：</p>\n<ul>\n<li>一次移动能产生贡献当且仅当其让树高增加 <span class=\"math inline\">\\(1\\)</span>。</li>\n<li>如果每次移动都产生贡献，易发现答案下界为 <span class=\"math inline\">\\(n-\\sum mxd_i\\)</span>，可以取到。</li>\n</ul>\n<p>看到深度相关就要想到长剖 😅 bro 还没 ptsd</p>\n<p>取以根为 top 的长链，从底到顶依次完成『并到短链所在树上，把树拆成链』的操作。具体过程大概是一个 dfn 的感觉。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 2, x; i &lt;= n; ++i)\n        std::cin &gt;&gt; x, g[x + 1].push_back(i);\n    std::vector&lt;int&gt; mxd(n + 1), son(n + 1), res, nex(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        mxd[x] = 1;\n        for (auto i : g[x]) &#123;\n            DFS(i);\n            if (mxd[i] + 1 &gt; mxd[x])\n                son[x] = i, mxd[x] = mxd[i] + 1;\n        &#125;\n        return;\n    &#125;;\n    DFS(1);\n    std::vector&lt;int&gt; p;\n    for (int i = 1; son[i]; i = son[i])\n        p.push_back(i);\n    std::function&lt;void(int, int)&gt; merge = [&amp;](int son, int x) &#123;\n        int la = son;\n        res.push_back(son);\n        for (auto i : g[x])\n            merge(la, i), la = i;\n        nex[x] = la;\n        return;\n    &#125;;\n    for (int i = (int)p.size() - 1; ~i; --i) &#123;\n        int la = son[p[i]];\n        for (auto j : g[p[i]])\n            if (j != son[p[i]])\n                merge(la, j), la = j;\n        nex[p[i]] = la;\n    &#125;\n    for (int i = 1; i; i = nex[i])\n        std::cout &lt;&lt; i - 1 &lt;&lt; &#39; &#39;;\n    std::cout &lt;&lt; &#39;\\n&#39; &lt;&lt; res.size() &lt;&lt; &#39;\\n&#39;;\n    std::reverse(res.begin(), res.end());\n    for (auto i : res)\n        std::cout &lt;&lt; i - 1 &lt;&lt; &#39; &#39;;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "思维"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250716/",
            "url": "https://xsc062.netlify.app/20250716/",
            "title": "练习 树的各种性质 I",
            "date_published": "2025-07-16T08:17:10.000Z",
            "content_html": "<p>这不比斜优做着爽。</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a---tree\">A - Tr/ee</h2>\n<p><a href=\"https://atcoder.jp/contests/arc103/tasks/arc103_c\" class=\"uri\">https://atcoder.jp/contests/arc103/tasks/arc103_c</a></p>\n<p>可以发现，类似删边的问题，删出来的连通块当中，靠下的是一个完整的子树；就可以转化为子树问题了。</p>\n<p>容易想到枚举 <span class=\"math inline\">\\(i-1\\)</span> 时树的状态，尝试转化为 <span class=\"math inline\">\\(i\\)</span> 时的状态；进一步可以胡出来一堆方案（大概），这里我胡的是，初始设置一个单点，<span class=\"math inline\">\\(0\\to 1\\)</span> 啥也不干，<span class=\"math inline\">\\(0\\to 0\\)</span> 在当前根上再加一个叶子，<span class=\"math inline\">\\(1\\to 0\\)</span> 新建一个带叶子的根并令其成为当前根的父亲，<span class=\"math inline\">\\(1\\to 1\\)</span> 加一个父亲。</p>\n<p>然后特判一下 <span class=\"math inline\">\\(s_1=0\\)</span> 和 <span class=\"math inline\">\\(s_n=1\\)</span> 和 <span class=\"math inline\">\\(s_i\\ne s_{n-i}\\)</span> 的情况，发现其他时候都有解。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::string s;\n    std::cin &gt;&gt; s, n = (int)s.length();\n    s = &quot;#&quot; + s;\n    if (s[1] == &#39;0&#39; || s[n] == &#39;1&#39;) &#123;\n        std::cout &lt;&lt; -1 &lt;&lt; &#39;\\n&#39;;\n        return 0;\n    &#125;\n    for (int i = 1; i &lt; n; ++i)\n        if (s[i] != s[n - i]) &#123;\n            std::cout &lt;&lt; -1 &lt;&lt; &#39;\\n&#39;;\n            return 0;\n        &#125;\n    int tot = 1, rt = 1;\n    for (int i = 2; i &lt; n; ++i) &#123;\n        if (tot == i - 1) &#123;\n            if (s[i] == &#39;0&#39;) &#123;\n                std::cout &lt;&lt; rt &lt;&lt; &#39; &#39; &lt;&lt; ++tot &lt;&lt; &#39;\\n&#39;;\n                rt = tot;\n                std::cout &lt;&lt; rt &lt;&lt; &#39; &#39; &lt;&lt; ++tot &lt;&lt; &#39;\\n&#39;;\n            &#125;\n            else &#123;\n                std::cout &lt;&lt; rt &lt;&lt; &#39; &#39; &lt;&lt; ++tot &lt;&lt; &#39;\\n&#39;;\n                rt = tot;\n            &#125;\n        &#125;\n        else if (s[i] == &#39;0&#39;)\n            std::cout &lt;&lt; rt &lt;&lt; &#39; &#39; &lt;&lt; ++tot &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    if (tot != n)\n        std::cout &lt;&lt; rt &lt;&lt; &#39; &#39; &lt;&lt; n &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---keep-perfectly-matched\">B - Keep Perfectly Matched</h2>\n<p><a href=\"https://atcoder.jp/contests/arc183/tasks/arc183_d\" class=\"uri\">https://atcoder.jp/contests/arc183/tasks/arc183_d</a></p>\n<p>发现这个『完美匹配』就是在树上给每个点找相邻点配对，看看能不能配上；继而发现由于点的总数为偶，一个点有且仅能有一个 siz 为奇的子树（不然非法），再发现对于任意一个点，删掉的点对要么来自其同一个子树；要么一个来自其奇子树，另一个来自其偶子树。</p>\n<p>发现要求最大化距离，又只能删叶子，所以需要最小化 LCA 深度；有没有办法让每次的 LCA 都是根呢？让重心成为根，并保证每次操作的两个点都不来自同一个儿子即可（显然这样是完全可能的）。</p>\n<p>接着写了一发发现过不了样例，原因是发现在偶子树中会出现『一个中途的节点本来有一个奇儿子，删去偶子树中的一个叶子后非法』的情况。显然这样的节点是一个偶儿子。确保每个偶儿子的奇儿子先被删掉就可以解决问题。</p>\n<p>对重心的每个儿子，提前规划其节点被删除的顺序即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; siz(n + 1);\n    int rt = 0;\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        siz[x] = 1;\n        bool flag = 1;\n        for (auto i : g[x])\n            if (i != fa) &#123;\n                DFS(i, x);\n                siz[x] += siz[i];\n                if (siz[i] &gt; n / 2)\n                    flag = 0;\n            &#125;\n        if (flag &amp;&amp; n - siz[x] &lt;= n / 2)\n            rt = x;\n        return;\n    &#125;;\n    DFS(1, -1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; lf(n + 1);\n    int f1 = -1;\n    auto comp = [&amp;](int i, int j) &#123; return siz[i] &lt; siz[j]; &#125;;\n    std::priority_queue&lt;int, std::vector&lt;int&gt;, decltype(comp)&gt; f0(comp);\n    siz.assign(n + 1, 0);\n    for (auto t : g[rt]) &#123;\n        DFS = [&amp;](int x, int fa) &#123;\n            siz[x] = 1;\n            for (auto i : g[x])\n                if (i != fa) &#123;\n                    DFS(i, x);\n                    siz[x] += siz[i];\n                &#125;\n            return;\n        &#125;;\n        DFS(t, rt);\n        DFS = [&amp;](int x, int fa) &#123;\n            if (siz[x] % 2 == 0) &#123;\n                for (auto i : g[x])\n                    if (i != fa &amp;&amp; siz[x] % 2 == 1)\n                        DFS(i, x);\n                for (auto i : g[x])\n                    if (i != fa &amp;&amp; siz[x] % 2 == 0)\n                        DFS(i, x);\n            &#125;\n            else\n                for (auto i : g[x])\n                    if (i != fa)\n                        DFS(i, x);\n            lf[t].push_back(x);\n            return;\n        &#125;;\n        DFS(t, rt);\n        if (siz[t] &amp; 1)\n            assert(f1 == -1), f1 = t;\n        else\n            f0.push(t);\n        std::reverse(lf[t].begin(), lf[t].end());\n    &#125;\n    fprintf(stderr, &quot;rt = %d\\n&quot;, rt);\n    assert(~f1);\n    for (int _ = n / 2; _--; ) &#123;\n        assert(~f1);\n        if (!_ &amp;&amp; f0.empty()) &#123;\n            std::cout &lt;&lt; f1 &lt;&lt; &#39; &#39; &lt;&lt; rt &lt;&lt; &#39;\\n&#39;;\n            break;\n        &#125;\n        assert(!f0.empty());\n        int t = f0.top();\n        f0.pop();\n        assert(!lf[f1].empty());\n        assert(!lf[t].empty());\n        std::cout &lt;&lt; lf[f1].back() &lt;&lt; &#39; &#39; &lt;&lt; lf[t].back() &lt;&lt; &#39;\\n&#39;;\n        lf[f1].pop_back(), --siz[f1];\n        lf[t].pop_back(), --siz[t];\n        if (siz[f1])\n            f0.push(f1);\n        f1 = t;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---fiolki\">C - Fiolki</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P5578\" class=\"uri\">https://www.luogu.com.cn/problem/P5578</a></p>\n<p>难点在于判断每一步有哪些反应发生；显然一个反应只会在某一步发生。</p>\n<p>发现将倒水的操作视为连边 <span class=\"math inline\">\\(b_i\\to a_i\\)</span>，那么形成了森林，把每个反应丢到 LCA 处等待 check。</p>\n<p>发现在 LCA 之外，两种试剂不可能相遇；故最后遍历一遍反应序列，维护每种药水当前数量，在每个点处 check 即可。</p>\n<p>再发现如果每次加边都在父亲处 check 所有可能发生的反应，复杂度肯定是错的；故用倍增求出两个点在 LCA 下方的点作为『检查点』，当『检查点』被合并到其父亲时，就可以 check 一下检查点上面挂的所有询问。显然每个点上的询问只会被检查一次；复杂度线性。</p>\n<p>加上倍增 LCA 的复杂度，就可以 <span class=\"math inline\">\\(O(n\\log n)\\)</span> 地完成。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m, k;\n    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    std::vector&lt;int&gt; f(n + 1), deg(n + 1), now(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; now[i];\n    std::iota(f.begin() + 1, f.end(), 1);\n    std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;\n        return x == f[x] ? x : f[x] = find(f[x]);\n    &#125;;\n    auto merge = [&amp;](int x, int y) &#123;\n        f[find(x)] = find(y);\n        return;\n    &#125;;\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; a(m + 1);\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        auto &amp;[x, y] = a[i];\n        std::cin &gt;&gt; x &gt;&gt; y, ++deg[x];\n        g[y].push_back(x), merge(x, y);\n    &#125;\n    std::vector&lt;int&gt; dep(n + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; fa(n + 1, std::vector&lt;int&gt; (21));\n    for (int i = 1; i &lt;= n; ++i)\n        if (!deg[i]) &#123;\n            std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n                for (auto i : g[x]) &#123;\n                    fa[i][0] = x;\n                    for (int j = 1; j &lt;= 20; ++j)\n                        fa[i][j] = fa[fa[i][j - 1]][j - 1];\n                    dep[i] = dep[x] + 1, DFS(i);\n                &#125;\n                return;\n            &#125;;\n            dep[i] = 1, DFS(i);\n        &#125;\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; t(n + 1);\n    for (int x, y; k--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        if (find(x) == find(y)) &#123;\n            std::pair&lt;int, int&gt; p(x, y);\n            if (dep[x] != dep[y]) &#123;\n                if (dep[x] &lt; dep[y])\n                    std::swap(x, y);\n                for (int i = 20; ~i; --i)\n                    if (dep[fa[x][i]] &gt; dep[y])\n                        x = fa[x][i];\n                if (fa[x][0] == y) &#123;\n                    t[x].push_back(p);\n                    // printf(&quot;add (%d, %d) to %d\\n&quot;, p.first, p.second, x);\n                    continue;\n                &#125;\n                x = fa[x][0];\n            &#125;\n            for (int i = 20; ~i; --i)\n                if (fa[x][i] != fa[y][i])\n                    x = fa[x][i], y = fa[y][i];\n            t[x].push_back(p), t[y].push_back(p);\n        &#125;\n    &#125;\n    std::iota(f.begin() + 1, f.end(), 1);\n    auto res(0ll);\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        auto [x, y] = a[i];\n        merge(x, y);\n        for (auto [p, q] : t[x])\n            if (find(p) == find(x) &amp;&amp; find(q) == find(x)) &#123;\n                int u = std::min(now[p], now[q]);\n                res += 2 * u, now[p] -= u, now[q] -= u;\n            &#125;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125; </code></pre>\n</details>\n<hr />\n<h2 id=\"d---permutation-tree\">D - Permutation Tree</h2>\n<p><a href=\"https://atcoder.jp/contests/arc095/tasks/arc095_d\" class=\"uri\">https://atcoder.jp/contests/arc095/tasks/arc095_d</a></p>\n<p>随便画图，会发现，如果按层数从小到大标号，一个点的儿子只有最多一个不是叶子。一言以蔽之：毛毛虫。</p>\n<p>然后就可以判断可行性了（直径就是虫身）。接下来需要考虑最小化答案字典序的问题，发现对于一个点的儿子，必须是虫足在其左、虫身在其右且必须严格按照层数标号。</p>\n<p>字典序是个偏贪心的东西，所以可以开始瞎搞：发现虫足越多，标号更小的父亲就会越靠后，所以依次比较用两端开头的情况，如果到了虫身的某一段，哪种的儿子更少就选谁，然后直接按最小来标号即可。</p>\n<p>实际上由于只有两种方案，你也可以两边都试试（）</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; dep(n + 1);\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        for (auto i : g[x])\n            if (i != fa) &#123;\n                dep[i] = dep[x] + 1;\n                DFS(i, x);\n            &#125;\n        return;\n    &#125;;\n    dep[1] = 1, DFS(1, -1);\n    int p = std::max_element(dep.begin() + 1, dep.end()) - dep.begin();\n    bool flag = 0;\n    std::vector&lt;int&gt; node, cnt(n + 1), siz(n + 1);\n    DFS = [&amp;](int x, int fa) &#123;\n        siz[x] = 1;\n        for (auto i : g[x])\n            if (i != fa) &#123;\n                DFS(i, x);\n                siz[x] += siz[i], ++cnt[x];\n            &#125;\n        if (siz[x] &gt; 1) &#123;\n            node.push_back(0), --cnt[x];\n            for (auto i : g[x]) &#123;\n                if (i != fa &amp;&amp; siz[node.back()] &gt; 1 &amp;&amp; siz[i] &gt; 1)\n                    flag = 1;\n                if (i != fa &amp;&amp; siz[i] &gt; siz[node.back()])\n                    node.back() = i;\n            &#125;\n        &#125;\n        return;\n    &#125;;\n    DFS(p, -1), node.push_back(p);\n    if (flag) &#123;\n        std::cout &lt;&lt; -1 &lt;&lt; &#39;\\n&#39;;\n        return 0;\n    &#125;\n    for (int i = 0, j = (int)node.size() - 1; i &lt;= j; ++i, --j)\n        if (cnt[node[i]] &gt; cnt[node[j]]) &#123;\n            std::reverse(node.begin(), node.end());\n            break;\n        &#125;\n        else if (cnt[node[i]] &lt; cnt[node[j]])\n            break;\n    int now = 0;\n    for (auto i : node) &#123;\n        int rt = ++now;\n        for (; cnt[i]--; std::cout &lt;&lt; ++now &lt;&lt; &#39; &#39;);\n        std::cout &lt;&lt; rt &lt;&lt; &#39; &#39;;\n    &#125;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"e---isomorphism-freak\">E - Isomorphism Freak</h2>\n<p><a href=\"https://atcoder.jp/contests/agc024/tasks/agc024_d\" class=\"uri\">https://atcoder.jp/contests/agc024/tasks/agc024_d</a></p>\n<p><del>像在数有多少种化学环境的 H 是可以说的吗</del></p>\n<p>鉴于这个，高中化学选择性必修三，给我们打下的坚实基础，我们可以非常迅速地注意到答案就是半径长。</p>\n<p>然后最少叶子，发现一眼瞪不出来，糟糕！没关系，观察样例输出，发现这些答案的因数都挺多，故猜测是若干个数乘起来的；然后再发现是每层最大儿子数的乘积。</p>\n<p>枚举中间的边（仅当直径长度为偶时）、点（奇偶都行）作为对称轴 / 对称中心的情况取 min 即可（原因是要尽量取靠近中心的 <strong>点</strong>），注意边两端算两个儿子数。</p>\n<p><del>所以为啥 <span class=\"math inline\">\\(n\\)</span> 这么小</del></p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst long long inf = 1e18;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; dep(n + 1);\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        for (auto i : g[x])\n        if (i != fa) &#123;\n            dep[i] = dep[x] + 1;\n            DFS(i, x);\n        &#125;\n        return;\n    &#125;;\n    dep[1] = 1, DFS(1, -1);\n    int p = std::max_element(dep.begin() + 1, dep.end()) - dep.begin();\n    dep[p] = 1, DFS(p, -1);\n    int q = std::max_element(dep.begin() + 1, dep.end()) - dep.begin();\n    std::cout &lt;&lt; (dep[q] + 1) / 2 &lt;&lt; &#39; &#39;;\n    std::vector&lt;int&gt; node;\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; edge;\n    if (dep[q] &amp; 1) &#123;\n        DFS = [&amp;](int x, int fa) &#123;\n            for (auto i : g[x])\n                if (i != fa)\n                    DFS(i, x);\n            if (dep[x] == (dep[q] + 1) / 2)\n                node.push_back(x), edge.emplace_back(x, fa);\n            if (dep[x] == (dep[q] + 1) / 2 + 1)\n                edge.emplace_back(x, fa);\n            return;\n        &#125;;\n        DFS(p, -1);\n    &#125;\n    else &#123;\n        std::function&lt;bool(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n            if (x == q)\n                return true;\n            bool ret = false;\n            for (auto i : g[x])\n                if (i != fa)\n                    ret |= DFS(i, x);\n            if (ret &amp;&amp; dep[x] == dep[q] / 2 + 1)\n                edge.emplace_back(x, fa);\n            return ret;\n        &#125;;\n        DFS(p, -1);\n    &#125;\n    long long res = inf;\n    for (auto [x, y] : edge) &#123;\n        std::vector&lt;int&gt; cnt(n + 1);\n        std::function&lt;void(int, int, int)&gt; DFS = [&amp;](int x, int fa, int dep) &#123;\n            int son = 0;\n            for (auto i : g[x])\n                if (i != fa)\n                    ++son, DFS(i, x, dep + 1);\n            cnt[dep] = std::max(cnt[dep], son);\n            return;\n        &#125;;\n        DFS(x, y, 1), DFS(y, x, 1);\n        auto now(2ll);\n        for (int i = 1; i &lt;= n &amp;&amp; cnt[i]; ++i)\n            now *= cnt[i];\n        res = std::min(res, now);\n    &#125;\n    for (auto rt : node) &#123;\n        std::vector&lt;int&gt; cnt(n + 1);\n        std::function&lt;void(int, int, int)&gt; DFS = [&amp;](int x, int fa, int dep) &#123;\n            int son = 0;\n            for (auto i : g[x])\n                if (i != fa)\n                    ++son, DFS(i, x, dep + 1);\n            cnt[dep] = std::max(cnt[dep], son);\n            return;\n        &#125;;\n        DFS(rt, -1, 1);\n        auto now(1ll);\n        for (int i = 1; i &lt;= n &amp;&amp; cnt[i]; ++i)\n            now *= cnt[i];\n        res = std::min(res, now);\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "思维"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250715/",
            "url": "https://xsc062.netlify.app/20250715/",
            "title": "练习 决策单调性",
            "date_published": "2025-07-15T06:13:24.000Z",
            "content_html": "<p>『心静自然凉』大抵是因为情绪平和时副交感神经兴奋，体温略有降低导致的。吗？</p>\n<span id=\"more\"></span>\n<p>其实是因为心脏停跳后血液循环终止、代谢中断，导致产热低于散热（？）</p>\n<hr />\n<h2 id=\"a---征途\">A - 征途</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P4072\" class=\"uri\">https://www.luogu.com.cn/problem/P4072</a></p>\n<p>用完全平方公式展开得到 <span class=\"math inline\">\\(m^2\\sigma^2=m\\left(\\sum {x_i}^2\\right)-S^2\\)</span>，其中 <span class=\"math inline\">\\(S\\)</span> 为求和。</p>\n<p>所以目标是最小化 <span class=\"math inline\">\\(\\sum {x_i}^2\\)</span> 这个东西。令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示第 <span class=\"math inline\">\\(i\\)</span> 天走到 <span class=\"math inline\">\\(j\\)</span>，得到：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nf_{i,j}&amp;=\\min\\{f_{i-1,k}+(s_j-s_k)^2\\}\\\\\n&amp;=\\min\\{f_{i-1,k}-2\\times s_j\\times s_k+{s_k}^2\\}+{s_j}^2\n\\end{aligned}\n\\]</span></p>\n<p>最后得到的斜率式子是 <span class=\"math inline\">\\(\\dfrac {f_{i - 1, a}-f_{i - 1, b}+{s_a}^2-{s_b}^2}{2(s_a-s_b)}&lt;s_j\\)</span>，由于 <span class=\"math inline\">\\(s_j\\)</span> 单增，<del>单调队列维护递减斜率即可</del> <strong>更正：是递增斜率。原因是 <span class=\"math inline\">\\(&lt;\\)</span> 是弹出条件，而非保留条件……</strong></p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst long long inf = 1e9;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;int&gt; a(n + 1);\n    std::vector&lt;long long&gt; s(n + 1);\n    auto sum(0ll);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        s[i] = s[i - 1] + a[i];\n        sum += a[i];\n    &#125;\n    std::vector&lt;std::vector&lt;long long&gt; &gt; f(m + 1, std::vector&lt;long long&gt; (n + 1, inf));\n    f[0][0] = 0ll;\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        auto f1 = [&amp;](int a, int b) &#123;\n            return f[i - 1][a] - f[i - 1][b] + s[a] * s[a] - s[b] * s[b];\n        &#125;;\n        auto f2 = [&amp;](int a, int b) &#123;\n            return 2 * (s[a] - s[b]);\n        &#125;;\n        std::vector&lt;int&gt; q(n + 1);\n        int h = 0, t = -1;\n        q[++t] = i - 1;\n        for (int j = i; j &lt;= n; ++j) &#123;\n            for (; h &lt; t &amp;&amp; f1(q[h + 1], q[h]) &lt; s[j] * f2(q[h + 1], q[h]); ++h);\n            f[i][j] = f[i - 1][q[h]] + (s[j] - s[q[h]]) * (s[j] - s[q[h]]);\n            for (; h &lt; t &amp;&amp; f1(j, q[t]) * f2(q[t], q[t - 1]) &lt; f1(q[t], q[t - 1]) * f2(j, q[t]); --t);\n            q[++t] = j;\n        &#125;\n    &#125;\n    std::cout &lt;&lt; m * f[m][n] - sum * sum &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---刷野-iii\">B - 刷野 III</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P10074\" class=\"uri\">https://www.luogu.com.cn/problem/P10074</a></p>\n<p>发现最坏情况就是每次『试探』都不中的情况，再试探中最坏的那一个。为啥呢，相当于我们每次攻击的一定是未知元素中血最多的一个。既然已经试探出了比阈值大的所有元素，那么下一个攻击的就一定是阈值本身，如果这次跳过它，它就会成为下一次试探失败的元素。这显然不如一开始就直接用新阈值试探。</p>\n<p>从大到小排序。令 <span class=\"math inline\">\\(f_{j, i}\\)</span> 表示只确定了前 <span class=\"math inline\">\\(i\\)</span> 大的数，已经杀了 <span class=\"math inline\">\\(j\\)</span> 个人的最坏情况最小代价。那么显然这一次的阈值是 <span class=\"math inline\">\\(a_i\\)</span>。随便选出上一次的阈值 <span class=\"math inline\">\\(a_k\\)</span>，那么中间这一段待确定的元素数量为 <span class=\"math inline\">\\(i-k\\)</span>。那么有：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nf_{j, i}&amp;=\\min\\limits_{k&lt;i}\\{f_{j-1,k}+(i-k)\\times a_i\\}\\\\\n&amp;=\\min\\limits_{k&lt;i}\\{f_{j-1,k}-k\\times a_i\\}+i\\times a_i\n\\end{aligned}\n\\]</span></p>\n<p>经过验证，虽然这个式子和题解长得不一样，但是是对的 <del>因为我 n^3 暴力 A 了</del></p>\n<p>推出斜优形式 <span class=\"math inline\">\\(\\dfrac {f_{j-1,A}-f_{j-1,B}}{A-B}&lt;a_i\\)</span>，但我的朋友，<span class=\"math inline\">\\(a_i\\)</span> 是递减的。所以用单调栈维护递增斜率即可。<del>或者你也可以学习 grisses 打一个单调队列上二分</del></p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst long long inf = 1e12;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;P10074_4.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;long long&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::sort(a.begin() + 1, a.end(), std::greater&lt;long long&gt; ());\n    std::vector&lt;std::vector&lt;long long&gt; &gt; f(m + 1, std::vector&lt;long long&gt; (n + 1, inf));\n    f[0][0] = 0ll;\n    for (int j = 1; j &lt;= m; ++j) &#123;\n        std::vector&lt;int&gt; q(n + 1);\n        int t = -1;\n        q[++t] = j - 1;\n        auto f1 = [&amp;](int A, int B) &#123;\n            return f[j - 1][A] - f[j - 1][B];\n        &#125;;\n        auto f2 =[&amp;](int A, int B) &#123;\n            return A - B;\n        &#125;;\n        for (int i = j; i &lt;= n; ++i) &#123;\n            for (; t &gt;= 1 &amp;&amp; f1(q[t], q[t - 1]) &gt; a[i] * f2(q[t], q[t - 1]); --t);\n            f[j][i] = f[j - 1][q[t]] + (i - q[t]) * a[i];\n            for (; t &gt;= 1 &amp;&amp; f1(i, q[t]) * f2(q[t], q[t - 1]) &lt; f1(q[t], q[t - 1]) * f2(i, q[t]); --t);\n            q[++t] = i;\n        &#125;\n    &#125;\n    auto res(inf);\n    for (int i = m; i &lt;= n; ++i)\n        res = std::min(res, f[m][i]);\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---traka\">C - TRAKA</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P7747\" class=\"uri\">https://www.luogu.com.cn/problem/P7747</a></p>\n<p>稍微手玩一下就可以发现，假如第 <span class=\"math inline\">\\(j\\)</span> 个人在第 <span class=\"math inline\">\\(i\\)</span> 次的工作时间为 <span class=\"math inline\">\\([L_{j,i},R_{j,i}]\\)</span>，第 <span class=\"math inline\">\\(i-1\\)</span> 次为 <span class=\"math inline\">\\([L_{j,i-1},R_{j,i-1}]\\)</span>，那么要求 <span class=\"math inline\">\\(L_{j,i}\\ge R_{j,i-1}\\)</span>。</p>\n<p>令 <span class=\"math inline\">\\(s_j\\)</span> 为 <span class=\"math inline\">\\(t\\)</span> 的前缀和。假设第 <span class=\"math inline\">\\(i-1\\)</span> 次加工于 <span class=\"math inline\">\\(x_{i-1}\\)</span> 开始，那么我们可以把上式转写为 <span class=\"math inline\">\\(x_{i}+s_{j-1}\\times f_{i}\\ge x_{i-1}+s_j\\times f_{i-1}\\)</span>。也即 <span class=\"math inline\">\\(x_i-x_{i-1}\\ge s_j\\times f_{i-1}-s_{j-1}\\times f_i\\)</span>。</p>\n<p>显然需要找到一个 <span class=\"math inline\">\\(j\\)</span> 使得 RSH 取得最大值；现在就可以考虑斜率优化了。由于所有项都和 <span class=\"math inline\">\\(i\\)</span> 有关，想到两边同除 <span class=\"math inline\">\\(f_{i}\\)</span> 消掉一个 <span class=\"math inline\">\\(i\\)</span> 有关的系数，最后化出来的斜优形式是 <span class=\"math inline\">\\(\\dfrac {s_A-s_B}{s_{A-1}-s_{B-1}}&gt;\\dfrac {f_{i-1}}{f_i}\\)</span>。由于 RSH 不单调，把所有 <span class=\"math inline\">\\(j\\)</span> 塞到队列里维护递减斜率，打二分即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;long long&gt; a(n + 1), w(m + 1), s(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i], s[i] = s[i - 1] + a[i];\n    for (int i = 1; i &lt;= m; ++i)\n        std::cin &gt;&gt; w[i];\n    std::vector&lt;long long&gt; f(m + 1);\n    std::vector&lt;int&gt; q(n + 1);\n    int h = 0, t = -1;\n    q[++t] = 1;\n    for (int i = 2; i &lt;= n; ++i) &#123;\n        for (; h &lt; t &amp;&amp; (s[i] - s[q[t]]) * (s[q[t] - 1] - s[q[t - 1] - 1]) &gt; (s[q[t]] - s[q[t - 1]]) * (s[i - 1] - s[q[t] - 1]); --t);\n        q[++t] = i;\n    &#125;\n    for (int i = 2; i &lt;= m; ++i) &#123;\n        int to = q[h];\n        for (int l = h + 1, r = t, mid; l &lt;= r; ) &#123;\n            mid = (l + r) &gt;&gt; 1;\n            if ((s[q[mid]] - s[q[mid - 1]]) * w[i - 1] &gt; w[i] * (s[q[mid] - 1] - s[q[mid - 1] - 1]))\n                to = q[mid], l = mid + 1;\n            else\n                r = mid - 1;\n        &#125;\n        f[i] = f[i - 1] + s[to] * w[i - 1] - s[to - 1] * w[i];\n    &#125;\n    std::cout &lt;&lt; f[m] + w[m] * s[n] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d---柠檬\">D - 柠檬</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P5504\" class=\"uri\">https://www.luogu.com.cn/problem/P5504</a></p>\n<ul>\n<li>观察零：原问题『从两端取』可以转化为分段问题，故从其中一端考虑即可。</li>\n<li>观察一：若有一段连续的 <span class=\"math inline\">\\(x\\)</span>，完整的比拆开的更优。</li>\n<li>观察二：如果一段 <span class=\"math inline\">\\(x\\)</span> 中夹杂了一些其他元素，那么在哪里分段是说不准的。</li>\n<li>观察三：如果选取的区间是 <span class=\"math inline\">\\([1,r]\\)</span>，那么贪心地想，<span class=\"math inline\">\\(a_r\\)</span> 一定是关键值，不然取 <span class=\"math inline\">\\(a_r\\)</span> 就浪费了。</li>\n<li>观察四：如果选取的区间是 <span class=\"math inline\">\\([l,r]\\)</span>，那么由观察四，<span class=\"math inline\">\\(a_l=a_r\\)</span>，且该值为关键值。</li>\n</ul>\n<p>结合这几个观察，令 <span class=\"math inline\">\\(c_i\\)</span> 表示 <span class=\"math inline\">\\(a_i\\)</span> 在 <span class=\"math inline\">\\([1,i]\\)</span> 中出现次数，<span class=\"math inline\">\\(f_i\\)</span> 表示这一段以 <span class=\"math inline\">\\(i\\)</span> 结尾的最大价值：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nf_i&amp;=\\max\\limits_{j&lt;i,a_{j+1}=a_i}\\{f_j+a_i\\times (c_i-c_{j + 1} + 1)^2\\}\\\\\n&amp;=\\max\\limits_{j&lt;i,a_{j+1}=a_i}\\{f_j+a_{j+1}\\times {c_{j+1}}^2-2\\times c_i\\times a_{j+1}\\times c_{j+1}-2\\times c_{j+1}\\times a_{j+1}\\}+a_i\\times(c_i-1)^2\n\\end{aligned}\n\\]</span></p>\n<p>（怎么这么大一堆。）最后可以化出 <span class=\"math inline\">\\(\\dfrac {f_A-f_B+a_{A+1}\\cdot c_{A+1}\\cdot (c_{A+1}-2)-a_{B+1}\\cdot c_{B+1}\\cdot (c_{B+1}-2)}{2(c_{A+1} - c_{B+1})}&gt;c_i\\times a_i\\)</span>。发现对于每一种 <span class=\"math inline\">\\(a_i\\)</span>，<span class=\"math inline\">\\(c_i\\times a_i\\)</span> 是单增的。单调栈维护即可。</p>\n<p><em>这其实提醒我们关于代换的问题——显然，当与 <span class=\"math inline\">\\(i\\)</span> 的项、与 <span class=\"math inline\">\\(j\\)</span> 有关的项之间存在代换关系时，应该尽量往 <span class=\"math inline\">\\(j\\)</span> 的方向靠。</em></p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;7.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;long long&gt; a(n + 1), c(n + 1), la(10001);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        c[i] = c[la[a[i]]] + 1, la[a[i]] = i;\n    &#125;\n    std::vector&lt;long long&gt; f(n + 1);\n    std::vector&lt;int&gt; _t(10001, -1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; _q(10001);\n    auto f1 = [&amp;](int A, int B) &#123;\n        return f[A] - f[B] + a[A + 1] * c[A + 1] * (c[A + 1] - 2) - a[B + 1] * c[B + 1] * (c[B + 1] - 2);\n    &#125;;\n    auto f2 = [&amp;](int A, int B) &#123;\n        return 2 * (c[A + 1] - c[B + 1]);\n    &#125;;\n    ++_t[a[1]], _q[a[1]].push_back(0);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        &#123;\n            auto &amp;t = _t[a[i]];\n            auto &amp;q = _q[a[i]];\n            for (; t &gt;= 1 &amp;&amp; f1(q[t], q[t - 1]) &lt; c[i] * a[i] * f2(q[t], q[t - 1]); --t);\n            f[i] = f[q[t]] + a[i] * (c[i] - c[q[t] + 1] + 1) * (c[i] - c[q[t] + 1] + 1);\n        &#125;\n        if (i &lt; n) &#123;\n            auto &amp;t = _t[a[i + 1]];\n            auto &amp;q = _q[a[i + 1]];\n            for (; t &gt;= 1 &amp;&amp; f1(i, q[t]) * f2(q[t], q[t - 1]) &gt; f1(q[t], q[t - 1]) * f2(i, q[t]); --t);\n            q.resize(++t + 1), q[t] = i;\n        &#125;\n    &#125;\n    std::cout &lt;&lt; f[n] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"e---knapsack-with-diminishing-values\">E - Knapsack with Diminishing Values</h2>\n<p><a href=\"https://atcoder.jp/contests/abc373/tasks/abc373_f\" class=\"uri\">https://atcoder.jp/contests/abc373/tasks/abc373_f</a></p>\n<p>发现和 <a href=\"/20250707-1/#例单调队列优化多重背包\">单调队列优化多重背包</a> 有异曲同工之妙。</p>\n<p>不妨令 <span class=\"math inline\">\\(v_i\\)</span> 表示体积，<span class=\"math inline\">\\(w_i\\)</span> 表示价值。对于每一个 <span class=\"math inline\">\\(i\\)</span>，把所有体积按模 <span class=\"math inline\">\\(v_i\\)</span> 的余数分类，设为 <span class=\"math inline\">\\(j\\cdot v_i+x\\)</span>。对于 <span class=\"math inline\">\\(k\\cdot v_i+x\\)</span>，有：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nf_{i,j\\cdot v_i+x}&amp;=\\max\\limits_{k&lt;j}\\{f_{i-1,k\\cdot v_i+x}+(j-k)\\cdot w_i-(j-k)^2\\}\\\\\n&amp;=\\max\\limits_{k&lt;j}\\{f_{i-1,k\\cdot v_i+x}-k\\cdot w_i-k^2+2\\times j\\times k\\}-j^2+j\\cdot w_i\n\\end{aligned}\n\\]</span></p>\n<p>则得到 <span class=\"math inline\">\\(\\dfrac {f_{i-1,A\\cdot v_i+x}-f_{i-1,B\\cdot v_i+x}+(B-A)\\cdot w_i - A^2+B^2}{2(B-A)}&lt;j\\)</span>。注意分母为负。总之单调队列维护递增斜率即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;long long&gt; v(n + 1), w(n + 1);\n    std::vector&lt;std::vector&lt;long long&gt; &gt; f(n + 1, std::vector&lt;long long&gt; (m + 1));\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; v[i] &gt;&gt; w[i];\n        for (int x = 0; x &lt; v[i]; ++x) &#123;\n            int h = 0, t = -1;\n            std::vector&lt;int&gt; q;\n            auto f1 = [&amp;](int A, int B) &#123;\n                return f[i - 1][A * v[i] + x] - f[i - 1][B * v[i] + x] + (B - A) * w[i] - A * A + B * B;\n            &#125;;\n            auto f2 = [&amp;](int A, int B) &#123;\n                return 2 * (B - A);\n            &#125;;\n            for (int j = 0, J = x; J &lt;= m; ++j, J += v[i]) &#123;\n                for (; h &lt; t &amp;&amp; f1(q[h + 1], q[h]) &gt; j * f2(q[h + 1], q[h]); ++h);\n                f[i][J] = f[i - 1][J];\n                if (h &lt;= t)\n                    f[i][J] = std::max(f[i][J], f[i - 1][q[h] * v[i] + x] + (j - q[h]) * w[i] - (j - q[h]) * (j - q[h]));\n                for (; h &lt; t &amp;&amp; f1(j, q[t]) * f2(q[t], q[t - 1]) &lt; f1(q[t], q[t - 1]) * f2(j, q[t]); --t);\n                q.resize(++t + 1), q[t] = j;\n            &#125;\n        &#125;\n    &#125;\n    std::cout &lt;&lt; f[n][m] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"f---managing-telephone-poles\">F - Managing Telephone Poles</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1575/M\" class=\"uri\">https://codeforces.com/problemset/problem/1575/M</a></p>\n<p>？观察到性质然后被自己忽略了。非常值得批评。</p>\n<p>不难写出类似斜率优化的式子 <span class=\"math inline\">\\(S(i,j)=\\min\\{ {x_k}^2-2\\times i\\times x_k+{y_k}^2-2\\times j \\times y_k\\}+i^2+j^2\\)</span>。</p>\n<p>会下意识尝试固定 <span class=\"math inline\">\\(i\\)</span>，就可以 <span class=\"math inline\">\\(O(n^2m)\\)</span> 完成任务，似乎不太行。顺着这个想法会观察到，固定 <span class=\"math inline\">\\(i\\)</span> 之后，每一列的 poles 中只有和第 <span class=\"math inline\">\\(i\\)</span> 行最近的才会有贡献。</p>\n<p>这个是好做的，且这样的相邻点数量是 <span class=\"math inline\">\\(O(m)\\)</span> 的；于是将 <span class=\"math inline\">\\(i\\)</span> 视为常数进行变形，若将所有 poles 按 <span class=\"math inline\">\\(y\\)</span> 从小到大排序就能得到斜率形式 <span class=\"math inline\">\\(\\dfrac { {x_A}^2-{x_B}^2+{y_A}^2-{y_B}^2-2\\times i\\times(x_A-x_B)}{2(y_A-y_B)}&lt;j\\)</span>。维护递增斜率就能 <span class=\"math inline\">\\(O(n^2)\\)</span> 完成问题。</p>\n<p>那么找相邻点这一步大可以摆烂写二分。所以总共是 <span class=\"math inline\">\\(O(nm\\log m)\\)</span> 的。</p>\n<p>不要像我一样把两边最近的都加进队列，不然你会有分母为 <span class=\"math inline\">\\(0\\)</span> 的斜率 <img src=\"/em/hsh.gif\" /></p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m, ++n, ++m;\n    std::vector&lt;std::vector&lt;int&gt; &gt; tag(n + 1, std::vector&lt;int&gt; (m + 1));\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(m + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = 1; j &lt;= m; ++j) &#123;\n            char t;\n            std::cin &gt;&gt; t;\n            if (t == &#39;1&#39;)\n                g[j].push_back(i), tag[i][j] = 1;\n        &#125;\n    struct node &#123; long long x, y; &#125;;\n    auto res(0ll);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::vector&lt;node&gt; p;\n        for (int j = 1; j &lt;= m; ++j) &#123;\n            int to = std::lower_bound(g[j].begin(), g[j].end(), i) - g[j].begin();\n            if (to &lt; (int)g[j].size()) &#123;\n                p.push_back(&#123; g[j][to], j &#125;);\n                if (g[j][to] != i &amp;&amp; to != 0 &amp;&amp; g[j][to] - i &gt; i - g[j][to - 1])\n                    p.back() = &#123; g[j][to - 1], j &#125;;\n            &#125;\n            else if (to != 0)\n                p.push_back(&#123; g[j][to - 1], j &#125;);\n        &#125;\n        std::vector&lt;int&gt; q(m + 1);\n        int h = 0, t = -1;\n        auto f1 = [&amp;](node A, node B) &#123;\n            return A.x * A.x - B.x * B.x + A.y * A.y - B.y * B.y - 2 * i * (A.x - B.x);\n        &#125;;\n        auto f2 = [&amp;](node A, node B) &#123;\n            return 2 * (A.y - B.y);\n        &#125;;\n        for (int j = 0; j &lt; (int)p.size(); ++j) &#123;\n            for (; h &lt; t &amp;&amp; f1(p[j], p[q[t]]) * f2(p[q[t]], p[q[t - 1]]) &lt; f1(p[q[t]], p[q[t - 1]]) * f2(p[j], p[q[t]]); --t);\n            q[++t] = j;\n        &#125;\n        for (int j = 1; j &lt;= m; ++j) &#123;  \n            for (; h &lt; t &amp;&amp; f1(p[q[h + 1]], p[q[h]]) &lt; j * f2(p[q[h + 1]], p[q[h]]); ++h);\n            res += (p[q[h]].x - i) * (p[q[h]].x - i) + (p[q[h]].y - j) * (p[q[h]].y - j);\n        &#125;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"g---partition-game\">G - Partition Game</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1527/E\" class=\"uri\">https://codeforces.com/problemset/problem/1527/E</a></p>\n<p>发现不太斜优，终于给我浸泡了两天斜优内容的大脑加了勺新的底物。</p>\n<p>令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示第 <span class=\"math inline\">\\(i\\)</span> 段以 <span class=\"math inline\">\\(j\\)</span> 结尾的最小代价；对 <span class=\"math inline\">\\(w\\)</span> 套用四边形不等式变式 <span class=\"math inline\">\\(w(l-1,r+1)+w(l,r)\\ge w(l-1,r)+w(l,r+1)\\)</span> 发现成立（其中大多数时候能取等；部分特殊情况取到大于号）。</p>\n<p>那么发现可以用分治优化。发现 <span class=\"math inline\">\\(w\\)</span> 不那么能快速求；还是套用 <a href=\"/20250707-1/#例yet-another-minimization-problem\">Yet Another Minimization Problem</a> 中的方法，用类似莫队的方式求解。</p>\n<p>发现这个莫队套路也很熟悉了，直接用双端队列维护即可。复杂度 <span class=\"math inline\">\\(O(nk\\log n)\\)</span>，看着不太安全。但注意到我们在 20 个月前的提交中使用了 <span class=\"math inline\">\\(O(nk\\log n)\\)</span> 的线段树，所以能过的兄弟。</p>\n<details>\n<p>鉴于 deque 的时空常数都大得吓人，所以我用静态 vector 模拟 deque 了。</p>\n<p>跑得比我之前线段树的一半还快，兄弟。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int inf = 1e18;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;std::vector&lt;int&gt; &gt; pos(n + 1);\n    std::vector&lt;int&gt; a(n + 1), _h(n + 1), _t(n + 1, -1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i], pos[a[i]].push_back(i);\n    std::vector&lt;std::vector&lt;long long&gt; &gt; f(m + 1, std::vector&lt;long long&gt; (n + 1, inf));\n    f[0][0] = 0ll;\n    auto w = [&amp;](int ql, int qr) &#123;\n        static int l = 1, r = 0;\n        static auto res(0ll);\n        for (; l &gt; ql; ) &#123;\n            --l;\n            auto &amp;h = _h[a[l]], &amp;t = _t[a[l]];\n            auto &amp;q = pos[a[l]];\n            if (h &lt;= t)\n                res -= q[t] - q[h];\n            res += q[t] - q[--h];\n        &#125;\n        for (; r &gt; qr; ) &#123;\n            auto &amp;h = _h[a[r]], &amp;t = _t[a[r]];\n            auto &amp;q = pos[a[r]];\n            res -= q[t--] - q[h];\n            if (h &lt;= t)\n                res += q[t] - q[h];\n            --r;\n        &#125;\n        for (; r &lt; qr; ) &#123;\n            ++r;\n            auto &amp;h = _h[a[r]], &amp;t = _t[a[r]];\n            auto &amp;q = pos[a[r]];\n            if (h &lt;= t)\n                res -= q[t] - q[h];\n            res += q[++t] - q[h];\n        &#125;\n        for (; l &lt; ql; ) &#123;\n            auto &amp;h = _h[a[l]], &amp;t = _t[a[l]];\n            auto &amp;q = pos[a[l]];\n            res -= q[t] - q[h++];\n            if (h &lt;= t)\n                res += q[t] - q[h];\n            ++l;\n        &#125;\n        return res;\n    &#125;;\n    for (int t = 1; t &lt;= m; ++t) &#123;\n        std::function&lt;void(int, int, int, int)&gt; calc = [&amp;](int l, int r, int lp, int rp) &#123;\n            if (l &gt; r)\n                return;\n            if (l == r) &#123;\n                for (int i = lp; i &lt;= rp &amp;&amp; i &lt; l; ++i)\n                    f[t][l] = std::min(f[t][l], f[t - 1][i] + w(i + 1, l));\n                return;\n            &#125;\n            int mid = (l + r) &gt;&gt; 1, p = -1;\n            for (int i = lp; i &lt;= rp &amp;&amp; i &lt; mid; ++i)\n                if (f[t - 1][i] + w(i + 1, mid) &lt; f[t][mid])\n                    f[t][mid] = f[t - 1][i] + w(i + 1, mid), p = i;\n            calc(l, mid - 1, lp, p), calc(mid + 1, r, p, rp);\n            return;\n        &#125;;\n        calc(t, n, t - 1, n - 1);\n    &#125;\n    std::cout &lt;&lt; f[m][n] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"h---battle-lemmings\">H - Battle Lemmings</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1420/E\" class=\"uri\">https://codeforces.com/problemset/problem/1420/E</a></p>\n<p>容易发现 <span class=\"math inline\">\\(0\\)</span> 的数目不变，答案就是 <span class=\"math inline\">\\(0\\)</span> 的对数 - 连续 <span class=\"math inline\">\\(0\\)</span> 的对数。</p>\n<p>然后有一个我们很熟悉的 trick，随便找一个目标序列，那么花费的操作次数就是每个对应的 <span class=\"math inline\">\\(1\\)</span> 的位置差。令 <span class=\"math inline\">\\(f_{i,j,k}\\)</span> 表示用了 <span class=\"math inline\">\\(i\\)</span> 次操作、<span class=\"math inline\">\\(j\\)</span> 个 <span class=\"math inline\">\\(1\\)</span>、最后一个 <span class=\"math inline\">\\(1\\)</span> 在 <span class=\"math inline\">\\(k\\)</span> 的最小连续 <span class=\"math inline\">\\(0\\)</span> 对数。那么有：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nf_{i,j,k}&amp;=\\min\\limits_{p&lt;k}\\left\\{f_{i-|k-pos_j|,j-1,p}+\\dfrac {(k-p-1)(k-p-2)}2\\right\\}\\\\\n&amp;=\\min\\left\\{f_{i-|k-pos_j|,j-1,p}-k\\cdot p+\\dfrac {p(p + 2)}2\\right\\}+\\dfrac {k^2-3k+2}2\n\\end{aligned}\n\\]</span></p>\n<p>发现这个式子是 <span class=\"math inline\">\\(O(n^5)\\)</span> 的，而且看起来很斜优，化为斜率形式 <span class=\"math inline\">\\(\\dfrac{2\\times f_A-2\\times f_B+A(A+2)-B(B+2)}{2(A-B)}&lt;k\\)</span>。维护递增斜率就可以 <span class=\"math inline\">\\(O(n^4)\\)</span> 做了。</p>\n<p>Tip：当时写着写着愣住了，比如这个 <span class=\"math inline\">\\(i-|k-pos_j|\\)</span> 不是一直在动吗。解决方案？同时维护很多个队列即可。</p>\n<details>\n<p>注意还要把最后一个 <span class=\"math inline\">\\(1\\)</span> 之后连续 <span class=\"math inline\">\\(0\\)</span> 的代价算上。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst long long inf = 1e9;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1);\n    std::vector&lt;long long&gt; pos(1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        if (a[i] == 1)\n            pos.push_back(i);\n    &#125;\n    int m = n * (n - 1) / 2;\n    std::vector&lt;std::vector&lt;std::vector&lt;long long&gt; &gt; &gt; f(pos.size(), std::vector&lt;std::vector&lt;long long&gt; &gt; (m + 1, std::vector&lt;long long&gt; (n + 1, inf)));\n    f[0][0][0] = 0ll;\n    for (int j = 1; j &lt; (int)pos.size(); ++j) &#123;\n        std::vector&lt;std::vector&lt;int&gt; &gt; _q(m + 1, std::vector&lt;int&gt; (n + 1));\n        std::vector&lt;int&gt; _h(m + 1), _t(m + 1, -1);\n        for (int k = 0; k &lt;= n; ++k)\n            for (int i = m; i &gt;= 0; --i) &#123;\n                if (i &gt;= std::abs(k - pos[j])) &#123;\n                    auto f1 = [&amp;](long long A, long long B) &#123;\n                        return 2 * f[j - 1][i - std::abs(k - pos[j])][A] - 2 * f[j - 1][i - std::abs(k - pos[j])][B] + A * (A + 2) - B * (B + 2);\n                    &#125;;\n                    auto f2 = [&amp;](long long A, long long B) &#123;\n                        return 2 * (A - B);\n                    &#125;;\n                    auto &amp;h = _h[i - std::abs(k - pos[j])], &amp;t = _t[i - std::abs(k - pos[j])];\n                    auto &amp;q = _q[i - std::abs(k - pos[j])];\n                    for (; h &lt; t &amp;&amp; f1(q[h + 1], q[h]) &lt; k * f2(q[h + 1], q[h]); ++h) &#123;&#125;\n                    if (h &lt;= t)\n                        f[j][i][k] = std::min(inf, f[j - 1][i - std::abs(k - pos[j])][q[h]] + (k - q[h] - 1) * (k - q[h] - 2) / 2);\n                &#125;\n                auto f1 = [&amp;](long long A, long long B) &#123;\n                    return 2 * f[j - 1][i][A] - 2 * f[j - 1][i][B] + A * (A + 2) - B * (B + 2);\n                &#125;;\n                auto f2 = [&amp;](long long A, long long B) &#123;\n                    return 2 * (A - B);\n                &#125;;\n                auto &amp;h = _h[i], &amp;t = _t[i];\n                auto &amp;q = _q[i];\n                for (; h &lt; t &amp;&amp; f1(k, q[t]) * f2(q[t], q[t - 1]) &lt; f1(q[t], q[t - 1]) * f2(k, q[t]); --t);\n                q[++t] = k;\n            &#125;\n    &#125;\n    auto res(-inf);\n    int cnt = n - (int)pos.size() + 1;\n    cnt = cnt * (cnt - 1) / 2;\n    for (int i = 0; i &lt;= m; ++i) &#123;\n        for (int k = 0; k &lt;= n; ++k)\n            res = std::max(res, cnt - f.back()[i][k] - (n - k) * (n - k - 1) / 2);\n        std::cout &lt;&lt; res &lt;&lt; &#39; &#39;;\n    &#125;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"a---yakiniku-restaurants\">A - Yakiniku Restaurants</h2>\n<p><a href=\"https://atcoder.jp/contests/arc067/tasks/arc067_d\" class=\"uri\">https://atcoder.jp/contests/arc067/tasks/arc067_d</a></p>\n<p>发现固定左右端点后，收益是可以贪心算的；下意识想到只固定左端点，那么右端点应该就可以用单调队列之类的搞一搞。</p>\n<p>先提前把所有东西塞到队列里。左端点一开始在最右边；往左边动一下之后，就可以更新每种菜的队列；发现在所有元素中作决策点的不总是队头；这个地方用 <strong>单调递减的单调栈</strong> 是极好的。这里的单调栈其实就类似 <a href=\"/20250707-1/#优化-dp单调数据结构\">四边形不等式中的单调数据结构</a> 了。</p>\n<p>维护单调栈中每个决策点的影响区间；显然每个右端点的答案变化量相同；用个类似于差分的东西记录一下就好了。</p>\n<p>复杂度 <span class=\"math inline\">\\(O(n^2)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst long long inf = 1e18;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;long long&gt; s(n + 1), f(n + 1);\n    for (int i = 2; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; s[i], s[i] += s[i - 1];\n        f[i] = -s[i];\n    &#125;\n    std::vector&lt;std::vector&lt;int&gt; &gt; a(n + 1, std::vector&lt;int&gt; (m + 1));\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = 1; j &lt;= m; ++j)\n            std::cin &gt;&gt; a[i][j];\n    struct node &#123; int j, l, r; &#125;;\n    std::vector&lt;std::stack&lt;node&gt; &gt; _q(m + 1);\n    auto res(-inf);\n    for (int l = n; l; --l) &#123;\n        std::vector&lt;long long&gt; d(n + 1);\n        auto add = [&amp;](int l, int r, long long v) &#123;\n            d[l] += v;\n            if (r != n)\n                d[r + 1] -= v;\n            return;\n        &#125;;\n        for (int j = 1; j &lt;= m; ++j) &#123;\n            auto &amp;q = _q[j];\n            node now = &#123; j, l, l &#125;;\n            add(l, l, a[l][j]);\n            for (; !q.empty() &amp;&amp; a[l][j] &gt;= a[q.top().l][q.top().j]; q.pop()) &#123;\n                now.r = q.top().r;\n                add(q.top().l, q.top().r, a[l][j] - a[q.top().l][q.top().j]);\n            &#125;\n            q.push(now);\n        &#125;\n        std::partial_sum(d.begin() + 1, d.end(), d.begin() + 1);\n        for (int r = l; r &lt;= n; ++r) &#123;\n            f[r] += d[r];\n            res = std::max(res, f[r] + s[l]);\n        &#125;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---jellyfish-and-miku\">B - Jellyfish and Miku</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1874/D\" class=\"uri\">https://codeforces.com/problemset/problem/1874/D</a></p>\n<p>唉数列。唉概统。在数学讲义上折磨了我一遍之后还要到这儿来折磨我。</p>\n<p>假设已经知道了 <span class=\"math inline\">\\(a\\)</span>，考虑求期望步数。设 <span class=\"math inline\">\\(E_i\\)</span> 为从 <span class=\"math inline\">\\(i\\)</span> 出发走到 <span class=\"math inline\">\\(n\\)</span> 的期望步数。那么有：</p>\n<p><span class=\"math display\">\\[\nE_i=\\begin{cases}\nE_1+1&amp;i=0\\\\\n0&amp;i=n\\\\\nE_i=(E_{i-1}+1)\\cdot \\dfrac {a_i}{a_{i+1}+a_i}+(E_{i+1}+1)\\cdot \\dfrac {a_{i+1}}{a_{i+1}+a_{i}}&amp;\\text{otherwise}\n\\end{cases}\n\\]</span></p>\n<p>（提示：从『<span class=\"math inline\">\\(i\\)</span> 下一步会走哪个方向』考虑。）</p>\n<p>接下来就可以利用你的高中数学知识进行一个 <span class=\"math inline\">\\(f_0\\)</span> 的求，（一堆过程），得到 <span class=\"math inline\">\\(E_0=n+2\\times \\sum\\limits_{i=1}^n\\dfrac {\\sum_{j\\le i}a_j}{a_i}\\)</span>，然后想要最小化这个东西。</p>\n<p>不妨令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示到 <span class=\"math inline\">\\(i\\)</span> 时已经分配走了 <span class=\"math inline\">\\(j\\)</span> 体积，<span class=\"math inline\">\\(\\sum_{k=1}^i \\dfrac {\\sum_{l\\le k}a_l}{a_k}\\)</span> 的最小值，有 <span class=\"math inline\">\\(f_{i,j}=\\min\\limits_{k&lt;j}\\left\\{f_{i-1,k}+\\dfrac {k}{j - k}\\right\\}\\)</span>。发现它大抵是满足四边形不等式的，按照 <a href=\"/20250707-1/#d1d-dp-优化\">2D/1D DP 优化的结论</a>，代入 <span class=\"math inline\">\\(p_{i,j-1}&lt;p_{i,j}&lt;p_{i+1,j}\\)</span> 可以 <span class=\"math inline\">\\(O(nm)\\)</span> 解决问题。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;std::vector&lt;int&gt; &gt; p(n + 1, std::vector&lt;int&gt; (m + 1));\n    std::vector&lt;std::vector&lt;long double&gt; &gt; f(n + 1, std::vector&lt;long double&gt; (m + 1, 1e18));\n    f[0][0] = 0ll;\n    for (int j = 1; j &lt;= m; ++j)\n        for (int i = std::min(j, n); i; --i) &#123;\n            int to = ((i == std::min(j, n)) ? j : std::min(p[i + 1][j], j));\n            for (int k = p[i][j - 1]; k &lt;= to; ++k)\n                if (f[i - 1][k] + k * 1. / (j - k) &lt; f[i][j])\n                    f[i][j] = f[i - 1][k] + k * 1. / (j - k), p[i][j] = k;\n            // printf(&quot;f[%d][%d] = %Lf, p = %d\\n&quot;, i, j, f[i][j], p[i][j]);\n        &#125;\n    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(10) &lt;&lt; n + 2 * f[n][m] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"cut-the-sequence\">Cut the Sequence</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P10977\" class=\"uri\">https://www.luogu.com.cn/problem/P10977</a></p>\n<h1 id=\"通知区间最值-不满足-四边形不等式\"><mark>通知：区间最值 不满足 四边形不等式。</mark></h1>\n<p>其实在猜的时候是举了反例的，但是大脑萎缩了推着推着忘记符号了 😅</p>\n<p>看到 <span class=\"math inline\">\\(f_i=\\min\\limits_{g(i)\\le j&lt;i}\\{f_j+\\max\\{a_{j+1\\sim i}\\}\\}\\)</span> 这个 <span class=\"math inline\">\\(j\\)</span> 的范围其实是有点单调队列优化的感觉的，但这个最大值传统的单调队列不是很可做。可以注意到最大值这一项有点 <strong>单调队列</strong> 后缀最大值的感觉（实际上就是）；一个很自然的想法是利用这个最大值影响的区间，维护 <span class=\"math inline\">\\(f\\)</span> 的线段树来暴力做。</p>\n<p>另一个比较牛的做法是发现同一个下标的 <span class=\"math inline\">\\(f\\)</span> 和 <span class=\"math inline\">\\(a\\)</span> 的关系。首先需要注意到 <span class=\"math inline\">\\(f\\)</span> 单调不降；对于同一个 <span class=\"math inline\">\\(a\\)</span>，能取到的 <span class=\"math inline\">\\(f\\)</span> 就是最靠前的；维护一个 <span class=\"math inline\">\\(a\\)</span> 的单减队列，那么共用同一个 <span class=\"math inline\">\\(a\\)</span> 的就是相邻两个下标之间的部分，其最优决策在能取到的最前端取得；需要注意到队列里的贡献并不单调，需要用一个 multiset 来存储所有贡献并查找、更新。</p>\n<p>需要注意单调队列里某个元素 <span class=\"math inline\">\\(f_{q_i}\\)</span> 结合的其实是 <span class=\"math inline\">\\(a_{q_{i+1}}\\)</span>。还需要注意队头的维护，可能需要一些小巧思。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;int&gt; a(n + 1);\n    std::vector&lt;long long&gt; s(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i], s[i] = s[i - 1] + a[i];\n    int h = 0, t = -1;\n    std::multiset&lt;long long&gt; st;\n    std::vector&lt;long long&gt; f(n + 1);\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; q(n + 1);\n    q[++t] = &#123; 0, 0 &#125;, a[0] = 0x3f3f3f3f;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (; s[i] - s[q[h].second] &gt; m; ) &#123;\n            st.erase(st.find(f[q[h].second] + a[q[h + 1].first]));\n            if (++q[h].second &gt;= q[h + 1].first)\n                a[q[++h].first] = 0x3f3f3f3f;\n            else\n                st.insert(f[q[h].second] + a[q[h + 1].first]);\n        &#125;\n        for (; h &lt; t &amp;&amp; a[q[t].first] &lt;= a[i]; --t)\n            st.erase(st.find(f[q[t - 1].second] + a[q[t].first]));\n        st.insert(f[q[t].second] + a[i]), q[++t] = &#123; i, i &#125;;\n        f[i] = *st.begin();\n    &#125;\n    std::cout &lt;&lt; f[n] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "斜率优化",
                "DP",
                "四边形不等式"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250712/",
            "url": "https://xsc062.netlify.app/20250712/",
            "title": "杂题",
            "date_published": "2025-07-12T07:36:52.000Z",
            "content_html": "<p>我生待明日，万事成蹉跎。</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"town\">town</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6407/problem/1\" class=\"uri\">http://222.180.160.110:61235/contest/6407/problem/1</a></p>\n<blockquote>\n<p>给定一棵大小为 <span class=\"math inline\">\\(n\\)</span> 的树，点有点权，欲将树划分为若干个连通块，使得每个块内的点权异或和都为 <span class=\"math inline\">\\(x\\)</span>，求方案数，模 <span class=\"math inline\">\\(998244353\\)</span>。</p>\n<p><span class=\"math inline\">\\(n\\le 10^6,0\\le x\\le 10^9\\)</span>。</p>\n</blockquote>\n<p>记 <span class=\"math inline\">\\(u\\)</span> 引导的子树异或和为 <span class=\"math inline\">\\(s_u\\)</span>。把连通块转化为对断边的讨论。考察一条最末端的边，其下方子树的异或和一定为 <span class=\"math inline\">\\(x\\)</span>。</p>\n<p>简单数归可得断掉的每一条边，其下方子树异或和为 <span class=\"math inline\">\\(x\\)</span> 或 <span class=\"math inline\">\\(0\\)</span>（那么显然有解的充要条件是 <span class=\"math inline\">\\(s_1=0\\lor s_1=x\\)</span>）。考虑树形 DP，令 <span class=\"math inline\">\\(f_{u,0/1}\\)</span> 表示当前 DP 到 <span class=\"math inline\">\\(u\\)</span> 子树头上那条边，它连接了一个异或和为 <span class=\"math inline\">\\(s_u\\)</span> （或 <span class=\"math inline\">\\(s_u\\oplus x\\)</span>）的连通块的合法方案数，分别代表已经『断』掉了偶数 / 奇数个合法连通块。</p>\n<p>首先自然可以一条边都不断，<span class=\"math inline\">\\(f_{u,0}=1\\)</span>。那么更新就应为：</p>\n<p><span class=\"math display\">\\[\nf&#39;_{u,0}=f_{u,0}\\cdot f_{v,0}+f_{u,1}\\cdot f_{v,1}\\\\\nf&#39;_{u,1}=f_{u,0}\\cdot f_{v,1}+f_{u,1}\\cdot f_{v,0}\n\\]</span></p>\n<p>接着，如果 <span class=\"math inline\">\\(s_u\\)</span> 恰好为 <span class=\"math inline\">\\(0\\)</span> 或 <span class=\"math inline\">\\(x\\)</span>，这条边连接的连通块的异或和就可以是 <span class=\"math inline\">\\(x\\)</span>，那么就可以在这条边处断开，提供一个空连通块（加入异或和为 <span class=\"math inline\">\\(0\\)</span> 的方案）。</p>\n<p>最后注意 <span class=\"math inline\">\\(x\\)</span> 可能为 <span class=\"math inline\">\\(0\\)</span>，需要特殊处理——每个 <span class=\"math inline\">\\(s_u=0\\)</span> 处都可以断开。</p>\n<p>这个 DP 状态实在非常新奇；同时 DP 和删边又是分开的，显得非常割裂。看 sol、听 grisses 讲解的时候都完全一头雾水。quack 说这是因为我没做过连通块 DP /ll</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;ex_town1.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;int&gt; a(n + 1), s(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        s[x] = a[x];\n        for (auto i : g[x])\n            if (i != fa) &#123;\n                DFS(i, x);\n                s[x] ^= s[i];\n            &#125;\n        return;\n    &#125;;\n    DFS(1, -1);\n    if (s[1] != 0 &amp;&amp; s[1] != m) &#123;\n        std::cout &lt;&lt; 0 &lt;&lt; &#39;\\n&#39;;\n        return 0;\n    &#125;\n    if (m == 0) &#123;\n        auto res(1ll);\n        for (int i = 2; i &lt;= n; ++i)\n            if (s[i] == 0)\n                (res *= 2) %= mod;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    else &#123;\n        std::vector&lt;std::array&lt;long long, 2&gt; &gt; f(n + 1);\n        DFS = [&amp;](int x, int fa) &#123;\n            f[x][0] = 1ll;\n            for (auto i : g[x])\n                if (i != fa) &#123;\n                    DFS(i, x);\n                    std::tie(f[x][0], f[x][1]) = std::make_tuple((f[x][0] * f[i][0] + f[x][1] * f[i][1]) % mod, (f[x][0] * f[i][1] + f[x][1] * f[i][0]) % mod);\n                &#125;\n            if (x != 1) &#123;\n                if (s[x] == m)\n                    (f[x][1] += f[x][0]) %= mod;\n                if (s[x] == 0)\n                    (f[x][0] += f[x][1]) %= mod;\n            &#125;\n            // printf(&quot;f[%d][0] = %lld, f[%d][1] = %lld\\n&quot;, x, f[x][0], x, f[x][1]);\n            return;\n        &#125;;\n        DFS(1, -1);\n        std::cout &lt;&lt; (s[1] == m ? f[1][0] : f[1][1]) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"perm\">perm</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6407/problem/3\" class=\"uri\">http://222.180.160.110:61235/contest/6407/problem/3</a></p>\n<blockquote>\n<p>给定一个长度为 <span class=\"math inline\">\\(n\\)</span>、元素两两不同的序列，你可以交换任意两个元素。试使用最少交换次数使得序列有序，问方案数。</p>\n<p><span class=\"math inline\">\\(n\\le 10^6\\)</span>。</p>\n</blockquote>\n<p>对于一个下标，将它和它上面元素的 rank 连有向边，那么每个下标的出、入度都为 <span class=\"math inline\">\\(1\\)</span>，则图由若干个简单环组成。</p>\n<p>接着，考虑一次任意一次交换 <span class=\"math inline\">\\((x,y)\\)</span> 的操作会带来什么：</p>\n<ul>\n<li><p>若 <span class=\"math inline\">\\(x,y\\)</span> 不在同一环上：</p>\n该操作使得 <span class=\"math inline\">\\(x,y\\)</span> 所在的环合为一个大环。</li>\n<li><p>若 <span class=\"math inline\">\\(x,y\\)</span> 在同一环上：</p>\n<p>该操作使得环以 <span class=\"math inline\">\\(x,y\\)</span> 为分界线裂成两个小环。</p></li>\n</ul>\n<p>以得到 <span class=\"math inline\">\\(n\\)</span> 个自环为目标，数归得到，对于最优方案，当且仅当每次交换的目标都在同一环上。</p>\n<p>考虑方案数。把一个大小为 <span class=\"math inline\">\\(k\\)</span> 的环，欲将其拆成 <span class=\"math inline\">\\(k\\)</span> 个自环，共需 <span class=\"math inline\">\\(k-1\\)</span> 次 <em>有序</em> 的拆解。</p>\n<p>考虑 DP，令 <span class=\"math inline\">\\(f_k\\)</span> 为方案数，那么 <span class=\"math inline\">\\(f_k=\\dfrac {k\\sum\\limits_{j=1}^{k-1} f_j\\cdot f_{k-j}\\cdot C_{k-2}^j}2\\)</span>。尝试打表，（惊讶地）发现 <span class=\"math inline\">\\(f_k=k^{k-2}\\)</span>。</p>\n<p>不同的环之间的操作可以交错，看作多重集排列即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1), p(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i], p[i] = i;\n    std::sort(p.begin() + 1, p.end(), [&amp;](int i, int j) &#123; return a[i] &lt; a[j]; &#125;);\n    std::vector&lt;int&gt; f(n + 1), siz(n + 1, 1);\n    std::iota(f.begin() + 1, f.end(), 1);\n    std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;\n        return x == f[x] ? x : f[x] = find(f[x]);\n    &#125;;\n    auto merge = [&amp;](int x, int y) &#123;\n        x = find(x), y = find(y);\n        if (x != y)\n            siz[y] += siz[x], f[x] = y;\n        return;\n    &#125;;\n    for (int i = 1; i &lt;= n; ++i)\n        merge(i, p[i]);\n    std::vector&lt;long long&gt; g(n + 1), fac(n + 1), inv(n + 1);\n    g[1] = g[2] = 1ll, fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[n] = qkp(fac[n], mod - 2);\n    for (int i = n - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    for (int i = 3; i &lt;= n; ++i)\n        g[i] = qkp(i, i - 2);\n    int cnt(0);\n    auto res(1ll);\n    for (int i = 1; i &lt;= n; ++i)\n        if (f[i] == i) &#123;\n            cnt += siz[i] - 1;\n            (res *= g[siz[i]]) %= mod;\n            (res *= inv[siz[i] - 1]) %= mod;\n        &#125;\n    (res *= fac[cnt]) %= mod;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"cf2122d-traffic-lights\">CF2122D Traffic Lights</h2>\n<p><a href=\"https://codeforces.com/contest/2122/problem/D\" class=\"uri\">https://codeforces.com/contest/2122/problem/D</a></p>\n<blockquote>\n<p>给你一个由 <span class=\"math inline\">\\(n\\)</span> 个顶点和 <span class=\"math inline\">\\(m\\)</span> 条边组成的简单无向连通图。在顶点 <span class=\"math inline\">\\(1\\)</span> 有一个标记。认为初始时间为 <span class=\"math inline\">\\(t=0\\)</span>，在 <span class=\"math inline\">\\(t\\)</span> 秒后，如果标记位于点 <span class=\"math inline\">\\(u\\)</span> ，则必须执行以下操作之一：</p>\n<ul>\n<li>等待一秒。</li>\n<li>将标记沿 <span class=\"math inline\">\\(u\\)</span> 的第 <span class=\"math inline\">\\((t \\bmod \\mathrm{deg}(u) + 1)\\)</span> 条边移动，花费一秒。</li>\n</ul>\n<p>计算将标记从顶点 <span class=\"math inline\">\\(1\\)</span> 移到顶点 <span class=\"math inline\">\\(n\\)</span> 所需的最短时间，以及在使总时间最小化的同时所能达到的最短等待时间。<span class=\"math inline\">\\(m\\le 5\\times 10^5\\)</span>。</p>\n</blockquote>\n<p>能够发现这是一个边权和 dis 有关的最短路，本着分层图一类的想法，考察答案的最值。发现一个很松的上界是 <span class=\"math inline\">\\(O(m)\\)</span>；发现实际情况会比这个乐观得多，这个时候就会考虑用一些暴力做法草过去了。</p>\n<p>实际上有一个上界是 <span class=\"math inline\">\\(3n\\)</span>：取一条最短路，则不存在路径外的点，与路径上至少四个点有连边，否则可以更新最短路。设最短路长 <span class=\"math inline\">\\(k\\)</span>，让每次等待时间取满，考察答案发现为 <span class=\"math inline\">\\(2k\\)</span>（路径上点之间）、<span class=\"math inline\">\\(3(n-k)\\)</span>（路径上与路径外），共为 <span class=\"math inline\">\\(\\le 3n\\)</span>。还有一个上确界是 <span class=\"math inline\">\\(2n-3\\)</span>，可以欣赏一下 <a href=\"https://codeforces.com/blog/entry/144876?#comment-1295568\" class=\"uri\">https://codeforces.com/blog/entry/144876?#comment-1295568</a>，我没看懂 😰</p>\n<p>总之可以猜到暴力 dij 上 DP 得到…… 啊题解怎么说是 <span class=\"math inline\">\\(O(n^2+m)\\)</span> 的。原因是求得答案上界之后就能暴力模拟这个过程了 😅</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int inf = 0x3f3f3f3f;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, m;\n        std::cin &gt;&gt; n &gt;&gt; m;\n        std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n        for (int x, y; m--; ) &#123;\n            std::cin &gt;&gt; x &gt;&gt; y;\n            g[x].push_back(y), g[y].push_back(x);\n        &#125;\n        std::vector&lt;std::vector&lt;int&gt; &gt; dis(2, std::vector&lt;int&gt; (n + 1, inf));\n        dis[1][1] = 0;\n        for (int t = 0; ; ++t) &#123;\n            auto &amp;d = dis[t &amp; 1], &amp;la = dis[(t &amp; 1) ^ 1];\n            std::vector&lt;int&gt; (n + 1, inf).swap(d);\n            for (int i = 1; i &lt;= n; ++i) &#123;\n                int to = t % ((int)g[i].size());\n                d[g[i][to]] = std::min(d[g[i][to]], la[i]);\n                d[i] = std::min(d[i], la[i] + 1);\n            &#125;\n            if (d[n] != inf) &#123;\n                std::cout &lt;&lt; t + 1 &lt;&lt; &#39; &#39; &lt;&lt; d[n] &lt;&lt; &#39;\\n&#39;;\n                break;\n            &#125;\n        &#125;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"arc202a-merge-and-increment\">ARC202A Merge and Increment</h2>\n<p><a href=\"https://atcoder.jp/contests/arc202/tasks/arc202_a\" class=\"uri\">https://atcoder.jp/contests/arc202/tasks/arc202_a</a></p>\n<p>假设相邻元素全部不同，至少在当前这一步有一个很显然的策略（记为 <em>策略一</em>）是选全局最小值，把它和它左边、右边更小的一个 merge 起来。</p>\n<p>注意到如果当前全局最小值有相邻的偶数个，可以把相邻项合并一次，得到长度减半的区间，一定不劣（记为 <em>策略二</em>）；假如当前全局最小值存在相邻的奇数个，很容易注意到有两种处理方式：</p>\n<ol type=\"1\">\n<li>选取偶数个应用策略二，剩余一个应用策略一。</li>\n<li>花一步，补一个全局最小值，转化为策略二。</li>\n</ol>\n<p>很容易发现第二种方式一定不劣 😅。模拟即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n;\n        std::cin &gt;&gt; n;\n        std::vector&lt;std::pair&lt;int, int&gt; &gt; a(1);\n        &#123;\n            for (int i = 1, x; i &lt;= n; ++i) &#123;\n                std::cin &gt;&gt; x;\n                if (x != a.back().first)\n                    a.emplace_back(x, 1);\n                else\n                    ++a.back().second;\n            &#125;\n            n = (int)a.size() - 1;\n        &#125;\n        std::vector&lt;int&gt; pre(n + 2), nex(n + 1), tag(n + 1);\n        std::priority_queue&lt;std::pair&lt;int, int&gt;, std::vector&lt;std::pair&lt;int, int&gt; &gt;, std::greater&lt;std::pair&lt;int, int&gt; &gt; &gt; q;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            q.emplace(a[i].first, i);\n            pre[i] = i - 1, nex[i] = i + 1;\n        &#125;\n        nex[0] = 1, pre[n + 1] = n;\n        auto del = [&amp;](int i) &#123;\n            tag[i] = 1;\n            pre[nex[i]] = pre[i], nex[pre[i]] = nex[i];\n            return;\n        &#125;;\n        auto res(0ll);\n        for (; (int)q.size() &gt; 1;) &#123;\n            auto [x, id] = q.top();\n            q.pop();\n            if (tag[id] || a[id].first != x)\n                continue;\n            if (a[id].second == 1) &#123;\n                if (!pre[id] || (nex[id] != n + 1 &amp;&amp; a[nex[id]].first &lt;= a[pre[id]].first))\n                    res += a[nex[id]].first - x, a[id].first = a[nex[id]].first;\n                else\n                    res += a[pre[id]].first - x, a[id].first = a[pre[id]].first;\n            &#125;\n            else &#123;\n                if (a[id].second &amp; 1)\n                    ++res, ++a[id].second;\n                ++a[id].first, a[id].second /= 2;\n            &#125;\n            if (pre[id] &amp;&amp; a[id].first == a[pre[id]].first)\n                a[id].second += a[pre[id]].second, del(pre[id]);\n            if (nex[id] != n + 1 &amp;&amp; a[id].first == a[nex[id]].first)\n                a[id].second += a[nex[id]].second, del(nex[id]);\n            q.emplace(a[id].first, id);\n        &#125;\n        &#123;\n            auto [x, id] = q.top();\n            for ( ; a[id].second != 1; ) &#123;\n                if (a[id].second &amp; 1)\n                    ++res, ++a[id].second;\n                ++a[id].first, a[id].second /= 2;\n            &#125;\n        &#125;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": []
        },
        {
            "id": "https://xsc062.netlify.app/20250709/",
            "url": "https://xsc062.netlify.app/20250709/",
            "title": "练习 - DP 凸优化",
            "date_published": "2025-07-09T13:59:41.000Z",
            "content_html": "<p>Stewart’s theorem：在线段 <span class=\"math inline\">\\(AB\\)</span> 上取一点 <span class=\"math inline\">\\(M\\)</span>，使得 <span class=\"math inline\">\\(\\vec{AB}=\\lambda \\vec{AM}\\)</span>。在 <span class=\"math inline\">\\(AB\\)</span> 上方任取一点 <span class=\"math inline\">\\(P\\)</span>，则有 <span class=\"math inline\">\\(PM^2=(1-\\lambda) PA^2+\\lambda PB^2-\\lambda(1-\\lambda) AB^2\\)</span>。</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"d.-akvizna\">D. Akvizna</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6393/problem/4\" class=\"uri\">http://222.180.160.110:61235/contest/6393/problem/4</a></p>\n<p>其实到这里应该发现了，WQS 的奖励都以一次项系数出现，原因也很显然，奖励的对象是一次项系数嘛。此外，WQS 内层 DP 数组的维度都应和操作次数无关，而 DP 值应为最大收益。这个也很显然。</p>\n<p>令一轮比赛的惩罚是 <span class=\"math inline\">\\(mid\\)</span> 然后二分。令 <span class=\"math inline\">\\(f_{j}\\)</span> 表示剩余人数为 <span class=\"math inline\">\\(j\\)</span> 时的最大收益，那么有 <span class=\"math inline\">\\(f_{j}=\\max\\limits_{k\\ge j}\\left\\{f_k+\\frac {k-j}k\\right\\}-mid\\)</span>。最后在 <span class=\"math inline\">\\(f_0\\)</span> 处找答案即可。</p>\n<p>然后就发现一个很可怕的问题，内层 DP 咋写。发现把 <span class=\"math inline\">\\(\\frac {k-j}k\\)</span> 改写成 <span class=\"math inline\">\\(1-\\frac jk\\)</span> 后出现交叉项，考虑斜优。令 <span class=\"math inline\">\\(a&lt;b\\)</span>，那么 <span class=\"math inline\">\\(a\\)</span> 优于 <span class=\"math inline\">\\(b\\)</span> 当且仅当 <span class=\"math inline\">\\(\\dfrac {f_a-f_b}{\\frac 1a - \\frac 1b} &gt; j\\)</span>。维护单减的斜率即可。</p>\n<details>\n<p>笑话：二分 50 次不够，需要 60 次。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    double l = 0., r = 1e5, mid;\n    auto calc = [&amp;](double mid) &#123;\n        std::vector&lt;double&gt; f(n + 1, -1e18);\n        f[n] = 0.;\n        int h = 1, t = 0;\n        std::vector&lt;int&gt; q(n + 1), p(n + 1);\n        q[++t] = n;\n        // printf(&quot;mid = %.3lf: \\n&quot;, mid);\n        for (int i = n - 1; ~i; --i) &#123;\n            for (; h &lt; t &amp;&amp; (f[q[h + 1]] - f[q[h]]) / (1. / q[h + 1] - 1. / q[h]) &gt;= i; ++h);\n            f[i] = f[q[h]] + 1. - i * 1.0 / q[h] - mid, p[i] = p[q[h]] + 1;\n            // printf(&quot;  %d: f = %.3lf, p = %d, q[h] = %d(%.3lf / %d)\\n&quot;, i, f[i], p[i], q[h], f[q[h]], p[q[h]]);\n            if (i) &#123;\n                for (; h &lt; t &amp;&amp; (f[i] - f[q[t]]) / (1. / i - 1. / q[t]) &gt;= (f[q[t]] - f[q[t - 1]]) / (1. / q[t] - 1. / q[t - 1]); --t);\n                q[++t] = i;\n            &#125;\n        &#125;\n        // printf(&quot;res = %.3lf\\n&quot;, f[0] + p[0] * mid);\n        return std::make_pair(f[0], p[0]);\n    &#125;;\n    // calc(0.);\n    // return 0;\n    double res(0.);\n    for (int i = 1; i &lt;= 60; ++i) &#123;\n        mid = (l + r) / 2.;\n        auto t(calc(mid));\n        if (t.second &gt;= k)\n            l = mid, res = t.first + k * mid;\n        else\n            r = mid;\n    &#125;\n    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(8) &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"e.-poborcy-podatkowi\">E. Poborcy podatkowi</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6393/problem/5\" class=\"uri\">http://222.180.160.110:61235/contest/6393/problem/5</a></p>\n<p>首先令 <span class=\"math inline\">\\(f_{u,l}(i),l=0,1,2,3\\)</span> 表示在 <span class=\"math inline\">\\(u\\)</span> 上挂了长度为 <span class=\"math inline\">\\(l\\)</span> 的半条链，共有 <span class=\"math inline\">\\(i\\)</span> 条整链的最大收益。</p>\n<p>可以观察到是凸的。那么不难发现需要闵可夫斯基和，考虑 <span class=\"math inline\">\\(u\\)</span> 位置上的合并。<strong>首先需要注意到儿子上长度为 <span class=\"math inline\">\\(l\\)</span> 的链到父亲上会变成 <span class=\"math inline\">\\(l+1\\)</span></strong>。显然每条可以不选；如果选了 <span class=\"math inline\">\\(cnt_a\\)</span> 条长度为 <span class=\"math inline\">\\(a\\)</span> 的半链，那么合并出来的结果是 <span class=\"math inline\">\\(cnt_1-cnt_3\\)</span> 条长度为 <span class=\"math inline\">\\(1\\)</span> 或 <span class=\"math inline\">\\(3\\)</span> 的链、<span class=\"math inline\">\\(cnt_2\\bmod 2\\)</span> 条长度为 <span class=\"math inline\">\\(2\\)</span> 的链，并且要求两者不同时出现。发现这个东西基本上处理不了。</p>\n<p>接着注意到这个形式有点像背包。但怎么处理 <span class=\"math inline\">\\(cnt_1\\)</span> 和 <span class=\"math inline\">\\(cnt_3\\)</span> 配对的这个要求呢？有个非常精妙的在物品体积上做文章的方法：</p>\n<p>首先注意到我们最后的查询的答案肯定要求把所有儿子用完。那么不妨设体积之和为儿子总数 <span class=\"math inline\">\\(tot\\)</span>。接着，对 <span class=\"math inline\">\\(cnt_0\\)</span>（同时也是 <span class=\"math inline\">\\(cnt_4\\)</span>）没有限制，直接令其体积为 <span class=\"math inline\">\\(1\\)</span>。<span class=\"math inline\">\\(cnt_2\\)</span> 单独处理（等会儿会说），为了不对现在的问题产生影响也令其体积为 <span class=\"math inline\">\\(1\\)</span>。对于 <span class=\"math inline\">\\(cnt_1\\)</span> 和 <span class=\"math inline\">\\(cnt_3\\)</span>，显然两者平均体积需要为 <span class=\"math inline\">\\(1\\)</span>；你可以令 <span class=\"math inline\">\\(cnt_3\\)</span> 体积为 <span class=\"math inline\">\\(2\\)</span>，令 <span class=\"math inline\">\\(cnt_1\\)</span> 体积为 <span class=\"math inline\">\\(0\\)</span>。</p>\n<p>接下来就有个很好的性质：<span class=\"math inline\">\\(cnt_1\\)</span> 必须和 <span class=\"math inline\">\\(cnt_3\\)</span> 配对才能让平均体积为 <span class=\"math inline\">\\(1\\)</span>。在 <span class=\"math inline\">\\(tot\\)</span> 处查找的答案，由 <span class=\"math inline\">\\(x\\)</span> 个体积不为 <span class=\"math inline\">\\(0\\)</span> 的物品和 <span class=\"math inline\">\\(tot-x\\)</span> 个体积为 <span class=\"math inline\">\\(0\\)</span> 的物品（<span class=\"math inline\">\\(cnt_1\\)</span>）组成，原因是背包会贪心地在所有『剩余』的分组中选择体积为 <span class=\"math inline\">\\(0\\)</span> 的一项。再计算一下 <span class=\"math inline\">\\(cnt_3\\)</span>，发现显然为 <span class=\"math inline\">\\(tot-x\\)</span>。符合目的。</p>\n<p>在 <span class=\"math inline\">\\(dp_{tot}\\)</span> 处查找可以找到 <span class=\"math inline\">\\(cnt_1=cnt_3\\)</span> 时的答案；同理，在 <span class=\"math inline\">\\(dp_{tot-1},dp_{tot1+1}\\)</span> 处可以查找到 <span class=\"math inline\">\\(cnt_1=cnt_3\\pm 1\\)</span> 的答案。</p>\n<p>接下来再考虑 <span class=\"math inline\">\\(cnt_2\\)</span>，解决『<span class=\"math inline\">\\(cnt\\bmod2=1\\)</span> 和 <span class=\"math inline\">\\(cnt_1\\ne cnt_3\\)</span> 不能同时成立』的限制。那太好了，直接多开一维记录 <span class=\"math inline\">\\(cnt_2\\bmod 2\\)</span> 即可。</p>\n<p>啊啊太妙了。像利用体积为 <span class=\"math inline\">\\(-1,1\\)</span> 的随机数据背包期望最大体积不超过 <span class=\"math inline\">\\(\\sqrt V\\)</span> 的那个方法，显然就没有办法利用凸性了。所以这或许是闵可夫斯基和做法的唯一解？</p>\n<p>需要知道，如果设 <span class=\"math inline\">\\(cnt_1\\)</span> 为 <span class=\"math inline\">\\(2\\)</span> 而 <span class=\"math inline\">\\(cnt_3\\)</span> 为 <span class=\"math inline\">\\(0\\)</span>，始终会出一些问题。这个我和 yly 讨论了一下没啥结果。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst long long inf = 1e12;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(n + 1);\n    for (int i = 1, x, y, w; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;\n        g[x].emplace_back(y, w), g[y].emplace_back(x, w);\n    &#125;\n    using arr = std::vector&lt;long long&gt;;\n    std::vector&lt;arr&gt; f(n + 1, arr(4));\n    struct node &#123;\n        std::vector&lt;arr&gt; f;\n        node(): f(2) &#123;&#125;\n        node(std::vector&lt;arr&gt; f1): f(f1) &#123;&#125;\n        arr&amp; operator[](int q) &#123;\n            return f[q];\n        &#125;\n    &#125;;\n    auto getmax = [&amp;](arr p, arr q) &#123;\n        arr res(p);\n        if (q.size() &gt; p.size())\n            res.resize(q.size());\n        for (int i = 0; i &lt; (int)q.size(); ++i)\n            res[i] = std::max(res[i], q[i]);\n        return res;\n    &#125;;\n    auto merge = [&amp;](arr &amp;p, arr &amp;q) &#123;\n        arr res(p.size() + q.size() - 1), dp(p.size()), dq(q.size());\n        std::adjacent_difference(p.begin(), p.end(), dp.begin());\n        std::adjacent_difference(q.begin(), q.end(), dq.begin());\n        std::merge(dp.begin() + 1, dp.end(), dq.begin() + 1, dq.end(), res.begin() + 1, std::greater&lt;long long&gt; ());\n        res[0] = p[0] + q[0];\n        std::partial_sum(res.begin(), res.end(), res.begin());\n        return res;\n    &#125;; \n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        if ((int)g[x].size() == 1 &amp;&amp; x != 1) &#123;\n            f[x][1] = f[x][2] = f[x][3] = -inf;\n            return;\n        &#125;\n        int tot = (int)g[x].size() - (x != 1);\n        std::vector&lt;arr&gt; w1(1), w2(1);\n        for (auto [i, w] : g[x])\n            if (i != fa) &#123;\n                DFS(i, x);\n                w1.push_back(&#123; f[i][0] + w, std::max(f[i][0], f[i][3] + w), f[i][2] + w &#125;);\n                w2.push_back(&#123; -inf, f[i][1] + w &#125;);\n            &#125;\n        auto fun = [&amp;](arr &amp;p, arr &amp;q) &#123;\n            arr res(p.size() + q.size() - 1, -inf);\n            for (int ip = 0; ip &lt; 2; ++ip)\n                for (int iq = 0; iq &lt; 2; ++iq) &#123;\n                    arr tp, tq;\n                    for (int i = ip; i &lt; (int)p.size(); i += 2)\n                        tp.push_back(p[i]);\n                    for (int i = iq; i &lt; (int)q.size(); i += 2)\n                        tq.push_back(q[i]);\n                    auto t = merge(tp, tq);\n                    for (int i = 0; i &lt; (int)t.size(); ++i)\n                        if (i * 2 + ip + iq &lt; (int)res.size())\n                            res[i * 2 + ip + iq] = std::max(res[i * 2 + ip + iq], t[i]);\n                &#125;\n            return res;\n        &#125;; \n        std::function&lt;node(int, int)&gt; calc = [&amp;](int l, int r) &#123;\n            if (l == r)\n                return node(&#123; w1[l], w2[l] &#125;);\n            int mid = (l + r) &gt;&gt; 1;\n            node t1(calc(l, mid)), t2(calc(mid + 1, r));\n            return node(&#123; getmax(fun(t1[0], t2[0]), fun(t1[1], t2[1])),\n                          getmax(fun(t1[0], t2[1]), fun(t1[1], t2[0])) &#125;);\n        &#125;;\n        auto t(calc(1, tot));\n        f[x][0] = t[0][tot], f[x][1] = t[0][tot - 1], f[x][2] = t[1][tot], f[x][3] = t[0][tot + 1];\n        return;\n    &#125;;\n    DFS(1, -1);\n    std::cout &lt;&lt; f[1][0] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "DP",
                "DP 优化"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250707-1/",
            "url": "https://xsc062.netlify.app/20250707-1/",
            "title": "决策单调性",
            "date_published": "2025-07-07T13:23:01.000Z",
            "content_html": "<p>等和线：在线段 <span class=\"math inline\">\\(AB\\)</span> 上取一点 <span class=\"math inline\">\\(M\\)</span>，使得 <span class=\"math inline\">\\(\\vec{AB}=\\lambda \\vec{AM}\\)</span>。在 <span class=\"math inline\">\\(AB\\)</span> 上方任取一点 <span class=\"math inline\">\\(P\\)</span>，则有 <span class=\"math inline\">\\(\\vec{PM}=(1-\\lambda) \\vec{PA}+\\lambda \\vec{PB}\\)</span>。</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"什么是-xdyd-dp\">什么是 xD/yD DP</h2>\n<p>即 DP 数组共有 <span class=\"math inline\">\\(x\\)</span> 维，一次转移复杂度为 <span class=\"math inline\">\\(O(n^y)\\)</span>。</p>\n<p><del>为什么要给一句话单开一个标题</del></p>\n<p>下面设通式 <span class=\"math inline\">\\(f_i=\\max\\left\\{f_j+w(i,j)\\right\\}\\)</span>。</p>\n<hr />\n<h2 id=\"单调队列优化-dp\">单调队列优化 DP</h2>\n<p><span class=\"math inline\">\\(w(i,j)\\)</span> 仅包含 <span class=\"math inline\">\\(i,j\\)</span> 的最高一次项。</p>\n<ul>\n<li>如果要求 <span class=\"math inline\">\\(j\\in [1,i]\\)</span>，前缀最小值即可。</li>\n<li>若 <span class=\"math inline\">\\(j\\)</span> 的取值范围在到处乱动，可以写 DS =_=</li>\n<li><p>若 <span class=\"math inline\">\\(j\\)</span> 的取值范围 <span class=\"math inline\">\\([l,r]\\)</span> 随着 <span class=\"math inline\">\\(i\\)</span> 增大而 <span class=\"math inline\">\\(l,r\\)</span> 都不减小，那么可以使用单调队列。</p>\n<p>顺带一提，和这种的单调队列用法相似的『单调栈』主要在斜优里出现。</p></li>\n</ul>\n<p>具体过程被 grizzly bear 吃掉了 <img src=\"/em/eat.gif\" /></p>\n<h3 id=\"例单调队列优化多重背包\">例：单调队列优化多重背包</h3>\n<p>朴素的多重背包式子是 <span class=\"math inline\">\\(f_{i,j}=\\max\\left\\{f_{i-1,j-k\\times v_i}+k\\times w_i\\right\\}\\)</span>，因为 <span class=\"math inline\">\\(i\\)</span> 和整个式子无关，所以是关于 <span class=\"math inline\">\\(j\\)</span> 的 1D/1D。</p>\n<p>为了套用单调队列，需要把查询的项变成连续的。发现 <span class=\"math inline\">\\(j-k\\times v_i\\)</span> 和 <span class=\"math inline\">\\(j\\)</span> 关于 <span class=\"math inline\">\\(v_i\\)</span> 同余；且随着 <span class=\"math inline\">\\(k\\)</span> 的增大，查询的位置不断移动 <span class=\"math inline\">\\(v_i\\)</span>。那么不妨把所有 <span class=\"math inline\">\\(j\\)</span> 按照模 <span class=\"math inline\">\\(v_i\\)</span> 的余数分开做。具体地，不妨设 <span class=\"math inline\">\\(j=a\\times v_i+b\\)</span>，将 <span class=\"math inline\">\\(j-k\\times v_i\\)</span> 替换为余数写法，那么有：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nf_{i,j}&amp;=\\max\\{f_{i-1,x\\times v_i+b}+(a-x)\\times v_i\\}\\\\\n&amp;=\\max\\{f_{i-1,x\\times v_i+b}-x\\times v_i\\}+a\\times v_i\n\\end{aligned}\n\\]</span></p>\n<p>限制 <span class=\"math inline\">\\((a-x)\\)</span> 的取值不超过物品数，在不同模数下按 <span class=\"math inline\">\\(x\\)</span> 从小到大将 <span class=\"math inline\">\\(j\\)</span> 这一维进行单调队列优化即可。容易发现会不重不漏枚举所有体积；复杂度 <span class=\"math inline\">\\(O(nV)\\)</span>。</p>\n<hr />\n<h2 id=\"斜率优化-dp\">斜率优化 DP</h2>\n<p>若 <span class=\"math inline\">\\(w(i,j)\\)</span> 种含有 <span class=\"math inline\">\\(i,j\\)</span> 的交叉项，可以考虑斜优。</p>\n<p>具体过程，（如果你愿意），可以看这篇 <a href=\"/20210214/\">四年半前的博客</a>。</p>\n<p>关于符号等问题，分享一下我的做法：</p>\n<ul>\n<li><p>单调队列维护：适用于符号和右侧斜率要求单调性相反的情况。</p>\n<ul>\n<li>首先，讨论队头维护。不妨假设 <span class=\"math inline\">\\(a\\)</span> 为队头第二个元素，<span class=\"math inline\">\\(b\\)</span> 为队头第一个元素。</li>\n<li>如果队头 <span class=\"math inline\">\\(b\\)</span> 需要被弹出，说明 <span class=\"math inline\">\\(a\\)</span> 优于 <span class=\"math inline\">\\(b\\)</span>；假设式子要求 max，则用 <span class=\"math inline\">\\(a\\)</span> 转移得到的答案 &gt; 用 <span class=\"math inline\">\\(b\\)</span> 转移得到的答案。</li>\n<li>化式子，注意 <span class=\"math inline\">\\(a&gt;b\\)</span>；且负数乘除要变号。</li>\n<li><p>最后得到的式子中间的不等号就决定了需要维护的斜率单调情况。以此决定队尾维护方式即可。</p>\n<strong>注意这个式子的不等号体现的是弹出条件；保留条件和其相反</strong> <img src=\"/em/ll.gif\" /></li>\n</ul></li>\n<li><p>单调栈维护：适用于符号和右侧斜率要求单调性相同的情况；需要清楚，维护合法性、维护单调和取答案都在栈顶进行。</p>\n<ul>\n<li>首先，都知道要用单调栈了，说明斜优形式已经被化出来了；以此维护合法性即可。</li>\n<li>维护一个从底到顶，『优』得越来越小的斜率序列。找到从更优到更劣的临界点，更新答案。</li>\n</ul></li>\n</ul>\n<p>啊，果然高中文化学科是非常有用的。算是明白为什么我小学 / 初中基本没弄懂过斜优，而旁边的大佬已经在乱杀了 <img src=\"/em/hsh.gif\" /></p>\n<hr />\n<p>现在假设正在维护一个上凸包，可以进行一些思考：</p>\n<ul>\n<li><p>如果查询区间不单增？</p>\n搞不了啊这个。废了。</li>\n<li><p>查询的斜率不单增？</p>\n写个二分 + 单调栈。参见 <a href=\"https://www.luogu.com.cn/problem/P5785\">任务安排</a>、<a href=\"#例traka\">TRAKA</a>。</li>\n<li><p>加入斜率的位置不单增？</p>\n<p>李超 / CDQ / 平衡树。</p></li>\n</ul>\n<hr />\n<h2 id=\"四边形不等式优化-dp\">四边形不等式优化 DP</h2>\n<h3 id=\"关于四边形不等式\">关于四边形不等式</h3>\n<p>对于代价矩阵 <span class=\"math inline\">\\(w\\)</span> 和定义域内 <span class=\"math inline\">\\(\\forall\\,a\\le b\\le c\\le d\\)</span>，若 <span class=\"math inline\">\\(w(a,d)+w(b,c)\\ge w(a,c)+w(b,d)\\)</span>，认为 <span class=\"math inline\">\\(w\\)</span> 满足四边形不等式。简记为重叠大于交叉。</p>\n<p>命名来源是四边形对角线之和大于对边之和；将恒大于改为恒小于也能得到相似的性质。</p>\n<p>就会发现单调队列优化和斜优其实是四边形不等式的特化，导致它们可以少一个 log。</p>\n<hr />\n<h3 id=\"性质\">性质</h3>\n<p>用于证明：</p>\n<ul>\n<li>对于任意 <span class=\"math inline\">\\(c\\le l\\le r\\)</span>，若 <span class=\"math inline\">\\(w(l-c,r+c) + w(l,r)\\le w(l-c,r)+ w(l,r+c)\\)</span>，则 <span class=\"math inline\">\\(w\\)</span> 满足四边形不等式。</li>\n</ul>\n<p>用于题目：</p>\n<ul>\n<li><strong>性质一</strong>：若 <span class=\"math inline\">\\(f_i\\)</span> 满足四边形不等式（或其反式），那么最优决策点 <span class=\"math inline\">\\(p_i\\)</span> 与 <span class=\"math inline\">\\(i\\)</span> 有单调关系。</li>\n<li><strong>性质二</strong>：当 <span class=\"math inline\">\\(i\\)</span> 变化时，每个 <span class=\"math inline\">\\(j\\)</span> 带来贡献的相对大小 rank 不变。亦作：若 <span class=\"math inline\">\\(j_1\\)</span> 相对于 <span class=\"math inline\">\\(j_2\\)</span> 对 <span class=\"math inline\">\\(i\\)</span> 更优，对于任意 <span class=\"math inline\">\\(i&#39;\\)</span>，<span class=\"math inline\">\\(j_1\\)</span> 相对于 <span class=\"math inline\">\\(j_2\\)</span> 对 <span class=\"math inline\">\\(i&#39;\\)</span> 更优。</li>\n</ul>\n<hr />\n<h3 id=\"在优化-dp-之前\">在优化 DP 之前</h3>\n<ul>\n<li><p>首先我必须要提一嘴。由于我第一次接触『四边形不等式』是在四年前，看到『石子合并的 <span class=\"math inline\">\\(n^2\\)</span> 做法』时。然而，这一题的 DP 本身有一个特殊性质，即贡献是一个以决策点为极值的凸函数；这直接导致我误以为这是四边形不等式本身带来的性质，导致我在理解上浪费了很多时间。<strong>四边形不等式带来的性质，只有上述两条！</strong></p>\n当然这也告诉我们，如果你发现『贡献是一个以决策点为极值的凸函数』，你就可以用类似石子合并中的线性转移完成问题。</li>\n<li><p>『满足四边形不等式』并不能等价于『决策单调性』。决策单调性并不具备性质二。</p>\n<p>也就是说，如果只满足决策单调性，只有最优决策点是单调的，但贡献函数随着 <span class=\"math inline\">\\(i\\)</span> 的变化，其形状会有很大的变动。</p></li>\n</ul>\n<hr />\n<h3 id=\"优化-dp分治\">优化 DP：分治</h3>\n<p>主要适用于 <span class=\"math inline\">\\(f_{i}=g_j+w(j,i)\\)</span> 的场景，其中 <span class=\"math inline\">\\(g\\)</span> 是与 <span class=\"math inline\">\\(f\\)</span> 无关的函数。</p>\n<p>对于分治范围 <span class=\"math inline\">\\([l,r]\\)</span> 和其决策点范围 <span class=\"math inline\">\\([L_p,R_p]\\)</span>，首先把暴力 <span class=\"math inline\">\\(mid\\)</span> 的决策点 <span class=\"math inline\">\\(p_{mid}\\)</span> 找出来。</p>\n<p>接着对于 <span class=\"math inline\">\\([l,mid)\\)</span> 和 <span class=\"math inline\">\\((mid,R]\\)</span>，分别在 <span class=\"math inline\">\\([L_p,p_{mid}]\\)</span> 和 <span class=\"math inline\">\\([p_{mid},R_p]\\)</span> 里找决策点（注意两边都是闭的）。递归地做。</p>\n<p>这时候你肯定就会怀疑了，主播主播，虽然你的区间每次在减半，但决策点范围并不是均分的，还会被共用，复杂度真的对吗？</p>\n<p>对的兄弟，对的。观察搜索树，你会发现虽然 <span class=\"math inline\">\\(p_{mid}\\)</span> 会被给两个儿子共用，但是在任何一层中，被重复经过的点只会出现在两个区间的交界处。也就是说每整层大概遍历 <span class=\"math inline\">\\(2n\\)</span> 次。是不是很对了。</p>\n<hr />\n<h4 id=\"例yet-another-minimization-problem\">例：Yet Another Minimization Problem</h4>\n<p><a href=\"https://codeforces.com/problemset/problem/868/F\" class=\"uri\">https://codeforces.com/problemset/problem/868/F</a></p>\n<details>\n<p><summary>我的天哪！是罕见的四级标题！</summary></p>\n<p>笑点解析：这个人因为懒得写 CSS 所以只写了经常用的 h2 和 h3 的样式，现在迫不得已用 h4 被倒逼去写了 h4 的 CSS。</p>\n</details>\n<p>发现 <span class=\"math inline\">\\(k\\le 20\\)</span>，所以可以不用写 WQS 二分。令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示第 <span class=\"math inline\">\\(i\\)</span> 段分在 <span class=\"math inline\">\\(j\\)</span> 处的代价，那么有 <span class=\"math inline\">\\(f_{i,j}=\\min\\{f_{i-1,l}+w(l+1,j)\\}\\)</span>，分治解决。</p>\n<p>接着发现问题：<span class=\"math inline\">\\(w(l+1,j)\\)</span> 并不能很快地求出来；然后注意到这个代价的形式很莫队（其实在看到这个题的时候就会有莫队的想法），考虑使用莫队移动端点的方式解决问题。由于分治中查询的区间两端单增，每层的总移动次数是 <span class=\"math inline\">\\(O(n)\\)</span> 的，总复杂度就是 <span class=\"math inline\">\\(O(nk\\log n)\\)</span> 的。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst long long inf = 1e12;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::vector&lt;long long&gt; cnt(n + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; p(k + 1, std::vector&lt;int&gt; (n + 1));\n    std::vector&lt;std::vector&lt;long long&gt; &gt; f(k + 1, std::vector&lt;long long&gt; (n + 1, inf));\n    auto w = [&amp;](int l, int r) &#123;\n        static int L = 1, R = 0;\n        static long long res = 0ll;\n        for (; L &gt; l; --L, res -= cnt[a[L]] * (cnt[a[L]] - 1) / 2, ++cnt[a[L]], res += cnt[a[L]] * (cnt[a[L]] - 1) / 2);\n        for (; R &gt; r; res -= cnt[a[R]] * (cnt[a[R]] - 1) / 2, --cnt[a[R]], res += cnt[a[R]] * (cnt[a[R]] - 1) / 2, --R);\n        for (; R &lt; r; ++R, res -= cnt[a[R]] * (cnt[a[R]] - 1) / 2, ++cnt[a[R]], res += cnt[a[R]] * (cnt[a[R]] - 1) / 2);\n        for (; L &lt; l; res -= cnt[a[L]] * (cnt[a[L]] - 1) / 2, --cnt[a[L]], res += cnt[a[L]] * (cnt[a[L]] - 1) / 2, ++L);\n        return res;\n    &#125;;\n    f[0][0] = 0ll;\n    for (int t = 1; t &lt;= k; ++t) &#123;\n        std::function&lt;void(int, int, int, int)&gt; calc = [&amp;](int l, int r, int lp, int rp) &#123;\n            if (l &gt; r)\n                return;\n            if (l == r) &#123;\n                for (int i = lp; i &lt;= rp &amp;&amp; i &lt; l; ++i)\n                    if (f[t - 1][i] + w(i + 1, l) &lt; f[t][l])\n                        f[t][l] = f[t - 1][i] + w(i + 1, l), p[t][l] = i;\n                return;\n            &#125;\n            int mid = (l + r) &gt;&gt; 1;\n            for (int i = lp; i &lt;= rp &amp;&amp; i &lt; mid; ++i)\n                if (f[t - 1][i] + w(i + 1, mid) &lt; f[t][mid])\n                    f[t][mid] = f[t - 1][i] + w(i + 1, mid), p[t][mid] = i;\n            calc(l, mid - 1, lp, p[t][mid]), calc(mid + 1, r, p[t][mid], rp);\n            return;\n        &#125;;\n        calc(1, n, 0, n - 1);\n    &#125;\n    std::cout &lt;&lt; f[k][n] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"优化-dp单调数据结构\">优化 DP：单调数据结构</h3>\n<p>有的时候会出现 <span class=\"math inline\">\\(f_{i}=f_{j}+w(j,i)\\)</span> 的结构，也就是 <span class=\"math inline\">\\(f\\)</span> 的取值与自己有关。</p>\n<p>这种情况我们通常选择填表法，求出 <span class=\"math inline\">\\(f_i\\)</span> 后找到 <span class=\"math inline\">\\(i\\)</span> 是哪些点的最优决策（那么显然这些点是一段连续区间）。用 <span class=\"math inline\">\\((i,l_i,r_i)\\)</span> 这个三元组表示当前算出来的 <span class=\"math inline\">\\(i\\)</span> 管辖的范围。</p>\n<p>这是什么意思呢？结合性质二，每当我们手上拿到一个新的 <span class=\"math inline\">\\(i\\)</span>，那么推出来其管辖范围右端点就会是 <span class=\"math inline\">\\(n\\)</span>。接着想办法找到左端点，同样利用性质二，二分出最靠左的一个 <span class=\"math inline\">\\(j\\)</span>，满足之前算出来的决策点没有 <span class=\"math inline\">\\(i\\)</span> 优，那么 <span class=\"math inline\">\\([j,n]\\)</span> 就是当前条件下 <span class=\"math inline\">\\(i\\)</span> 的管辖范围。</p>\n<p>在队列里加入当前版本的整个三元组序列就可以方便地完成这个过程。为寻找当前元素的答案，需要将队头上，管辖范围完全早于当前元素的弹出去。由于维护的过程和单调队列很像，所以也有人直接把这里的队列叫单调队列。</p>\n<p>视题目不同，也可能用到单调栈，也有可能不用二分（例如满足前两种特化的情况）。goto <a href=\"/20250715/#a---yakiniku-restaurants\">Yakiniku Restaurants</a>。</p>\n<hr />\n<h4 id=\"例诗人小g\">例：诗人小G</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P1912\" class=\"uri\">https://www.luogu.com.cn/problem/P1912</a></p>\n<p><del>我觉得给出字符串内容的唯一价值是让出题人欣赏白日依山尽</del></p>\n<p>令 <span class=\"math inline\">\\(f_{j}\\)</span> 为某一行分在第 <span class=\"math inline\">\\(j\\)</span> 句处的代价，那么有 <span class=\"math inline\">\\(f_{j}=\\min\\limits_{k&lt;j}\\left\\{f_{k}+|(s_j-s_k+j-k-1)-L|^P\\right\\}\\)</span>。</p>\n<p>那么就可以考虑单调队列 + 二分了。需要注意无穷大之间的大小比较，我写这个写红温了，直接用指数项相对大小来代替了，似乎可以过。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst long long inf = 1000000000000000001ll;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;P1912_2.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, l, p;\n        std::cin &gt;&gt; n &gt;&gt; l &gt;&gt; p;\n        long long to;\n        switch (p) &#123; // 会有精度问题\n        case 1:\n            to = 1e18;\n            break;\n        case 2:\n            to = 1e9;\n            break;\n        case 3:\n            to = 1e6;\n            break;\n        case 4:\n            to = 31622;\n            break;\n        case 5:\n            to = 3981;\n            break;\n        case 6:\n            to = 1e3;\n            break;\n        case 7:\n            to = 372;\n            break;\n        case 8:\n            to = 177;\n            break;\n        case 9:\n            to = 100;\n            break;\n        default:\n            to = 63;\n            break;\n        &#125;\n        std::vector&lt;int&gt; s(n + 1);\n        std::vector&lt;std::string&gt; a(n + 1);\n        for (int i = 1; i &lt;= n; ++i)\n            std::cin &gt;&gt; a[i], s[i] = (int)a[i].length();\n        std::partial_sum(s.begin() + 1, s.end(), s.begin() + 1);\n        struct node &#123; int i, l, r; &#125;;\n        std::vector&lt;node&gt; q(n + 1);\n        int h = 0, t = -1;\n        q[++t] = &#123; 0, 1, n &#125;;\n        auto qkp = [&amp;](long long x, int y) &#123;\n            if (x &gt; to)\n                return inf;\n            auto res(1ll);\n            for (; y--; res *= x);\n            return res;\n        &#125;;\n        std::vector&lt;int&gt; pre(n + 1);\n        std::vector&lt;long long&gt; f(n + 1);\n        auto calc = [&amp;](int k, int j) &#123;\n            return std::min(inf, f[k] + qkp(std::abs(s[j] - s[k] + j - k - 1 - l), p));\n        &#125;;\n        auto less = [&amp;](int k1, int j1, int k2, int j2) &#123;\n            auto t1(calc(k1, j1)), t2(calc(k2, j2));\n            if (t1 == inf &amp;&amp; t2 == inf)\n                return std::abs(s[j1] - s[k1] + j1 - k1 - 1 - l) &lt; std::abs(s[j2] - s[k2] + j2 - k2 - 1 - l);\n            return t1 &lt; t2;\n        &#125;;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            for (; h &lt;= t &amp;&amp; q[h].r &lt; i; ++h);\n            f[i] = calc(q[h].i, i), pre[i] = q[h].i;\n            for (; h &lt;= t &amp;&amp; q[t].l &gt; i &amp;&amp; less(i, q[t].l, q[t].i, q[t].l); --t)\n                q[t - 1].r = q[t].r;\n            for (int l = std::max(q[t].l, i + 1), r = q[t].r, mid; l &lt;= r; ) &#123;\n                mid = (l + r) &gt;&gt; 1;\n                if (less(i, mid, q[t].i, mid))\n                    r = q[t].r = mid - 1, q[t + 1] = &#123; i, mid, n &#125;;\n                else\n                    l = mid + 1;\n            &#125;\n            if (q[t + 1].i == i)\n                ++t;\n        &#125;\n        if (f[n] &gt;= inf)\n            std::cout &lt;&lt; &quot;Too hard to arrange&quot; &lt;&lt; &#39;\\n&#39;;\n        else &#123;\n            std::cout &lt;&lt; f[n] &lt;&lt; &#39;\\n&#39;;\n            std::function&lt;void(int)&gt; print = [&amp;](int x) &#123;\n                if (x == 0)\n                    return;\n                print(pre[x]);\n                for (int i = pre[x] + 1; i &lt;= x; ++i) &#123;\n                    std::cout &lt;&lt; a[i];\n                    if (i != x)\n                        std::cout &lt;&lt; &#39; &#39;;\n                &#125;\n                std::cout &lt;&lt; &#39;\\n&#39;;\n                return;\n            &#125;;\n            print(n);\n        &#125;\n        std::cout &lt;&lt; &quot;--------------------&quot;;\n        if (T)\n            std::cout &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<p>需要注意，本题也可以再加一个『恰好分 <span class=\"math inline\">\\(k\\)</span> 段』的限制，直接在外层套一个 WQS 二分就好了，参见 <a href=\"https://www.luogu.com.cn/problem/P6246\">邮局 加强版 加强版</a>。</p>\n<h3 id=\"d1d-dp-优化\">2D/1D DP 优化</h3>\n<p>若存在 <span class=\"math inline\">\\(f(i,j)=\\min\\limits_{k&lt;j} f(i-1,k)+w(k+1,j)\\)</span>，且 <span class=\"math inline\">\\(w\\)</span> 满足四边形不等式：</p>\n<ul>\n<li><p>设 <span class=\"math inline\">\\(p(i,j)\\)</span> 为最优决策点，那么有 <span class=\"math inline\">\\(p(i,j)\\le p(i,j+1)\\le p(i+1,j+1)\\)</span>，亦作 <span class=\"math inline\">\\(p(i,j-1)\\le p(i,j)\\le p(i+1,j)\\)</span>。</p>\n<p>此时可以 <span class=\"math inline\">\\(O(nm)\\)</span> 解决问题：</p>\n<p><img src=\"image.png\" /></p></li>\n<li><p>若 <span class=\"math inline\">\\(i\\)</span> 固定，<span class=\"math inline\">\\(f_i(j)\\)</span> 为凸函数。（例：邮局 加强版 加强版）</p>\n<p>goto <a href=\"/20250707/\">DP 凸优化</a>。</p></li>\n</ul>\n",
            "tags": [
                "DP",
                "DP 优化"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250707/",
            "url": "https://xsc062.netlify.app/20250707/",
            "title": "DP 凸优化",
            "date_published": "2025-07-07T06:10:02.000Z",
            "content_html": "<p>袜，这篇文章一下子创建了三个新 tag。</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"什么是凸函数\">什么是凸函数</h2>\n<h3 id=\"定义\">定义</h3>\n<p>在信息学中研究的凸函数大抵是只在正整数域上有定义的，所以只能直接摒弃导函数的概念了。</p>\n<p>若斜率递增，换言之，差分数组递增，认为函数是凸的（好反直觉）。</p>\n<p>或者看看符号化的定义：若对于任意 <span class=\"math inline\">\\(\\lambda\\in[0,1]\\)</span>，函数 <span class=\"math inline\">\\(f(x)\\)</span> 均满足：</p>\n<p><span class=\"math display\">\\[\nf(\\lambda x+(1-\\lambda) y)\\le \\lambda f(x)+(1-\\lambda) f(y).\n\\]</span></p>\n<p>或等价地：</p>\n<p><span class=\"math display\">\\[\nf(x)-f(x - 1)\\le f(x + 1) - f(x)\n\\]</span></p>\n<p>那么认为 <span class=\"math inline\">\\(f\\)</span> 是凸函数。</p>\n<p>因为凹凸在性质上没区别，所以 <strong>下文施行暴政，将凹函数和凸函数统称为凸函数</strong>。</p>\n<hr />\n<h3 id=\"判定\">判定</h3>\n<p>对于具体情境下的问题，怎么判断 DP 数组是否关于其某一维为凸函数？</p>\n<ul>\n<li>相信相信的力量（最常用）。</li>\n<li><p>对于分段问题，证明分出来的每一段满足四边形不等式。</p>\n<em>值得一提的是，数学上不认为满足四边形不等式能够推出函数为凸。但这是信息学.jpg</em></li>\n<li><p>其由两个凸函数线性相加得到：</p>\n<p>对于 <span class=\"math inline\">\\(\\forall\\, \\lambda,\\mu\\ge 0\\)</span> 和凸函数 <span class=\"math inline\">\\(f,g\\)</span>，若 <span class=\"math inline\">\\(h=\\lambda f+\\mu g\\)</span>，则 <span class=\"math inline\">\\(h\\)</span> 为凸函数。</p>\n此外，此时 <span class=\"math inline\">\\(h\\)</span> 的差分数组和 <span class=\"math inline\">\\(f,g\\)</span> 差分数组也满足上述关系。</li>\n<li>其是两个凸函数的 <a href=\"#闵可夫斯基和\">闵可夫斯基和</a>。</li>\n<li><p>其由两个凸函数线性 max 得到。</p>\n<p>对于两个凸函数的线性 min，一般不是凸函数，甚至可能是凹的。</p></li>\n</ul>\n<hr />\n<h3 id=\"性质\">性质</h3>\n<ul>\n<li>最值为唯一极值。</li>\n<li>斜率 / 差分数组具有单调性。</li>\n</ul>\n<p>在解题中主要用到的大概就是上面两条。</p>\n<hr />\n<h2 id=\"wqs-二分\">WQS 二分</h2>\n<h3 id=\"主要任务\">主要任务</h3>\n<blockquote>\n<p>例：把 <span class=\"math inline\">\\(a_{1\\sim n}\\)</span> 分为恰好 <span class=\"math inline\">\\(k\\)</span> 段，每段的代价为 <span class=\"math inline\">\\(sum^2+c\\)</span>（<span class=\"math inline\">\\(c\\)</span> 为给定的常数），问最小代价。<span class=\"math inline\">\\(n\\le 2\\times 10^5,a_i\\le 10^9\\)</span>。</p>\n</blockquote>\n<p>如果对段数没有要求，可以用斜优 <span class=\"math inline\">\\(O(n)\\)</span> 做。</p>\n<p>加上了 <span class=\"math inline\">\\(k\\)</span> 的限制，DP 变成二维的，令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示在 <span class=\"math inline\">\\(i\\)</span> 处分第 <span class=\"math inline\">\\(j\\)</span> 段，可以在第一维斜率优化，做到 <span class=\"math inline\">\\(O(nk)\\)</span>；亦或发现 <span class=\"math inline\">\\((i,j)\\)</span> 有决策单调性，然后四边形不等式优化到 <span class=\"math inline\">\\(O(n^2)\\)</span>。</p>\n<p>我们发现 <span class=\"math inline\">\\(f\\)</span> 关于 <span class=\"math inline\">\\(j\\)</span> 这一维是凸的（而非上文的 <span class=\"math inline\">\\((i,j)\\)</span>），故将 <span class=\"math inline\">\\(f(n,j)\\)</span> 关于 <span class=\"math inline\">\\(j\\)</span> 的函数提取出来（记为 <span class=\"math inline\">\\(f_n(j)\\)</span>）。发现只有最高点是可以一次斜优快速求出来的，故可以认为在当前复杂度限制下，整个函数除了最高点以外都是未知的（注意可以在 DP 时记录极值点的横坐标，即分了几段）。</p>\n<p>我们给每个 <span class=\"math inline\">\\(f_n(j)\\)</span> 加上 <span class=\"math inline\">\\(\\alpha\\cdot j\\)</span>（在本题中即将 <span class=\"math inline\">\\(c\\gets c+k\\)</span>），勉强可以认为 <span class=\"math inline\">\\(\\alpha\\cdot j\\)</span> 是凸的，所以新函数 <span class=\"math inline\">\\(f&#39;_n(j)\\)</span> 也是凸的。若 <span class=\"math inline\">\\(k&gt;0\\)</span>，可以感受到极值点向左偏移，且随着 <span class=\"math inline\">\\(k\\)</span> 的增大，极值点不会右移；<span class=\"math inline\">\\(k&lt;0\\)</span> 时同理。</p>\n<p>结合几何观点，在 <span class=\"math inline\">\\(f_n\\)</span> 上的极值点可以用斜率为 <span class=\"math inline\">\\(0\\)</span> 的直线切到；而加上 <span class=\"math inline\">\\(\\alpha\\cdot j\\)</span> 的过程，其实就是切线斜率减去 <span class=\"math inline\">\\(\\alpha\\)</span> 的过程。相当于令切线斜率为 <span class=\"math inline\">\\(-\\alpha\\)</span>，看看能切到哪里。</p>\n<p>故可以二分一个合适的 <span class=\"math inline\">\\(k\\)</span>，使得极值点的横坐标为 <span class=\"math inline\">\\(k\\)</span>。此时 <span class=\"math inline\">\\(f&#39;_n(k)-\\alpha\\cdot k\\)</span> 即为待求。</p>\n<hr />\n<p>WQS 二分参与的问题一般以如下形式呈现：</p>\n<blockquote>\n<p>给定序列，将其恰好分为 <span class=\"math inline\">\\(k\\)</span> 段 / 恰好选 <span class=\"math inline\">\\(k\\)</span> 个，求最大 / 最小代价。</p>\n</blockquote>\n<p>题目要求最大 / 最小值一般能够反映函数的凹凸性，可以根据这一点来猜。</p>\n<hr />\n<h3 id=\"细节处理\">细节处理</h3>\n<p>考虑如下凸函数：</p>\n<p><img src=\"1.png\" /></p>\n<ul>\n<li>显然对于『凸出来』的点（即图中除了 <span class=\"math inline\">\\(E,H\\)</span> 以外的点），能切到的直线斜率为一个范围；而位于直线上的点（途中 <span class=\"math inline\">\\(E,H\\)</span>），能切到的直线斜率更是定死了。所以这要求你的二分精度需要略高一点。</li>\n<li><p>对于 <span class=\"math inline\">\\(E\\)</span>（或 <span class=\"math inline\">\\(H\\)</span>），不能找到只过它一点的切线。根据 DP 的写法，记录的横坐标可能是最小的 <span class=\"math inline\">\\(D\\)</span>，也可能是最大的 <span class=\"math inline\">\\(F\\)</span>，此时你可以：</p>\n<ul>\n<li>同时记录最小和最大的横坐标，看看 <span class=\"math inline\">\\(k\\)</span> 在不在中间。</li>\n<li><p>题目要求最大代价时，记录最大横坐标，二分到一个极值点 <span class=\"math inline\">\\(k&#39;\\ge k\\)</span> 时，显然 <span class=\"math inline\">\\(\\alpha&#39;\\ge \\alpha\\)</span>，用 <span class=\"math inline\">\\(f&#39;_n(k&#39;)-\\alpha&#39;\\cdot k\\)</span> 更新答案（是赋值而不是取最值）；求最小代价时同理。</p>\n<p>主要是需要记住斜率是 <span class=\"math inline\">\\(\\alpha\\)</span> 的相反数，<del>实在搞不清对应关系可以都试一试</del></p></li>\n</ul></li>\n</ul>\n<hr />\n<h3 id=\"例种树\">例：种树</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P1484\" class=\"uri\">https://www.luogu.com.cn/problem/P1484</a></p>\n<p>首先，函数是凸的——感性理解即可。</p>\n<p>接着，要求的是 <span class=\"math inline\">\\(\\le k\\)</span> 时的最值。分为两种情况：<span class=\"math inline\">\\(k\\)</span> 是否右于原函数极值点。</p>\n<ul>\n<li>若 <span class=\"math inline\">\\(k\\)</span> 右于原函数极值点，则原函数极值点为答案。</li>\n<li>否则，<span class=\"math inline\">\\(k\\)</span> 为答案。</li>\n</ul>\n<p>好消息是整数域上一定有解（最后答案为整、倒推即可），所以不用打浮点数二分了。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int lim = 1e6;\nconst long long inf = 1e18;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    std::vector&lt;long long&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    auto calc = [&amp;](int c) &#123;\n        std::vector&lt;std::pair&lt;long long, int&gt; &gt; f(n + 1);\n        auto mx = f.front();\n        auto upd = [&amp;](auto &amp;x, auto y) &#123;\n            if (y.first &gt; x.first || (y.first == x.first &amp;&amp; y.second &lt; x.second))\n                x = y;\n            return;\n        &#125;;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            f[i].first = mx.first + a[i] + c;\n            f[i].second = mx.second + 1;\n            upd(mx, f[i - 1]);\n        &#125;\n        upd(mx, f[n]);\n        return mx;\n    &#125;;\n    auto t(calc(0));\n    if (t.second &lt;= k) &#123;\n        std::cout &lt;&lt; t.first &lt;&lt; &#39;\\n&#39;;\n        return 0;\n    &#125;\n    auto res(-inf);\n    for (int l = -lim, r = lim, mid; l &lt;= r; ) &#123;\n        mid = (l + r) &gt;&gt; 1;\n        auto t = calc(mid);\n        if (t.second &lt;= k)\n            res = t.first - (long long)mid * k, l = mid + 1;\n        else\n            r = mid - 1;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"例raper\">例：Raper</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P4694\" class=\"uri\">https://www.luogu.com.cn/problem/P4694</a></p>\n<p>给所有光盘附一个奖励 <span class=\"math inline\">\\(mid\\)</span>，进行 WQS 二分。</p>\n<p>然后内层就和 <a href=\"#例序列-sequence\">sequence</a> 差得不是特别多，所以考虑反悔贪心。（？）</p>\n<p>把路过的 <span class=\"math inline\">\\(-a_j\\)</span> 丢到大根堆里，尝试和 <span class=\"math inline\">\\(b_i\\)</span> 配对。如果 <span class=\"math inline\">\\(mid-a_i-b_i\\ge 0\\)</span> 那么暂时配对，顺便把 <span class=\"math inline\">\\(b_i-mid\\)</span> 丢进去用于反悔，若 <span class=\"math inline\">\\(b_{i&#39;}\\)</span> 选中了 <span class=\"math inline\">\\(b_i-mid\\)</span> 说明反悔，将 <span class=\"math inline\">\\(a_j\\)</span> 与 <span class=\"math inline\">\\(b_{i&#39;}\\)</span> 配对。</p>\n<p>贪心的时候需要记录已经配的对数，优先队列中需要对 <span class=\"math inline\">\\(-a_j\\)</span> 和 <span class=\"math inline\">\\(b_i-mid\\)</span> 打标记进行区分，匹配到前者时才增加成功对数。</p>\n<p>发现整数域上仍然必有解（答案为整，倒推），不用打浮点数二分 neiher.</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst long long inf = 2e9 + 5;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    std::vector&lt;int&gt; a(n + 1), b(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; b[i];\n    auto calc = [&amp;](long long mid) &#123;\n        std::priority_queue&lt;std::pair&lt;long long, int&gt; &gt; q;\n        int cnt = 0;\n        auto res(0ll);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            q.emplace(-a[i], 1);\n            auto [v, ty] = q.top();\n            if (mid + v - b[i] &gt;= 0) &#123;\n                q.pop(), cnt += ty;\n                res += mid + v - b[i], q.emplace(b[i] - mid, 0);\n            &#125;\n        &#125;\n        return std::make_pair(cnt, res);\n    &#125;;\n    auto res(inf);\n    for (long long l = 1ll, r = inf, mid; l &lt;= r; ) &#123;\n        mid = (l + r) &gt;&gt; 1;\n        auto t(calc(mid));\n        if (t.first &gt;= k)\n            r = mid - 1, res = -(t.second - k * mid);\n        else\n            l = mid + 1;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"区间分拆问题\">区间分拆问题</h3>\n<p>目标：尝试将 <span class=\"math inline\">\\(a_{1\\sim n}\\)</span> 分割成恰好 <span class=\"math inline\">\\(k\\)</span> 段，定义 <span class=\"math inline\">\\(w(i,j)\\)</span> 为将 <span class=\"math inline\">\\([i,j]\\)</span> 作为一段的代价，求代价最值。其中 <span class=\"math inline\">\\(w(i,j)\\)</span> 满足四边形不等式。</p>\n<p>不妨设求最小代价。定义 <span class=\"math inline\">\\(f(i,j)\\)</span> 在 <span class=\"math inline\">\\(i\\)</span> 处分第 <span class=\"math inline\">\\(j\\)</span> 段，那么有：</p>\n<p><span class=\"math display\">\\[\nf(i,j)=\\min(f(i-1,p-1)+w(p,j)).\n\\]</span></p>\n<blockquote>\n<p>有定理：若 <span class=\"math inline\">\\(w(i,j)\\)</span> 满足四边形不等式，那么有 <span class=\"math inline\">\\(f(i-1,j)\\le f(i,j)\\le f(i,j+1)\\)</span>，从 <span class=\"math inline\">\\(f\\)</span> 定义出发很好感性理解。</p>\n</blockquote>\n<p>那么可以从这一点出发，<span class=\"math inline\">\\(p\\)</span> 这一维就可以被摊掉，做到 <span class=\"math inline\">\\(O(n(n+m))\\)</span>。</p>\n<blockquote>\n<p>有定理：若 <span class=\"math inline\">\\(w(i,j)\\)</span> 满足四边形不等式，那么 <span class=\"math inline\">\\(f_i(j)\\)</span> 是凸函数。</p>\n</blockquote>\n<p>那很好了。直接冲刺 WQS 即可。</p>\n<hr />\n<h2 id=\"闵可夫斯基和\">闵可夫斯基和</h2>\n<p>给定两个凸函数（当然是指 OI 中那种长得很直的函数），将它们的『边』拆下来过后，以某种方式拼在一起，使得最后得到一个新的凸函数。</p>\n<p>按每条『边』的斜率归并一下就可以得到，显然答案存在且唯一，这个过程被称为闵可夫斯基和。可以发现这是一种最值 - 加卷积。</p>\n<p>假设我们要求的 DP 数组是两个已知的子数组以类似的方法卷起来的，最后要求完整的 DP 数组（而非 WQS 中的单点值），就可以考虑闵可夫斯基和。</p>\n<p>发现这个结构是很适合归并的，使用归并要求状态中含有版本维、因变量维。</p>\n<hr />\n<h3 id=\"例its-mooin-time-p\">例：It's Mooin' Time P</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P11459\" class=\"uri\">https://www.luogu.com.cn/problem/P11459</a></p>\n<p>定义 <span class=\"math inline\">\\(w_i\\)</span> 为将 <span class=\"math inline\">\\([i,i+L)\\)</span> 改为 <code>MOO</code> 的代价，问题转化为选取 <span class=\"math inline\">\\(1\\sim \\frac nL\\)</span> 个不重区间的最小代价和。</p>\n<p>尝试归并，每次将 <span class=\"math inline\">\\([l,mid]\\)</span> 和 <span class=\"math inline\">\\((mid, r]\\)</span> 卷起来。但是会有一点问题：如果恰好有区间卡在中间呢？</p>\n<p>可以令 <span class=\"math inline\">\\(f_{l,r,0/1/2,0/1/2}(i)\\)</span> 表示在 <span class=\"math inline\">\\([l,r]\\)</span> 内选了 <span class=\"math inline\">\\(i\\)</span> 个 <code>MOO</code>，且两侧最远的被选点距离端点为 <span class=\"math inline\">\\(0/1/\\ge 2\\)</span> 的 DP 值。然后可以进行相应的讨论、平移、闵可夫斯基和，最后将所有情况线性取 max 得到这一层的答案，容易发现得到的答案也是凸的。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst long long inf = 1e18;\nint L;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; L &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1);\n    std::vector&lt;char&gt; t(n + 1);\n    std::vector&lt;long long&gt; w(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; t[i];\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    for (int i = 1; i &lt;= n - L + 1; ++i) &#123;\n        w[i] = a[i] * (t[i] != &#39;M&#39;);\n        for (int j = i + 1; j &lt; i + L; ++j)\n            w[i] += a[j] * (t[j] != &#39;O&#39;);\n        // printf(&quot;[%d, %d]: %lld\\n&quot;, i, i + L - 1, w[i]);\n    &#125;\n    if (L == 1) &#123;\n        std::sort(w.begin() + 1, w.end());\n        auto s(0ll);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            s += w[i];\n            std::cout &lt;&lt; s &lt;&lt; &#39;\\n&#39;;\n        &#125;\n        return 0;\n    &#125;\n    using arr = std::vector&lt;long long&gt;;\n    using brr = std::vector&lt;arr&gt;;\n    using crr = std::vector&lt;brr&gt;;\n    struct node &#123;\n        crr f;\n        node(int len): f(L, brr(L, arr(len, inf))) &#123;\n            for (int i = 0; i &lt; L; ++i)\n                for (int j = 0; j &lt; L; ++j)\n                    f[i][j][0] = 0ll;\n            return;\n        &#125;\n        brr&amp; operator[] (int q) &#123; return f[q]; &#125;\n    &#125;;\n    auto upd = [&amp;](arr &amp;x, arr y) &#123;\n        if (x.size() &lt; y.size())\n            x.resize(y.size(), inf);\n        for (int i = 0; i &lt; (int)y.size(); ++i)\n            x[i] = std::min(x[i], y[i]);\n        return;\n    &#125;;\n    auto merge = [&amp;](arr l, arr r) &#123;\n        arr out((int)(l.size() + r.size()) - 1), dl(l.size()), dr(r.size());\n        for (int i = 1; i &lt; (int)l.size(); ++i)\n            dl[i] = l[i] - l[i - 1];\n        for (int i = 1; i &lt; (int)r.size(); ++i)\n            dr[i] = r[i] - r[i - 1];\n        std::merge(dl.begin() + 1, dl.end(), dr.begin() + 1, dr.end(), out.begin() + 1);\n        out[0] = l[0] + r[0];\n        std::partial_sum(out.begin(), out.end(), out.begin());\n        return out;\n    &#125;;\n    std::function&lt;node(int, int)&gt; calc = [&amp;](int l, int r) &#123;\n        if (r - l + 1 &lt; 2 * L) &#123;\n            node res(1);\n            for (int ll = 0; ll &lt; L; ++ll)\n                for (int rr = 0; rr &lt; L; ++rr)\n                    if (l + ll &lt;= r - rr - L + 1) &#123;\n                        res[ll][rr].resize(2, inf);\n                        for (int i = l + ll; i &lt;= r - rr - L + 1; ++i)\n                            res[ll][rr][1] = std::min(res[ll][rr][1], w[i]);\n                        // printf(&quot;[%d, %d]: (%d, %d) = %lld\\n&quot;, l, r, ll, rr, res[ll][rr][1]);\n                    &#125;\n            // for (int i = 0; i &lt; L; ++i)\n            //     if (l + i + L - 1 &lt;= r) &#123;\n            //         printf(&quot;[%d, %d]: (%d, %d) = %lld\\n&quot;, l, r, i, r - (l + i + L - 1), w[l + i]);\n            //         res[i][r - (l + i + L - 1)].emplace_back(w[l + i]);\n            //     &#125;\n            return res;\n        &#125;   \n        int mid = (l + r) &gt;&gt; 1;\n        node tl(calc(l, mid)), tr(calc(mid + 1, r)), res((r - l + 1) / L + 1);\n        for (int ll = 0; ll &lt; L; ++ll)\n            for (int rr = 0; rr &lt; L; ++rr)\n                res[ll][rr] = merge(tl[ll][0], tr[0][rr]);\n        for (int ll = 0; ll &lt; L; ++ll)\n            for (int rr = 0; rr &lt; L; ++rr)\n                for (int i = 1; i &lt; L &amp;&amp; i &lt; mid; ++i)\n                    upd(res[ll][rr], merge(merge(tl[ll][i], tr[L - i][rr]), &#123; 0, w[mid - i + 1] &#125;));\n        for (int ll = 0; ll &lt; L; ++ll)\n            for (int rr = L - 1; rr; --rr)\n                upd(res[ll][rr - 1], res[ll][rr]);\n        for (int rr = 0; rr &lt; L; ++rr)\n            for (int ll = L - 1; ll; --ll)\n                upd(res[ll - 1][rr], res[ll][rr]);\n        // for (int i = 0; i &lt; L; ++i)\n        //     for (int j = 0; j &lt; L; ++j) &#123;\n        //         printf(&quot;  (%d, %d): &quot;, i, j);\n        //         for (auto p : res[i][j])\n        //             printf(&quot;%lld &quot;, p);\n        //         puts(&quot;&quot;);\n        //     &#125;\n        return res;\n    &#125;;\n    auto res(calc(1, n));\n    for (int i = 1; i &lt;= n / L; ++i)\n        std::cout &lt;&lt; res[0][0][i] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"例假人\">例：假人</h3>\n<p><a href=\"http://222.180.160.110:61235/problem/47728\" class=\"uri\">http://222.180.160.110:61235/problem/47728</a></p>\n<p>令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示前 <span class=\"math inline\">\\(i\\)</span> 组选完占了 <span class=\"math inline\">\\(j\\)</span> 体积的最大价值。那么有 <span class=\"math inline\">\\(f_{i,j}=\\max\\{f_{i-1,k}+a_{i,j-k}\\}\\)</span>。</p>\n<p><em>袜，这个东西好凸的样子！啊？居然不是凸的？</em></p>\n<p>事实上，有结论：若干个体积为 <span class=\"math inline\">\\(0\\sim 4\\)</span> 的物品做背包，可以凑出值域内任意 <span class=\"math inline\">\\(24\\)</span> 的倍数。所以先把体积全部 <span class=\"math inline\">\\(-1\\)</span>，然后就可以得到体积为 <span class=\"math inline\">\\(0\\sim 4\\)</span> 的物品。然后会发现他们按照模 <span class=\"math inline\">\\(12\\)</span> 的余数分别是凸的。</p>\n<p>能感受到恶意了。然后就可以枚举体积，再闵可夫斯基和了。同样需要在状态中引入作为版本号的 <span class=\"math inline\">\\([l,r]\\)</span> 维，显然因变量是体积、版本号是组数。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst long long inf = 1e18;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;fake2.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m = 0;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; siz(n + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; siz[i], m += siz[i];\n        a[i].resize(siz[i] + 1);\n        for (int j = 1; j &lt;= siz[i]; ++j)\n            std::cin &gt;&gt; a[i][j];\n    &#125;\n    using arr = std::vector&lt;long long&gt;;\n    struct node &#123;\n        std::vector&lt;arr&gt; f;\n        node(): f(12) &#123;&#125;\n        arr &amp;operator[] (int q) &#123;\n            return f[q];\n        &#125;\n    &#125;;\n    auto merge = [&amp;](arr &amp;p, arr &amp;q) &#123;\n        arr res((int)(p.size() + q.size()) - 1), dp(p.size()), dq(q.size());\n        std::adjacent_difference(p.begin(), p.end(), dp.begin());\n        std::adjacent_difference(q.begin(), q.end(), dq.begin());\n        std::merge(dp.begin() + 1, dp.end(), dq.begin() + 1, dq.end(), res.begin() + 1, std::greater&lt;long long&gt; ());\n        res[0] = p[0] + q[0];\n        std::partial_sum(res.begin(), res.end(), res.begin());\n        return res;\n    &#125;;\n    auto upd = [&amp;](arr y, arr &amp;x, int tag) &#123;\n        if (tag)\n            y.insert(y.begin(), -inf);\n        if (y.size() &gt; x.size())\n            x.resize(y.size(), -inf);\n        for (int i = 0; i &lt; (int)y.size(); ++i)\n            x[i] = std::max(x[i], y[i]);\n        return;\n    &#125;;\n    std::function&lt;node(int, int)&gt; calc = [&amp;](int l, int r) &#123;\n        if (l == r) &#123;\n            node res;\n            for (int i = 1; i &lt;= siz[l]; ++i)\n                res[i - 1].push_back(a[l][i]);\n            return res;\n        &#125;\n        int mid = (l + r) &gt;&gt; 1;\n        node tl(calc(l, mid)), tr(calc(mid + 1, r)), res;\n        for (int p = 0; p &lt; 12; ++p)\n            for (int q = 0; q &lt; 12; ++q)\n                if (!tl[p].empty() &amp;&amp; !tr[q].empty())\n                    upd(merge(tl[p], tr[q]), res[(p + q) % 12], p + q &gt;= 12);\n        return res;\n    &#125;;\n    auto res(calc(1, n));\n    for (int i = 0; i &lt;= m - n; ++i)\n        std::cout &lt;&lt; res[i % 12][i / 12] &lt;&lt; &#39; &#39;;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"slope-trick\">slope trick</h2>\n<p>对于一个 OI 中的凸函数，它是由一些斜率单调的线段拼接成的图形。</p>\n<p>在这个前提下，发现可以用整个函数的左 / 右端点值（截距）和 <span class=\"math inline\">\\((n-1)\\)</span> 个斜率 / 差分信息描述函数。而这有时比直接维护 <span class=\"math inline\">\\(n\\)</span> 个点值有着更优美的性质，唤其为 slope trick。</p>\n<p>例如，关于斜率序列，如果定义域不大，可以直接维护；如果它的变化次数不多，可以利用它的单调性质，用单调数据结构维护；如果它的值域很小，可以直接维护拐点。</p>\n<p>注意前两种方法一般关注横坐标对应的函数值，所以自变量一般是和操作次数一类有关的；而这里关注函数最值而弱化了具体横坐标，操作次数一般会作为待最优化的因变量，例如：</p>\n<ul>\n<li>我想要将数列通过若干次单点修改使序列单调，但不关心序列最终形态，问最小操作次数。</li>\n<li>我想要让树上所有叶子到根的路径边权和相等，但不关心这个值是多少，问最小操作次数。</li>\n</ul>\n<p>下面依次解决上述问题。</p>\n<hr />\n<h3 id=\"例序列-sequence\">例：序列 sequence</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P4597\" class=\"uri\">https://www.luogu.com.cn/problem/P4597</a></p>\n<p>暴力地，令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示 <span class=\"math inline\">\\(a_i\\)</span> 最终被修改为 <span class=\"math inline\">\\(j\\)</span>，容易写出 DP 式子 <span class=\"math inline\">\\(f_{i,j}=\\min\\limits_{k\\le j}\\{f_{i-1,k}\\}+|a_i-j|\\)</span>。</p>\n<p>然后就会发现它的定义域实在是太大了！那如果关注斜率的变化情况呢？</p>\n<p>令 <span class=\"math inline\">\\(f_{i-1}(k)\\)</span> 的极值点为 <span class=\"math inline\">\\(k_m\\)</span>，分类讨论拆绝对值和 min：</p>\n<ul>\n<li><p>当 <span class=\"math inline\">\\(j\\le a_i\\)</span> 时，<span class=\"math inline\">\\(f_i(j)=\\min\\limits_{k\\le j}\\{f_{i-1}(k)\\}+a_i - j\\)</span>。</p>\n<ul>\n<li>当 <span class=\"math inline\">\\(j &lt; k_m\\)</span> 时，<span class=\"math inline\">\\(f_i(j)=f_{i-1}(j)+a_i-j\\)</span>，斜率相对于 <span class=\"math inline\">\\(f_{i-1}(j)\\)</span> 整体减 <span class=\"math inline\">\\(1\\)</span>。<del>我就说导数没白学吧</del></li>\n<li>当 <span class=\"math inline\">\\(j \\ge k_m\\)</span> 时，<span class=\"math inline\">\\(f_i(j)=f_{i-1}(k_m)+a_i-j\\)</span>，斜率为 <span class=\"math inline\">\\(-1\\)</span>。</li>\n</ul></li>\n<li><p>当 <span class=\"math inline\">\\(j &gt; a_i\\)</span> 时，<span class=\"math inline\">\\(f_i(j)=\\min\\limits_{k\\le j}\\{f_{i-1}(k)\\}+j-a_i\\)</span>。</p>\n<ul>\n<li>当 <span class=\"math inline\">\\(j &lt; k_m\\)</span> 时，<span class=\"math inline\">\\(f_i(j)=f_{i-1}(j)+j-a_i\\)</span>，斜率相对于 <span class=\"math inline\">\\(f_{i-1}(j)\\)</span> 整体加 <span class=\"math inline\">\\(1\\)</span>。</li>\n<li>当 <span class=\"math inline\">\\(j\\ge k_m\\)</span> 时，<span class=\"math inline\">\\(f_i(j) = f_{i-1}(k_m)+j-a_i\\)</span>，斜率为 <span class=\"math inline\">\\(1\\)</span>。</li>\n</ul></li>\n</ul>\n<p>如果现在我们掏一个支持区间加斜率、区间推平斜率且维护区间函数最值点的数据结构，那就太逆天了。一个经典的解决方案是用堆维护线段斜率的差分（也就是差分的差分）。</p>\n<p>发现整体修改次数是 <span class=\"math inline\">\\(O(n)\\)</span> 的，且如果只看比 <span class=\"math inline\">\\(k_m\\)</span> 更左的 <span class=\"math inline\">\\(j\\)</span>（更靠右的已经与极值无关所以不用维护），那么就只需要维护区间减法。</p>\n<p>如果将一次区间前缀减法看作一次前缀右端点入队，显然左侧某点 <span class=\"math inline\">\\(a\\)</span> 的实际被减次数为 <span class=\"math inline\">\\(a\\)</span> 入队的次数 + 所有右于 <span class=\"math inline\">\\(a\\)</span> 点的元素的入队次数。用大根堆维护这些元素，就可以快速维护整个斜率序列。例如 <code>3 2 2 1</code>，代表 <span class=\"math inline\">\\(3\\)</span> 处斜率为 <span class=\"math inline\">\\(-1\\)</span>，<span class=\"math inline\">\\(2\\)</span> 处斜率为 <span class=\"math inline\">\\(-3\\)</span>，<span class=\"math inline\">\\(1\\)</span> 处斜率为 <span class=\"math inline\">\\(-4\\)</span>。</p>\n<ul>\n<li><p>当 <span class=\"math inline\">\\(a_i\\ge k_m\\)</span> 时（容易发现它会成为新的 <span class=\"math inline\">\\(k_m\\)</span>），直接把 <span class=\"math inline\">\\(a_i\\)</span> 加入大根堆，就可以把 <span class=\"math inline\">\\(\\le a_i\\)</span> 的所有位置斜率减去 <span class=\"math inline\">\\(1\\)</span>。</p>\n什么你问在 <span class=\"math inline\">\\(k_m\\)</span> 和 <span class=\"math inline\">\\(a_i\\)</span> 之间的推平怎么办？由于唯一右于它们的拐点 <span class=\"math inline\">\\(a_i\\)</span> 入了一次队，所以中间的元素斜率自然是 <span class=\"math inline\">\\(-1\\)</span> 啊。</li>\n<li><p>当 <span class=\"math inline\">\\(a_i&lt;k_m\\)</span> 时，我们需要：</p>\n<ol type=\"1\">\n<li>将 <span class=\"math inline\">\\(a_i\\)</span> 以左的位置斜率减去 <span class=\"math inline\">\\(1\\)</span>，直接将 <span class=\"math inline\">\\(a_i\\)</span> 入队即可。</li>\n<li>将 <span class=\"math inline\">\\(a_i\\)</span> 和 <span class=\"math inline\">\\(k_m\\)</span> 之间的位置斜率加上 <span class=\"math inline\">\\(1\\)</span>，把 <span class=\"math inline\">\\(k_m\\)</span> 弹出（太好了就在队首）再把 <span class=\"math inline\">\\(a_i\\)</span> 加入即可。由于 <span class=\"math inline\">\\(k_m\\)</span> 显然是一个拐点，所以删除 <span class=\"math inline\">\\(k_m\\)</span> 并非虚空索敌，但注意 <span class=\"math inline\">\\(k_m\\)</span> 可能会变化成其后继。</li>\n</ol></li>\n</ul>\n<p>其实就会发现还有一些有趣的小性质，比如 <span class=\"math inline\">\\(k_m\\)</span> 与队首等价（用于实现）；<span class=\"math inline\">\\(k_m\\)</span> 右侧斜率全部为 <span class=\"math inline\">\\(1\\)</span>，也是唯一可以取到的正斜率。</p>\n<details>\n<p>袜写起来好简单。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1);\n    long long res = 0ll;\n    std::priority_queue&lt;int&gt; q;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        if (i == 1 || a[i] &gt;= q.top())\n            q.push(a[i]);\n        else &#123;\n            res += q.top() - a[i];\n            q.pop(), q.push(a[i]), q.push(a[i]);\n        &#125;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"例烟花表演\">例：烟花表演</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P3642\" class=\"uri\">https://www.luogu.com.cn/problem/P3642</a></p>\n<p>设 <span class=\"math inline\">\\(f_{u,d}\\)</span> 表示在 <span class=\"math inline\">\\(u\\)</span> 子树中所有叶子距根均为 <span class=\"math inline\">\\(d\\)</span> 的最小代价。那么有：</p>\n<p><span class=\"math display\">\\[\nf_{u,d}=\\sum\\limits_{(v, w)\\in u}\\min\\limits_{0\\le w&#39;\\le d}\\{f_{v,d-w&#39;}+|w-w&#39;|\\}.\n\\]</span></p>\n<p>可以归纳证明 <span class=\"math inline\">\\(f_{u,d}\\)</span> 为凸；和上一题相似地，考虑用 <span class=\"math inline\">\\(f_v\\)</span> 的堆得到 <span class=\"math inline\">\\(f_u\\)</span> 的堆。</p>\n<p>首先最外层是一个线性加，这其实就是把差分数组 / 斜率加起来，放到我们这个堆里面就是合并两个堆。虽然你可能和我一样不认识可并堆，但是你可以和我一样不会 pd_ds。</p>\n<p>再看内层，发现和上一题长得像但其实不一样，呜呜呜。发现 <span class=\"math inline\">\\(|w-w&#39;|\\)</span> 是一个左右斜率分别为 <span class=\"math inline\">\\(-1,1\\)</span> 的分段函数，而左边类比可得斜率最大为 <span class=\"math inline\">\\(1\\)</span>。</p>\n<p>由闵可夫斯基和，内层函数斜率 <span class=\"math inline\">\\(&lt;-1\\)</span> 的部分来自 <span class=\"math inline\">\\(f_{v,d-w&#39;}\\)</span>；<span class=\"math inline\">\\(=-1\\)</span> 的部分来自 <span class=\"math inline\">\\(f_{v,d-w&#39;}\\)</span> 和 <span class=\"math inline\">\\(|w-w&#39;|\\)</span> 的左半边（感谢 <span class=\"math inline\">\\(w&#39;\\)</span> 是有下确界的）；<span class=\"math inline\">\\(=0\\)</span> 的部分来自 <span class=\"math inline\">\\(f_{v,d-w&#39;}\\)</span>；<span class=\"math inline\">\\(&gt;0\\)</span> 的部分我们不关心。</p>\n<p>最终函数图像的变化：水平部分的左端点右移了 <span class=\"math inline\">\\(w\\)</span>。找到 <span class=\"math inline\">\\(f_{v,d}\\)</span> 中的水平线段和斜率为 <span class=\"math inline\">\\(1\\)</span> 的线段，令其在堆中的值 <span class=\"math inline\">\\(+w\\)</span> 就能达到平移的目的。</p>\n<p>但需要注意，此时仍然需要 <strong>保留内层函数中斜率为 <span class=\"math inline\">\\(1\\)</span> 的部分，但斜率 <span class=\"math inline\">\\(&gt;1\\)</span> 的部分被删除</strong>。原因如下：</p>\n<ul>\n<li>绝对值函数与内层函数定义域相同，作闵可夫斯基和后，斜率为 <span class=\"math inline\">\\(1\\)</span> 的右侧线段会将 <span class=\"math inline\">\\(f_{v,d-w&#39;}\\)</span> 中原有的 <span class=\"math inline\">\\(&gt;1\\)</span> 的部分『挤』出定义域，故可以将其直接删除。</li>\n<li>斜率为 <span class=\"math inline\">\\(1\\)</span> 的部分，虽然对内层函数中极值点无贡献，但在外层函数中极值点可能向右偏移，此时会对其产生影响，需要维护。</li>\n</ul>\n<p>容易发现由于 <span class=\"math inline\">\\(w&#39;\\)</span> 的取值上限是 <span class=\"math inline\">\\(d\\)</span>，但 <span class=\"math inline\">\\(d\\)</span> 没有上界，所以每个内层函数的右侧都一定是一条斜率为 <span class=\"math inline\">\\(1\\)</span> 的射线；也就是说，每个外层函数一定有（儿子个数）个拐点（堆中元素），弹出这么多个就可以删除外层函数中斜率 <span class=\"math inline\">\\(&gt;1\\)</span> 的线段，顺便找到斜率为 <span class=\"math inline\">\\(0\\)</span> 和 <span class=\"math inline\">\\(1\\)</span> 的线段。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\n#include &lt;ext/pb_ds/priority_queue.hpp&gt;\nconst int inf= 0x3f3f3f3f;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m, n += m;\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(n + 1);\n    auto res(0ll);\n    for (int i = 2, fa, w; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; fa &gt;&gt; w, res += w;\n        g[fa].emplace_back(i, w);\n    &#125;\n    std::vector&lt;__gnu_pbds::priority_queue&lt;long long&gt; &gt; q(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        if (g[x].empty())\n            q[x].push(0), q[x].push(0);\n        else\n            for (auto [i, w] : g[x]) &#123;\n                DFS(i);\n                for (int j = 1; j &lt; (int)g[i].size(); ++j)\n                    q[i].pop();\n                long long t1 = q[i].top(), t0;\n                q[i].pop(), t0 = q[i].top(), q[i].pop();\n                q[i].push(t1 + w), q[i].push(t0 + w);\n                q[x].join(q[i]);\n            &#125;\n        // fprintf(stderr, &quot;size(%d) = %d\\n&quot;, x, (int)q[x].size());\n        return;\n    &#125;;\n    DFS(1);\n    for (int i = 1; i &lt;= (int)g[1].size(); ++i)\n        q[1].pop();\n    for (; !q[1].empty(); q[1].pop())\n        res -= q[1].top();\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"例buy-low-sell-high\">例：Buy Low Sell High</h3>\n<p><a href=\"https://codeforces.com/problemset/problem/865/D\" class=\"uri\">https://codeforces.com/problemset/problem/865/D</a></p>\n<p>令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示在第 <span class=\"math inline\">\\(i\\)</span> 天结束后持有 <span class=\"math inline\">\\(j\\)</span> 支股票的最大收益。则 <span class=\"math inline\">\\(f_{i,j}=\\max\\{f_{i-1,j},f_{i-1,j-1}-a_i,f_{i-1,j+1}+a_i\\}\\)</span>。</p>\n<p>（由于这里和 max 有关所以需要精细描述凹凸了）发现就是把三个（可能）经过平移的（可能）凹的函数做线性 max。虽然实际上的结论『函数在整点上是凹的』不算太显然，但是可以猜是凹的。</p>\n<p>线性 max 在 slope trick 中是不太能体现的，但我们发现这里是同一个凹函数向左上、右下平移同一个向量，希望得到新的凹函数不管是从差分角度还是图象，都能得到新函数由左上部分斜率 <span class=\"math inline\">\\(&gt;-a_i\\)</span> 的线段、两段斜率 <span class=\"math inline\">\\(=-a_i\\)</span> 的线段、右下部分斜率 <span class=\"math inline\">\\(&lt;-a_i\\)</span> 的线段组成。此外，由于向左上平移的函数有一处离开了定义域，还需将其剔除。</p>\n<p>值得注意的是，当 <span class=\"math inline\">\\(-a_i\\)</span> 比最小斜率还要小时会有变化，可以画图看一下。</p>\n<p><img src=\"2.png\" /></p>\n<p>发现定义域是相对小的（<span class=\"math inline\">\\(0\\le j\\le n\\)</span>），故用优先队列维护整个斜率序列就可以快速插入两个 <span class=\"math inline\">\\(k=-a_i\\)</span> 的线段。容易发现顶点在 <span class=\"math inline\">\\(j=0\\)</span> 处取得（从图象和定义都易知），最右侧是只买不卖的最劣方案，可以倒推。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1);\n    auto res = 0ll;\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i], res -= a[i];\n    std::priority_queue&lt;int&gt; q;\n    q.push(-a[1]);\n    for (int i = 2; i &lt;= n; ++i)\n        if (a[i] &lt; -q.top())\n            q.push(-a[i]);\n        else\n            q.pop(), q.push(-a[i]), q.push(-a[i]);\n    for (; !q.empty(); res -= q.top(), q.pop());\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "DP",
                "反悔贪心",
                "DP 优化",
                "WQS 二分",
                "闵可夫斯基和",
                "slope trick"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250612/",
            "url": "https://xsc062.netlify.app/20250612/",
            "title": "点分治",
            "date_published": "2025-06-12T09:18:55.000Z",
            "content_html": "<p>一时兴起在博客里搜索『点分治』，发现没有匹配项。</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"定义\">定义</h2>\n<p>适用于解决和点对、路径相关的问题。</p>\n<p>对于任意点 <span class=\"math inline\">\\(x\\)</span>，树上任意简单路径 <span class=\"math inline\">\\((u,v)\\)</span> 被分为几类：</p>\n<ol type=\"1\">\n<li>不经过 <span class=\"math inline\">\\(x\\)</span>。</li>\n<li>经过 <span class=\"math inline\">\\(x\\)</span>：\n<ul>\n<li>一个端点为 <span class=\"math inline\">\\(x\\)</span>。</li>\n<li>两个端点都不为 <span class=\"math inline\">\\(x\\)</span>：可以由上一种情况拼接得到。</li>\n</ul></li>\n</ol>\n<p>如果我们把每个点作为 <span class=\"math inline\">\\(x\\)</span> 的情况都枚举一遍，再统计不重复的 <span class=\"math inline\">\\((u,v)\\)</span>，在一种特定的枚举顺序下可以做到 <span class=\"math inline\">\\(O(n\\log n)\\)</span> 完成所有点对的枚举。</p>\n<p>证明略，每次取子树重心，只遍历没遍历过的点即可。</p>\n<p>关于子树重心，一则阅读材料：<a href=\"https://liu-cheng-ao.blog.uoj.ac/blog/2969\">一种基于错误的寻找重心方法的点分治的复杂度分析</a>。</p>\n<hr />\n<h2 id=\"cf1575e-eye-pleasing-city-park-tour\">CF1575E Eye-Pleasing City Park Tour</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1575/E\" class=\"uri\">https://codeforces.com/problemset/problem/1575/E</a></p>\n<p>随便用线段树维护一下就行了。复杂度 <span class=\"math inline\">\\(O(n\\log^2 n)\\)</span>。</p>\n<details>\n<p>随便维护一下 <img src=\"/em/ll.gif\" /></p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(n + 1);\n    for (int i = 1, x, y, c; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; c;\n        g[x].emplace_back(y, c), g[y].emplace_back(x, c);\n    &#125;\n    std::vector&lt;std::vector&lt;std::pair&lt;int, long long&gt; &gt; &gt; bit(2, std::vector&lt;std::pair&lt;int, long long&gt; &gt; (n + 1));\n    auto lowbit = [&amp;](int x) &#123;\n        return x &amp; -x;\n    &#125;;\n    auto add = [&amp;](int id, int x, long long v, int type) &#123;\n        for (++x; x &lt;= n; x += lowbit(x))\n            bit[id][x].first += type, (bit[id][x].second += v * type) %= mod;\n        return;\n    &#125;;\n    auto ask = [&amp;](int id, int x) &#123;\n        std::pair&lt;int, long long&gt; res;\n        for (++x; x; x -= lowbit(x))\n            res.first += bit[id][x].first, (res.second += bit[id][x].second) %= mod;\n        return res;\n    &#125;;\n    std::vector&lt;int&gt; p, siz(n + 1), mx(n + 1), tag(n + 1);\n    std::function&lt;void(int, int)&gt; findp = [&amp;](int x, int fa) &#123;\n        p.push_back(x);\n        siz[x] = 1, mx[x] = 0;\n        for (auto [i, c] : g[x])\n            if (i != fa &amp;&amp; !tag[i]) &#123;\n                findp(i, x);\n                siz[x] += siz[i];\n                mx[x] = std::max(mx[x], siz[i]);\n            &#125;\n        return;\n    &#125;;\n    auto findrt = [&amp;](int x) &#123;\n        std::vector&lt;int&gt;().swap(p), findp(x, -1);\n        int n = (int)p.size();\n        for (auto i : p)\n            if (mx[i] &lt;= n / 2 &amp;&amp; n - siz[i] &lt;= n / 2)\n                return i;\n        return -1;\n    &#125;;\n    auto res(0ll);\n    std::function&lt;void(int, int, int, int, int, long long, int, int)&gt; calc = [&amp;](int x, int fa, int oc, int la, int cnt, long long s, int os, int type) &#123;\n        if (cnt &gt; k)\n            return;\n        if (type == 0) &#123;\n            auto t0(ask(oc, k - cnt)), t1(ask(!oc, k - cnt - 1));\n            // auto lr(res);\n            (res += t0.first * (s - os) + t0.second) %= mod;\n            (res += t1.first * (s - os) + t1.second) %= mod;\n            // printf(&quot;  %d(%d, %lld): ask[0](%d) = (%d, %lld), ask[1](%d) = (%d, %lld), res += %lld\\n&quot;, x, cnt, s - os, k - cnt, t0.first, t0.second, k - cnt - 1, t1.first, t1.second, res - lr);\n        &#125;\n        else if (type != 0) &#123;\n            // printf(&quot;  %d(%d, %lld): add(%d, %lld)\\n&quot;, x, cnt, s - os, oc, s * type);\n            add(oc, cnt, s, type);\n        &#125;\n        for (auto [i, c] : g[x])\n            if (i != fa &amp;&amp; !tag[i])\n                calc(i, x, oc, c, cnt + (la != c), (s + a[i]) % mod, os, type);\n        return;\n    &#125;;\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        x = findrt(x);\n        // printf(&quot;DFS %d\\n&quot;, x);\n        for (auto [i, c] : g[x])\n            if (!tag[i]) &#123;\n                calc(i, x, c, c, 0, (a[x] + a[i]) % mod, a[x], 0);\n                calc(i, x, c, c, 0, (a[x] + a[i]) % mod, a[x], 1);\n            &#125;\n        (res += ask(0, k).second + ask(1, k).second) %= mod;\n        (res += a[x]) %= mod;\n        // printf(&quot;res += %lld + %lld\\n&quot;, ask(0, k).second, ask(1, k).second);\n        for (auto [i, c] : g[x])\n            if (!tag[i])\n                calc(i, x, c, c, 0, (a[x] + a[i]) % mod, a[x], -1);\n        // assert(!ask(0, k).second);\n        tag[x] = 1;\n        for (auto [i, c] : g[x])\n            if (!tag[i])\n                DFS(i);\n        return;\n    &#125;;\n    DFS(1);\n    std::cout &lt;&lt; (res + mod) % mod &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"a---三元图-graf\">A - 三元图 Graf</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P10829\" class=\"uri\">https://www.luogu.com.cn/problem/P10829</a></p>\n<p>发现很圆方树；观察题图，肯定想要把中间的方点作为树根。</p>\n<p>发现它就是重心；进一步地，整个圆方树其实是一个点分治的结构。显然除了最后一层，每次找到的重心都应该是方点；并且其应该有三个等大的儿子。check 上述两点即可。</p>\n<p>唉还是挺常规的，限制我做出来这道题的应该是我已经 &gt; 1y 没写过连通性问题了 😅</p>\n<details>\n<p>怎么还有人不会判重边的 😅</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1), _g(n + 1);\n    auto nosol = [](void) &#123;\n        std::cout &lt;&lt; &quot;ne&quot; &lt;&lt; &#39;\\n&#39;;\n        exit(0);\n        return;\n    &#125;;\n    std::set&lt;std::pair&lt;int, int&gt; &gt; t;\n    for (int x, y; m--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        if (x == y || t.count(&#123; x, y &#125;))\n            nosol();\n        t.insert(&#123; x, y &#125;), t.insert(&#123; y, x &#125;);\n        _g[x].push_back(y), _g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; st, dfn(n + 1), low(n + 1);\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        static int now = 0;\n        st.push_back(x);\n        dfn[x] = low[x] = ++now;\n        for (auto i : _g[x])\n            if (!dfn[i]) &#123;\n                DFS(i, x);\n                low[x] = std::min(low[x], low[i]);\n                if (low[i] &gt;= dfn[x]) &#123;\n                    ++n, g.emplace_back();\n                    for (int p = st.back(); ; p = st.back()) &#123;\n                        g[n].push_back(p), g[p].push_back(n);\n                        st.pop_back();\n                        if (p == i)\n                            break;\n                    &#125;\n                    g[n].push_back(x), g[x].push_back(n);\n                &#125;\n            &#125;\n            else if (i != fa)\n                low[x] = std::min(low[x], dfn[i]);\n        return;\n    &#125;;\n    int n1 = n;\n    DFS(1, -1);\n    std::vector&lt;int&gt; siz(n + 1), p, mx(n + 1), tag(n + 1);\n    DFS = [&amp;](int x, int fa) &#123;\n        siz[x] = 1, mx[x] = 0;\n        p.push_back(x);\n        for (auto i : g[x])\n            if (i != fa &amp;&amp; !tag[i]) &#123;\n                DFS(i, x);\n                siz[x] += siz[i];\n                mx[x] = std::max(mx[x], siz[i]);\n            &#125;\n        return;\n    &#125;;\n    auto findrt = [&amp;](int x) &#123;\n        p.clear(), DFS(x, -1);\n        int n = (int)p.size();\n        for (auto i : p)\n            if (mx[i] &lt;= n / 2 &amp;&amp; n - siz[i] &lt;= n / 2)\n                return i;\n        return -1;\n    &#125;;\n    std::function&lt;void(int)&gt; DFS1 = [&amp;](int x) &#123;\n        x = findrt(x), DFS(x, -1);\n        int si = -1, cnt = 0;\n        if (siz[x] == 1) &#123;\n            if (x &gt; n1)\n                nosol();\n            return;\n        &#125;\n        if (x &lt;= n1)\n            nosol();\n        for (auto i : g[x])\n            if (!tag[i]) &#123;\n                ++cnt;\n                if (~si &amp;&amp; si != siz[i])\n                    nosol();\n                if (si == -1)\n                    si = siz[i];\n            &#125;\n        if (cnt != 3)\n            nosol();\n        tag[x] = 1;\n        for (auto i : g[x])\n            if (!tag[i])\n                DFS1(i);\n        return;\n    &#125;; \n    DFS1(1);\n    std::cout &lt;&lt; &quot;da&quot; &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---distance-on-triangulation\">B - Distance on Triangulation</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P6976\" class=\"uri\">https://www.luogu.com.cn/problem/P6976</a></p>\n<p>众（除了我）所周知 <a href=\"/20231117/#经典建模\">凸多边形的三角剖分可以转化为树上问题</a>，故把树建出来；一个重要的点是要认识到这个树的意义。树上的点其实是没什么物理含义的；经过了某一个树上的点和经过了三角形上的任一点是等价的；也就是说，想要从某个点走到另一个点，肯定要经过对应的树上路径，但这不能反应实际距离什么的，只是能获取路径可能包含的点和必须包含的点（的超集），具体还是要最短路。</p>\n<p>接着转化为点分治。但其实这里的点分治有点像序列分治：先跑一遍根节点（三个）在当前分治范围内的最短路，然后处理经过了这个点的询问，然后递归。容易发现三个点里有一些之前被算过了，且一定包含了这个分治范围，直接跳过就行了。</p>\n<p>注意询问要写成整体二分那种动态下传的形式，只把被某个子树完全包含的询问传下去；不然复杂度是错的。以及这样就可以剪枝：发现询问数组空了就可以停了。直接 TLE to 200ms 了 😅</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; deg(n + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; _g(n + 1), g(n + 1);\n    for (int i = 1; i &lt; n; ++i) &#123;\n        _g[i].push_back(i + 1), _g[i + 1].push_back(i);\n        ++deg[i], ++deg[i + 1];\n    &#125;\n    _g[1].push_back(n), _g[n].push_back(1);\n    ++deg[1], ++deg[n];\n    for (int i = 1, x, y; i &lt;= n - 3; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        _g[x].push_back(y), _g[y].push_back(x);\n        ++deg[x], ++deg[y];\n    &#125;\n    int cnt = 0;\n    std::vector&lt;std::vector&lt;int&gt; &gt; t(1);\n    &#123;\n        std::queue&lt;int&gt; q;\n        std::vector&lt;int&gt; inq(n + 1);\n        for (int i = 1; i &lt;= n; ++i)\n            if (deg[i] == 2)\n                q.push(i);\n        std::map&lt;std::pair&lt;int, int&gt;, int&gt; st;\n        for (; !q.empty(); ) &#123;\n            int x = q.front();\n            q.pop(), inq[x] = 1;\n            if (deg[x] == 2) &#123;\n                ++cnt, t.push_back(&#123; x &#125;);\n                for (auto i : _g[x])\n                    if (!inq[i]) &#123;\n                        t[cnt].push_back(i);\n                    &#125;\n                std::sort(t[cnt].begin(), t[cnt].end());\n                for (int a = 0; a &lt; 2; ++a)\n                    for (int b = a + 1; b &lt; 3; ++b) &#123;\n                        std::pair&lt;int, int&gt; now(t[cnt][a], t[cnt][b]);\n                        if (st.count(now)) &#123;\n                            int to = st[now];\n                            // printf(&quot;add %d &lt;-&gt; %d\\n&quot;, to, cnt);\n                            g[cnt].push_back(to), g[to].push_back(cnt);\n                        &#125;\n                        else\n                            st[now] = cnt;\n                    &#125;\n            &#125;\n            for (auto i : _g[x])\n                if (--deg[i] == 2)\n                    q.push(i);\n        &#125;\n    &#125;\n    int q;\n    std::cin &gt;&gt; q;\n    std::vector&lt;int&gt; res(q + 1, 0x3f3f3f3f);\n    std::vector&lt;std::tuple&lt;int, int, int&gt; &gt; u(q);\n    for (int i = 1, x, y; i &lt;= q; ++i)\n        std::cin &gt;&gt; x &gt;&gt; y, u[i - 1] = &#123; x, y, i &#125;;\n    int tik = 0;\n    std::vector&lt;int&gt; siz(cnt + 1), mx(cnt + 1), p, now(n + 1), p1;\n    std::vector&lt;int&gt; dis(n + 1), tag(n + 1), vis(n + 1), faa(n + 1);\n    std::function&lt;void(int, int)&gt; DFS1 = [&amp;](int x, int fa) &#123;\n        siz[x] = 1, mx[x] = 0;\n        p.push_back(x);\n        for (auto i : t[x])\n            now[i] = tik, p1.push_back(i);\n        for (auto i : g[x])\n            if (i != fa &amp;&amp; !tag[i]) &#123;\n                DFS1(i, x);\n                siz[x] += siz[i];\n                mx[x] = std::max(mx[x], siz[i]);\n            &#125;\n        return;\n    &#125;;\n    auto findrt = [&amp;](int x) &#123;\n        p.clear(), p1.clear(), DFS1(x, -1);\n        int n = (int)p.size();\n        for (auto i : p)\n            if (mx[i] &lt;= n / 2 &amp;&amp; n - siz[i] &lt;= n / 2)\n                return i;\n        return -1;\n    &#125;;\n    auto BFS = [&amp;](int x) &#123;\n        std::queue&lt;int&gt; q;\n        for (auto i : p1)\n            dis[i] = 0x3f3f3f3f;\n        q.push(x), dis[x] = 0;\n        for (; !q.empty(); ) &#123;\n            int x = q.front();\n            q.pop();\n            for (auto i : _g[x])\n                if (dis[i] == 0x3f3f3f3f &amp;&amp; now[i] == tik)\n                    dis[i] = dis[x] + 1, q.push(i);\n        &#125;\n        return;\n    &#125;;\n    std::function&lt;void(int, int, int)&gt; calc = [&amp;](int x, int fa, int rt) &#123;\n        for (auto i : t[x])\n            faa[i] = rt;\n        for (auto i : g[x])\n            if (i != fa &amp;&amp; !tag[i])\n                calc(i, x, rt);\n        return;\n    &#125;;\n    std::vector&lt;std::vector&lt;std::tuple&lt;int, int, int&gt; &gt; &gt; tmp(n + 1);\n    std::function&lt;void(int, std::vector&lt;std::tuple&lt;int, int, int&gt; &gt;)&gt; DFS = [&amp;](int x, std::vector&lt;std::tuple&lt;int, int, int&gt; &gt; q) &#123;\n        if (q.empty())\n            return;\n        ++tik, x = findrt(x);\n        for (auto i : g[x])\n            calc(i, x, i);\n        for (auto k : t[x])\n            if (!vis[k]) &#123;\n                vis[k] = 1, BFS(k);\n                for (auto [u, v, id] : q)\n                    res[id] = std::min(res[id], dis[u] + dis[v]);\n            &#125;\n        for (auto [u, v, id] : q)\n            if (faa[u] == faa[v])\n                tmp[faa[u]].emplace_back(u, v, id);\n        std::vector&lt;std::tuple&lt;int, int, int&gt; &gt;().swap(q);\n        tag[x] = 1;\n        for (auto i : g[x])\n            if (!tag[i])\n                DFS(i, std::move(tmp[i]));\n        return;\n    &#125;;\n    DFS(1, std::move(u));\n    for (int i = 1; i &lt;= q; ++i)\n        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---shopping\">C - Shopping</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P6326\" class=\"uri\">https://www.luogu.com.cn/problem/P6326</a></p>\n<p>意识到连通块 DP 也是可以放在点分上做的，令 <span class=\"math inline\">\\(f_{u,i}\\)</span> 表示在（点分时的）子树 <span class=\"math inline\">\\(u\\)</span> 中，<span class=\"math inline\">\\(u\\)</span> 选了至少一个，共用了 <span class=\"math inline\">\\(i\\)</span> 体积的最大价值。剩下就是一个树上的多重 + 01 背包；发现这个 01 背包不满足可以优化的形式，所以考虑树上背包序列化，转换成序列上多重背包问题；不知道真实数据强度，但我认为应该用 <a href=\"/20250707-1/#例单调队列优化多重背包\">单调队列优化多重背包</a>。</p>\n<p>注意树背包序列化的细节其实是有点多的。可能需要一些邪思。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int inf = 0x3f3f3f3f;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, m;\n        std::cin &gt;&gt; n &gt;&gt; m;\n        std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n        std::vector&lt;int&gt; v(n + 1), w(n + 1), c(n + 1);\n        for (int i = 1; i &lt;= n; ++i)\n            std::cin &gt;&gt; w[i];\n        for (int i = 1; i &lt;= n; ++i)\n            std::cin &gt;&gt; v[i];\n        for (int i = 1; i &lt;= n; ++i)\n            std::cin &gt;&gt; c[i];\n        for (int i = 1, x, y; i &lt; n; ++i) &#123;\n            std::cin &gt;&gt; x &gt;&gt; y;\n            g[x].push_back(y), g[y].push_back(x);\n        &#125;\n        std::vector&lt;int&gt; siz(n + 1), mx(n + 1), tag(n + 1), p;\n        std::function&lt;void(int, int)&gt; DFS1 = [&amp;](int x, int fa) &#123;\n            p.push_back(x);\n            siz[x] = 1, mx[x] = 0;\n            for (auto i : g[x])\n                if (i != fa &amp;&amp; !tag[i]) &#123;\n                    DFS1(i, x);\n                    siz[x] += siz[i];\n                    mx[x] = std::max(mx[x], siz[i]);\n                &#125;\n            return;\n        &#125;;\n        int now = 0;\n        std::vector&lt;int&gt; nex(n + 1), tab(n + 1);\n        auto findrt = [&amp;](int x) &#123;\n            p.clear(), DFS1(x, -1);\n            int n = (int)p.size();\n            for (auto i : p)\n                if (mx[i] &lt;= n / 2 &amp;&amp; n - siz[i] &lt;= n / 2)\n                    return i;\n            assert(0);\n            return -1;\n        &#125;;\n        std::function&lt;void(int, int)&gt; DFS2 = [&amp;](int x, int fa) &#123;\n            tab[++now] = x;\n            for (auto i : g[x])\n                if (i != fa &amp;&amp; !tag[i])\n                    DFS2(i, x);\n            nex[x] = now;\n            return;\n        &#125;;\n        int res = -inf;\n        std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n            x = findrt(x), now = 0, DFS2(x, -1);\n            std::vector&lt;std::vector&lt;int&gt; &gt; f(now + 1, std::vector&lt;int&gt; (m + 1, -inf));\n            for (int i = 1; i &lt;= c[x] &amp;&amp; i * v[x] &lt;= m; ++i)\n                f[1][i * v[x]] = i * w[x];\n            for (int i = 1; i &lt; now; ++i) &#123;\n                int V = v[tab[i + 1]], W = w[tab[i + 1]], C = c[tab[i + 1]];\n                for (int b = 0; b &lt; V; ++b) &#123;\n                    std::vector&lt;int&gt; q;\n                    int h = 0, t = -1;\n                    for (int a = 0; a * V + b &lt;= m; ++a) &#123;\n                        for (; h &lt;= t &amp;&amp; a - q[h] &gt; C; ++h);\n                        if (h &lt;= t &amp;&amp; f[i][q[h] * V + b] != -inf)\n                            f[i + 1][a * V + b] = std::max(f[i + 1][a * V + b], f[i][q[h] * V + b] + (a - q[h]) * W);\n                        for (; h &lt;= t &amp;&amp; f[i][a * V + b] - a * W &gt;= f[i][q[t] * V + b] - q[t] * W; --t);\n                        q.resize(++t + 1), q[t] = a;\n                    &#125;\n                &#125;\n                int to = nex[tab[i + 1]];\n                for (int j = 0; j &lt;= m; ++j)\n                    f[to][j] = std::max(f[to][j], f[i][j]);\n            &#125;\n            res = std::max(res, *std::max_element(f[now].begin(), f[now].end()));\n            std::vector&lt;std::vector&lt;int&gt; &gt;().swap(f);\n            tag[x] = 1;\n            for (auto i : g[x])\n                if (!tag[i])\n                    DFS(i);\n            return;\n        &#125;;\n        DFS(1);\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d---加油站\">D - 加油站</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P10805\" class=\"uri\">https://www.luogu.com.cn/problem/P10805</a></p>\n<p>点分治后分为 <span class=\"math inline\">\\(u\\to rt\\)</span> 和 <span class=\"math inline\">\\(rt\\to v\\)</span> 两个部分考虑。前者只需要倍增找到第一次加油的点即可；后者需要对于每个点作为加油站的情况，统计起点个数。</p>\n<p>具体地，需要分类讨论：若 <span class=\"math inline\">\\(d(rt,v)&lt;k\\)</span>，说明<strong>上次加油一定不在当前子树内</strong>；在根节点上登记的加油站中统计走得到 <span class=\"math inline\">\\(fa_v\\)</span> 但走不到 <span class=\"math inline\">\\(v\\)</span> 的，就可以找到 <span class=\"math inline\">\\(fa_v\\)</span> 作为加油站对应的起点个数。对 <span class=\"math inline\">\\(d(rt,v)\\ge k\\)</span>，只需要倍增找到上一次加油的点即可找到 <span class=\"math inline\">\\(fa_v\\)</span> 的答案。</p>\n<p>说着很轻巧，实现着很恶心。摆了。</p>\n<hr />\n<h2 id=\"e---首都\">E - 首都</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P7215\" class=\"uri\">https://www.luogu.com.cn/problem/P7215</a></p>\n<p>启示我们点分治处理的问题不一是与『树结构』强相关者；也可以仅利用点分治划分出来的块，例如『若超出当前块，则一定不优』之类的。</p>\n<p>本题的该性质通过分讨是好证的；所以直接每个块内暴力即可。复杂度 <span class=\"math inline\">\\(O(n\\log n)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1), t(k + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; col(n + 1), mx(n + 1), siz(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; col[i];\n        t[col[i]].push_back(i);\n    &#125;\n    std::vector&lt;int&gt; tag(n + 1), p, tik(n + 1), faa(n + 1), vis(n + 1), book(k + 1);\n    std::function&lt;void(int, int)&gt; DFS1 = [&amp;](int x, int fa) &#123;\n        siz[x] = 1, mx[x] = 0;\n        p.push_back(x), tik[x] = 1;\n        for (auto i : g[x])\n            if (!tag[i] &amp;&amp; i != fa) &#123;\n                DFS1(i, x);\n                siz[x] += siz[i];\n                mx[x] = std::max(mx[x], siz[i]);\n            &#125;\n        return;\n    &#125;;\n    auto findrt = [&amp;](int x) &#123;\n        p.clear(), DFS1(x, -1);\n        int n = (int)p.size();\n        for (auto i : p)\n            if (mx[i] &lt;= n / 2 &amp;&amp; n - siz[i] &lt;= n / 2)\n                return i;\n        assert(0);\n        return -1;\n    &#125;;\n    std::function&lt;void(int)&gt; DFS2 = [&amp;](int x) &#123;\n        for (auto i : g[x])\n            if (!tag[i] &amp;&amp; i != faa[x])\n                faa[i] = x, DFS2(i);\n        return;\n    &#125;;\n    int res = 0x3f3f3f3f;\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        x = findrt(x);\n        faa[x] = -1, DFS2(x);\n        std::queue&lt;int&gt; q;\n        q.push(col[x]), book[col[x]] = 1;\n        int cnt = 0;\n        for (; !q.empty(); ) &#123;\n            int f = q.front();\n            q.pop();\n            for (auto i : t[f])\n                if (tik[i]) \n                    for (int p = i; ~p &amp;&amp; !vis[p]; p = faa[p]) &#123;\n                        vis[p] = 1;\n                        if (!book[col[p]]) &#123;\n                            if (++cnt &gt;= res)\n                                goto outo;\n                            q.push(col[p]), book[col[p]] = 1;\n                        &#125;\n                    &#125;\n                else\n                    goto outo;\n        &#125;\n        res = cnt;\n        // printf(&quot;x = %d: cnt = %d\\n&quot;, x, cnt);\n    outo:\n        for (auto i : p)\n            vis[i] = tik[i] = book[col[i]] = 0;\n        tag[x] = 1;\n        for (auto i : g[x])\n            if (!tag[i])\n                DFS(i);\n        return;\n    &#125;;\n    DFS(1);\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;    \n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"f---开店\">F - 开店</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P3241\" class=\"uri\">https://www.luogu.com.cn/problem/P3241</a></p>\n<p>转化问题，原问题即求解权值在 <span class=\"math inline\">\\([L,R]\\)</span> 间的元素到 <span class=\"math inline\">\\(u\\)</span> 的距离和。</p>\n<p>一般求解距离的方法是找到 LCA 后计算，考虑如果不利用树上 LCA，而是利用点分树上 LCA 如何计算。分讨易证得点分树上 LCA 一定在两点路径上。</p>\n<p>储存点分树上每个点到其每个祖先的距离，就可以方便地计算任意两点间距离。接下来处理原问题的弱化：对于每个 <span class=\"math inline\">\\(u\\)</span> 求解其到树上所有点距离和。显然这是一个类似换根的问题，随便做即可。</p>\n<p>现在需要在线地解决原问题。<strong>可以用 vector 存储这一层所有点的权值与深度信息，按权值排序后二分查询</strong>。复杂度 <span class=\"math inline\">\\(O(n\\log^2 n)\\)</span>。实现的时候应该可以注意到原题限制点度数对复杂度的保证。</p>\n<details>\n<p>打起来的时候感觉很史，但实际上调得比大多数题快。</p>\n<p>大概懂得为什么经常看大佬写游记做到史题的实现预期都是『一遍过』了。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst long long inf = 1e18;\nconst int maxn = 1.5e5 + 5;\nstd::vector&lt;std::pair&lt;int, int&gt; &gt; g[maxn];\nint top[maxn], siz[maxn], fa[maxn], son[maxn], dep[maxn], dis[maxn];\nvoid DFS1(int x) &#123;\n    siz[x] = 1;\n    for (auto [i, w] : g[x])\n        if (i != fa[x]) &#123;\n            fa[i] = x;\n            dep[i] = dep[x] + 1, dis[i] = dis[x] + w;\n            DFS1(i);\n            siz[x] += siz[i];\n            if (siz[i] &gt; siz[son[x]])\n                son[x] = i;\n        &#125;\n    return;\n&#125;\nvoid DFS2(int x) &#123;\n    if (son[x])\n        top[son[x]] = top[x], DFS2(son[x]);\n    for (auto [i, w] : g[x])\n        if (i != fa[x] &amp;&amp; i != son[x])\n            top[i] = i, DFS2(i);\n    return;\n&#125;\nint ask(int x, int y) &#123;\n    int sx = x, sy = y;\n    for (; top[x] != top[y]; x = fa[top[x]])\n        if (dep[top[x]] &lt; dep[top[y]])\n            std::swap(x, y);\n    x = dep[x] &lt; dep[y] ? x : y;\n    return dis[sx] + dis[sy] - 2 * dis[x];\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, q, A;\n    std::cin &gt;&gt; n &gt;&gt; q &gt;&gt; A;\n    std::vector&lt;int&gt; c(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; c[i];\n    for (int i = 1, x, y, w; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;\n        g[x].emplace_back(y, w), g[y].emplace_back(x, w);\n    &#125;\n    DFS1(1), DFS2(1);\n    std::vector&lt;int&gt; mx(n + 1), siz(n + 1), p, tag(n + 1);\n    std::function&lt;void(int, int)&gt; DFS1 = [&amp;](int x, int fa) &#123;\n        siz[x] = 1, mx[x] = 0;\n        p.push_back(x);\n        for (auto [i, w] : g[x])\n            if (!tag[i] &amp;&amp; i != fa) &#123;\n                DFS1(i, x);\n                siz[x] += siz[i];\n                mx[x] = std::max(mx[x], siz[i]);\n            &#125;\n        return;\n    &#125;;\n    auto findrt = [&amp;](int x) &#123;\n        p.clear(), DFS1(x, -1);\n        int n = (int)p.size();\n        for (auto i : p)\n            if (mx[i] &lt;= n / 2 &amp;&amp; n - siz[i] &lt;= n / 2)\n                return i;\n        assert(0);\n        return -1;\n    &#125;;\n    std::vector&lt;int&gt; dis(n + 1);\n    std::vector&lt;std::array&lt;std::vector&lt;std::pair&lt;int, long long&gt; &gt;, 3&gt; &gt; t(n + 1);\n    std::function&lt;void(int, int, std::vector&lt;std::pair&lt;int, long long&gt; &gt;&amp;)&gt; DFS2 = [&amp;](int x, int fa, std::vector&lt;std::pair&lt;int, long long&gt; &gt; &amp;t) &#123;\n        t.emplace_back(c[x], dis[x]);\n        for (auto [i, w] : g[x])\n            if (!tag[i] &amp;&amp; i != fa) &#123;\n                dis[i] = dis[x] + w;\n                DFS2(i, x, t);\n            &#125;\n        return;\n    &#125;;\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; to(n + 1);\n    std::function&lt;std::pair&lt;int, int&gt; (int)&gt; DFS = [&amp;](int x) &#123;\n        x = findrt(x);\n        int ret = dis[x];\n        for (int j = 0; j &lt; (int)g[x].size(); ++j) &#123;\n            auto [i, w] = g[x][j];\n            if (!tag[i]) &#123;\n                dis[i] = w;\n                DFS2(i, x, t[x][j]);\n                std::sort(t[x][j].begin(), t[x][j].end());\n                // printf(&quot;[%d, %d]: %d(%lld)&quot;, x, j, t[x][j][0].first, t[x][j][0].second);\n                for (int k = 1; k &lt; (int)t[x][j].size(); ++k) &#123;\n                    t[x][j][k].second += t[x][j][k - 1].second;\n                    // printf(&quot; %d(%lld)&quot;, t[x][j][k].first, t[x][j][k].second);\n                &#125;\n                // puts(&quot;&quot;);\n            &#125;\n        &#125;\n        tag[x] = 1;\n        for (int j = 0; j &lt; (int)g[x].size(); ++j) &#123;\n            auto [i, w] = g[x][j];\n            if (!tag[i]) &#123;\n                auto [rt, d] = DFS(i);\n                to[rt] = &#123; x, j &#125;;\n            &#125;\n        &#125;\n        return std::make_pair(x, ret);\n    &#125;;\n    int rt = DFS(1).first;\n    std::vector&lt;std::vector&lt;int&gt; &gt; fd(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        int now = i;\n        for (;; now = to[now].first) &#123;\n            fd[i].push_back(ask(now, i));\n            if (now == rt)\n                break;\n        &#125;\n    &#125;\n    for (int u, a, b; q--; ) &#123;\n        static long long la = 0ll;\n        std::cin &gt;&gt; u &gt;&gt; a &gt;&gt; b;\n        int l = std::min((a + la) % A, (b + la) % A), r = std::max((a + la) % A, (b + la) % A);\n        // printf(&quot;ask %d, [%d, %d]\\n&quot;, u, l, r);\n        auto ask = [&amp;](int x, int j) &#123;\n            auto res(0ll);\n            int cnt = 0, p = 0;\n            p = std::lower_bound(t[x][j].begin(), t[x][j].end(), std::make_pair(l, -1ll)) - t[x][j].begin();\n            cnt -= p;\n            if (p != 0)\n                res -= t[x][j][p - 1].second;\n            p = std::upper_bound(t[x][j].begin(), t[x][j].end(), std::make_pair(r, inf)) - t[x][j].begin();\n            cnt += p;\n            if (p != 0)\n                res += t[x][j][p - 1].second;\n            return std::make_pair(res, cnt);\n        &#125;;\n        la = ask(u, 0).first + ask(u, 1).first + ask(u, 2).first;\n        // int U = u;\n        for (auto d = ++fd[u].begin(); u != rt; ++d) &#123;\n            auto [fa, k] = to[u];\n            // fprintf(stderr, &quot;u = %d, fa = %d, d = %d\\n&quot;, U, fa, *d);\n            for (int j = 0; j &lt; 3; ++j)\n                if (j != k) &#123;\n                    auto [len, cnt] = ask(fa, j);\n                    la += len + (long long)cnt * *d;\n                &#125;\n            if (c[fa] &gt;= l &amp;&amp; c[fa] &lt;= r)\n                la += *d;\n            u = fa;\n        &#125;\n        std::cout &lt;&lt; la &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "点分治"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250603/",
            "url": "https://xsc062.netlify.app/20250603/",
            "title": "虚树",
            "date_published": "2025-06-03T12:15:29.000Z",
            "content_html": "<p>凡所有相，皆是虚妄①。</p>\n<p><em>注释：①虚妄：犹言虚树是狂妄的算法。</em></p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"定义\">定义</h2>\n<p>给定一个大小为 <span class=\"math inline\">\\(n\\)</span> 的树和树上 <span class=\"math inline\">\\(k\\)</span> 个关键点。取出这 <span class=\"math inline\">\\(k\\)</span> 个关键点和它们任意两个间的 LCA 作为虚树的点集，按照原树上的祖孙关系连边得到虚树。</p>\n<p><img src=\"1.png\" /></p>\n<hr />\n<h2 id=\"求虚树\">求虚树</h2>\n<p>按照 DFN 排序，获取任意相邻两点 LCA，即可生成虚树点集。将点集按 DFN 排序后连边，复杂度为 <span class=\"math inline\">\\(O(k\\log k)\\)</span>。</p>\n<p>至少两个实点对应一个虚点，故而虚树大小为 <span class=\"math inline\">\\(O(k)\\)</span>。</p>\n<hr />\n<h2 id=\"用途\">用途</h2>\n<p>注意到无论是构建还是遍历虚树复杂度都与 <span class=\"math inline\">\\(n\\)</span> 无关。因而适用于对 <span class=\"math inline\">\\(\\sum k\\)</span> 有限制的题目。</p>\n<hr />\n<h3 id=\"b---leaf-color\">B - Leaf Color</h3>\n<p><a href=\"https://atcoder.jp/contests/abc340/tasks/abc340_g\" class=\"uri\">https://atcoder.jp/contests/abc340/tasks/abc340_g</a></p>\n<p>枚举所有颜色，每次对该颜色对应的所有点建立虚树，发现不能选虚树外的其他点，虚树上 DP 即可。</p>\n<p>注意根有可能是叶子。需要特判一下。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1), t(n + 1), g(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i], t[a[i]].push_back(i);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g1[x].push_back(y), g1[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; siz(n + 1), son(n + 1), dep(n + 1), fa(n + 1);\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int faa) &#123;\n        siz[x] = 1;\n        for (auto i : g1[x])\n            if (i != faa) &#123;\n                dep[i] = dep[x] + 1;\n                fa[i] = x;\n                DFS(i, x);\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1, -1);\n    std::vector&lt;int&gt; dfn(n + 1), rfn(n + 1), top(n + 1);\n    DFS = [&amp;](int x, int fa) &#123;\n        static int now = 0;\n        dfn[x] = ++now;\n        if (son[x])\n            top[son[x]] = top[x], DFS(son[x], x);\n        for (auto i : g1[x])\n            if (i != fa &amp;&amp; i != son[x])\n                top[i] = i, DFS(i, x);\n        rfn[x] = now;\n        return;\n    &#125;;\n    top[1] = 1, DFS(1, -1);\n    auto getLCA = [&amp;](int x, int y) &#123;\n        for (; top[x] != top[y]; x = fa[top[x]])\n            if (dep[top[x]] &lt; dep[top[y]])\n                std::swap(x, y);\n        return dep[x] &lt; dep[y] ? x : y;\n    &#125;;\n    std::vector&lt;int&gt; tag(n + 1);\n    std::vector&lt;long long&gt; f(n + 1);\n    auto res(0ll);\n    for (int k = 1; k &lt;= n; ++k)\n        if (!t[k].empty()) &#123;\n            std::sort(t[k].begin(), t[k].end(), [&amp;](int x, int y) &#123; return dfn[x] &lt; dfn[y]; &#125;);\n            std::vector&lt;int&gt; p;\n            for (auto i : t[k])\n                tag[i] = 1, p.push_back(i);\n            for (int i = 1; i &lt; (int)t[k].size(); ++i) &#123;\n                int fa = getLCA(t[k][i - 1], t[k][i]);\n                if (!tag[fa])\n                    tag[fa] = 1, p.push_back(fa);\n            &#125;\n            std::sort(p.begin(), p.end(), [&amp;](int x, int y) &#123; return dfn[x] &lt; dfn[y]; &#125;);\n            std::vector&lt;int&gt; tmp;\n            for (auto i : p) &#123;\n                if (!tmp.empty()) &#123;\n                    for (; rfn[tmp.back()] &lt; dfn[i]; tmp.pop_back());\n                    g[tmp.back()].push_back(i);\n                &#125;\n                tmp.push_back(i);\n            &#125;\n            std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n                f[x] = 1ll;\n                auto s(1ll);\n                for (auto i : g[x]) &#123;\n                    DFS(i), (s += f[i]) %= mod;\n                    (f[x] *= f[i] + 1) %= mod;\n                &#125;\n                if (a[x] != k)\n                    (f[x] += mod - s) %= mod;\n                // printf(&quot;color = %d, res += f[%d](%lld)\\n&quot;, k, x, f[x]);\n                (res += f[x]) %= mod;\n                if (a[x] != k)\n                    --s, (f[x] += s) %= mod;\n                return;\n            &#125;;\n            DFS(p.front());\n            for (auto i : p) &#123;\n                tag[i] = 0, f[i] = 0ll;\n                std::vector&lt;int&gt;().swap(g[i]);\n            &#125;\n        &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"c---watching-cowflix-p\">C - Watching Cowflix P</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P9132\" class=\"uri\">https://www.luogu.com.cn/problem/P9132</a></p>\n<p>会想到钦定 <span class=\"math inline\">\\(k\\)</span> 再来做。发现任意情况下都有：假如两个连通块距离 <span class=\"math inline\">\\(\\le k\\)</span>，那么合并起来不劣。所以把距离 <span class=\"math inline\">\\(\\le k\\)</span> 的所有点都合并起来发现只剩下 <span class=\"math inline\">\\(O(\\frac nk)\\)</span> 个点了，想到用虚树。</p>\n<p>然后虚树上枚举点选不选，DP 一下就完了。</p>\n<p>但是实现起来好史啊。合并需要用并查集维护父亲（而非本身），特别打脑壳。</p>\n<details>\n<p>我的天哪滔天巨史。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int inf = 0x3f3f3f3f;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, rt;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; p, tag(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        char t;\n        std::cin &gt;&gt; t;\n        if (t == &#39;1&#39;)\n            p.push_back(i), tag[i] = 1;\n    &#125;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1), g1(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g1[x].push_back(y), g1[y].push_back(x);\n    &#125;\n    std::set&lt;int&gt; st;\n    std::vector&lt;int&gt; to(n + 1), len(n + 1), cnt(n + 1), dfn(n + 1);\n    &#123;\n        std::vector&lt;int&gt; siz(n + 1), son(n + 1), fa(n + 1), dep(n + 1);\n        std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int faa) &#123;\n            siz[x] = 1;\n            for (auto i : g1[x])\n                if (i != faa) &#123;\n                    dep[i] = dep[x] + 1;\n                    fa[i] = x, DFS(i, x);\n                    siz[x] += siz[i];\n                    if (siz[i] &gt; siz[son[x]])\n                        son[x] = i;\n                &#125;\n            return;\n        &#125;;\n        DFS(1, -1);\n        std::vector&lt;int&gt; rfn(n + 1), top(n + 1);\n        DFS = [&amp;](int x, int fa) &#123;\n            static int now = 0;\n            dfn[x] = ++now;\n            if (son[x])\n                top[son[x]] = top[x], DFS(son[x], x);\n            for (auto i : g1[x])\n                if (i != son[x] &amp;&amp; i != fa)\n                    top[i] = i, DFS(i, x);\n            rfn[x] = now;\n            return;\n        &#125;;\n        DFS(1, -1);\n        auto getLCA = [&amp;](int x, int y) &#123;\n            for (; top[x] != top[y]; x = fa[top[x]])\n                if (dep[top[x]] &lt; dep[top[y]])\n                    std::swap(x, y);\n            return dep[x] &lt; dep[y] ? x : y;\n        &#125;;\n        std::sort(p.begin(), p.end(), [&amp;](int x, int y) &#123; return dfn[x] &lt; dfn[y]; &#125;);\n        std::vector&lt;int&gt; vis(tag), t(p);\n        for (int i = 1; i &lt; (int)p.size(); ++i) &#123;\n            int fa = getLCA(p[i - 1], p[i]);\n            if (!vis[fa])\n                vis[fa] = 1, t.push_back(fa);\n        &#125;\n        std::sort(t.begin(), t.end(), [&amp;](int x, int y) &#123; return dfn[x] &lt; dfn[y]; &#125;);\n        rt = t.front();\n        std::vector&lt;int&gt; stk;\n        for (auto i : t) &#123;\n            if (!stk.empty()) &#123;\n                for (; rfn[stk.back()] &lt; dfn[i]; stk.pop_back());\n                to[i] = stk.back(), len[i] = dep[i] - dep[to[i]] - 1;\n            &#125;\n            st.insert(i), stk.push_back(i);\n        &#125;\n    &#125;\n    std::vector&lt;int&gt; fa(n + 1), siz(n + 1, 1);\n    std::iota(fa.begin() + 1, fa.end(), 1);\n    std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;\n        return x == fa[x] ? x : fa[x] = find(fa[x]);\n    &#125;;\n    std::vector&lt;std::array&lt;int, 2&gt; &gt; f(n + 1);\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int k) &#123;\n        if (tag[x])\n            f[x][0] = inf;\n        f[x][1] = siz[x] + k;\n        for (auto i : g[x]) &#123;\n            DFS(i, k);\n            if (!tag[x])\n                f[x][0] += std::min(f[i][0], f[i][1]);\n            f[x][1] += std::min(&#123; f[i][0], f[i][1], f[i][1] + len[i] - k &#125;);\n        &#125;\n        return;\n    &#125;;\n    std::function&lt;void(int, int, int)&gt; DFS1 = [&amp;](int x, bool flag, int k) &#123;\n        for (auto i : g[x])\n            if (flag) &#123;\n                if (f[i][0] &lt;= std::min(f[i][1], f[i][1] + len[i] - k))\n                    DFS1(i, 0, k);\n                else &#123;\n                    DFS1(i, 1, k);\n                    if (f[i][1] + len[i] - k &lt; f[i][1]) &#123;\n                        tag[x] |= tag[i];\n                        siz[x] += siz[i] + len[i];\n                        st.erase(i), fa[i] = x;\n                    &#125;\n                &#125;\n            &#125;\n            else &#123;\n                if (f[i][0] &lt;= f[i][1])\n                    DFS1(i, 0, k);\n                else\n                    DFS1(i, 1, k);\n            &#125;\n        return;\n    &#125;;\n    for (int k = 1; k &lt;= n; ++k) &#123;\n        std::vector&lt;int&gt; p;\n        for (auto i : st) &#123;\n            p.push_back(i);\n            if (to[i])\n                g[find(to[i])].push_back(i);\n        &#125;\n        DFS(rt, k);\n        std::cout &lt;&lt; std::min(f[rt][0], f[rt][1]) &lt;&lt; &#39;\\n&#39;;\n        DFS1(rt, f[rt][1] &lt;= f[rt][0], k);\n        for (auto i : st)\n            f[i][0] = f[i][1] = 0, std::vector&lt;int&gt;().swap(g[i]);\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"d---smuggling-marbles\">D - Smuggling Marbles</h3>\n<p><a href=\"https://atcoder.jp/contests/arc086/tasks/arc086_c\" class=\"uri\">https://atcoder.jp/contests/arc086/tasks/arc086_c</a></p>\n<p>容易想到从贡献角度思考问题；那么每个点只与同深度的所有点存在竞争关系。</p>\n<p>把每个深度的点拿出来建虚树，在虚树上跑 DP 即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m = 0;\n    std::cin &gt;&gt; n, ++n;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1), g1(n + 1);\n    for (int i = 2, x; i &lt;= n; ++i)\n        std::cin &gt;&gt; x, g1[x + 1].push_back(i);\n    std::vector&lt;int&gt; top(n + 1), dep(n + 1), dfn(n + 1), rfn(n + 1), fa(n + 1);\n    &#123;\n        std::vector&lt;int&gt; siz(n + 1), son(n + 1);\n        std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n            siz[x] = 1;\n            m = std::max(m, dep[x]);\n            for (auto i : g1[x]) &#123;\n                dep[i] = dep[x] + 1;\n                fa[i] = x, DFS(i);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n            return;\n        &#125;;\n        dep[1] = 1, DFS(1);\n        DFS = [&amp;](int x) &#123;\n            static int now = 0;\n            dfn[x] = ++now;\n            if (son[x])\n                top[son[x]] = top[x], DFS(son[x]);\n            for (auto i : g1[x])\n                if (i != son[x])\n                    top[i] = i, DFS(i);\n            rfn[x] = now;\n            return;\n        &#125;;\n        top[1] = 1, DFS(1);\n    &#125;\n    auto getLCA = [&amp;](int x, int y) &#123;\n        for (; top[x] != top[y]; x = fa[top[x]])\n            if (dep[top[x]] &lt; dep[top[y]])\n                std::swap(x, y);\n        return dep[x] &lt; dep[y] ? x : y;\n    &#125;;\n    std::vector&lt;std::vector&lt;int&gt; &gt; _p(m + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        _p[dep[i]].push_back(i);\n    std::vector&lt;int&gt; tag(n + 1), flag(n + 1);\n    std::vector&lt;std::array&lt;long long, 2&gt; &gt; f(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        f[x][0] = 1ll + flag[x], f[x][1] = flag[x];\n        auto s(1ll);\n        for (auto i : g[x]) &#123;\n            DFS(i);\n            f[x][1] = (f[x][1] * f[i][0] + s * f[i][1]) % mod;\n            (f[x][0] *= f[i][0] + f[i][1]) %= mod;\n            (s *= f[i][0]) %= mod;\n        &#125;\n        (f[x][0] += mod - f[x][1]) %= mod;\n        // printf(&quot;f[%d][0] = %lld, f[%d][1] = %lld\\n&quot;, x, f[x][0], x, f[x][1]);\n        return;\n    &#125;;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    auto res(0ll);\n    for (int k = 1; k &lt;= m; ++k) &#123;\n        auto &amp;p = _p[k], t(p);\n        for (auto i : p)\n            flag[i] = 1;\n        std::sort(p.begin(), p.end(), [&amp;](int x, int y) &#123; return dfn[x] &lt; dfn[y]; &#125;);\n        for (int i = 1; i &lt; (int)p.size(); ++i) &#123;\n            int fa = getLCA(p[i - 1], p[i]);\n            if (!tag[fa])\n                tag[fa] = 1, t.push_back(fa);\n        &#125;\n        std::sort(t.begin(), t.end(), [&amp;](int x, int y) &#123; return dfn[x] &lt; dfn[y]; &#125;);\n        int rt = t.front();\n        std::vector&lt;int&gt; st;\n        for (auto i : t) &#123;\n            if (!st.empty()) &#123;\n                for (; rfn[st.back()] &lt; dfn[i]; st.pop_back());\n                g[st.back()].push_back(i);\n            &#125;\n            st.push_back(i);\n        &#125;\n        DFS(rt);\n        (res += f[rt][1] * qkp(2ll, n - (int)p.size())) %= mod;\n        // std::cout &lt;&lt; f[rt][1] * qkp(2ll, n - (int)p.size()) % mod &lt;&lt; &#39;\\n&#39;;\n        for (auto i : t) &#123;\n            tag[i] = flag[i] = 0;\n            std::vector&lt;int&gt;().swap(g[i]);\n        &#125;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"e---世界树\">E - 世界树</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P3233\" class=\"uri\">https://www.luogu.com.cn/problem/P3233</a></p>\n<p>会想到在虚树上两次 DFS 找到离任意点最近的实点。具体地，第一次找下方，第二次尝试用上方更新。</p>\n<p>接着发现对于虚树上的实点是好做的；对于实点的不在树上的儿子是好做的；接下来是虚点及其不在树上的儿子。</p>\n<p>就要用到刚刚求的信息了。显然二分一下就可以了。说起来很简单，然而实际上写起来很苦恼 <img src=\"/em/ll.gif\" /></p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, q;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1), g1(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g1[x].push_back(y), g1[y].push_back(x);\n    &#125;\n    std::vector&lt;std::array&lt;int, 21&gt; &gt; fa(n + 1);\n    std::vector&lt;int&gt; siz(n + 1), top(n + 1), dep(n + 1), dfn(n + 1), rfn(n + 1);\n    &#123;\n        std::vector&lt;int&gt; son(n + 1);\n        std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int faa) &#123;\n            siz[x] = 1;\n            for (auto i : g1[x])\n                if (i != faa) &#123;\n                    dep[i] = dep[x] + 1;\n                    fa[i][0] = x;\n                    for (int j = 1; j &lt;= 20; ++j)\n                        fa[i][j] = fa[fa[i][j - 1]][j - 1];\n                    DFS(i, x);\n                    siz[x] += siz[i];\n                    if (siz[i] &gt; siz[son[x]])\n                        son[x] = i;\n                &#125;\n            return;\n        &#125;;\n        DFS(1, -1);\n        int now = 0;\n        DFS = [&amp;](int x, int fa) &#123;\n            dfn[x] = ++now;\n            if (son[x])\n                top[son[x]] = top[x], DFS(son[x], x);\n            for (auto i : g1[x])\n                if (i != fa &amp;&amp; i != son[x])\n                    top[i] = i, DFS(i, x);\n            rfn[x] = now;\n            return;\n        &#125;;\n        top[1] = 1, DFS(1, -1);\n    &#125;\n    auto getLCA = [&amp;](int x, int y) &#123;\n        for (; top[x] != top[y]; x = fa[top[x]][0])\n            if (dep[top[x]] &lt; dep[top[y]])\n                std::swap(x, y);\n        return dep[x] &lt; dep[y] ? x : y;\n    &#125;;\n    auto getfa = [&amp;](int x, int p) &#123;\n        for (int i = 20; ~i; --i)\n            if (p &gt;= (1 &lt;&lt; i))\n                x = fa[x][i], p -= (1 &lt;&lt; i);\n        return x;\n    &#125;;\n    std::vector&lt;int&gt; to(n + 1);\n    std::vector&lt;int&gt; tag(n + 1), flag(n + 1), res(n + 1);\n    std::cin &gt;&gt; q;\n    auto dis = [&amp;](int x, int y) &#123;\n        return std::make_pair(dep[x] + dep[y] - 2 * dep[getLCA(x, y)], y);\n    &#125;;\n    std::function&lt;void(int)&gt; DFS1 = [&amp;](int x) &#123;\n        to[x] = (flag[x] ? x : -1);\n        for (auto i : g[x]) &#123;\n            DFS1(i);\n            if (~to[i] &amp;&amp; (to[x] == -1 || dis(x, to[i]) &lt; dis(x, to[x])))\n                to[x] = to[i];\n        &#125;\n        // printf(&quot;to[%d] = %d\\n&quot;, x, to[x]);\n        return;\n    &#125;, DFS2 = [&amp;](int x) &#123;\n        // printf(&quot;to[%d] = %d\\n&quot;, x, to[x]);\n        for (auto i : g[x]) &#123;\n            if (to[i] == -1 || dis(i, to[x]) &lt; dis(i, to[i]))\n                to[i] = to[x];\n            DFS2(i);\n        &#125;\n        return;\n    &#125;, DFS3 = [&amp;](int x) &#123;\n        res[to[x]] += siz[x];\n        for (auto i : g[x]) &#123;\n            res[to[x]] -= siz[getfa(i, dep[i] - dep[x] - 1)];\n            DFS3(i);\n        &#125;\n        // printf(&quot;res[%d] = %d\\n&quot;, x, res[x]);\n        return;\n    &#125;, DFS4 = [&amp;](int x) &#123;\n        for (auto i : g[x]) &#123;\n            if (to[x] == to[i])\n                res[to[x]] += siz[getfa(i, dep[i] - dep[x] - 1)] - siz[i];\n            else &#123;\n                auto dx(dis(x, to[x])), di(dis(i, to[i]));\n                int at = -1, len = dep[i] - dep[x] - 1;\n                for (int l = 0, r = len, mid; l &lt;= r; ) &#123;\n                    mid = (l + r) &gt;&gt; 1;\n                    if ([&amp;](auto dx, auto dy) &#123;\n                        dx.first += mid, dy.first += len - mid + 1;\n                        return dx &lt; dy;\n                    &#125; (dx, di))\n                        at = mid, l = mid + 1;\n                    else\n                        r = mid - 1;\n                &#125;\n                int fa = getfa(i, len - at);\n                res[to[x]] += siz[getfa(i, len)] - siz[fa];\n                res[to[i]] += siz[fa] - siz[i];\n            &#125;\n            DFS4(i);\n        &#125;\n        return;\n    &#125;;\n    for (int k; q--; ) &#123;\n        std::cin &gt;&gt; k;\n        std::vector&lt;int&gt; p(k);\n        for (int i = 0; i &lt; k; ++i)\n            std::cin &gt;&gt; p[i], tag[p[i]] = flag[p[i]] = 1;\n        auto org(p);\n        std::sort(p.begin(), p.end(), [&amp;](int x, int y) &#123; return dfn[x] &lt; dfn[y]; &#125;);\n        std::vector&lt;int&gt; t(p);\n        for (int i = 1; i &lt; (int)p.size(); ++i) &#123;\n            int fa = getLCA(p[i - 1], p[i]);\n            if (!tag[fa])\n                tag[fa] = 1, t.push_back(fa);\n        &#125;\n        if (!tag[1])\n            t.push_back(1), tag[1] = 1;\n        std::sort(t.begin(), t.end(), [&amp;](int x, int y) &#123; return dfn[x] &lt; dfn[y]; &#125;);\n        std::vector&lt;int&gt; st;\n        for (auto i : t) &#123;\n            if (!st.empty()) &#123;\n                for (; rfn[st.back()] &lt; dfn[i]; st.pop_back());\n                g[st.back()].push_back(i);\n            &#125;\n            st.push_back(i);\n        &#125;\n        DFS1(1), DFS2(1), DFS3(1), DFS4(1);\n        for (auto i : org)\n            std::cout &lt;&lt; res[i] &lt;&lt; &#39; &#39;;\n        std::cout &lt;&lt; &#39;\\n&#39;;\n        for (auto i : t) &#123;\n            res[i] = 0;\n            tag[i] = flag[i] = 0;\n            std::vector&lt;int&gt;().swap(g[i]);\n        &#125;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"f---大工程\">F - 大工程</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P4103\" class=\"uri\">https://www.luogu.com.cn/problem/P4103</a></p>\n<p>虚树上 DP 统计相关信息即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst long long inf = 0x3f3f3f3f;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, q;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1), g1(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g1[x].push_back(y), g1[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; top(n + 1), dep(n + 1), dfn(n + 1), rfn(n + 1), fa(n + 1);\n    &#123;\n        std::vector&lt;int&gt; siz(n + 1), son(n + 1);\n        std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int faa) &#123;\n            siz[x] = 1;\n            for (auto i : g1[x])\n                if (i != faa) &#123;\n                    dep[i] = dep[x] + 1;\n                    fa[i] = x, DFS(i, x);\n                    siz[x] += siz[i];\n                    if (siz[i] &gt; siz[son[x]])\n                        son[x] = i;\n                &#125;\n            return;\n        &#125;;\n        DFS(1, -1);\n        int now = 0;\n        DFS = [&amp;](int x, int fa) &#123;\n            dfn[x] = ++now;\n            if (son[x])\n                top[son[x]] = top[x], DFS(son[x], x);\n            for (auto i : g1[x])\n                if (i != fa &amp;&amp; i != son[x])\n                    top[i] = i, DFS(i, x);\n            rfn[x] = now;\n            return;\n        &#125;;\n        top[1] = 1, DFS(1, -1);\n    &#125;\n    auto getLCA = [&amp;](int x, int y) &#123;\n        for (; top[x] != top[y]; x = fa[top[x]])\n            if (dep[top[x]] &lt; dep[top[y]])\n                std::swap(x, y);\n        return dep[x] &lt; dep[y] ? x : y;\n    &#125;;\n    std::vector&lt;long long&gt; s(n + 1);\n    std::vector&lt;int&gt; mx(n + 1), mn(n + 1);\n    std::vector&lt;int&gt; tag(n + 1), siz(n + 1), flag(n + 1);\n    int rmx, rmn;\n    long long rs;\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        if (flag[x]) &#123;\n            siz[x] = 1;\n            mx[x] = mn[x] = s[x] = 0;\n        &#125;\n        else &#123;\n            siz[x] = s[x] = 0;\n            mn[x] = inf, mx[x] = -inf;\n        &#125;\n        for (auto i : g[x]) &#123;\n            DFS(i);\n            int len = dep[i] - dep[x];\n            rmx = std::max(rmx, mx[x] + mx[i] + len);\n            mx[x] = std::max(mx[x], mx[i] + len);\n            rmn = std::min(rmn, mn[x] + mn[i] + len);\n            mn[x] = std::min(mn[x], mn[i] + len);\n            rs += siz[x] * (s[i] + (long long)siz[i] * len) + siz[i] * s[x]; \n            s[x] += s[i] + (long long)siz[i] * len;\n            siz[x] += siz[i];\n            // printf(&quot;%d -&gt; %d, mx = %d, mn = %d, s = %lld\\n&quot;, x, i, rmx, rmn, rs);\n        &#125;\n        return;\n    &#125;;\n    std::cin &gt;&gt; q;\n    for (int k; q--; ) &#123;\n        std::cin &gt;&gt; k;\n        std::vector&lt;int&gt; p(k);\n        for (int i = 0; i &lt; k; ++i)\n            std::cin &gt;&gt; p[i], tag[p[i]] = flag[p[i]] = 1;\n        std::sort(p.begin(), p.end(), [&amp;](int x, int y) &#123; return dfn[x] &lt; dfn[y]; &#125;);\n        std::vector&lt;int&gt; t(p);\n        for (int i = 1; i &lt; (int)p.size(); ++i) &#123;\n            int fa = getLCA(p[i - 1], p[i]);\n            if (!tag[fa])\n                tag[fa] = 1, t.push_back(fa);\n        &#125;\n        std::sort(t.begin(), t.end(), [&amp;](int x, int y) &#123; return dfn[x] &lt; dfn[y]; &#125;);\n        int rt = t.front();\n        std::vector&lt;int&gt; st;\n        for (auto i : t) &#123;\n            if (!st.empty()) &#123;\n                for (; rfn[st.back()] &lt; dfn[i]; st.pop_back());\n                g[st.back()].push_back(i);\n            &#125;\n            st.push_back(i);\n        &#125;\n        rs = 0ll, rmx = -inf, rmn = inf;\n        DFS(rt);\n        std::cout &lt;&lt; rs &lt;&lt; &#39; &#39; &lt;&lt; rmn &lt;&lt; &#39; &#39; &lt;&lt; rmx &lt;&lt; &#39;\\n&#39;;\n        for (auto i : t) &#123;\n            tag[i] = flag[i] = 0;\n            std::vector&lt;int&gt;().swap(g[i]);\n        &#125;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "虚树"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250526/",
            "url": "https://xsc062.netlify.app/20250526/",
            "title": "多维 DP",
            "date_published": "2025-05-26T07:05:53.000Z",
            "content_html": "<p>上楼听到有人在哼 <em>Climbing on the Trees</em>，上来听到隔壁班在放 <em>Burn the House Down</em>，果然春天是 AJR 的季节（）</p>\n<span id=\"more\"></span>\n<hr />\n<p>主要是多维 DP 特有的优化！</p>\n<h2 id=\"分步转移\">分步转移</h2>\n<p>如果状态的若干维之间只存在很弱的联系，可以分步转移每一维。</p>\n<p>假设有二维状态转移 <span class=\"math inline\">\\((a,b)\\to (a&#39;,b&#39;)\\)</span>，『很弱的联系』举例：</p>\n<ol type=\"1\">\n<li>DP 值中包含 <span class=\"math inline\">\\(w(a&#39;,b&#39;)\\)</span>，但不包含诸如 <span class=\"math inline\">\\(w(a&#39;,b),w(a,b&#39;)\\)</span> 之类。也即该值的求解不依赖于上一个状态、不依赖于转移。</li>\n<li>对于 <span class=\"math inline\">\\((a&#39;,b&#39;)\\)</span> 的取值有限制，比如 <span class=\"math inline\">\\((114,514)\\)</span> 不能取到之类。显然这也不依赖于上一个状态、不依赖于转移。</li>\n<li>符号限制（如转移间为 <span class=\"math inline\">\\(+\\)</span>，状态间为 <span class=\"math inline\">\\(\\times\\)</span> 之类），在计数中常出现。</li>\n<li>一个变动的时候另一个必须也一起动。</li>\n</ol>\n<p>注意！有的时候一个状态也可以拆成两个状态，然后分步转移。</p>\n<hr />\n<h3 id=\"例题经典题\">例题：经典题</h3>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(w_{N\\times M}\\)</span>，求 <span class=\"math inline\">\\((A,B)_{1\\sim K}\\)</span>，最大化 <span class=\"math inline\">\\(\\sum\\limits_{i=1}^K w_{A_i,B_i}+w_{A_{i-1},A_i}+w_{B_{i-1},B_i}\\)</span> 的值。</p>\n</blockquote>\n<p>发现如果设 <span class=\"math inline\">\\(f_{i,a,b}\\)</span> 表示 <span class=\"math inline\">\\((A,B)_i=(a,b)\\)</span> 的话，转移就会达到可观的 <span class=\"math inline\">\\(O(N\\times M)\\)</span>；但发现里面的 <span class=\"math inline\">\\(A\\)</span> 和 <span class=\"math inline\">\\(B\\)</span> 其实没什么有机联系；唯一的联系 <span class=\"math inline\">\\(w_{A_i,B_i}\\)</span>（上面『很弱的联系』中的第一、四种情况）。因此分布转移：</p>\n<p><span class=\"math display\">\\[\nf&#39;_{a&#39;,b}\\gets \\max\\limits_a f_{a,b}+w_{a&#39;,a}\\\\\nf_{a&#39;,b&#39;}\\gets \\max\\limits_b f&#39;_{a&#39;, b} + w_{b,b&#39;}+w_{a&#39;,b&#39;}\n\\]</span></p>\n<p>由此便优化转移复杂度到 <span class=\"math inline\">\\(O(N+M)\\)</span>。</p>\n<hr />\n<h3 id=\"例题彩灯晚会\">例题：彩灯晚会</h3>\n<p>goto <a href=\"/20250407/#e---kdoi-11彩灯晚会\">link</a>。</p>\n<p>Tips：发现 <span class=\"math inline\">\\(l_1,l_2\\)</span> 之间也没啥有机联系（上面『很弱的联系』中的第三、四种情况），故分步转移。</p>\n<hr />\n<h3 id=\"例题序列妙妙值\">例题：序列妙妙值</h3>\n<p><a href=\"https://uoj.ac/problem/549\" class=\"uri\">https://uoj.ac/problem/549</a></p>\n<p>朴素地，设 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示在第 <span class=\"math inline\">\\(i\\)</span> 个处分第 <span class=\"math inline\">\\(j\\)</span> 段的最大价值，显然有 <span class=\"math inline\">\\(O(k\\times n^2)\\)</span>，且并没有优化的空间。</p>\n<p>考虑利用 <span class=\"math inline\">\\(a_i\\)</span> 很小这一条件，发现上一条无法优化是因为要获取 <span class=\"math inline\">\\(sum_{i}\\)</span> 的值；那么把 <span class=\"math inline\">\\(sum_i\\)</span> 塞到状态里。设 <span class=\"math inline\">\\(f_{s&#39;,j}\\)</span> 表示 <span class=\"math inline\">\\(sum=s&#39;\\)</span> 时，分了 <span class=\"math inline\">\\(j\\)</span> 段的最大价值。同样可以 <span class=\"math inline\">\\(O(k\\cdot n^2)\\)</span>。</p>\n<p>接下来有两个理解这个优化的角度：</p>\n<ol type=\"1\">\n<li><p>从平衡角度，原问题等价于 <span class=\"math inline\">\\(O(1)\\)</span> 更新 <span class=\"math inline\">\\((s,j)\\)</span> 处的最大值，<span class=\"math inline\">\\(O(v)\\)</span> 查找 <span class=\"math inline\">\\(j-1\\)</span> 处的最大值；把 <span class=\"math inline\">\\(s\\)</span> 拆成前 <span class=\"math inline\">\\(8\\)</span> 位、后 <span class=\"math inline\">\\(8\\)</span> 位两个 part，当更新</p>\n<p>对于修改：相当于固定前 <span class=\"math inline\">\\(8\\)</span> 位 <span class=\"math inline\">\\(s\\)</span>，枚举后 <span class=\"math inline\">\\(8\\)</span> 位 <span class=\"math inline\">\\(x\\)</span>，并更新 <span class=\"math inline\">\\((s,x)\\)</span>。</p>\n对于查询：相当于固定后 <span class=\"math inline\">\\(8\\)</span> 位 <span class=\"math inline\">\\(x\\)</span>，枚举前 <span class=\"math inline\">\\(8\\)</span> 位 <span class=\"math inline\">\\(s\\)</span>，并查询 <span class=\"math inline\">\\((s,x)\\)</span>。</li>\n<li><p>从分步转移角度，由于『现时刻』的贡献是按位的，二进制状态的前 <span class=\"math inline\">\\(8\\)</span> 位和后 <span class=\"math inline\">\\(8\\)</span> 位没啥有机联系，故直接拆开，先转移前 <span class=\"math inline\">\\(8\\)</span> 位，再转移后 <span class=\"math inline\">\\(8\\)</span> 位。</p></li>\n</ol>\n<p>这样就被优化为 <span class=\"math inline\">\\(O(k\\cdot n\\times \\sqrt v)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxv = 1 &lt;&lt; 8;\nconst int inf = 0x3f3f3f3f;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    using arr = std::vector&lt;int&gt;;\n    using brr = std::vector&lt;arr&gt;;\n    using crr = std::vector&lt;brr&gt;;\n    arr s(n + 1), tag0(maxv), d0;\n    crr f(maxv, brr(maxv, arr(k + 1, inf))), g(maxv, brr(maxv, arr(k + 1, inf)));\n    f[0][0][0] = 0;\n    for (int j = 0; j &lt; maxv; ++j)\n        g[0][j][1] = j;\n    tag0[0] = 1, d0.push_back(0);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; s[i], s[i] ^= s[i - 1];\n        int p0 = s[i] &gt;&gt; 8, p1 = s[i] &amp; ((1 &lt;&lt; 8) - 1);\n        for (int j = k; j; --j) &#123;\n            for (auto a : d0)\n                f[p0][p1][j] = std::min(f[p0][p1][j], g[a][p1][j] + ((a ^ p0) &lt;&lt; 8));\n            // printf(&quot;f[%d][%d][%d] = %d\\n&quot;, p0, p1, j, f[p0][p1][j]);\n            if (j != k)\n                for (int a = 0; a &lt; maxv; ++a)\n                    g[p0][a][j + 1] = std::min(g[p0][a][j + 1], f[p0][p1][j] + (a ^ p1));\n        &#125;\n        if (i &gt;= k)\n            std::cout &lt;&lt; f[p0][p1][k] &lt;&lt; &#39; &#39;;\n        if (!tag0[p0])\n            tag0[p0] = 1, d0.push_back(p0);\n    &#125;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"割裂\">割裂</h2>\n<p>如果状态的若干维之间连无机联系都没了，可以直接把 DP 数组拆开，各自转移各自的。</p>\n<p>最后答案的拼接，可能是枚举、直接拼、用一个转移另一个之类。</p>\n<hr />\n<h3 id=\"例题经典题-1\">例题：经典题</h3>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(w_{N\\times M}\\)</span>，求 <span class=\"math inline\">\\((A,B)_{1\\sim K}\\)</span>，最大化 <span class=\"math inline\">\\(\\sum\\limits_{i=1}^K w_{A_{i-1},A_i}+w_{B_{i-1},B_i}\\)</span> 的值。</p>\n</blockquote>\n<p>先 DP 出来 <span class=\"math inline\">\\(A\\)</span>，再 DP 出来 <span class=\"math inline\">\\(B\\)</span>，直接相加即可。</p>\n<hr />\n<h3 id=\"例题mnogomet\">例题：MNOGOMET</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P7648\" class=\"uri\">https://www.luogu.com.cn/problem/P7648</a></p>\n<p>想到设 <span class=\"math inline\">\\(f_{t,i,a,b}\\)</span> 表示『过去了 <span class=\"math inline\">\\(t\\)</span> 秒，且球在球员 <span class=\"math inline\">\\(i\\)</span> 手上，且两个队伍得分分别为 <span class=\"math inline\">\\(a,b\\)</span>』的概率。那么枚举球上一次在谁手上，有美观的 <span class=\"math inline\">\\(O(T\\cdot N^2R^2)\\)</span>。</p>\n<p>发现比分变动时（上半个时刻完成射门并传球）球一定在某个队的 <span class=\"math inline\">\\(1\\)</span> 号手上；<span class=\"math inline\">\\(i\\)</span> 这一维和 <span class=\"math inline\">\\(a,b\\)</span> 也没有相互的干扰；故可以将 <span class=\"math inline\">\\(i\\)</span> 提取出来（作为对比，射门和夺球、传球都会影响 <span class=\"math inline\">\\(t\\)</span>，所以分裂出来的状态中必须包含 <span class=\"math inline\">\\(t\\)</span>）。具体地：</p>\n<ol type=\"1\">\n<li><p>令 <span class=\"math inline\">\\(g_{t,0/1,i}\\)</span> 表示『一开始球在哪个球队的 <span class=\"math inline\">\\(1\\)</span> 号，花费 <span class=\"math inline\">\\(t\\)</span> 秒，且没人射门，且球在球员 <span class=\"math inline\">\\(i\\)</span> 手上』的概率。发现可以 <span class=\"math inline\">\\(O(T\\times N^2)\\)</span> 计算。</p>\n<p>当然这里就是条件概率了。其中『一开始球在哪个球队的 <span class=\"math inline\">\\(1\\)</span> 号』就是条件。</p>\n再预处理可以得到 <span class=\"math inline\">\\(G_{t,0/1,0/1,0/1}\\)</span> 表示『一开始球在哪个球队的 <span class=\"math inline\">\\(1\\)</span> 号，花费 <span class=\"math inline\">\\(t\\)</span> 秒，哪个球队射门，（没）射进』的概率。</li>\n<li><p>令 <span class=\"math inline\">\\(f_{t,0/1,a,b}\\)</span> 表示『过去了 <span class=\"math inline\">\\(t\\)</span> 秒，球在哪个队的 <span class=\"math inline\">\\(1\\)</span> 号，且得分为 <span class=\"math inline\">\\(a,b\\)</span>』的概率。枚举距离上一次射门的时间，可以 <span class=\"math inline\">\\(O(T^2\\times R^2)\\)</span> 完成转移。</p></li>\n</ol>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, r, T;\n    std::cin &gt;&gt; n &gt;&gt; r &gt;&gt; T;\n    using arr = std::vector&lt;double&gt;;\n    using brr = std::vector&lt;arr&gt;;\n    using crr = std::vector&lt;brr&gt;;\n    brr p(2 * n + 1, arr(2)), pp(2 * n + 1, arr(2 * n + 1));\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; p[i][1], p[i][0] = 1. - p[i][1];\n        int ss, sd;\n        std::cin &gt;&gt; ss &gt;&gt; sd;\n        double P = 1. / (ss + sd + 1);\n        p[i][0] *= P, p[i][1] *= P;\n        for (int x; ss--; pp[i][x] = P)\n            std::cin &gt;&gt; x;\n        for (int x; sd--; pp[i][x + n] = P)\n            std::cin &gt;&gt; x;\n    &#125;\n    for (int i = n + 1; i &lt;= 2 * n; ++i) &#123;\n        std::cin &gt;&gt; p[i][1], p[i][0] = 1. - p[i][1];\n        int ss, sd;\n        std::cin &gt;&gt; ss &gt;&gt; sd;\n        double P = 1. / (ss + sd + 1);\n        p[i][0] *= P, p[i][1] *= P;\n        for (int x; ss--; pp[i][x + n] = P)\n            std::cin &gt;&gt; x;\n        for (int x; sd--; pp[i][x] = P)\n            std::cin &gt;&gt; x;\n    &#125;\n    brr s(T + 1, arr(2));\n    crr g(T + 1, brr(2, arr(2 * n + 1)));\n    std::vector&lt;crr&gt; G(T + 1, crr(2, brr(2, arr(2)))), f(T + 1, crr(2, brr(r + 1, arr(r + 1))));\n    g[0][0][1] = g[0][1][n + 1] = 1.;\n    for (int t = 1; t &lt;= T; ++t) &#123;\n        for (int f1 = 0; f1 &lt;= 1; ++f1)\n            for (int i = 1; i &lt;= 2 * n; ++i) &#123;\n                G[t][f1][i &gt; n][0] += g[t - 1][f1][i] * p[i][0];\n                G[t][f1][i &gt; n][1] += g[t - 1][f1][i] * p[i][1];\n                for (int j = 1; j &lt;= 2 * n; ++j)\n                    if (j != i)\n                        g[t][f1][i] += pp[j][i] * g[t - 1][f1][j];\n                // printf(&quot;spend %ds, start from %d, now at %d: %.10lf\\n&quot;, t, 1 + f1 * n, i, g[t][f1][i]);\n                s[t][f1] += g[t][f1][i];\n            &#125;\n    &#125;\n    // puts(&quot;------------------------------------&quot;);\n    // for (int t = 1; t &lt;= T; ++t) &#123;\n    //     for (int f1 = 0; f1 &lt;= 1; ++f1)\n    //         for (int f2 = 0; f2 &lt;= 1; ++f2)\n    //             for (int f3 = 0; f3 &lt;= 1; ++f3)\n    //                 printf(&quot;spend %ds, start from %d, %d shoots, STATUS: %d, P = %.10lf\\n&quot;, t, 1 + f1 * n, 1 + f2, f3, G[t][f1][f2][f3]);\n    // &#125;\n    // puts(&quot;------------------------------------&quot;);\n    f[0][0][0][0] = 1.;\n    for (int t = 0; t &lt; T; ++t)\n        for (int f1 = 0; f1 &lt;= 1; ++f1)\n            for (int a = 0; a &lt; r; ++a)\n                for (int b = 0; b &lt; r; ++b) &#123;\n                    for (int t1 = 1; t + t1 &lt;= T; ++t1) &#123;\n                        f[t + t1][0][a][b] += f[t][f1][a][b] * G[t1][f1][1][0];\n                        f[t + t1][0][a][b + 1] += f[t][f1][a][b] * G[t1][f1][1][1];\n                        f[t + t1][1][a][b] += f[t][f1][a][b] * G[t1][f1][0][0];\n                        f[t + t1][1][a + 1][b] += f[t][f1][a][b] * G[t1][f1][0][1];\n                        if (t + t1 == T)\n                            f[T][0][a][b] += f[t][f1][a][b] * s[t1][f1];\n                    &#125;\n                &#125;\n    // for (int t = 0; t &lt;= T; ++t)\n    //     for (int f1 = 0; f1 &lt;= 1; ++f1)\n    //         for (int a = 0; a &lt;= r; ++a)\n    //             for (int b = 0; b &lt;= r; ++b)\n    //                 if (f[t][f1][a][b] &gt; 1e-10)\n    //                     printf(&quot;%ds later, %d shoots, %d : %d, P = %.10lf\\n&quot;, t, 1 + !f1 * n, a, b, f[t][f1][a][b]);\n    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(10);\n    for (int a = 0; a &lt;= r; ++a) &#123;\n        for (int b = 0; b &lt;= r; ++b) &#123;\n            if (a == r &amp;&amp; b == r)\n                continue;\n            double res(0.);\n            if (a == r)\n                for (int t = r; t &lt;= T; ++t)\n                    res += f[t][1][r][b];\n            else if (b == r)\n                for (int t = r; t &lt;= T; ++t)\n                    res += f[t][0][a][r];\n            else\n                res = f[T][0][a][b] + f[T][1][a][b];\n            std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n        &#125;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "DP",
                "DP 优化"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250524/",
            "url": "https://xsc062.netlify.app/20250524/",
            "title": "周考",
            "date_published": "2025-05-24T06:29:44.000Z",
            "content_html": "<p>并非周考。</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"b---carousel-of-combinations\">B - Carousel of Combinations</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1957/E\" class=\"uri\">https://codeforces.com/problemset/problem/1957/E</a></p>\n<blockquote>\n<p><span class=\"math inline\">\\(q\\)</span> 次询问，每次给定一个 <span class=\"math inline\">\\(n\\)</span>，求：</p>\n<p><span class=\"math display\">\\[\n\\left(\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^i \\dfrac {i!}{(i-j)!\\cdot j!}\\bmod j\\right) \\bmod 10^9+7\n\\]</span></p>\n<p><span class=\"math inline\">\\(n,q\\le 10^6\\)</span>。</p>\n</blockquote>\n<p>赛时打表 <span class=\"math inline\">\\(\\dfrac {i!}{(i-j)!\\cdot j!}\\bmod j\\)</span> 易发现只有 <span class=\"math inline\">\\(j=4\\)</span> 或 <span class=\"math inline\">\\(j\\)</span> 为质数的列上有值；且仅当 <span class=\"math inline\">\\(\\left\\lfloor \\dfrac ij\\right\\rfloor\\)</span> 发生变化时，<span class=\"math inline\">\\((i,j)\\)</span> 的值不同。</p>\n<p>于是乎埃筛找每个 <span class=\"math inline\">\\(j\\)</span> 的倍数，由于每个值会持续一段 <span class=\"math inline\">\\(i\\)</span> 上的区间，考虑维护差分数组。前缀和得到原数组，再前缀和就能得到答案。</p>\n<details>\n<p><summary>证明</summary></p>\n<p>考虑转化为组合数形式方便证明。当 <span class=\"math inline\">\\(j\\)</span> 为质数时：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\n\\dfrac {i!}{(i-j)!\\cdot j!}\\bmod j\n&amp;=C_i^j\\cdot (j-1)!\\bmod j\\\\\n&amp;=C_{i\\bmod j}^{j\\bmod j}\\cdot C_{\\lfloor \\frac ij\\rfloor}^{\\frac jj}\\cdot (j-1)!\\bmod j\\\\\n&amp;=\\left\\lfloor \\frac ij\\right\\rfloor\\cdot (j-1)!\\bmod j\\\\\n&amp;=\\left\\lfloor \\frac ij\\right\\rfloor\\cdot (j-1)\\bmod j\n\\end{aligned}\n\\]</span></p>\n<p>当 <span class=\"math inline\">\\(j\\)</span> 为合数时：</p>\n<p><span class=\"math display\">\\[\n\\dfrac {i!}{(i-j)!\\cdot j!}\\bmod j=\\left\\lfloor \\frac ij\\right\\rfloor\\cdot (j-1)!\\bmod j\n\\]</span></p>\n<ul>\n<li><p>当 <span class=\"math inline\">\\(j=p^2\\)</span>，其中 <span class=\"math inline\">\\(p\\)</span> 为质数时：</p>\n<ul>\n<li>当 <span class=\"math inline\">\\(j\\ne 4\\)</span> 时，<span class=\"math inline\">\\(\\dfrac jp \\ge 3\\)</span>，代表在 <span class=\"math inline\">\\(1\\sim j-1\\)</span> 中至少出现了两个 <span class=\"math inline\">\\(p\\)</span> 的倍数，即 <span class=\"math inline\">\\((j-1)\\bmod j = 0\\)</span>。</li>\n<li>否则，原式转化为 <span class=\"math inline\">\\(2\\cdot \\left\\lfloor \\frac i4\\right\\rfloor\\bmod 4\\)</span>。</li>\n</ul></li>\n<li><p>否则：可以找到至少一组 <span class=\"math inline\">\\(j=i\\cdot k\\)</span> 满足 <span class=\"math inline\">\\(i\\ne k\\)</span>，则 <span class=\"math inline\">\\(i,k\\)</span> 出现在 <span class=\"math inline\">\\(1\\sim j-1\\)</span> 中，即 <span class=\"math inline\">\\((j-1)\\bmod j = 0\\)</span>。</p></li>\n</ul>\n<p>得到上述结论。</p>\n<p>Tips：</p>\n<ul>\n<li>卢卡斯定理：懒得写了。</li>\n<li>威尔逊定理：对于质数 <span class=\"math inline\">\\(p\\)</span>，<span class=\"math inline\">\\((p-1)!\\equiv -1\\pmod p\\)</span>。</li>\n</ul>\n</details>\n<hr />\n<h2 id=\"c---玻利维亚-bolivija\">C - 玻利维亚 / Bolivija</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P12401\" class=\"uri\">https://www.luogu.com.cn/problem/P12401</a></p>\n<blockquote>\n<p>给定若干次区间的插入与删除操作，对于所有值域内未被覆盖极长段 <span class=\"math inline\">\\(i\\)</span>，令 <span class=\"math inline\">\\(len_i\\)</span> 为其长度；每次操作后询问 <span class=\"math inline\">\\(\\sum \\frac {len_i\\cdot (len_i-1)}2+len_i\\)</span>。</p>\n</blockquote>\n<p>来一点新奇的思路。假如你和我一样，很不幸地不知道维护最小值这个 trick，怎么解决这道题？</p>\n<p>容易想到线段树维护节点内贡献和左侧、右侧极长未覆盖长度。加入区间是简单的：对于线段树上被完全覆盖的节点，更新其贡献为 <span class=\"math inline\">\\(0\\)</span>。依次 <code>pushup</code> 即可。</p>\n<p>删除区间，对于被这段区间完全覆盖的节点，发现如果整体被覆盖次数减少 <span class=\"math inline\">\\(1\\)</span>，有可能出现新的、未被覆盖的点，如果暴力 check 左右儿子是否出现了这样的点并更新，复杂度就不太美观了。</p>\n<p>故而对于一个节点，<strong>将『完全覆盖它的区间』和『部分覆盖它的区间』分开考虑</strong>，在维护该节点所有实时信息（记为 <span class=\"math inline\">\\(s\\)</span>）的同时，<strong>维护另一份只考虑了『部分覆盖它地区间』的信息（记为 <span class=\"math inline\">\\(s&#39;\\)</span>）</strong>：</p>\n<ul>\n<li><p>如果一个『部分覆盖它的区间』被删除：</p>\n<ul>\n<li>如果存在『完全覆盖它的区间』：<span class=\"math inline\">\\(s\\)</span> 不变；向下修改儿子的 <span class=\"math inline\">\\(s\\)</span>，<span class=\"math inline\">\\(s&#39;\\)</span> 需要从儿子的 <span class=\"math inline\">\\(s\\)</span> 更新。</li>\n</ul></li>\n<li><p>如果一个『完全覆盖它的区间』被删除：</p>\n<ul>\n<li>如果还存在其他『完全覆盖它的区间』：<span class=\"math inline\">\\(s,s&#39;\\)</span> 都不变。</li>\n<li>如果不存在其他『完全覆盖它的区间』：用 <span class=\"math inline\">\\(s&#39;\\)</span> 更新 <span class=\"math inline\">\\(s\\)</span>。</li>\n</ul></li>\n</ul>\n<p>这样就能 <span class=\"math inline\">\\(O(q\\log V)\\)</span> 解决上述问题。本方法较维护最小值的优势在于——似乎没有。想了许多种情况，它们大抵是等价的——且本方法更难写（哭）。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 654205;\nstruct &#123;\n    int cnt;\n    long long u, s;\n    int l, r, lu, ru, ls, rs;\n&#125; t[maxn &lt;&lt; 2];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\n#define len(p) (t[p].r - t[p].l + 1)\nvoid pushup(int p) &#123;\n    t[p].s = t[lt].u + t[rt].u + (long long)t[lt].ru * t[rt].lu;\n    if (t[lt].lu == len(lt))\n        t[p].ls = len(lt) + t[rt].lu;\n    else\n        t[p].ls = t[lt].lu;\n    if (t[rt].ru == len(rt))\n        t[p].rs = t[lt].ru + len(rt);\n    else\n        t[p].rs = t[rt].ru;\n    if (!t[p].cnt)\n        t[p].u = t[p].s, t[p].lu = t[p].ls, t[p].ru = t[p].rs;\n    return;\n&#125;\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        t[p].u = t[p].s = 1ll;\n        t[p].lu = t[p].ru = t[p].ls = t[p].rs = 1;\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    pushup(p);\n    return;\n&#125;\nvoid add(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        ++t[p].cnt, t[p].u = 0ll, t[p].lu = t[p].ru = 0;\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid)\n        add(lt, l, r);\n    if (r &gt; mid)\n        add(rt, l, r);\n    pushup(p);\n    return;\n&#125;\nvoid rem(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        if (!--t[p].cnt)\n            t[p].u = t[p].s, t[p].lu = t[p].ls, t[p].ru = t[p].rs;\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid)\n        rem(lt, l, r);\n    if (r &gt; mid)\n        rem(rt, l, r);\n    pushup(p);\n    return;\n&#125;\nint main() &#123;\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    int n, q;\n    std::cin &gt;&gt; n &gt;&gt; q;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    int u = (n + 1) / 2;\n    const int N = a[u];\n    bld(1, 1, N);\n    for (int i = 1; i &lt; u; ++i)\n        if (a[i] != a[n - i + 1])\n            add(1, std::min(a[i], a[n - i + 1]) + 1, std::max(a[i], a[n - i + 1]));\n    std::cout &lt;&lt; t[1].u &lt;&lt; &#39;\\n&#39;;\n    for (int i, v; q--; ) &#123;\n        std::cin &gt;&gt; i &gt;&gt; v;\n        if (a[i] != a[n - i + 1])\n            rem(1, std::min(a[i], a[n - i + 1]) + 1, std::max(a[i], a[n - i + 1]));\n        a[i] = v;\n        if (a[i] != a[n - i + 1])\n            add(1, std::min(a[i], a[n - i + 1]) + 1, std::max(a[i], a[n - i + 1]));\n        std::cout &lt;&lt; t[1].u &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d---移动金币\">D - 移动金币</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P5363\" class=\"uri\">https://www.luogu.com.cn/problem/P5363</a></p>\n<p>最后一个棋子的移动等价于丢掉最后一部分空格；中间棋子的移动等价于把左边间隔里的一段空格拿到右边的间隔里。发现原问题转化为『阶梯 Nim 博弈』。</p>\n<details>\n<p><summary>关于阶梯 Nim 博弈…</summary></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(n\\)</span> 层石头，每次行动可以选择以下操作中的一种：</p>\n<ol type=\"1\">\n<li>选择 <span class=\"math inline\">\\(2\\le i\\le n\\)</span>，从第 <span class=\"math inline\">\\(i\\)</span> 层石头中拿走若干颗，全部放到第 <span class=\"math inline\">\\(i-1\\)</span> 层里。</li>\n<li>从第 <span class=\"math inline\">\\(1\\)</span> 层石头中拿走若干颗，全部丢弃。</li>\n</ol>\n<p>不能行动者输。</p>\n</blockquote>\n<p>本问题可以等效为 Nim 游戏：</p>\n<p>对于第偶数层，若 Alice 选择从第 <span class=\"math inline\">\\(2i\\)</span> 层中移动 <span class=\"math inline\">\\(x\\)</span> 个石头到 <span class=\"math inline\">\\(2i-1\\)</span>，Bob 可以立即从 <span class=\"math inline\">\\(2i-1\\)</span> 层中将这 <span class=\"math inline\">\\(x\\)</span> 个石头移动到 <span class=\"math inline\">\\(2i-2\\)</span>（或丢弃）。</p>\n<p>也就是说，Alice 在偶数层中的操作不会对 Bob 带来任何限制。偶数层的石头可以被视作不存在；从奇数层移动到偶数层的石头可以被视为丢弃；进而，奇数堆中的移动等效为『丢弃』，将原问题中所有奇数堆抽离出来，等效成普通的 Nim 游戏。</p>\n</details>\n<p>问题转化成，将 <span class=\"math inline\">\\(n-m\\)</span> 个元素放到编号 <span class=\"math inline\">\\(0\\sim m+1\\)</span> 的盒子里，满足奇数号盒子球个数异或和为 <span class=\"math inline\">\\(0\\)</span> 的方案数。小容斥一下，用总数减去异或和为 <span class=\"math inline\">\\(0\\)</span> 者。</p>\n",
            "tags": [
                "线段树",
                "博弈论"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250520/",
            "url": "https://xsc062.netlify.app/20250520/",
            "title": "杂题",
            "date_published": "2025-05-20T14:22:43.000Z",
            "content_html": "<p>manual 是 anual 的 m 词形式（胡言乱语）</p>\n<p>Everyone is potential. （每个人都是蛋白质。）</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"cf2043e-matrix-transformation\">CF2043E Matrix Transformation</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/2043/E\" class=\"uri\">https://codeforces.com/problemset/problem/2043/E</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(n\\times m\\)</span> 的 <span class=\"math inline\">\\(01\\)</span> 矩阵 <span class=\"math inline\">\\(A,B\\)</span>，可任意将 <span class=\"math inline\">\\(A\\)</span> 的一行置为 <span class=\"math inline\">\\(0\\)</span> 或一列置为 <span class=\"math inline\">\\(1\\)</span>，问是否能将 <span class=\"math inline\">\\(A\\)</span> 变成 <span class=\"math inline\">\\(B\\)</span>。</p>\n</blockquote>\n<p>发现如果 <span class=\"math inline\">\\(B\\)</span> 的某一行是 <span class=\"math inline\">\\(0\\)</span>，那么不管 <span class=\"math inline\">\\(A\\)</span> 这一行是什么东西都可以通过一次操作让这一行满足条件（当然，要求这步操作最后进行）。列也是相似的。</p>\n<p>那么就有一个撤销的思路，从 <span class=\"math inline\">\\(B\\)</span> 中不断删除全 <span class=\"math inline\">\\(0\\)</span> 行或全 <span class=\"math inline\">\\(1\\)</span> 列，不能删了就对比二者剩下的部分是否全等（因为此时任何操作都是非法的）。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, m;\n        std::cin &gt;&gt; n &gt;&gt; m;\n        using arr = std::vector&lt;int&gt;;\n        using brr = std::vector&lt;arr&gt;;\n        using crr = std::vector&lt;brr&gt;;\n        brr cn(31, arr(n + 1)), cm(31, arr(m + 1));\n        crr a(31, brr(n + 1, arr(m + 1))), b(31, brr(n + 1, arr(m + 1)));\n        for (int i = 1; i &lt;= n; ++i)\n            for (int j = 1, x; j &lt;= m; ++j) &#123;\n                std::cin &gt;&gt; x;\n                for (int k = 0; k &lt; 31; ++k)\n                    a[k][i][j] = (x &gt;&gt; k) &amp; 1;\n            &#125;\n        for (int i = 1; i &lt;= n; ++i)\n            for (int j = 1, x; j &lt;= m; ++j) &#123;\n                std::cin &gt;&gt; x;\n                for (int k = 0; k &lt; 31; ++k) &#123;\n                    b[k][i][j] = (x &gt;&gt; k) &amp; 1;\n                    cn[k][i] += b[k][i][j];\n                    cm[k][j] += !b[k][i][j];\n                &#125;\n            &#125;\n        for (int k = 0; k &lt; 31; ++k) &#123;\n            std::queue&lt;int&gt; qn, qm;\n            std::vector&lt;int&gt; tn(n + 1, 1), tm(m + 1, 1);\n            for (int i = 1; i &lt;= n; ++i)\n                if (!cn[k][i])\n                    tn[i] = 0, qn.push(i);\n            for (int j = 1; j &lt;= m; ++j)\n                if (!cm[k][j])\n                    tm[j] = 0, qm.push(j);\n            for (; !qn.empty() || !qm.empty(); ) &#123;\n                if (!qn.empty()) &#123;\n                    int i = qn.front();\n                    // printf(&quot;delete line %d\\n&quot;, i);\n                    qn.pop();\n                    for (int j = 1; j &lt;= m; ++j)\n                        if (!b[k][i][j] &amp;&amp; !--cm[k][j])\n                            tm[j] = 0, qm.push(j);\n                &#125;\n                else &#123;\n                    int j = qm.front();\n                    // printf(&quot;delete column %d\\n&quot;, j);\n                    qm.pop();\n                    for (int i = 1; i &lt;= n; ++i)\n                        if (b[k][i][j] &amp;&amp; !--cn[k][i])\n                            tn[i] = 0, qn.push(i);\n                &#125;\n            &#125;\n            for (int i = 1; i &lt;= n; ++i)\n                if (tn[i])\n                    for (int j = 1; j &lt;= m; ++j)\n                        if (tm[j] &amp;&amp; a[k][i][j] != b[k][i][j]) &#123;\n                            // printf(&quot;k = %d: (%d, %d)\\n&quot;, k, i, j);\n                            goto nosol;\n                        &#125;\n        &#125;\n        std::cout &lt;&lt; &quot;Yes\\n&quot;;\n        continue;\n    nosol :\n        std::cout &lt;&lt; &quot;No\\n&quot;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"cf2043f-nim\">CF2043F Nim</h2>\n<p><a href=\"https://codeforces.com/contest/2043/problem/F\" class=\"uri\">https://codeforces.com/contest/2043/problem/F</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(m\\)</span> 次询问，每次问从 <span class=\"math inline\">\\(a_l\\sim a_r\\)</span> 选非空子序列使得异或和为 <span class=\"math inline\">\\(0\\)</span>，问子序列最小长度、该前提下的方案数。</p>\n</blockquote>\n<p>发现子序列问题可以等价为背包；背包可以合并（即把整区间拆成若干段后，两两信息可以合并）；<a href=\"/20231117/#关于背包\">背包可以放在分治上</a>；</p>\n<p>由此，把询问离线下来放在 <span class=\"math inline\">\\(a_{1\\sim n}\\)</span> 的分治上，每次只处理在 <span class=\"math inline\">\\([l,r]\\)</span> 间且跨越 <span class=\"math inline\">\\(mid\\)</span> 的询问就可以得到答案。复杂度 <span class=\"math inline\">\\(O(n\\cdot v^2\\log n)\\)</span>。</p>\n<details>\n<p>不要用方案数是否为 <span class=\"math inline\">\\(0\\)</span> 来判断是否无解！因为方案数可能是 <span class=\"math inline\">\\(998244353\\)</span> 的倍数……</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int siz = 63;\nconst int mod = 998244353;\nconst int inf = 0x3f3f3f3f;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    struct _ &#123; int l, r, id; &#125;;\n    std::vector&lt;_&gt; q(m + 1);\n    std::vector&lt;std::pair&lt;int, long long&gt; &gt; res(m + 1, &#123; inf, 0ll &#125;);\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        std::cin &gt;&gt; q[i].l &gt;&gt; q[i].r;\n        q[i].id = i;\n    &#125;\n    std::function&lt;void(int, int, std::vector&lt;_&gt; &amp;q)&gt; calc = [&amp;](int l, int r, std::vector&lt;_&gt; &amp;q) &#123;\n        if (l == r) &#123;\n            for (auto [l, r, id] : q)\n                if (a[l] == 0)\n                    res[id] = &#123; 0, 1ll &#125;;\n            return;\n        &#125;\n        int mid = (l + r) &gt;&gt; 1;\n        std::vector&lt;_&gt; ql, qr, qm;\n        for (; !q.empty(); q.pop_back()) &#123;\n            if (q.back().r &lt;= mid)\n                ql.push_back(std::move(q.back()));\n            else if (q.back().l &gt; mid)\n                qr.push_back(std::move(q.back()));\n            else\n                qm.push_back(std::move(q.back()));\n        &#125;\n        calc(l, mid, ql), calc(mid + 1, r, qr);\n        std::vector&lt;std::vector&lt;int&gt; &gt; f(r - l + 1, std::vector&lt;int&gt; (siz + 1, inf));\n        std::vector&lt;std::vector&lt;long long&gt; &gt; g(r - l + 1, std::vector&lt;long long&gt; (siz + 1));\n        f[mid - l][a[mid]] = 1ll, g[mid - l][a[mid]] = 1ll;\n        for (int i = mid - l - 1; ~i; --i) &#123;\n            int k = a[i + l];\n            f[i] = f[i + 1], g[i] = g[i + 1];\n            if (f[i][k] == 1)\n                (++g[i][k]) %= mod;\n            else\n                f[i][k] = 1, g[i][k] = 1ll;\n            for (int j = 0, k = a[i + l]; j &lt;= siz; ++j)\n                if (f[i + 1][j ^ k] + 1 &lt; f[i][j])\n                    f[i][j] = f[i + 1][j ^ k] + 1, g[i][j] = g[i + 1][j ^ k];\n                else if (f[i + 1][j ^ k] + 1 == f[i][j])\n                    (g[i][j] += g[i + 1][j ^ k]) %= mod;\n        &#125;\n        f[mid - l + 1][a[mid + 1]] = 1ll, g[mid - l + 1][a[mid + 1]] = 1ll;\n        for (int i = mid - l + 2; i &lt;= r - l; ++i) &#123;\n            int k = a[i + l];\n            f[i] = f[i - 1], g[i] = g[i - 1];\n            if (f[i][k] == 1)\n                (++g[i][k]) %= mod;\n            else\n                f[i][k] = 1, g[i][k] = 1ll;\n            for (int j = 0; j &lt;= siz; ++j)\n                if (f[i - 1][j ^ k] + 1 &lt; f[i][j])\n                    f[i][j] = f[i - 1][j ^ k] + 1, g[i][j] = g[i - 1][j ^ k];\n                else if (f[i - 1][j ^ k] + 1 == f[i][j])\n                    (g[i][j] += g[i - 1][j ^ k]) %= mod;\n        &#125;\n        for (auto [ql, qr, id] : qm) &#123;\n            // printf(&quot;at [%d, %d], mid = %d: ASK [%d, %d]: \\n&quot;, l, r, mid, ql, qr);\n            ql -= l, qr -= l;\n            if (f[ql][0] &lt; inf)\n                res[id].first = f[ql][0], res[id].second = g[ql][0];\n            if (f[qr][0] &lt; res[id].first)\n                res[id].first = f[qr][0], res[id].second = g[qr][0];\n            else if (f[qr][0] == res[id].first)\n                (res[id].second += g[qr][0]) %= mod;\n            for (int i = 1; i &lt;= siz; ++i) &#123;\n                // printf(&quot;  %d[%d]: %d(%lld)  |  %d[%d]: %d(%lld)\\n&quot;, ql + l, i, f[ql][i], g[ql][i], qr + l, i, f[qr][i], g[qr][i]);\n                if (f[ql][i] + f[qr][i] &lt; res[id].first)\n                    res[id].first = f[ql][i] + f[qr][i], res[id].second = g[ql][i] * g[qr][i] % mod;\n                else if (f[ql][i] + f[qr][i] == res[id].first)\n                    (res[id].second += g[ql][i] * g[qr][i]) %= mod;\n            &#125;\n            if (res[id].first &lt; inf)\n                res[id].first = (qr - ql + 1) - res[id].first;\n        &#125;\n        return;\n    &#125;;\n    calc(1, n, q);\n    for (int i = 1; i &lt;= m; ++i)\n        if (res[i].first &lt; inf)\n            std::cout &lt;&lt; res[i].first &lt;&lt; &#39; &#39; &lt;&lt; res[i].second &lt;&lt; &#39;\\n&#39;;\n        else\n            std::cout &lt;&lt; -1 &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"贪玩蓝月\">贪玩蓝月</h2>\n<p><a href=\"https://loj.ac/p/6515\" class=\"uri\">https://loj.ac/p/6515</a></p>\n<p><em>差不多的题：<a href=\"https://atcoder.jp/contests/jag2018summer-day2/tasks/jag2018summer_day2_d\" class=\"uri\">https://atcoder.jp/contests/jag2018summer-day2/tasks/jag2018summer_day2_d</a>，注意加入是按体积单增的</em></p>\n<p>发现断点确定时可以背包 <span class=\"math inline\">\\(O(p)\\)</span> 维护插入删除；使用 <a href=\"/20231117/#双栈模拟双端队列\">双栈模拟双端队列</a> 就可以均摊 <span class=\"math inline\">\\(O(pm)\\)</span> 实现插入删除。</p>\n<p>对于询问，当然可以 <span class=\"math inline\">\\(O(p^2)\\)</span> 枚举最值再枚举方案（即枚举一端的贡献）；但复杂度不太美观。考虑倒过来，先 <span class=\"math inline\">\\(O(v)\\)</span> 枚举一端贡献，再枚举『能凑出 <span class=\"math inline\">\\([l,r]\\)</span> 中的值』的另一端的贡献。这样就发现我们是在求区间最大值；每次询问时构建 ST 表预处理另一端的区间最大值即可。</p>\n<p>复杂度 <span class=\"math inline\">\\(O(mq\\log q)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst long long inf = 1e18;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int m, mod;\n    std::cin &gt;&gt; m &gt;&gt; m &gt;&gt; mod;\n    std::array&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt;, 2&gt; T;\n    std::array&lt;std::vector&lt;std::vector&lt;long long&gt; &gt;, 2&gt; F;\n    F[0].emplace_back(mod, -inf), F[1].emplace_back(mod, -inf);\n    F[0][0][0] = 0ll, F[1][0][0] = 0ll;\n    for (; m--; ) &#123;\n        std::string op;\n        std::cin &gt;&gt; op;\n        if (op[0] == &#39;I&#39;) &#123;\n            int v, w;\n            std::cin &gt;&gt; v &gt;&gt; w, v %= mod;\n            auto &amp;t = T[op[1] == &#39;G&#39;];\n            auto &amp;f = F[op[1] == &#39;G&#39;];\n            t.emplace_back(v, w);\n            f.emplace_back(f.back());\n            for (int i = (int)f.size() - 1, j = 0; j &lt; mod; ++j)\n                if (f[i - 1][(j + mod - v) % mod] + w &gt; f[i][j])\n                    f[i][j] = f[i - 1][(j + mod - v) % mod] + w;\n        &#125;\n        else if (op[0] == &#39;D&#39;) &#123;\n            auto &amp;t0 = T[op[1] == &#39;G&#39;], &amp;t1 = T[op[1] == &#39;F&#39;];\n            auto &amp;f0 = F[op[1] == &#39;G&#39;], &amp;f1 = F[op[1] == &#39;F&#39;];\n            if (t0.empty()) &#123;\n                t1.erase(t1.begin());\n                int to = t1.size() / 2;\n                std::vector&lt;std::pair&lt;int, int&gt; &gt; (t1.begin(), t1.begin() + to).swap(t0);\n                std::reverse(t0.begin(), t0.end());\n                std::vector&lt;std::pair&lt;int, int&gt; &gt; (t1.begin() + to, t1.end()).swap(t1);\n                f0.resize(1), f1.resize(1);\n                for (auto [v, w] : t0) &#123;\n                    f0.emplace_back(f0.back());\n                    for (int i = (int)f0.size() - 1, j = 0; j &lt; mod; ++j)\n                        if (f0[i - 1][(j + mod - v) % mod] + w &gt; f0[i][j])\n                            f0[i][j] = f0[i - 1][(j + mod - v) % mod] + w;\n                &#125;\n                for (auto [v, w] : t1) &#123;\n                    f1.emplace_back(f1.back());\n                    for (int i = (int)f1.size() - 1, j = 0; j &lt; mod; ++j)\n                        if (f1[i - 1][(j + mod - v) % mod] + w &gt; f1[i][j])\n                            f1[i][j] = f1[i - 1][(j + mod - v) % mod] + w;\n                &#125;\n            &#125;\n            else\n                t0.pop_back(), f0.pop_back();\n        &#125;\n        else &#123;\n            int l, r;\n            std::cin &gt;&gt; l &gt;&gt; r;\n            auto res(-inf);\n            std::vector&lt;std::vector&lt;long long&gt; &gt; st(std::__lg(mod) + 1, std::vector&lt;long long&gt; (mod + 1));\n            st[0] = F[1].back();\n            for (int j = 1; (1 &lt;&lt; j) &lt;= mod; ++j)\n                for (int i = 0; i + (1 &lt;&lt; j) - 1 &lt; mod; ++i)\n                    st[j][i] = std::max(st[j - 1][i], st[j - 1][i + (1 &lt;&lt; (j - 1))]);\n            auto ask = [&amp;](int l, int r) &#123;\n                int k = std::__lg(r - l + 1);\n                return std::max(st[k][l], st[k][r - (1 &lt;&lt; k) + 1]);\n            &#125;;\n            for (int j = 0; j &lt; mod; ++j)\n                if (j &lt;= l)\n                    res = std::max(res, F[0].back()[j] + ask(l - j, r - j));\n                else if (l &lt; j &amp;&amp; j &lt;= r)\n                    res = std::max(&#123; res, F[0].back()[j] + ask(0, r - j), F[0].back()[j] + ask(l + mod - j, mod - 1) &#125;);\n                else\n                    res = std::max(res, F[0].back()[j] + ask(l + mod - j, r + mod - j));\n            std::cout &lt;&lt; std::max(-1ll, res) &lt;&lt; &#39;\\n&#39;;\n        &#125;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"apio2025-转杆\">APIO2025 转杆</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P12543\" class=\"uri\">https://www.luogu.com.cn/problem/P12543</a></p>\n<p><del>总有一天我要让全天下的数学题 DP 题字符串题图论题模拟题数据结构题思维题全部消失</del></p>\n<p>不要把它转化成序列问题来考虑！这对观察到结论没有好处！</p>\n<p>考虑 <span class=\"math inline\">\\(n=2\\)</span> 的情况，当且仅当垂直时最优。<span class=\"math inline\">\\(n=3\\)</span> 时，随便固定其中一条线，发现剩下两条线如果夹角固定，则代价固定；当夹角取 <span class=\"math inline\">\\(90^{\\circ}\\)</span> 时最优。</p>\n<p>于是猜是不是任意一对都要垂直。考虑数归，当前 <span class=\"math inline\">\\(2n\\)</span> 对 <del>不知道怎么摆的，反正就是</del> 最优时：</p>\n<ul>\n<li>考虑加入第 <span class=\"math inline\">\\(2n+1\\)</span> 条；参照 <span class=\"math inline\">\\(n=3\\)</span> 的情形，把前 <span class=\"math inline\">\\(2n\\)</span> 条任意两两配对，则第 <span class=\"math inline\">\\(2n+1\\)</span> 的位置对代价没有任何影响。</li>\n<li>考虑加入第 <span class=\"math inline\">\\(2n+2\\)</span> 条；相似地，它的位置对前 <span class=\"math inline\">\\(2n\\)</span> 条没有任何影响；故需要最大化它和第 <span class=\"math inline\">\\(2n+1\\)</span> 条的贡献。取垂直即可。</li>\n</ul>\n<p>因此得到任意一对都要垂直。具体怎么调整呢？首先下意识排序；配对方式即将 <span class=\"math inline\">\\(i\\)</span> 与 <span class=\"math inline\">\\(\\dfrac i+\\lfloor \\frac n2\\rfloor\\)</span> 配对；因为能感受到这样影响的线段最少。严谨的证明好像没看到。</p>\n<details>\n<pre class=\"cpp\"><code>#include&lt;bits/stdc++.h&gt;\nvoid energy(int, std::vector&lt;int&gt;);\nvoid rotate(std::vector&lt;int&gt;, int);\nvoid energy(int n, std::vector&lt;int&gt; a) &#123;\n    std::vector&lt;int&gt; id(n);\n    std::iota(id.begin(), id.end(), 0);\n    std::sort(id.begin(), id.end(), [&amp;](int x, int y) &#123; return a[x] &lt; a[y]; &#125;);\n    for (int i = 0, j = n / 2; i &lt; n / 2; ++i, ++j)\n        rotate(&#123; id[j] &#125;, (a[id[i]] + 75000 - a[id[j]]) % 50000);\n    return;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"abc407e-most-valuable-parentheses\">ABC407E Most Valuable Parentheses</h2>\n<p><a href=\"https://atcoder.jp/contests/abc407/tasks/abc407_e\" class=\"uri\">https://atcoder.jp/contests/abc407/tasks/abc407_e</a></p>\n<p>这里有一个很典（可惜我不知道）的 trick：<a href=\"/20231117/#贪心选取括号序列\">贪心构造最优括号序列</a>。</p>\n<p>用优先队列维护，贪心选即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n;\n        std::cin &gt;&gt; n;\n        std::vector&lt;int&gt; a(2 * n + 1);\n        for (int i = 1; i &lt;= 2 * n; ++i)\n            std::cin &gt;&gt; a[i];\n        long long res = a[1];\n        std::priority_queue&lt;int&gt; q;\n        for (int i = 2; i &lt; 2 * n; i += 2) &#123;\n            q.push(a[i]), q.push(a[i + 1]);\n            res += q.top(), q.pop();\n        &#125;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "分治",
                "背包"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250518/",
            "url": "https://xsc062.netlify.app/20250518/",
            "title": "构造类问题的很少解题方法",
            "date_published": "2025-05-18T06:43:30.000Z",
            "content_html": "<p>病毒可能具有膜结构，但不存在生物膜系统。核糖体是唯一所有细胞均含有的细胞器，但病毒中无核糖体。</p>\n<span id=\"more\"></span>\n<p>病毒的主要组成是 <span class=\"math inline\">\\(10\\%\\sim 20\\%\\)</span> 的核酸，<span class=\"math inline\">\\(60\\%\\sim 70\\%\\)</span> 的蛋白质外壳，<span class=\"math inline\">\\(&lt;10\\%\\)</span> 的结合水，可能具有逆转录酶、RNA 聚合酶。病毒的含水量（<span class=\"math inline\">\\(&lt;10\\%\\)</span>）远远小于细胞（<span class=\"math inline\">\\(70\\%\\)</span>）。</p>\n<hr />\n<h2 id=\"type-i调整法---1\">Type I：调整法 - 1</h2>\n<p>虽然话是这么说，感觉这就是平常正常的做题路径，『想做法』——『发现有锅』——『打补丁』。</p>\n<p>只是可能这是在提醒你在构造题中发现有锅不要急着换做法（？）</p>\n<hr />\n<h3 id=\"例题c---stations\">例题：C - Stations</h3>\n<p><a href=\"https://qoj.ac/problem/1139\" class=\"uri\">https://qoj.ac/problem/1139</a></p>\n<p>一个简单的想法是，当可用的编号范围很大时，可以记下每个点 <span class=\"math inline\">\\(u\\)</span> 的 <span class=\"math inline\">\\(DFN_u\\)</span> 和出栈序（记为 <span class=\"math inline\">\\(RFN_u\\)</span>），这样就能解决查询；但标号是 <span class=\"math inline\">\\(N^2\\)</span> 级别的。</p>\n<p>现在思考，我们为什么需要记录 <span class=\"math inline\">\\(RFN_u\\)</span> 呢？因为在询问时，需要判断 <span class=\"math inline\">\\(t\\)</span> 的位置：如果在 <span class=\"math inline\">\\(x\\)</span> 某一儿子的子树内，答案为该儿子；否则，答案为 <span class=\"math inline\">\\(fa\\)</span>。当 <span class=\"math inline\">\\(DFN_t\\)</span> 比 <span class=\"math inline\">\\(u\\)</span> 最靠后的儿子 <span class=\"math inline\">\\(v\\)</span> 的 <span class=\"math inline\">\\(DFN\\)</span> 还要大时，无法判断 <span class=\"math inline\">\\(t\\)</span> 在 <span class=\"math inline\">\\(v\\)</span> 内还是在 <span class=\"math inline\">\\(u\\)</span> 外。</p>\n<p>此处有一个解决方案（原谅我实在无法猜出是怎么想到的），将树按奇数层、偶数层分层，计数层记录 <span class=\"math inline\">\\(DFN\\)</span>，偶数层记录 <span class=\"math inline\">\\(RFN\\)</span>（具体地，奇数层在入栈时编号，偶数层在出栈时编号）；接下来进行判断（注意我们并不知道 <span class=\"math inline\">\\(u\\)</span> 所在层数的奇偶性）：</p>\n<ul>\n<li>若不存在 <span class=\"math inline\">\\(id_i&gt;id_u\\)</span>，说明 <span class=\"math inline\">\\(id_u\\)</span> 为 <span class=\"math inline\">\\(RFN_u\\)</span>；此时 可以判断 <span class=\"math inline\">\\(t\\)</span> 是否位于 <span class=\"math inline\">\\(u\\)</span> 内。</li>\n<li>否则，<span class=\"math inline\">\\(id_u\\)</span> 为 <span class=\"math inline\">\\(DFN_u\\)</span>。由于知道 <span class=\"math inline\">\\(RFN_v\\)</span>，可以判断 <span class=\"math inline\">\\(t\\)</span> 是否位于 <span class=\"math inline\">\\(v\\)</span> 内。</li>\n</ul>\n<p>容易证明其他一般情况也可以判断 <span class=\"math inline\">\\(t\\)</span> 的位置。复杂度 <span class=\"math inline\">\\(O(n^2)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &quot;stations.h&quot;\n#include &lt;bits/stdc++.h&gt;\nstd::vector&lt;int&gt; label(int n, int k, std::vector&lt;int&gt; u, std::vector&lt;int&gt; v) &#123;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n);\n    for (int i = 0; i &lt; n - 1; ++i)\n        g[u[i]].push_back(v[i]), g[v[i]].push_back(u[i]);\n    std::vector&lt;int&gt; id(n, -1);\n    int now = 0;\n    std::function&lt;void(int, int, int)&gt; DFS = [&amp;](int x, int fa, int tag) &#123;\n        if (tag)\n            id[x] = now++;\n        for (auto i : g[x])\n            if (i != fa)\n                DFS(i, x, tag ^ 1);\n        if (!tag)\n            id[x] = now++;\n        return;\n    &#125;;\n    DFS(0, -1, 1);\n    return id;\n&#125;\nint find_next_station(int s, int t, std::vector&lt;int&gt; c) &#123;\n    if (c.back() &lt; s) &#123;\n        int fa = c.front();\n        if (t &gt; s)\n            return fa;\n        for (int i = (int)c.size() - 1; ~i; --i)\n            if (t &gt;= c[i])\n                return c[i];\n        return fa;\n    &#125;\n    else &#123;\n        int fa = c.back();\n        if (t &lt; s)\n            return fa;\n        for (int i = 0; i &lt; (int)c.size() - 1; ++i)\n            if (t &lt;= c[i])\n                return c[i];\n        return fa;\n    &#125;\n    // assert(0);\n    return 114514;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"type-ii调整法---2\">Type II：调整法 - 2</h2>\n<p>题目要求构造『恰好为 <span class=\"math inline\">\\(k\\)</span>』，可以先不看这个限制，对于局面求出上界和下界，然后再看是不是上下界中全部（或大多数）都能取到，此时有两个路径：</p>\n<ul>\n<li>直接在某个上界 / 下界局面中通过若干步极小改动调整到恰好为 <span class=\"math inline\">\\(k\\)</span>；</li>\n<li>通过这一点优化 DP 状态（这样就可以大量压缩『可到达局面』这一信息）。见 <a href=\"/20250510/#b---miriany-and-matchstick\">此</a>。</li>\n</ul>\n<hr />\n<h3 id=\"例题d---construct-the-binary-tree\">例题：D - Construct the Binary Tree</h3>\n<p><a href=\"https://codeforces.com/problemset/problem/1311/E\" class=\"uri\">https://codeforces.com/problemset/problem/1311/E</a></p>\n<p>首先从找上下界的角度出发，发现链为上界，完全二叉树为下界。</p>\n<p>那么只需先 check <span class=\"math inline\">\\(d\\)</span> 是否在该范围内；固定树最左侧的一条链，每次拿走右下角的一个叶子（这样就能<strong>维持完全二叉树性质</strong>），如果可以插入到链底就 do so；否则由于这是个左边挂着单链的完全二叉树，可以证明你想取的任意深度都可以取到，暴力跳即可，且跳完后就构造完了。</p>\n<p>复杂度 <span class=\"math inline\">\\(O(n)\\)</span>。</p>\n<p><span class=\"math inline\">\\(O(nd)\\)</span> 是每次取点时扫一遍完全二叉树找一个能让当前点深度 <span class=\"math inline\">\\(+1\\)</span> 的父节点。<span class=\"math inline\">\\(O(d)\\)</span> 的做法是慢慢把树变窄变高，一次还是只 <span class=\"math inline\">\\(+1\\)</span>，二者的弊端都在于没利用『上界为链』即链和完全二叉树的优美性质。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, d;\n        std::cin &gt;&gt; n &gt;&gt; d;\n        std::vector&lt;int&gt; tag(n + 1), dep(n + 1), cnt(n + 1), fa(n + 1);\n        int L = 0, R = n * (n - 1) / 2;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            L += std::__lg(i), dep[i] = std::__lg(i);\n            if (i * 2 &lt;= n)\n                ++cnt[i], fa[i * 2] = i;\n            if (i * 2 + 1 &lt;= n)\n                ++cnt[i], fa[i * 2 + 1] = i;\n        &#125;\n        if (L &lt;= d &amp;&amp; d &lt;= R) &#123;\n            std::cout &lt;&lt; &quot;YES\\n&quot;;\n            int t = 1;\n            for (int i = 1; i &lt;= n; i *= 2)\n                tag[i] = 1, t = i;\n            for (int i = n; i &amp;&amp; L != d; --i)\n                if (!tag[i]) &#123;\n                    // printf(&quot;i = %d\\n&quot;, i);\n                    if (L + (dep[t] + 1) - dep[i] &lt;= d) &#123;\n                        // printf(&quot;L += %d - %d\\n&quot;, dep[t] + 1, dep[i]);\n                        L += (dep[t] + 1) - dep[i];\n                        --cnt[fa[i]], cnt[i] = 0, ++cnt[t];\n                        dep[i] = dep[t] + 1, fa[i] = t;\n                        t = i, tag[i] = 1;\n                    &#125;\n                    else &#123;\n                        for (int j = 1; j &lt;= n; ++j)\n                            if (cnt[j] != 2 &amp;&amp; L + (dep[j] + 1) - dep[i] == d) &#123;\n                                fa[i] = j, L = d;\n                                break;\n                            &#125;\n                    &#125;\n                &#125;\n            for (int i = 2; i &lt;= n; ++i)\n                std::cout &lt;&lt; fa[i] &lt;&lt; &#39; &#39;;\n            std::cout &lt;&lt; &#39;\\n&#39;;\n        &#125;\n        else &#123;\n            // printf(&quot;[%d, %d]\\n&quot;, L, R);\n            std::cout &lt;&lt; &quot;NO\\n&quot;;\n        &#125;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"type-iii增量法-规约法\">Type III：增量法 / 规约法</h2>\n<p>增量法：类似数归，发现可以方便地从 <span class=\"math inline\">\\(n-k\\)</span> 扩展到 <span class=\"math inline\">\\(n\\)</span>，考虑 <span class=\"math inline\">\\(n-k\\)</span> 给 <span class=\"math inline\">\\(k\\)</span> 带来的限制 / 性质，就可以类递推地做了。</p>\n<p>规约法：发现抠掉一个好处理的 <span class=\"math inline\">\\(k\\)</span> 之后可以转化为规模为 <span class=\"math inline\">\\(n-k\\)</span> 的子问题，考虑 <span class=\"math inline\">\\(k\\)</span> 给 <span class=\"math inline\">\\(n - k\\)</span> 带来的限制，也可以类递推地做。</p>\n<p>其实真差不多哈，并不能说是一正一反之类的，因为思维路径真没太差。</p>\n<hr />\n<h3 id=\"例题经典题\">例题：经典题</h3>\n<blockquote>\n<p>给定大小为 <span class=\"math inline\">\\(n\\)</span> 的竞赛图，<span class=\"math inline\">\\(O(n^2)\\)</span> 内求出一条哈密顿路径。</p>\n<ul>\n<li>竞赛图：给完全图的每条边定向。</li>\n<li>哈密顿路径：经过每个点恰好一次，对边无要求。</li>\n</ul>\n</blockquote>\n<p>假设已经知道规模为 <span class=\"math inline\">\\(n-1\\)</span> 的子问题的解法，塞一个新点进去，考察 <span class=\"math inline\">\\(P(n-1)\\)</span> 中的 <span class=\"math inline\">\\(\\forall\\, u\\to v\\)</span>：</p>\n<ul>\n<li>若只存在 <span class=\"math inline\">\\(n\\to u,n\\to v\\)</span>：对于路径起点 <span class=\"math inline\">\\(s\\)</span> 也有 <span class=\"math inline\">\\(n\\to s\\)</span>，把 <span class=\"math inline\">\\(n\\)</span> 添加到开头即可。</li>\n<li>若只存在 <span class=\"math inline\">\\(u\\to n,v\\to n\\)</span>：对于路径终点 <span class=\"math inline\">\\(t\\)</span> 也有 <span class=\"math inline\">\\(t\\to n\\)</span>，把 <span class=\"math inline\">\\(n\\)</span> 添加到末尾即可。</li>\n<li>若只存在 <span class=\"math inline\">\\(n\\to u,v\\to n\\)</span>：对于路径起点 <span class=\"math inline\">\\(s\\)</span> 也有 <span class=\"math inline\">\\(n\\to s\\)</span>，对于路径终点 <span class=\"math inline\">\\(t\\)</span> 也有 <span class=\"math inline\">\\(t\\to n\\)</span>，爱加哪儿就加哪儿。</li>\n<li>否则：存在 <span class=\"math inline\">\\(u\\to n,n\\to v\\)</span>，皆大欢喜，将 <span class=\"math inline\">\\(u\\to v\\)</span> 改为 <span class=\"math inline\">\\(u\\to n\\to v\\)</span> 即可。</li>\n</ul>\n<p>由此就可以解决问题。</p>\n<hr />\n<h3 id=\"例题e---travelling-salesperson\">例题：E - Travelling Salesperson</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P6644\" class=\"uri\">https://www.luogu.com.cn/problem/P6644</a></p>\n<p>注意本题为无向边！</p>\n<p>相似地，对于 <span class=\"math inline\">\\(P(n-1)\\)</span>，假如存在 <span class=\"math inline\">\\(u\\to v\\)</span>，欲加入 <span class=\"math inline\">\\(u\\to n\\to v\\)</span> 讨论以下几种情况：</p>\n<ul>\n<li>若 <span class=\"math inline\">\\(P(n - 1)\\)</span> 中只含有一种颜色的边：直接加入首 / 尾即可。</li>\n<li>若存在 <span class=\"math inline\">\\(\\color{red}{\\to} u\\color{red}{\\to}v\\color{red}{\\to}\\)</span>、<span class=\"math inline\">\\(u\\color{red}{\\to} n\\)</span> 和 <span class=\"math inline\">\\(n\\color{red}{\\to} v\\)</span>（蓝色同理）：直接加入，皆大欢喜。</li>\n<li><p>其余情况，就是 <span class=\"math inline\">\\(\\color{red}{\\to} u\\color{blue}{\\to} v\\color{blue}{\\to}\\)</span> 的情况了。容易发现除了 <span class=\"math inline\">\\(u\\color{blue}{\\to} n\\land n\\color{red}{\\to} v\\)</span> 之外的情况都可以直接将边加入。故接下来讨论该特例。</p>\n<p>此时在 <span class=\"math inline\">\\((u,v)\\)</span> 处无法加入；尝试考虑相邻的点。由于在 <span class=\"math inline\">\\(u\\color{blue}{\\to} v\\)</span> 处切换颜色，易知 <span class=\"math inline\">\\(u\\ne s\\)</span>，即 <span class=\"math inline\">\\(u\\)</span> 存在前驱（记为 <span class=\"math inline\">\\(p\\)</span>）。</p>\n<ul>\n<li>若存在 <span class=\"math inline\">\\(p\\color{blue}{\\to} i\\)</span>：连接 <span class=\"math inline\">\\(p,i,u\\)</span>，最终局面为 <span class=\"math inline\">\\(\\color{red}{\\to} p\\color{blue}{\\to} i\\color{blue}{\\to} u\\color{blue}{\\to} v\\color{blue}{\\to}\\)</span>，即将变换处提前两位。</li>\n<li>否则：存在 <span class=\"math inline\">\\(p\\color{red}{\\to} i\\)</span>，仍然连接 <span class=\"math inline\">\\(p,i,u\\)</span>，最终局面为 <span class=\"math inline\">\\(\\color{red}{\\to} p\\color{red}{\\to} i\\color{blue}{\\to} u\\color{blue}{\\to} v\\color{blue}{\\to}\\)</span>，即将变换处提前一位。</li>\n</ul></li>\n</ul>\n<p>由此可解决问题。可以发现并不存在所谓无解的情况 <img src=\"/em/ll.gif\" /> —— 倒不如说可以对所有点套用最后一种情况（和第一种）——就能够 <span class=\"math inline\">\\(O(n^2)\\)</span> 解决原问题了。</p>\n<details>\n<p>loj 上过了但洛谷过不了 <img src=\"/em/kt.gif\" /></p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    if (n == 1) &#123;\n        std::cout &lt;&lt; &quot;1\\n1&quot; &lt;&lt; &#39;\\n&#39;;\n        return 0;\n    &#125;\n    std::vector&lt;std::vector&lt;char&gt; &gt; g(n + 1, std::vector&lt;char&gt; (n + 1));\n    for (int i = 2; i &lt;= n; ++i)\n        for (int j = 1; j &lt; i; ++j)\n            std::cin &gt;&gt; g[i][j], g[j][i] = g[i][j];\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::vector&lt;int&gt; tag(n + 1);\n        std::list&lt;int&gt; p(&#123; i, i == 1 ? 2 : 1 &#125;);\n        tag[p.front()] = tag[p.back()] = 1;\n        bool flag = 1;\n        char R = g[p.front()][p.back()], B = ((R == &#39;R&#39;) ? &#39;B&#39; : &#39;R&#39;);\n        auto pos = --p.end();\n        for (int j = 1; j &lt;= n; ++j)\n            if (!tag[j]) &#123;\n                if (flag &amp;&amp; g[j][p.back()] == R)\n                    // printf(&quot;%d: 30  &quot;, j),\n                    p.push_back(j), ++pos;\n                else if (g[j][p.back()] == B)\n                    // printf(&quot;%d: 33  &quot;, j),\n                    p.push_back(j), flag = 0;\n                else &#123;\n                    auto u = pos, v = std::next(pos);\n                    if (g[*u][j] == R &amp;&amp; g[j][*v] == R) &#123;\n                        // printf(&quot;%d: 38  &quot;, j),\n                        p.insert(v, j), ++++pos;\n                        if (v == --p.end())\n                            flag = 1;\n                    &#125;\n                    else if (g[*u][j] == R &amp;&amp; g[j][*v] == B)\n                        // printf(&quot;%d: 41  &quot;, j),\n                        p.insert(v, j), ++pos;\n                    else if (g[*u][j] == B &amp;&amp; g[j][*v] == B)\n                        // printf(&quot;%d: 44  &quot;, j),\n                        p.insert(v, j);\n                    else &#123;\n                        auto pr(std::prev(u));\n                        if (g[*pr][j] == B)\n                            // printf(&quot;%d: 49  &quot;, j),\n                            p.insert(u, j), ----pos;\n                        else\n                            // printf(&quot;%d: 52  &quot;, j),\n                            p.insert(u, j), --pos;\n                    &#125;\n                &#125;\n                // for (auto j : p)\n                //     std::cout &lt;&lt; j &lt;&lt; &#39; &#39;;\n                // printf(&quot; flag = %d\\n&quot;, flag);\n            &#125;\n        std::cout &lt;&lt; n &lt;&lt; &#39;\\n&#39;;\n        for (auto j : p)\n            std::cout &lt;&lt; j &lt;&lt; &#39; &#39;;\n        std::cout &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"f---sergeys-problem\">F - Sergey’s problem</h3>\n<p><a href=\"https://codeforces.com/problemset/problem/1019/C\" class=\"uri\">https://codeforces.com/problemset/problem/1019/C</a></p>\n",
            "tags": [
                "构造",
                "调整法"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250510/",
            "url": "https://xsc062.netlify.app/20250510/",
            "title": "杂题",
            "date_published": "2025-05-10T02:18:21.000Z",
            "content_html": "<p>啊啊。小封条。</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a---pass-to-next\">A - Pass to Next</h2>\n<p><a href=\"https://atcoder.jp/contests/arc124/tasks/arc124_e\" class=\"uri\">https://atcoder.jp/contests/arc124/tasks/arc124_e</a></p>\n<p>感觉其他一些题解讲得不是特别清楚，这里参考了 <a href=\"https://blog.csdn.net/weixin_43960287/article/details/119140590\">XJX 的文章</a>。</p>\n<p>要求的答案是 <span class=\"math inline\">\\(\\prod a&#39;_i\\)</span>，<mark>发现运算是乘法，比较怪；由此考虑转化为方案数，也就是假设每个人有 <span class=\"math inline\">\\(a&#39;_i\\)</span> 个互不相同的球，每个人在其中选出恰好一个的方案数</mark>。</p>\n<p>考虑 DP。发现每个人手上的球分为『自己的』和『左边的人传过来的』两种类型；<mark>显然第二种会有来自上一个人的限制，考虑把第二种在上一个人就完成求解</mark>。具体地，设 <span class=\"math inline\">\\(f_{i,0}\\)</span> 表示第 <span class=\"math inline\">\\(i\\)</span> 个人选取自己的球，但只记录 <span class=\"math inline\">\\(1\\sim i-1\\)</span> 的方案；<span class=\"math inline\">\\(f_{i,1}\\)</span> 表示第 <span class=\"math inline\">\\(i\\)</span> 个人选取第 <span class=\"math inline\">\\(i-1\\)</span> 个人的球，并记入答案的方案。<em>你可能需要注意到：最后一个被记入方案的球来自第 <span class=\"math inline\">\\(i-1\\)</span> 个人</em>。</p>\n<p>但这样会有个小问题。我们让所有人多往右边传一个球，那么在我们的这种分割方法看来是不一样的局面；但实际上它们是等价的。从每个人传出了多少个球（设为 <span class=\"math inline\">\\(x_i\\)</span>）的角度来看，对于 <span class=\"math inline\">\\(\\min\\{x_n\\}\\ne 0\\)</span>，只需要不断执行 <span class=\"math inline\">\\(\\forall\\, x_i\\gets x_i-1\\)</span> 就可以在局面不变的情况下使 <span class=\"math inline\">\\(\\min\\{x_n\\}\\ne 0\\)</span>。这是在说，可以让 <span class=\"math inline\">\\(\\min\\{x_n\\}\\ne 0\\)</span> 的方案和终局一一对应。</p>\n<p>发现可以容斥：钦定 <span class=\"math inline\">\\(x_i\\ge 1\\)</span>，也就是每个人必须往右传至少一个，相似地算一遍就能得到非法方案。</p>\n<p>考虑转移，令 <span class=\"math inline\">\\(x_i\\)</span> 可选最小值为 <span class=\"math inline\">\\(l\\)</span>，有：</p>\n<ul>\n<li><span class=\"math inline\">\\(f_{i+1,0}\\gets f_{i,0}\\)</span>：将第 <span class=\"math inline\">\\(i\\)</span> 个人未被记入的自己的球记入，球数可能为 <span class=\"math inline\">\\([0,a_i-l]\\)</span>。等差数列求和即可。</li>\n<li><span class=\"math inline\">\\(f_{i+1,0}\\gets f_{i,1}\\)</span>：没有球需要被记入，但是这种情况对应多种 <span class=\"math inline\">\\(x_i\\)</span>。具体地，<span class=\"math inline\">\\(x_i\\in [l,a_i]\\)</span>。共有 <span class=\"math inline\">\\(a_i-l+1\\)</span> 种方案。</li>\n<li><span class=\"math inline\">\\(f_{i+1,1}\\gets f_{i,0}\\)</span>：将第 <span class=\"math inline\">\\(i\\)</span> 个人的 <span class=\"math inline\">\\(a_i\\)</span> 个球分给 <span class=\"math inline\">\\(i\\)</span> 和 <span class=\"math inline\">\\(i+1\\)</span>。共有 <span class=\"math inline\">\\(x_i\\cdot (a_i-x_i)\\)</span> 种可能，也就是 <span class=\"math inline\">\\(\\left(a_i\\cdot \\sum_{x_i=l}^{a_i} x_i\\right)-\\left(\\sum_{x_i=l}^{a_i}{x_i}^2\\right)\\)</span> 种方案。</li>\n<li><span class=\"math inline\">\\(f_{i+1,1}\\gets f_{i,1}\\)</span>：将第 <span class=\"math inline\">\\(i+1\\)</span> 个人得到的第 <span class=\"math inline\">\\(i\\)</span> 个人的球记入，同第一条。</li>\n</ul>\n<p>破环为链，分别钦定第一个人是用自己的球还是上一个人的球来解决问题（必须对于两种可能性分开计算；否则就不知道答案应该取 <span class=\"math inline\">\\(f_{n,0}\\)</span> 还是 <span class=\"math inline\">\\(f_{n,1}\\)</span>）。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353, inv2 = (mod + 1) &gt;&gt; 1, inv6 = 166374059;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;long long&gt; a(n);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i % n];\n    auto sum = [&amp;](long long r) &#123;\n        return r * (r + 1) % mod * inv2 % mod;\n    &#125;;\n    auto sum2 = [&amp;](long long r) &#123;\n        return r * (r + 1) % mod * (2 * r % mod + 1) % mod * inv6 % mod;\n    &#125;;\n    std::vector&lt;std::vector&lt;long long&gt; &gt; f0(n, std::vector&lt;long long&gt; (2)), f1(n, std::vector&lt;long long&gt; (2));\n    auto calc = [&amp;](long long l, std::vector&lt;std::vector&lt;long long&gt; &gt; &amp;f) &#123;\n        f[0][0] = 1ll;\n        for (int i = 0; i &lt; n; ++i) &#123;\n            int j = (i + 1) % n;\n            f[j][0] = f[i][0] * sum(a[i] - l) % mod;\n            (f[j][0] += f[i][1] * (a[i] - l + 1)) %= mod;\n            f[j][1] = f[i][0] * (a[i] * sum(a[i]) % mod - sum2(a[i])) % mod;\n            (f[j][1] += f[i][1] * sum(a[i]) % mod) %= mod;\n            // printf(&quot;0, l = %lld, f[%d]: %lld / %lld\\n&quot;, l, j, f[j][0], f[j][1]);\n        &#125;\n        auto res(f[0][0]);\n        f.assign(n, std::vector&lt;long long&gt; (2));\n        f[0][1] = 1ll;\n        for (int i = 0; i &lt; n; ++i) &#123;\n            int j = (i + 1) % n;\n            f[j][0] = f[i][0] * sum(a[i] - l) % mod;\n            (f[j][0] += f[i][1] * (a[i] - l + 1)) %= mod;\n            f[j][1] = f[i][0] * (a[i] * sum(a[i]) % mod - sum2(a[i])) % mod;\n            (f[j][1] += f[i][1] * sum(a[i]) % mod) %= mod;\n            // printf(&quot;1, l = %lld, f[%d]: %lld / %lld\\n&quot;, l, j, f[j][0], f[j][1]);\n        &#125;\n        return (res + f[0][1]) % mod;\n    &#125;;\n    std::cout &lt;&lt; (calc(0, f0) + mod - calc(1, f1)) % mod &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---绿宝石之岛\">B - 绿宝石之岛</h2>\n<p><a href=\"https://loj.ac/p/6406\" class=\"uri\">https://loj.ac/p/6406</a></p>\n<p>因为只关心最终状态，原题可以转化为：将 <span class=\"math inline\">\\(d\\)</span> 分成 <span class=\"math inline\">\\(n\\)</span> 个非负整数，前 <span class=\"math inline\">\\(r\\)</span> 大数之和的期望（当然你需要加上初始的 <span class=\"math inline\">\\(r\\)</span> 个）。</p>\n<p>关于非负整数拆分：设 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示将 <span class=\"math inline\">\\(i\\)</span> 分成 <span class=\"math inline\">\\(j\\)</span> 个 <strong>非负整数</strong> 的方案，钦定其中恰有 <span class=\"math inline\">\\(k\\)</span> 个 <strong>正整数</strong> 进行转移，给这 <span class=\"math inline\">\\(k\\)</span> 个数先分一个 <span class=\"math inline\">\\(1\\)</span>，则 <span class=\"math inline\">\\(f_{i,j}=\\sum\\limits_{k=0}^{\\min(i,j)} C_j^k\\cdot f_{i-k,k}\\)</span>。</p>\n<p>再设 <span class=\"math inline\">\\(g_{i,j}\\)</span> 表示将 <span class=\"math inline\">\\(i\\)</span> 分成 <span class=\"math inline\">\\(j\\)</span> 个非负整数的所有方案中、前 <span class=\"math inline\">\\(r\\)</span> 大的数之和。类似地，有 <span class=\"math inline\">\\(g_{i,j}=\\sum\\limits_{k=0}^{\\min(i,j)} C_j^k\\cdot (g_{i-k,k}+\\min(k,r)\\cdot f_{i-k,k})\\)</span>。其中，<span class=\"math inline\">\\(\\min(k,r)\\)</span> 的来源是，只有 <span class=\"math inline\">\\(k\\)</span> 个数有值，前 <span class=\"math inline\">\\(r\\)</span> 大的数一定在这 <span class=\"math inline\">\\(k\\)</span> 个数里面。</p>\n<p>答案为 <span class=\"math inline\">\\(\\dfrac {g_{d,n}}{f_{d,n}}+r\\)</span>，复杂度 <span class=\"math inline\">\\(O(n^3)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, d, r;\n    std::cin &gt;&gt; n &gt;&gt; d &gt;&gt; r;\n    using arr = std::vector&lt;double&gt;;\n    std::vector&lt;arr&gt; f(d + 1, arr(n + 1)), g(d + 1, arr(n + 1)), C(n + 1, arr(n + 1));\n    for (int i = 0; i &lt;= n; ++i) &#123;\n        C[i][0] = 1.;\n        for (int j = 1; j &lt;= i; ++j)\n            C[i][j] = C[i - 1][j - 1] + C[i - 1][j];\n    &#125;\n    f[0].assign(n + 1, 1.);\n    for (int i = 1; i &lt;= d; ++i)\n        for (int j = 1; j &lt;= n; ++j) &#123;\n            for (int k = 1; k &lt;= i &amp;&amp; k &lt;= j; ++k) &#123;\n                f[i][j] += C[j][k] * f[i - k][k];\n                g[i][j] += C[j][k] * (g[i - k][k] + std::min(k, r) * f[i - k][k]);\n                // printf(&quot;  k = %d, %.0lf + %.0lf\\n&quot;, k, C[j][k] * g[i - k][k], std::min(k, r) * f[i - k][k]);\n            &#125;\n            // printf(&quot;f[%d][%d] = %.0lf, g[%d][%d] = %.0lf\\n&quot;, i, j, f[i][j], i, j, g[i][j]);\n        &#125;\n    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(8) &lt;&lt; g[d][n] / f[d][n] + r &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---uddered-but-not-herd-g\">C - Uddered but not Herd G</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P7296\" class=\"uri\">https://www.luogu.com.cn/problem/P7296</a></p>\n<p>给每个字母分配一个标号 <span class=\"math inline\">\\(x\\)</span>，那么最小段数就是 <span class=\"math inline\">\\(\\sum \\left[x_i\\ge x_{i+1}\\right]\\)</span>。</p>\n<p>考虑状压完成映射操作，令 <span class=\"math inline\">\\(f_{s}\\)</span> 表示给标号 <span class=\"math inline\">\\(1\\sim |s|\\)</span> 分配字母后，占用字符集 <span class=\"math inline\">\\(s\\)</span> 的方案数，那么就能 <span class=\"math inline\">\\(O(1)\\)</span> 得到贡献——只需预处理出 <span class=\"math inline\">\\(f_{c, s}\\)</span> 表示分配到字母 <span class=\"math inline\">\\(c\\)</span> 时，已经先给 <span class=\"math inline\">\\(s\\)</span> 中字母分配了更小标号时的贡献。</p>\n<p>注意字符集大小只有 <span class=\"math inline\">\\(20\\)</span>，可以 <span class=\"math inline\">\\(O(|S|\\cdot 2^{|S|})\\)</span> 解决问题，<mark>注意到预处理的内容是类高维前缀最值的形式，可以递推降低复杂度</mark>。</p>\n<details>\n<pre data-line=\"26-28\" class=\"cpp language-cpp\"><code data-line=\"26-28\" class=\"cpp language-cpp\">#include &lt;bits/stdc++.h>\nconst int inf = 0x3f3f3f3f;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(\".in\", \"r\", stdin);\n    std::freopen(\".out\", \"w\", stdout);\n#endif\n    int n;\n    std::string t;\n    std::cin >> t, n = (int)t.length(), t = \"#\" + t;\n    std::vector&lt;int> a, tag(26, -1), s(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        if (tag[t[i] - 'a'] == -1)\n            tag[t[i] - 'a'] = (int)a.size(), a.push_back(t[i] - 'a');\n        s[i] = tag[t[i] - 'a'];\n    &#125;\n    int m = (int)a.size(), siz = 1 &lt;&lt; m;\n    std::vector&lt;std::vector&lt;int> > cnt(m, std::vector&lt;int> (m));\n    for (int i = 1; i &lt; n; ++i)\n        ++cnt[s[i]][s[i + 1]];\n    std::vector&lt;std::vector&lt;int> > g(m, std::vector&lt;int> (siz));\n    for (int i = 0; i &lt; m; ++i)\n        for (int k = 0; k &lt; m; ++k) // 注意这里相当于是钦定从 k 处转移\n            for (int j = (1 &lt;&lt; k); j &lt; (2 &lt;&lt; k); ++j) // 枚举的是 k 位为 1 的所有数；这两层循环的复杂度为 O(siz)\n                g[i][j] = g[i][j ^ (1 &lt;&lt; k)] + cnt[i][k]; // 目的是此处的内存连续访问优化，把 ^ 看作 - 应该就能理解为什么第二维是连续的\n    std::vector&lt;int> f(siz, inf);\n    f[0] = 1;\n    for (int i = 1; i &lt; siz; ++i)\n        for (int j = 0; j &lt; m; ++j)\n            if ((i >> j) & 1)\n                f[i] = std::min(f[i], f[i ^ (1 &lt;&lt; j)] + g[j][i]);\n    std::cout &lt;&lt; f[siz - 1] &lt;&lt; '\\n';\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d---min-max-subarrays-p\">D - Min Max Subarrays P</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P11845\" class=\"uri\">https://www.luogu.com.cn/problem/P11845</a></p>\n<p>先考虑 <span class=\"math inline\">\\(01\\)</span> 序列的答案：如果序列中存在相邻的 <span class=\"math inline\">\\(2\\)</span> 个 <span class=\"math inline\">\\(1\\)</span>，总能保证最后的一个是 <span class=\"math inline\">\\(1\\)</span>。</p>\n<p>如果序列中存在 <span class=\"math inline\">\\(\\ge 3\\)</span> 个 <span class=\"math inline\">\\(1\\)</span>，可以牺牲其中的一些使得 <span class=\"math inline\">\\(2\\)</span> 个 <span class=\"math inline\">\\(1\\)</span> 相邻。</p>\n<p>当序列中只有 <span class=\"math inline\">\\(2\\)</span> 个 <span class=\"math inline\">\\(1\\)</span> 时，只有因为剩下的 <span class=\"math inline\">\\(0\\)</span> 不太够，导致我们无法随意『上下其手』时不能将 <span class=\"math inline\">\\(2\\)</span> 个 <span class=\"math inline\">\\(1\\)</span> 挪到一起。</p>\n<p>令两个 <span class=\"math inline\">\\(1\\)</span> 为序列最大值与次大值，暴搜处理序列长度较小的情况，剩下的直接用奇偶性判断两个 <span class=\"math inline\">\\(1\\)</span> 取哪个。</p>\n<hr />\n<h2 id=\"a---mst-on-line\">A - MST on Line++</h2>\n<p><a href=\"https://atcoder.jp/contests/arc167/tasks/arc167_c\" class=\"uri\">https://atcoder.jp/contests/arc167/tasks/arc167_c</a></p>\n<p>相当于把 <span class=\"math inline\">\\(a\\)</span> 打乱然后处理原问题。考虑每个 <span class=\"math inline\">\\(a_i\\)</span> 的贡献次数。模拟 Kruskal 连边，从小到大把点 <span class=\"math inline\">\\(a_i\\)</span> 加入图，<span class=\"math inline\">\\(a_i\\)</span> 可以向 <span class=\"math inline\">\\(a_{[i-K,i+K]}\\)</span> 内所有连通块连边。</p>\n<p>连通块数量当且仅当 <span class=\"math inline\">\\([i-K,i)\\)</span> 内最靠右的点和 <span class=\"math inline\">\\((i, i+K]\\)</span> 内最靠左的点距离 <span class=\"math inline\">\\(&gt;K\\)</span> 时为 <span class=\"math inline\">\\(2\\)</span>，其余情况为 <span class=\"math inline\">\\(1\\)</span>。</p>\n<p>但要是从这个角度想这个题就不太好做了。正确的想法应该是<mark>拆分为『若 <span class=\"math inline\">\\([i-K,i)\\)</span> 中有点，贡献次数 <span class=\"math inline\">\\(+1\\)</span>』和『若 <span class=\"math inline\">\\((i,i+K]\\)</span> 中有点 <span class=\"math inline\">\\(j\\)</span> 满足 <span class=\"math inline\">\\([j-K,j)\\)</span> 中无点，贡献次数 <span class=\"math inline\">\\(+1\\)</span>』</mark>。对于第一个问题，贡献次数将前 <span class=\"math inline\">\\(i-1\\)</span> 大的数分配至少一个到 <span class=\"math inline\">\\([i-K,i)\\)</span> 中的方案数；对于第二个问题，枚举 <span class=\"math inline\">\\(j\\)</span>，贡献次数为将前 <span class=\"math inline\">\\(i-1\\)</span> 大的数分配到 <span class=\"math inline\">\\(j\\)</span> 和 <span class=\"math inline\">\\([1,j-K)\\cup (j, n]\\)</span> 中的方案数。</p>\n<details>\n<p>实现的时候千万注意循环变量枚举的是位置还是值！不然你会调得很痛苦。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;03-max-01.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::sort(a.begin() + 1, a.end());\n    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[n] = qkp(fac[n], mod - 2);\n    for (int i = n - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto A = [&amp;](int n, int m) &#123;\n        if (n &lt; m)\n            return 0ll;\n        return fac[n] * inv[n - m] % mod;\n    &#125;;\n    auto C = [&amp;](int n, int m) &#123;\n        return A(n, m) * inv[m] % mod;\n    &#125;;\n    long long res = 0ll;\n    for (int i = 2; i &lt;= n; ++i) &#123;\n        for (int j = 1; j &lt;= n; ++j)\n            (res += a[i] * (fac[n - 1] + mod - A(n - 1 - (j - std::max(1, j - k)), i - 1) * fac[n - i] % mod) % mod) %= mod;\n        for (int j = 2; j &lt;= n; ++j)\n            (res += a[i] * C(i - 1, i - 2) % mod * C(j - std::max(1, j - k), 1) % mod * A(n - (j - std::max(1, j - k) + 1), i - 2) % mod * fac[n - i] % mod) %= mod;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---existence-counting\">B - Existence Counting</h2>\n<p><a href=\"https://atcoder.jp/contests/arc174/tasks/arc174_e\" class=\"uri\">https://atcoder.jp/contests/arc174/tasks/arc174_e</a></p>\n<p>发现可以分类讨论。假设 <span class=\"math inline\">\\(a&#39;\\)</span> 中第一个异于 <span class=\"math inline\">\\(a\\)</span> 的位置为 <span class=\"math inline\">\\(i\\)</span>，<span class=\"math inline\">\\(x\\)</span> 在 <span class=\"math inline\">\\(a\\)</span> 中位置为 <span class=\"math inline\">\\(pos_x\\)</span>（不存在则 <span class=\"math inline\">\\(pos_x=k+1\\)</span>）。令 <span class=\"math inline\">\\(f_i\\)</span> 为若 <span class=\"math inline\">\\(1\\sim i-1\\)</span> 均相同，<span class=\"math inline\">\\(i\\)</span> 位置可选的选项数。则 <span class=\"math inline\">\\(x\\)</span> 出现的次数：</p>\n<table>\n<colgroup>\n<col style=\"width: 25%\" />\n<col style=\"width: 25%\" />\n<col style=\"width: 25%\" />\n<col style=\"width: 25%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th style=\"text-align: center;\"></th>\n<th style=\"text-align: center;\"><span class=\"math inline\">\\(pos_x&lt;i\\)</span></th>\n<th style=\"text-align: center;\"><span class=\"math inline\">\\(pos_x=i\\)</span></th>\n<th style=\"text-align: center;\"><span class=\"math inline\">\\(pos_x&gt;i,i&lt;k\\)</span></th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(x\\le a_i\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(1+f_i\\cdot A_{n-i}^{k-i}\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(f_i\\cdot C_{k-i}^1\\cdot A_{n-i-1}^{k-i-1}\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\((f_i-1)\\cdot C_{k-i}^1\\cdot A_{n-i-1}^{k-i-1}+A_{n-i}^{k-i}\\)</span></td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(x&gt;a_i\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(f_i\\cdot A_{n-i}^{k-i}\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(0\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(f_i\\cdot C_{k-i}^1\\cdot A_{n-i-1}^{k-i-1}\\)</span></td>\n</tr>\n</tbody>\n</table>\n<p>故，对于任意 <span class=\"math inline\">\\(x\\)</span>，答案为：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\n&amp;1+\\left(\\sum_{i=pos_x+1}^k f_i\\cdot A_{n-i}^{k-i}\\right)\n+\\sum_{i=1}^{pos_x} (f_i-[x&lt; a_i])\\cdot C_{k-i}^1\\cdot A_{n-i-1}^{k-i-1}+[x&lt; a_i]\\cdot A_{n-i}^{k-i}\\\\\n=&amp;1+\\left(\\sum_{i=pos_x+1}^k f_i\\cdot A_{n-i}^{k-i}\\right)\n+\\left(\\sum_{i=1}^{pos_x} f_i\\cdot C_{k-i}^1\\cdot A_{n-i-1}^{k-i-1}\\right)+\\sum_{i=1,a_i&gt; x}^{pos_x}A_{n-i}^{k-i}-C_{k-i}^1\\cdot A_{n-i-1}^{k-i-1}\\\\\n\\end{aligned}\n\\]</span></p>\n<p>预处理出 <span class=\"math inline\">\\(f_i=\\sum\\limits_{j=i+1}^k [a_j&lt; a_i]\\)</span>（需要数据结构）、<span class=\"math inline\">\\(g_i=\\sum\\limits_{j=1}^i f_j\\cdot A_{n-j}^{k-j}\\)</span> 和 <span class=\"math inline\">\\(h_j=\\sum\\limits_{j=1}^i f_i\\cdot C_{k-i}^1\\cdot A_{n-i-1}^{k-i-1}\\)</span>，再用数据结构计算 <span class=\"math inline\">\\(\\sum\\limits_{i=1,a_i&gt;x}^{pos_x}C_{k-i}^1\\cdot A_{n-i-1}^{k-i-1} - A_{n-i}^{k-i}\\)</span> 即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    std::vector&lt;int&gt; a(k + 1), p(n + 1, k + 1);\n    for (int i = 1; i &lt;= k; ++i)\n        std::cin &gt;&gt; a[i], p[a[i]] = i;\n    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);\n    &#123;\n        fac[0] = inv[0] = 1ll;\n        for (int i = 1; i &lt;= n; ++i)\n            fac[i] = fac[i - 1] * i % mod;\n        auto qkp = [](long long x, int y) &#123;\n            auto res(1ll);\n            for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n                if (y &amp; 1)\n                    (res *= x) %= mod;\n            return res;\n        &#125;;\n        inv[n] = qkp(fac[n], mod - 2);\n        for (int i = n - 1; i; --i)\n            inv[i] = inv[i + 1] * (i + 1) % mod;\n    &#125;\n    auto A = [&amp;](int n, int m) &#123;\n        if (n &lt; m || m &lt; 0)\n            return 0ll;\n        return fac[n] * inv[n - m] % mod;\n    &#125;;\n    std::vector&lt;long long&gt; f(k + 1), g(k + 1), h(k + 1);\n    std::vector&lt;long long&gt; bit(n + 1);\n    auto lowbit = [](int x) &#123;\n        return x &amp; -x;\n    &#125;;\n    auto add = [&amp;](int x, int v) &#123;\n        for (; x &lt;= n; x += lowbit(x))\n            (bit[x] += v) %= mod;\n        return;\n    &#125;;\n    auto ask = [&amp;](int x) &#123;\n        auto res(0ll);\n        for (; x; x -= lowbit(x))\n            (res += bit[x]) %= mod;\n        return res;\n    &#125;;\n    for (int i = 1; i &lt;= n; ++i)\n        if (p[i] == k + 1)\n            add(i, 1);\n    for (int i = k; i; --i)\n        f[i] = ask(a[i]), add(a[i], 1);\n    for (int i = 1; i &lt;= k; ++i) &#123;\n        g[i] = (g[i - 1] + f[i] * A(n - i, k - i)) % mod;\n        h[i] = (h[i - 1] + f[i] * (k - i) % mod * A(n - i - 1, k - i - 1)) % mod;\n        // printf(&quot;%d: f = %lld, g = %lld, h = %lld\\n&quot;, i, f[i], g[i], h[i]);\n    &#125;\n    std::vector&lt;long long&gt; res(n + 1);\n    bit.assign(n + 1, 0ll);\n    auto s(0ll);\n    for (int i = 1; i &lt;= k; ++i) &#123;\n        // printf(&quot;%d: %lld + %lld + %lld\\n&quot;, a[i], 1 + g[k] - g[i], h[i], s - ask(a[i]));\n        res[a[i]] = (1 + g[k] - g[i] + h[i] + (s - ask(a[i]))) % mod;\n        res[a[i]] = (res[a[i]] + mod) % mod;\n        (s += A(n - i, k - i) - (k - i) * A(n - i - 1, k - i - 1)) %= mod;\n        add(a[i], (A(n - i, k - i) - (k - i) * A(n - i - 1, k - i - 1)) % mod);\n    &#125;\n    for (int i = 1; i &lt;= n; ++i)\n        if (p[i] == k + 1) &#123;\n            res[i] = (h[k] + (s - ask(i))) % mod;\n            res[i] = (res[i] + mod) % mod;\n        &#125;\n    for (int x = 1; x &lt;= n; ++x)\n        std::cout &lt;&lt; res[x] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---1-loop-bubble-sort\">C - 1 Loop Bubble Sort</h2>\n<p><a href=\"https://atcoder.jp/contests/arc187/tasks/arc187_c\" class=\"uri\">https://atcoder.jp/contests/arc187/tasks/arc187_c</a></p>\n<p>首先是被考烂了的：对序列进行一次冒泡排序，等价于将序列在前缀最大值处分段，并将其从段首移到段尾；且满足排序前为前缀最大值的元素，排序后仍为前缀最大值。</p>\n<p>考虑用 DP 解决问题。注意状态要从 <span class=\"math inline\">\\(P\\)</span> 的角度出发——假如 <span class=\"math inline\">\\(Q\\)</span> 中不存在 <span class=\"math inline\">\\(-1\\)</span>，发现也需要 DP。此时再设计有关 <span class=\"math inline\">\\(Q\\)</span> 的状态就很扯淡了，考虑令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示 <span class=\"math inline\">\\(P\\)</span> 中直到第 <span class=\"math inline\">\\(i\\)</span> 位的前缀最大值为 <span class=\"math inline\">\\(j\\)</span> 的方案数。为什么把前缀最大值作为状态呢？因为它可以表示分段；同时限制段间数的取值。具体地，考虑转移：</p>\n<ol type=\"1\">\n<li>若令 <span class=\"math inline\">\\(P_i=j\\)</span>，则在 <span class=\"math inline\">\\(i\\)</span> 处分段。对应到 <span class=\"math inline\">\\(Q\\)</span> 中，<span class=\"math inline\">\\(i-1\\)</span> 位是上一个前缀最大值，那么这要求 <span class=\"math inline\">\\(Q_{i-1}&lt;j\\)</span>，且 <span class=\"math inline\">\\(Q_{i-1}\\)</span> 是一个前缀最大值。也即：当 <span class=\"math inline\">\\(Q_{i-1}\\ne -1\\)</span> 时，<span class=\"math inline\">\\(f_{i,j}\\gets f_{i-1, Q_{i-1}}\\)</span>；否则，<span class=\"math inline\">\\(f_{i,j}\\gets \\sum\\limits_{k&lt;j} f_{i-1,k}\\)</span>。其中，二式都要求转移来源为前缀最大值。</li>\n<li>若令 <span class=\"math inline\">\\(P_i&lt;j\\)</span>，则 <span class=\"math inline\">\\(i\\)</span> 在 <span class=\"math inline\">\\(Q\\)</span> 中恰好前移一位，即 <span class=\"math inline\">\\(Q_{i-1}=P_i&lt;j\\)</span>。则当 <span class=\"math inline\">\\(Q_{i-1}\\ne -1\\)</span> 时，该位确定，<span class=\"math inline\">\\(f_{i,j}\\gets f_{i-1,j}\\)</span>；否则，<span class=\"math inline\">\\(Q_{i-1}\\)</span> 可选的值为 <span class=\"math inline\">\\(&lt;j\\)</span> 的所有未选数（定值，可预处理）。</li>\n</ol>\n<p>关于初值，可以在 <span class=\"math inline\">\\(P\\)</span> 前加一个 <span class=\"math inline\">\\(0\\)</span> 作为排列的一部分（那么按照冒泡排序的规则 <span class=\"math inline\">\\(Q\\)</span> 的第一位也一定是 <span class=\"math inline\">\\(0\\)</span>）来处理就好了。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; q(n + 1), t(n + 1), c(n + 1), pos(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; q[i], c[i] = c[i - 1];\n        if (q[i] == -1)\n            ++c[i];\n        else\n            pos[q[i]] = i;\n    &#125;\n    for (int i = 1; i &lt; n; ++i) &#123;\n        // printf(&quot;t[%d] = %d\\n&quot;, i, t[i]);\n        if (!pos[i])\n            for (int j = i + 1; j &lt;= n; ++j)\n                ++t[j];\n    &#125;\n    std::vector&lt;std::vector&lt;long long&gt; &gt; f(n + 1, std::vector&lt;long long&gt; (n + 1)), s(n + 1, std::vector&lt;long long&gt; (n + 1));\n    f[0][0] = 1ll;\n    s[0].assign(n + 1, 1ll);\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = 1; j &lt;= n; ++j) &#123;\n            if (q[i - 1] == -1)\n                f[i][j] = (s[i - 1][j - 1] + f[i - 1][j] * std::max(0, 1 + t[j] - c[i - 1])) % mod;\n            else if (q[i - 1] &lt; j)\n                f[i][j] = (f[i - 1][q[i - 1]] + f[i - 1][j]) % mod;\n            s[i][j] = s[i][j - 1];\n            if (q[i] == j || !pos[j]) // 满足前缀最大值\n                (s[i][j] += f[i][j]) %= mod;\n            // printf(&quot;f[%d][%d] = %lld\\n&quot;, i, j, f[i][j]);\n        &#125;\n    std::cout &lt;&lt; f[n][n] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"f---1.-intro\">(F - 1). Intro</h2>\n<blockquote>\n<p>给定一个大小为 <span class=\"math inline\">\\(n\\)</span> 的树，点有点权。给定 <span class=\"math inline\">\\(q\\)</span> 次操作，分为两种：</p>\n<ol type=\"1\">\n<li><code>1 x</code>：查询 <span class=\"math inline\">\\(x\\)</span> 的点权。</li>\n<li><code>2 x d v</code> 对于所有距 <span class=\"math inline\">\\(x\\)</span> 不超过 <span class=\"math inline\">\\(d\\)</span> 的点，将它们的权值加上 <span class=\"math inline\">\\(v\\)</span>。</li>\n</ol>\n<p><span class=\"math inline\">\\(n,q\\le 10^5,d\\le 20\\)</span>。</p>\n</blockquote>\n<p>由于 <span class=\"math inline\">\\(d\\)</span> 很小，我们可能需要枚举与 <span class=\"math inline\">\\(x\\)</span> 距离 <span class=\"math inline\">\\(0\\sim d\\)</span> 的点进行修改；那么对距离 <span class=\"math inline\">\\(x\\)</span> 为 <span class=\"math inline\">\\(i\\)</span> 的点的更改存储在 <span class=\"math inline\">\\(f_{x,i}\\)</span>，查询 <span class=\"math inline\">\\(v\\)</span> 时就可以从 <span class=\"math inline\">\\(\\sum\\limits_i f_{fa(v,i),i}\\)</span> 求得答案。</p>\n<p>考虑修改。记 <span class=\"math inline\">\\(S_{x,d}\\)</span> 为距 <span class=\"math inline\">\\(x\\)</span> 为 <span class=\"math inline\">\\(d\\)</span> 的点集。<span class=\"math inline\">\\(x\\)</span> 子树内是好处理的，但子树外的呢？发现 <span class=\"math inline\">\\(S_{fa,d-1}\\)</span> 中 <span class=\"math inline\">\\(x\\)</span> 子树外的点，就是 <span class=\"math inline\">\\(fa\\)</span> 子树下、<span class=\"math inline\">\\(x\\)</span> 子树外距离 <span class=\"math inline\">\\(x\\)</span> 为 <span class=\"math inline\">\\(d\\)</span> 的所有点。</p>\n<p>由于所有 <span class=\"math inline\">\\(S_{fa(x,i),d-i}\\)</span> 无交，这可能满足我们每个待操作点被不重不漏加一次的要求。考虑将所有 <span class=\"math inline\">\\(S_{fa(x,i),d-i}\\)</span> 标记出来：</p>\n<figure>\n<img src=\"1.png\" alt=\"粉色虚线框是待操作点集\" /><figcaption>粉色虚线框是待操作点集</figcaption>\n</figure>\n<p>然后我们可以一眼发现被叉的点和未被叉的待操作点是交错的！这意味着我们只需要再补充上所有 <span class=\"math inline\">\\(S_{fa(x,i),d-i-1}\\)</span> 即可（显然它们之间、它们和所有 <span class=\"math inline\">\\(S_{fa(x,i),d-i}\\)</span> 之间都不交）。</p>\n<figure>\n<img src=\"2.png\" alt=\"虚线叉为 S_{fa(x,i),d-i-1}\" /><figcaption>虚线叉为 <span class=\"math inline\">\\(S_{fa(x,i),d-i-1}\\)</span></figcaption>\n</figure>\n<p>此时就可以不重不漏。当然，也会存在一些细节：比如说 <span class=\"math inline\">\\(fa(x,i)\\)</span> 不存在之类。只需要在根节点 <span class=\"math inline\">\\(1\\)</span> 处将剩余的 <span class=\"math inline\">\\(S_{1,i\\to 0}\\)</span> 全部更新即可。</p>\n<p>故每次修改操作只需要修改 <span class=\"math inline\">\\(O(d)\\)</span> 坨点。时间复杂度 <span class=\"math inline\">\\(O(qd)\\)</span>。</p>\n<hr />\n<h2 id=\"f.-distance-to-the-path\">F. Distance to the Path</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1749/F\" class=\"uri\">https://codeforces.com/problemset/problem/1749/F</a></p>\n<p>本例中将单点修改替换为路径修改；考虑树剖解决问题。</p>\n<p>对于路径上的所有点 <span class=\"math inline\">\\(u\\)</span>，容易发现只需要修改所有的 <span class=\"math inline\">\\(S_{u,d}\\)</span> 就可以完成对『<strong>一部分路径内侧的点</strong>』的修改。这『一部分』，是因为不包括距离 LCA <span class=\"math inline\">\\(\\le d\\)</span> 的点。</p>\n<p>而『<strong>另一部分路径内侧的点</strong>（距 LCA <span class=\"math inline\">\\(\\le d\\)</span>：见上一行说明）』及『<strong>路径外侧的点</strong>（距 LCA <span class=\"math inline\">\\(\\le d\\)</span>：因为路径在 LCA 子树内，LCA 能够到最远的外侧点）』，等价于『<strong>距 LCA <span class=\"math inline\">\\(\\le d\\)</span> 的点</strong>』，只需要把 LCA 代入上例中方式修改即可。</p>\n<p>修改路径上所有点 <span class=\"math inline\">\\(u\\)</span> 的 <span class=\"math inline\">\\(S_{u,d}\\)</span> 时，可以对所有 <span class=\"math inline\">\\(f_{*,i}\\)</span> 建立数据结构，由于只需要区间修改、单点查询，使用差分树状数组即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt; \nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; siz(n + 1), dep(n + 1), fa(n + 1), son(n + 1);\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int faa) &#123;\n        siz[x] = 1;\n        for (auto i : g[x])\n            if (i != faa) &#123;\n                fa[i] = x, dep[i] = dep[x] + 1;\n                DFS(i, x);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1, -1);\n    std::vector&lt;int&gt; dfn(n + 1), top(n + 1);\n    DFS = [&amp;](int x, int toop) &#123;\n        static int now = 0;\n        dfn[x] = ++now, top[x] = toop;\n        if (son[x])\n            DFS(son[x], toop);\n        for (auto i : g[x])\n            if (i != fa[x] &amp;&amp; i != son[x])\n                DFS(i, i);\n        return;\n    &#125;;\n    DFS(1, 1);\n    std::vector&lt;std::vector&lt;long long&gt; &gt; bit(21, std::vector&lt;long long&gt; (n + 1));\n    auto lowbit = [&amp;](int x) &#123;\n        return x &amp; -x;\n    &#125;;\n    auto add = [&amp;](auto &amp;bit, int x, int v) &#123;\n        for (; x &lt;= n; x += lowbit(x))\n            bit[x] += v;\n        return;\n    &#125;;\n    auto ask = [&amp;](auto &amp;bit, int x) &#123;\n        auto res(0ll);\n        for (; x; x -= lowbit(x))\n            res += bit[x];\n        return res;\n    &#125;;\n    std::cin &gt;&gt; m;\n    for (int op; m--; ) &#123;\n        std::cin &gt;&gt; op;\n        if (op == 1) &#123;\n            int x;\n            std::cin &gt;&gt; x;\n            auto res(0ll);\n            for (int i = 0; i &lt;= 20 &amp;&amp; x; ++i, x = fa[x])\n                res += ask(bit[i], dfn[x]);\n            std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n        &#125;\n        else &#123;\n            int x, y, v, d;\n            std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; v &gt;&gt; d;\n            for (; top[x] != top[y]; x = fa[top[x]]) &#123;\n                if (dep[top[x]] &lt; dep[top[y]])\n                    std::swap(x, y);\n                add(bit[d], dfn[top[x]], v);\n                add(bit[d], dfn[x] + 1, -v);\n            &#125;\n            if (dep[x] &gt; dep[y])\n                std::swap(x, y);\n            add(bit[d], dfn[x] + 1, v), add(bit[d], dfn[y] + 1, -v);\n            for (x = x, y = d; ~y &amp;&amp; x; x = fa[x], --y) &#123;\n                add(bit[y], dfn[x], v), add(bit[y], dfn[x] + 1, -v);\n                if (y &amp;&amp; fa[x])\n                    add(bit[y - 1], dfn[x], v), add(bit[y - 1], dfn[x] + 1, -v);\n            &#125;\n            if (x == 0)\n                for (; ~y; --y)\n                    add(bit[y], dfn[1], v), add(bit[y], dfn[1] + 1, -v);\n        &#125;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"a---ina-of-the-mountain\">A - Ina of the Mountain</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1852/C\" class=\"uri\">https://codeforces.com/problemset/problem/1852/C</a></p>\n<p>考虑这么一个简化版的问题：</p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(\\{a_n\\}\\)</span>，每次可以进行区间 <span class=\"math inline\">\\(-1\\)</span>，问操作多少次才能将所有元素变为 <span class=\"math inline\">\\(0\\)</span>。</p>\n</blockquote>\n<p>会想到差分；对原数组进行差分，一次操作相当于令 <span class=\"math inline\">\\(d_l\\gets d_l-1\\)</span> 而 <span class=\"math inline\">\\(d_{r+1}\\gets d_{r+1}+1\\)</span>，最后要让 <span class=\"math inline\">\\(\\forall \\,d_i=0\\)</span>。那么答案就是差分数组中正数之和嘛。</p>\n<p>回到原问题。原问题等价于把上述问题变为：</p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(\\{a_n\\}\\)</span>，每次可以进行区间 <span class=\"math inline\">\\(-1\\)</span>，每个数的总操作次数对 <span class=\"math inline\">\\(k\\)</span> 取模，问操作多少次才能将所有元素变为 <span class=\"math inline\">\\(0\\)</span>。</p>\n</blockquote>\n<p>怎么套回到刚刚的问题上呢？还原被取模掉的操作即可。具体来说，提前在 <span class=\"math inline\">\\(d\\)</span> 上进行若干次操作（记为操作 1），形如令 <span class=\"math inline\">\\(d_i\\gets d_i+k\\)</span>，同时 <span class=\"math inline\">\\(d_{i+1}\\gets d_{i+1}-k\\)</span>。</p>\n<p>会发现相邻的操作 <span class=\"math inline\">\\(1\\)</span> 对一个数加加减减影响判断；发现可以合并一段连续的操作 1，表现在 <span class=\"math inline\">\\(a\\)</span> 上也就是区间 <span class=\"math inline\">\\(+k\\)</span>。此时可以发现，一个位置上只会剩下若干次 <span class=\"math inline\">\\(+k\\)</span> 或若干次 <span class=\"math inline\">\\(-k\\)</span> （否则可以把 <span class=\"math inline\">\\(+k\\)</span> 和 <span class=\"math inline\">\\(-k\\)</span> 代表的不同操作合并），就不会有互相影响一说了。这也是有的题解说可以提前在 <span class=\"math inline\">\\(a\\)</span> 上区间 <span class=\"math inline\">\\(+k\\)</span> 的原因。</p>\n<p>此时问题变为在 <span class=\"math inline\">\\(d\\)</span> 进行任意次前加 <span class=\"math inline\">\\(k\\)</span> 后减 <span class=\"math inline\">\\(k\\)</span> 的操作，使得 <span class=\"math inline\">\\(\\sum\\limits_{d_i&gt;0}d_i\\)</span> 最大化。那么显然如果要使代价更小，只可能在原本 <span class=\"math inline\">\\(&lt;0\\)</span> 的位置做加法、<span class=\"math inline\">\\(&gt;0\\)</span> 的位置做减法（其他情况会发现一定不优）。考虑两个数 <span class=\"math inline\">\\(d_l,d_r\\)</span>，可以感受到对于一个 <span class=\"math inline\">\\(r\\)</span>，选最小的 <span class=\"math inline\">\\(d_l\\)</span> 是最优的，但什么时候应该选呢？</p>\n<ul>\n<li><span class=\"math inline\">\\(d_l\\le -k,d_r\\ge k\\)</span>：当然可选，<span class=\"math inline\">\\(k\\)</span> 被完全利用，答案减少 <span class=\"math inline\">\\(k\\)</span>。</li>\n<li><p><span class=\"math inline\">\\(d_l&gt;-k,d_r\\ge k\\)</span>：此时 <span class=\"math inline\">\\(k\\)</span> 未被完全利用，但必须选：选择其他更大的数，<span class=\"math inline\">\\(k\\)</span> 的利用率只会更低；如果不选，答案也无法减少。</p>\n<p>Q：此时是否需要尝试找到一个 <span class=\"math inline\">\\(l&#39;&lt;l\\)</span> 与 <span class=\"math inline\">\\(l\\)</span> 做操作，使得 <span class=\"math inline\">\\(l\\)</span> 重新变为负数呢？</p>\nA：否。因为你可以将这两次操作合并，发现相当于是直接对 <span class=\"math inline\">\\((l&#39;,r)\\)</span> 做操作，是更劣的。</li>\n<li><span class=\"math inline\">\\(d_l\\le -k,d_r&lt;k\\)</span>：此时 <span class=\"math inline\">\\(k\\)</span> 未被完全利用，<span class=\"math inline\">\\(d_r\\)</span> 成为负数。这意味着 <span class=\"math inline\">\\(d_r\\)</span> 将会成为某个 <span class=\"math inline\">\\(r&#39;\\)</span> 的可选项。考察 <span class=\"math inline\">\\(d_{r&#39;}\\)</span> 可用的最小值。如果 <span class=\"math inline\">\\(d_r\\)</span> 在当前不应该作为右端点，它就一定会被 <span class=\"math inline\">\\(d_{r&#39;}\\)</span> 选择。具体的有点抽象，但是你可以理解为 <span class=\"math inline\">\\(d_r\\)</span> 选了 <span class=\"math inline\">\\(d_l\\)</span> 的贡献是被整合到 <span class=\"math inline\">\\(d_r\\)</span> 里的；如果 <span class=\"math inline\">\\(d_r\\)</span> 被选了就说明 <span class=\"math inline\">\\(d_{r&#39;}\\)</span> 选 <span class=\"math inline\">\\(d_l\\)</span> 会拥有更大的优势。</li>\n<li><p><span class=\"math inline\">\\(d_l&gt;-k,d_r&lt;k\\)</span>：和上面的情况相似；但这种情况下答案可能反而变得更大，因为没有后效性，所以至少要保证单步最优。此时不能选。</p>\n<p>说到单步最优，就会发现这里就是反悔贪心；单步最优一定是全局最优，但更靠前的局部最优可能被否定掉。而『否定』的方法表现为一次操作。</p></li>\n</ul>\n<p>综上，从前往后扫，优先队列实时维护负数最小值，对于每个正数，check 选最小值是否优于当前答案，有就选。如果正数被减为负，加入队列。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, k;\n        std::cin &gt;&gt; n &gt;&gt; k;\n        std::vector&lt;int&gt; a(n + 1), d(n + 1);\n        long long res(0ll);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            std::cin &gt;&gt; a[i], a[i] %= k;\n            d[i] = a[i] - a[i - 1];\n            if (d[i] &gt; 0)\n                (res += d[i]);\n        &#125;\n        std::priority_queue&lt;int&gt; q;\n        for (int i = 1; i &lt;= n; ++i)\n            if (d[i] &lt; 0)\n                q.push(-d[i]);\n            else &#123;\n                for (; !q.empty() &amp;&amp; d[i] &gt; 0; ) &#123;\n                    int x = -q.top(), y = d[i];\n                    auto t(res - y);\n                    x += k, y -= k;\n                    if (x &gt; 0)\n                        t += x;\n                    if (y &gt; 0)\n                        t += y;\n                    if (t &gt;= res)\n                        break;\n                    q.pop();\n                    res = t, d[i] = y;\n                    if (d[i] &lt; 0)\n                        q.push(-d[i]);\n                &#125;\n            &#125;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---miriany-and-matchstick\">B - Miriany and Matchstick</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1852/D\" class=\"uri\">https://codeforces.com/problemset/problem/1852/D</a></p>\n<p>从构造的角度出发，看到『恰好为 <span class=\"math inline\">\\(k\\)</span>』，会想到找到上界和下界并证明中间每一个数都能取到。</p>\n<p>但似乎很容易证伪：例如对于 <code>AAAA</code>，下界为 <span class=\"math inline\">\\(0\\)</span>，上界为 <span class=\"math inline\">\\(4\\)</span>，但有且仅有 <span class=\"math inline\">\\(1\\)</span> 取不到。但该想法并未破产——可以感受到这样的位置很少。进一步地，你 <a href=\"https://www.luogu.com.cn/article/2mmg5rjd\">可以证明只有一个这样的位置</a>，也可以 <a href=\"https://www.luogu.com.cn/article/679cwjgl\">大胆猜想这样的位置一定出现在 <span class=\"math inline\">\\(l+1\\)</span>，<span class=\"math inline\">\\(r-1\\)</span></a>。总之现在我们的状态就减少了（或者说状态变成 DP 值了）。预处理出这个东西之后大力搜索找方案即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, k;\n        std::cin &gt;&gt; n &gt;&gt; k;\n        std::vector&lt;int&gt; a(n + 1);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            char t;\n            std::cin &gt;&gt; t, a[i] = (t == &#39;A&#39;);\n            if (i &gt;= 2)\n                k -= (a[i] ^ a[i - 1]);\n        &#125;\n        std::vector&lt;std::array&lt;std::tuple&lt;int, int, int&gt;, 2&gt; &gt; f(n + 1);\n        f[n][0] = &#123; a[n], a[n], 0 &#125;, f[n][1] = &#123; !a[n], !a[n], 0 &#125;;\n        auto merge = [&amp;](int i, int l0, int r0, int p0, int l1, int r1, int p1) &#123;\n            if (l0 &gt; l1)\n                std::swap(l0, l1), std::swap(r0, r1), std::swap(p0, p1);\n            int l = l0, r = std::max(r0, r1), p = 0;\n            if (!p0 &amp;&amp; !p1) &#123;\n                if (r0 &lt; l1 - 1)\n                    assert(r0 == l1 - 2), p = r0 + 1;\n                else;\n            &#125;\n            else if (p0 &amp;&amp; p1) &#123;\n                if (p0 == p1)\n                    p = p0;\n                else &#123;\n                    int tag0 = (l1 &lt;= p0 &amp;&amp; p0 &lt;= r1), tag1 = (l0 &lt;= p1 &amp;&amp; p1 &lt;= r0);\n                    if (!tag0 &amp;&amp; !tag1);\n                    else if (!tag0)\n                        p = p0;\n                    else if (!tag1)\n                        p = p1;\n                    else;\n                &#125;\n            &#125;\n            else if (p0) &#123;\n                if (l1 &lt;= p0 &amp;&amp; p0 &lt;= r1);\n                else\n                    p = p0;\n            &#125;\n            else &#123;\n                if (l0 &lt;= p1 &amp;&amp; p1 &lt;= r0);\n                else\n                    p = p1;\n            &#125;\n            assert(p != l &amp;&amp; p != r &amp;&amp; l &lt;= r);\n            return std::make_tuple(l, r, p);\n        &#125;;\n        for (int i = n - 1; i; --i) &#123;\n            &#123;\n                auto [l0, r0, p0] = f[i + 1][0];\n                auto [l1, r1, p1] = f[i + 1][1];\n                if (a[i]) &#123;\n                    ++l0, ++r0, ++l1, ++r1;\n                    if (p0) ++p0;\n                    if (p1) ++p1;\n                &#125;\n                ++l1, ++r1;\n                if (p1) ++p1;\n                f[i][0] = merge(i, l0, r0, p0, l1, r1, p1);\n            &#125;\n            &#123;\n                auto [l0, r0, p0] = f[i + 1][0];\n                auto [l1, r1, p1] = f[i + 1][1];\n                if (!a[i]) &#123;\n                    ++l0, ++r0, ++l1, ++r1;\n                    if (p0) ++p0;\n                    if (p1) ++p1;\n                &#125;\n                ++l0, ++r0;\n                if (p0) ++p0;\n                f[i][1] = merge(i, l0, r0, p0, l1, r1, p1);\n            &#125;\n        &#125;\n        std::vector&lt;int&gt; res(n + 1);\n        std::function&lt;bool(int, int, int)&gt; DFS = [&amp;](int x, int cnt, int la) &#123;\n            if (x == n + 1)\n                return cnt == k;\n            auto [l0, r0, p0] = f[x][0];\n            auto [l1, r1, p1] = f[x][1];\n            if (cnt + (la == 1) + l0 &lt;= k &amp;&amp; cnt + (la == 1) + r0 &gt;= k &amp;&amp; (!p0 || cnt + (la == 1) + p0 != k) &amp;&amp; DFS(x + 1, cnt + (la == 1) + a[x], 0))\n                res[x] = 0;\n            else if (cnt + !la + l1 &lt;= k &amp;&amp; cnt + !la + r1 &gt;= k &amp;&amp; (!p1 || cnt + !la + p1 != k) &amp;&amp; DFS(x + 1, cnt + !la + !a[x], 1))\n                res[x] = 1;\n            else\n                return false;\n            return true;\n        &#125;;\n        if (DFS(1, 0, -1)) &#123;\n            std::cout &lt;&lt; &quot;YES\\n&quot;;\n            for (int i = 1; i &lt;= n; ++i)\n                std::cout &lt;&lt; (res[i] ? &#39;A&#39; : &#39;B&#39;);\n            std::cout &lt;&lt; &#39;\\n&#39;;\n        &#125;\n        else\n            std::cout &lt;&lt; &quot;NO\\n&quot;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "DP",
                "容斥原理",
                "树链剖分",
                "反悔贪心"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250505/",
            "url": "https://xsc062.netlify.app/20250505/",
            "title": "解题报告 喝醉的兔子",
            "date_published": "2025-05-05T00:04:36.000Z",
            "content_html": "<p>老题解批量补档。</p>\n<span id=\"more\"></span>\n<hr />\n<p><a href=\"http://222.180.160.110:61235/contest/6248/problem/2\" class=\"uri\">http://222.180.160.110:61235/contest/6248/problem/2</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(q\\)</span> 次询问，每次给定 <span class=\"math inline\">\\(f(0)\\)</span>，求最小的 <span class=\"math inline\">\\(t\\)</span>，使得 <span class=\"math inline\">\\(n | f(t)\\)</span>，其中 <span class=\"math inline\">\\(f(t)=d\\cdot f(t-1) + \\Delta_t\\)</span>，<span class=\"math inline\">\\(n,d,l,r\\)</span> 为常数，<span class=\"math inline\">\\(\\Delta_t\\)</span> 为你自选的 <span class=\"math inline\">\\([l,r]\\)</span> 间的整数，每次询问独立。</p>\n<p><span class=\"math inline\">\\(q, n\\le 10^7\\)</span>。</p>\n</blockquote>\n<p>如果这是数论题，<span class=\"math inline\">\\(n\\)</span> 就不会和 <span class=\"math inline\">\\(q\\)</span> 同阶了，所以这可能是一道偏模拟的题目。</p>\n<p>很容易想到建同余图（这里说的是从 <span class=\"math inline\">\\([0-r,0-l]\\)</span> 出发；这样每个点第一次被 BFS 到的时候就能确定答案了）。但如果直接把图建出来，大小就是 <span class=\"math inline\">\\(O(n^2)\\)</span> 级别的了。每次连的点都是连续的一段，容易想到线段树优化建图。这样就能 <span class=\"math inline\">\\(O(n\\log n)\\)</span> 解决问题了。但是题目要求线性。</p>\n<p>在实现的时候一定会注意到我们会连到一些已经被访问过的点。这样的边是『无效』的——我们不能将访问过的点再次加入队列。能不能规避掉这些点呢？</p>\n<p><mark>每次被访问过的点一定是连续的、长度为 <span class=\"math inline\">\\(r - l + 1\\)</span> 的一段——有没有<a href=\"/20250202/#texttt-aa-%E5%BC%8F%E5%AD%90%E4%B8%B2%E5%A4%84%E7%90%86\">联想到什么</a>？类似地，给 <span class=\"math inline\">\\(0\\sim n-1\\)</span> 每隔 <span class=\"math inline\">\\(r-l+1\\)</span> 打一个标记——或者说 <strong>分一段</strong></mark>，那么每次试图访问 <span class=\"math inline\">\\([l_0, r_0]\\)</span> 时：</p>\n<ol type=\"1\">\n<li><span class=\"math inline\">\\([l_0,r_0]\\)</span> 为两个相邻段的前后缀。</li>\n<li><span class=\"math inline\">\\([l_0,r_0]\\)</span> 恰好为一段。</li>\n</ol>\n<p>这时我们就发现了，每次访问的是完整的前后缀，利用前后缀和优化建图，由于边数是 <span class=\"math inline\">\\(O(n)\\)</span> 的，且边权只有 <span class=\"math inline\">\\(0\\)</span> 和 <span class=\"math inline\">\\(1\\)</span>，就可以做到 <span class=\"math inline\">\\(O(n)\\)</span> 01BFS 解决问题。</p>\n<details>\n<p>注：常数大到必可神机跑不过</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nstruct IO &#123;\n    static const int N = 1 &lt;&lt; 22;\n    char buf[N], pbuf[N], *p1 = buf, *p2 = buf, *pp = pbuf;\n#define gc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, N, stdin), p1 == p2) ? EOF : *p1++)\n    template &lt;typename T&gt;\n    void read(T&amp; x) &#123;\n        x = 0;\n        char ch;\n        int f = 0;\n        while ((ch = gc()) &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) f |= (ch == &#39;-&#39;);\n        while (x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), (ch = gc()) &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;)\n            ;\n        if (f)\n            x = ~x + 1;\n    &#125;\n    void putc(char c) &#123;\n        if (pp - pbuf == N)\n            fwrite(pbuf, 1, N, stdout), pp = pbuf;\n        *pp++ = c;\n    &#125;\n    void puts(const char* s) &#123;\n        while (*s) putc(*s), ++s;\n        putc(&#39;\\n&#39;);\n    &#125;\n    template &lt;typename T&gt;\n    void print(T x) &#123;\n        static int st[20];\n        int tp = 0;\n        if (x &lt; 0)\n            putc(&#39;-&#39;), x = ~x + 1;\n        do\n            st[++tp] = x % 10, x /= 10;\n        while (x);\n        while (tp) putc(st[tp--] + &#39;0&#39;);\n    &#125;\n    ~IO() &#123; fwrite(pbuf, pp - pbuf, 1, stdout); &#125;\n&#125; io;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::freopen(&quot;calculate.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;calculate.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;ex_calculator3.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int T;\n    for (io.read(T); T--; ) &#123;\n        int n, l, r, m, to;\n        long long d, len;\n        io.read(n), io.read(d), io.read(l), io.read(r), io.read(m);\n        len = r - l + 1, to = (n - 1) / len + 1;\n        std::vector&lt;std::vector&lt;int&gt; &gt; t(n), lid(to), rid(to);\n        for (int i = 0; i &lt; n; ++i)\n            t[i * d % n].push_back(i);\n        std::vector&lt;std::vector&lt;int&gt; &gt; g(3 * n);\n        for (int i = 0, id = n - 1; i &lt; to; ++i) &#123;\n            int at = ((i != to - 1 || !(n % len)) ? len : (n % len));\n            lid[i].resize(at), rid[i].resize(at);\n            for (int j = 0; j &lt; at; ++j) &#123;\n                lid[i][j] = ++id;\n                g[id].push_back(i * len + j);\n                if (j != 0)\n                    g[id].push_back(id - 1);\n            &#125;\n            for (int j = at - 1; ~j; --j) &#123;\n                rid[i][j] = ++id;\n                g[id].push_back(i * len + j);\n                if (j != at - 1)\n                    g[id].push_back(id - 1);\n            &#125;\n        &#125;\n        auto add = [&amp;](int p, int l0, int r0) &#123;\n            int p1 = l0 / len, p2 = r0 / len;\n            if (p1 == p2)\n                g[p].push_back(lid[p1].back());\n            else &#123;\n                g[p].push_back(rid[p1][l0 % len]);\n                if ((p1 + 1) % to != p2) &#123;\n                    // fprintf(stderr, &quot;p1 = %d, p2 = %d, to = %d, get %d(%d)\\n&quot;, p1, p2, to, (p1 + 1) % to, (int)lid[(p1 + 1) % to].size());\n                    g[p].push_back(lid[(p1 + 1) % to].back());\n                &#125;\n                g[p].push_back(lid[p2][r0 % len]);\n            &#125;\n            return;\n        &#125;;\n        for (int i = 0; i &lt; n; ++i)\n            for (auto j : t[i]) &#123;\n                // printf(&quot;%d -&gt; %d[%d, %d]\\n&quot;, i, j, (j + n - r) % n, (j + n - l) % n);\n                add(i, (j + n - r) % n, (j + n - l) % n);\n            &#125;\n        std::list&lt;std::pair&lt;int, int&gt; &gt; q;\n        std::vector&lt;int&gt; f(n + 1, -1), tag(3 * n + 1);\n        for (int i = l, p = (n - r) % n; i &lt;= r; ++i, (++p) %= n)\n            f[p] = 0, q.emplace_back(p, 0), tag[p] = 1;\n        for (; !q.empty(); ) &#123;\n            auto [u, d] = q.front();\n            q.pop_front();\n            if (u &lt; n)\n                f[u] = d;\n            // printf(&quot;u = %d, d = %d\\n&quot;, u, d);\n            for (auto i : g[u]) &#123;\n                // printf(&quot;  i = %d\\n&quot;, i);\n                if (!tag[i]) &#123;\n                    if (i &gt;= n)\n                        q.emplace_front(i, d), tag[i] = 1;\n                    else\n                        q.emplace_back(i, d + 1), tag[i] = 1;\n                &#125;\n            &#125;\n        &#125;\n        for (int x; m--; )\n            io.read(x), io.print(f[x]), io.putc(&#39;\\n&#39;);\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<p>或者，发现<mark>每次任意标记前后缀，则一段内未访问的一定是中间的一整截</mark>。根据这一点可维护每一段内可访问元素，就能 <span class=\"math inline\">\\(O(n)\\)</span> BFS；</p>\n<p>如果把图建出来了，还可以解决扩展问题：</p>\n<blockquote>\n<p>假如 <span class=\"math inline\">\\(\\Delta_i\\)</span> 在 <span class=\"math inline\">\\([l,r]\\)</span> 间的整数中等概率取值，则最优解出现的概率？</p>\n</blockquote>\n<p>为什么 BFS 不能解决该问题呢？因为同层同代价的点对共同能访问到的点的贡献不会被 BFS 记入（注意到一个点只会被一个点访问到），所以只有建图出来才能解决问题。</p>\n<p>这也侧面反映该图在忽略环后所对应的就是最优解，这其实是有点 BFS 扩展出来的意味在的。</p>\n",
            "tags": [
                "优化建图"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250430/",
            "url": "https://xsc062.netlify.app/20250430/",
            "title": "连通图计数",
            "date_published": "2025-04-30T02:31:11.000Z",
            "content_html": "<figure>\n<img src=\"/20250430/neko.png\" alt=\"猫\" style=\"width: 75px\">\n<figcaption>\n猫\n</figcaption>\n</figure>\n<span id=\"more\"></span>\n<p>太可怕了！2025 年才过去 4 个月，正经文章的总数已经和 2024 年中正经文章的总数一样多了。</p>\n<hr />\n<h2 id=\"有标号无向图计数\">有标号无向图计数</h2>\n<p>问题模型大概如下：</p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(N\\)</span> 个点，你可以在它们间任意连边，但存在限制：</p>\n<ul>\n<li>其中一个较好处理（如要求图必须是二分图）；</li>\n<li>另一个较难处理（如去重问题等）；</li>\n<li>最后，可能要求图连通。</li>\n</ul>\n</blockquote>\n<p>首先需要知道怎么处理这样的计数问题。以下皆建立在无重边、自环的基础上。</p>\n<ol type=\"1\">\n<li><p>先只考虑容易的限制，且不要求连通：</p>\n<p><em>注：如果发现 <strong>不连通</strong> 的时候没办法很方便地计算精确方案数（也就是说会算重），那么可以把 <strong>去重</strong> 作为较难的限制，这一步算重就不重要了</em>。</p>\n<p>该怎么求怎么求。例如，若该限制是二分图且可以算重，枚举左部点数及边，那么方案数就是 <span class=\"math inline\">\\(\\sum\\limits_{i=0}^n C_n^i\\cdot C_{i\\cdot (n-i)}^m\\)</span>。</p>\n这个时候需要注意到算重部分的意义是什么。比如此处，计算中一个连通块将左右部翻转后被视作不同的子图，但在全局看来对应的总图是同一个二分图。因此，对于拥有 <span class=\"math inline\">\\(k\\)</span> 个连通块的图，其被计算了 <span class=\"math inline\">\\(2^k\\)</span> 次。</li>\n<li><p>再加上必须连通的限制，仍只考虑容易的限制：</p>\n<p>如果不存在其他限制，那么就是 <a href=\"https://oeis.org/A001187\">A001187</a>。</p>\n<p>连通的方案就是任意的方案减去不连通的方案。</p>\n<ul>\n<li>任意的求法就是第一点；</li>\n<li>不连通的方案，枚举 <span class=\"math inline\">\\(1\\)</span> 所在子集，让其补集里面任意连边（第 1 点的子问题）且不和 <span class=\"math inline\">\\(1\\)</span> 所在子集相连。</li>\n</ul></li>\n<li><p>接着，对连通的情况应用较难处理的限制：</p>\n<p><em>因为连通会带来一些比较好的性质简化运算，所以选择在这一步加上较难的限制</em>。</p>\n例如，对于上文中二分图去重的例子，连通图中显然只有一个连通块，将连通图的方案 <span class=\"math inline\">\\(\\div 2\\)</span> 就可以得到答案。</li>\n<li><p>最后，如果题目要求任意图的方案，用第三步中的答案再次算出任意图的答案。</p>\n<p>相当于是把第 2 点中的过程反过来，枚举 <span class=\"math inline\">\\(1\\)</span> 所在子集，在其补集中任意连边（该问的子问题）且可以和 <span class=\"math inline\">\\(1\\)</span> 所在的子集连边。</p></li>\n</ol>\n<p>这样就可以解决问题。</p>\n<hr />\n<h3 id=\"a---many-good-tuple-problems\">A - Many Good Tuple Problems</h3>\n<p><a href=\"https://atcoder.jp/contests/abc327/tasks/abc327_g\" class=\"uri\">https://atcoder.jp/contests/abc327/tasks/abc327_g</a></p>\n<p>如果把一组 <span class=\"math inline\">\\((S_i,T_i)\\)</span> 看作一条边的话，原限制就可以转化为：在 <span class=\"math inline\">\\(N\\)</span> 个点中连 <span class=\"math inline\">\\(M\\)</span> 条可重边，形成二分图的方案数。边有序。</p>\n<p><del>你可以发现我偷懒把这道题拿去上面举例了</del>，由于边是可重的，而我们的模型要求无重边，但发现这个限制是独立于模型外的，也就是可以在最后枚举有多少条不同边，再用一点组合手段计算实际贡献。</p>\n<p>首先令 <span class=\"math inline\">\\(f_{0,n,m}\\)</span> 表示 <span class=\"math inline\">\\(n\\)</span> 个点、<span class=\"math inline\">\\(m\\)</span> 条边、<strong>不去重</strong>、<strong>连通性任意</strong> 的方案数，那么 <span class=\"math inline\">\\(f_{0,n,m}=\\sum_{i=0}^n C_n^i\\cdot C_{i\\cdot (n-i)}^m\\)</span>。</p>\n<p>令 <span class=\"math inline\">\\(f_{1,n,m}\\)</span> 表示 <strong>不去重</strong>、要求 <strong>连通</strong> 的方案，那么有 <span class=\"math inline\">\\(f_{1,n,m}=f_{0,n,m}-\\sum\\limits_{i,j} C_{n - 1}^{i-1}\\cdot f_{1,i,j}\\cdot f_{0,n-i,m-j}\\)</span>。</p>\n<p>令 <span class=\"math inline\">\\(f_{2,n,m}\\)</span> 表示 <strong>去重</strong>，要求 <strong>连通</strong> 的方案，那么有 <span class=\"math inline\">\\(f_{2,n,m}=\\dfrac {f_{1,n,m}}{2}\\)</span>。</p>\n<p>令 <span class=\"math inline\">\\(f_{3,n,m}\\)</span> 表示 <strong>去重</strong>，<strong>连通性任意</strong> 的方案数，那么有 <span class=\"math inline\">\\(f_{3,n,m}=\\sum\\limits_{i,j} C_{n-1}^{i-1} \\cdot f_{2,i,j} \\cdot f_{3,n-i,m-j}\\)</span>。</p>\n<p>最后的方案数为 <span class=\"math inline\">\\(\\sum\\limits_{j} f_{3,n,j}\\cdot F(m,j)\\)</span>。其中 <span class=\"math inline\">\\(F(m,j)\\)</span> 表示把 <span class=\"math inline\">\\(m\\)</span> 个有标号的球放在 <span class=\"math inline\">\\(j\\)</span> 个有标号的盒子里，不空放的方案数，可以容斥。最后注意边反向算两种，所以乘上 <span class=\"math inline\">\\(2^m\\)</span>。</p>\n<p>复杂度 <span class=\"math inline\">\\(O(n^6)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nconst int inv2 = (mod + 1) &gt;&gt; 1;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, M, m;\n    std::cin &gt;&gt; n &gt;&gt; M, m = std::min(n * (n - 1) / 2, M);\n    std::vector&lt;std::vector&lt;long long&gt; &gt; C(n * n + 1, std::vector&lt;long long&gt; (n * n + 1));\n    for (int i = 0; i &lt;= n * n; ++i) &#123;\n        C[i][0] = 1ll;\n        for (int j = 1; j &lt;= i; ++j)\n            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;\n    &#125;\n    std::vector&lt;std::vector&lt;std::vector&lt;long long&gt; &gt; &gt; f(4, std::vector&lt;std::vector&lt;long long&gt; &gt; (n + 1, std::vector&lt;long long&gt; (m + 1)));\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = 0; j &lt;= m &amp;&amp; j &lt;= i * (i - 1) / 2; ++j)\n            for (int k = 0; k &lt;= i; ++k)\n                (f[0][i][j] += C[i][k] * C[k * (i - k)][j]) %= mod;\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = 0; j &lt;= m; ++j) &#123;\n            auto t(0ll);\n            for (int k = 1; k &lt;= i; ++k)\n                for (int l = 0; l &lt;= j; ++l)\n                    (t += C[i - 1][k - 1] * f[1][k][l] % mod * f[0][i - k][j - l]) %= mod;\n            f[1][i][j] = (f[0][i][j] + mod - t) % mod;\n            f[2][i][j] = f[1][i][j] * inv2 % mod;\n        &#125;\n    f[3][0][0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = 0; j &lt;= m; ++j)\n            for (int k = 1; k &lt;= i; ++k)\n                for (int l = 0; l &lt;= j; ++l)\n                    (f[3][i][j] += C[i - 1][k - 1] * f[2][k][l] % mod * f[3][i - k][j - l]) %= mod;\n    auto qkp = [](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    std::vector&lt;long long&gt; F(m + 1);\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        F[i] = qkp(i, M);\n        for (int j = 1, p = mod - 1; j &lt; m; ++j, p = mod - p)\n            (F[i] += p * C[i][j] % mod * qkp(i - j, M)) %= mod;\n    &#125;\n    auto res(0ll);\n    for (int j = 1; j &lt;= m; ++j)\n        (res += f[3][n][j] * F[j]) %= mod;\n    std::cout &lt;&lt; res * qkp(2, M) % mod &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"b---many-mst\">B - Many MST</h3>\n<p><a href=\"https://atcoder.jp/contests/abc386/tasks/abc386_g\" class=\"uri\">https://atcoder.jp/contests/abc386/tasks/abc386_g</a></p>\n<p>这里需要注意到 MST 和连通块的隐含联系。按照 Kruskal 的生成方式可以发现只需要在合并两个连通块时加上它们之间连边中最小的边权就可以得到 MST。</p>\n<p>因此容易想到在 DP 时对最小边权进行限制；枚举 <span class=\"math inline\">\\(k\\)</span>，让边权 <span class=\"math inline\">\\(\\le k\\)</span> 成为简单限制；让求解 MST 成为某种意义上的较难限制。</p>\n<p>令 <span class=\"math inline\">\\(f_{0,n,k}\\)</span> 表示 <span class=\"math inline\">\\(n\\)</span> 个点，边权 <span class=\"math inline\">\\(\\le k\\)</span>、<strong>对连通性没有要求</strong> 的方案数；相应地，<span class=\"math inline\">\\(f_{1,n,k}\\)</span> 表示 <strong>要求连通</strong> 的方案数，则：</p>\n<ul>\n<li><p><span class=\"math inline\">\\(f_{0,n,k}=\\sum\\limits_i C_{n-1}^{i-1}\\cdot f_{1,i,k-1} \\cdot f_{0,n-i,k}\\cdot (M-k+1)^{i\\times(n-i)}\\)</span>。</p>\n<p>注解：式子正确性建立在 <strong><span class=\"math inline\">\\(1\\)</span> 所在 的由权值 <span class=\"math inline\">\\(&lt;k\\)</span> 的边构成的最大连通块 大小为 <span class=\"math inline\">\\(i\\)</span></strong> 的基础之上，故两个连通块之间的边权只能 <span class=\"math inline\">\\(\\ge k\\)</span>。这也提醒我们，此处的 <strong>不连通</strong> 含义实际上是给这些边一个 <span class=\"math inline\">\\((M-k)\\)</span> 的系数。</p>\n那么这样你会注意到，<span class=\"math inline\">\\(f_0\\)</span> 的意义就与 <span class=\"math inline\">\\(k\\)</span> 无关了（那么显然值也与 <span class=\"math inline\">\\(k\\)</span> 无关），但是仍然保留 <span class=\"math inline\">\\(k\\)</span> 对思考有帮助，故留之。</li>\n<li><p><span class=\"math inline\">\\(f_{1,n,k}=f_{0, n, k} - \\sum\\limits_i C_{n - 1}^{i-1} \\cdot f_{1,i,k}\\cdot f_{0,n-i,k}\\times (M-k)^{i\\times (n - i)}\\)</span>。</p></li>\n</ul>\n<p>令 <span class=\"math inline\">\\(g_{0, n, k}\\)</span> 表示 <span class=\"math inline\">\\(n\\)</span> 个点、边权 <span class=\"math inline\">\\(\\le k\\)</span>、<strong>对连通性没有要求</strong> 的 MST 之和；相应地，<span class=\"math inline\">\\(g_{1,n,k}\\)</span> 表示对应条件下 <strong>要求连通</strong> 的 MST 之和。则：</p>\n<ul>\n<li><p><span class=\"math inline\">\\(g_{0,n,k}=\\sum\\limits_{i} C_{n-1}^{i-1}\\cdot (f_{1,i,k - 1}\\cdot g_{0,n-i,k}+g_{1,i,k - 1} \\cdot f_{0,n-i,k}+f_{1,i,k-1}\\cdot f_{0,n-i,k}\\cdot k)\\cdot (M-k+1)^{i\\times (n-i)}\\)</span>。</p>\n注解：类比 <span class=\"math inline\">\\(f_0\\)</span> 的计算方式得到 <span class=\"math inline\">\\(g_0\\)</span>。在 <span class=\"math inline\">\\(i\\times (n-i)\\)</span> 中任选一条作为 MST 上权值为 <span class=\"math inline\">\\(k\\)</span> 的边，故有 <span class=\"math inline\">\\(f_{1,i,k-1}\\cdot f_{0,n-i,k}\\cdot k\\)</span>。之所以必须要求有这么一条边是为了和 <span class=\"math inline\">\\(g_{k-1}\\)</span> 和 <span class=\"math inline\">\\(g_{k+1}\\)</span> 等区分。</li>\n<li><p><span class=\"math inline\">\\(g_{1,n,k}=g_{0,n,k}-\\sum\\limits_i C_{n-1}^{i-1}\\cdot (f_{1,i,k}\\cdot g_{0,n-i,k}+g_{1,i,k}\\cdot f_{0,n-i,k}+f_{1,i,k}\\cdot f_{0,n-i,k}\\cdot k)\\cdot (M-k)^{i\\times (n-i)}\\)</span>。</p></li>\n</ul>\n<p>复杂度 <span class=\"math inline\">\\(O(n^2\\cdot M)\\)</span>。要求预处理幂，不然会 T。以及可能需要把 <span class=\"math inline\">\\(f_0,f_1,g_0,g_1\\)</span> 放在同一个内层循环求，不然会卡常；<del>在此基础上使用内存连续访问优化似乎并不明显</del> <img src=\"/em/kt.gif\" /></p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int N, M;\n    std::cin &gt;&gt; N &gt;&gt; M;\n    using arr = std::vector&lt;long long&gt;;\n    using brr = std::vector&lt;arr&gt;;\n    using crr = std::vector&lt;brr&gt;;\n    crr f(2, brr(N + 1, arr(M + 1))), g(2, brr(N + 1, arr(M + 1)));\n    brr C(N + 1, arr(N + 1)), p(M + 1, arr(N * N + 1));\n    for (int i = 0; i &lt;= M; ++i) &#123;\n        p[i][0] = 1ll;\n        for (int j = 1; j &lt;= N * N; ++j)\n            p[i][j] = p[i][j - 1] * i % mod;\n    &#125;\n    for (int i = 0; i &lt;= N; ++i) &#123;\n        C[i][0] = 1ll;\n        for (int j = 1; j &lt;= i; ++j)\n            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;\n    &#125;\n    f[1][0][0] = f[1][1][0] = 1ll;\n    for (int n = 1; n &lt;= N; ++n)\n        for (int k = 1; k &lt;= M; ++k) &#123;\n            f[0][n][k] = f[1][n][k - 1];\n            for (int i = 1; i &lt; n; ++i) &#123;\n                (f[0][n][k] += C[n - 1][i - 1] * f[1][i][k - 1] % mod * f[0][n - i][k] % mod * p[M - k + 1][i * (n - i)]) %= mod;\n                (f[1][n][k] += mod - C[n - 1][i - 1] * f[1][i][k] % mod * f[0][n - i][k] % mod * p[M - k][i * (n - i)] % mod) %= mod;\n            &#125;\n            (f[1][n][k] += f[0][n][k]) %= mod;\n        &#125;\n    for (int n = 1; n &lt;= N; ++n)\n        for (int k = 1; k &lt;= M; ++k) &#123;\n            g[0][n][k] = g[1][n][k - 1];\n            for (int i = 1; i &lt; n; ++i) &#123;\n                (g[0][n][k] += (f[1][i][k - 1] * g[0][n - i][k] % mod + g[1][i][k - 1] * f[0][n - i][k] % mod + f[1][i][k - 1] * f[0][n - i][k] % mod * k) % mod * C[n - 1][i - 1] % mod * p[M - k + 1][i * (n - i)]) %= mod;\n                (g[1][n][k] += mod - (f[1][i][k] * g[0][n - i][k] % mod + g[1][i][k] * f[0][n - i][k] % mod + f[1][i][k] * f[0][n - i][k] % mod * k) % mod * C[n - 1][i - 1] % mod * p[M - k][i * (n - i)] % mod) %= mod;\n            &#125;\n            (g[1][n][k] += g[0][n][k]) %= mod;\n        &#125;\n    // for (int n = 1; n &lt;= N; ++n)\n    //     for (int k = 1; k &lt;= M; ++k) &#123;\n    //         printf(&quot;f[0][%d][%d] = %lld\\n&quot;, n, k, f[0][n][k]);\n    //         printf(&quot;f[1][%d][%d] = %lld\\n&quot;, n, k, f[1][n][k]);\n    //         printf(&quot;g[0][%d][%d] = %lld\\n&quot;, n, k, g[0][n][k]);\n    //         printf(&quot;g[1][%d][%d] = %lld\\n&quot;, n, k, g[1][n][k]);\n    //     &#125;\n    std::cout &lt;&lt; g[1][N][M] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"有标号-dag-计数\">有标号 DAG 计数</h2>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(N\\)</span> 个点，你可以在它们间任意连边，要求最后图为 DAG，可能要求图弱连通。</p>\n</blockquote>\n<p>如果说无向图计数关键在于连通块，那么 DAG 在此基础上关键在于入度为 <span class=\"math inline\">\\(0\\)</span> 的点集。</p>\n<p>令 <span class=\"math inline\">\\(f(i)\\)</span> 表示 <span class=\"math inline\">\\(i\\)</span> 个点的 DAG 的答案；<span class=\"math inline\">\\(g_{0, i,j}\\)</span> 表示 <span class=\"math inline\">\\(i\\)</span> 个点的 DAG，其中 <span class=\"math inline\">\\(j\\)</span> 个入度为 <span class=\"math inline\">\\(0\\)</span> 的方案，不难想到容斥：令 <span class=\"math inline\">\\(g_{1,i,j}\\)</span> 表示至少 <span class=\"math inline\">\\(j\\)</span> 个的方案，那么：</p>\n<p><span class=\"math display\">\\[\ng_{1,i,j}=C_i^j\\times f(i-j)\\times 2^{j\\times (i-j)}\\\\\ng_{0,i,j}=\\sum_{k=j}^i (-1)^{k-j}\\cdot C_k^j\\cdot g_{1,i,j}\\\\\nf(i)=\\sum_{j=1}^i g_{0,i,j}\n\\]</span></p>\n<p>整理有：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nf(i)\n&amp;=\\sum_{j=1}^i \\sum_{k=j}^i (-1)^{k-j}\\cdot C_k^j\\cdot g_{1,i,k}\\\\\n&amp;=\\sum_{k=1}^i (-1)^k\\cdot g_{1,i,k}\\cdot \\sum_{j=1}^k (-1)^j\\cdot C_k^j\\\\\n&amp;=\\sum_{k=1}^i (-1)^k\\cdot g_{1,i,k}\\cdot (0^k-1)\\\\\n&amp;=\\sum_{k=1}^i (-1)^{k+1}\\cdot C_i^k\\times f(i-k)\\times 2^{(i-k)}\n\\end{aligned}\n\\]</span></p>\n<p>即得递推式。如果要求连通仿照无向图连通的方法，用任意减去不连通即可。</p>\n<hr />\n<h3 id=\"c---amusement-park\">C - Amusement Park</h3>\n<p><a href=\"https://codeforces.com/problemset/problem/1193/A\" class=\"uri\">https://codeforces.com/problemset/problem/1193/A</a></p>\n<p>先考虑计算方案数。枚举 <span class=\"math inline\">\\(1\\)</span> 所在子集，那么有 <span class=\"math inline\">\\(f(S)=\\sum\\limits_{T\\in S} (-1)^{|T|+1}\\cdot f(S - T)\\)</span>。相较于一般的 DAG 计数，因为每条边取不取是固定的，所以没有了 <span class=\"math inline\">\\(2\\)</span> 的次幂的系数；同时因为直接枚举子集，所以没有了组合系数。</p>\n<p>注意此处 <span class=\"math inline\">\\(T\\)</span> 可构成一轮新的入度为 <span class=\"math inline\">\\(0\\)</span> 的点集当且仅当 <span class=\"math inline\">\\(T\\)</span> 之内没有连边，即 <span class=\"math inline\">\\(T\\)</span> 为独立集。</p>\n<p>算出方案数后如何算答案呢？发现对于一种合法的方案，把里面所有的边反向一定唯一对应另一种合法方案，两种方案取反边数相加为 <span class=\"math inline\">\\(m\\)</span>；那么给所有方案除以 <span class=\"math inline\">\\(2\\)</span>，再乘上 <span class=\"math inline\">\\(m\\)</span> 就能得到答案。</p>\n<p>复杂度 <span class=\"math inline\">\\(O(3^n)\\)</span>。需要提前把每个点集是否独立预处理下来。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353, inv2 = (mod + 1) &gt;&gt; 1;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;int&gt; g(n + 1);\n    for (int i = 1, x, y; i &lt;= m; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x] |= (1 &lt;&lt; (y - 1));\n        g[y] |= (1 &lt;&lt; (x - 1));\n    &#125;\n    auto check = [&amp;](int s) &#123;\n        for (int i = 1; i &lt;= n; ++i)\n            if ((s &gt;&gt; (i - 1)) &amp; 1)\n                if (s &amp; g[i])\n                    return false;\n        return true;\n    &#125;;\n    int siz = 1 &lt;&lt; n;\n    std::vector&lt;int&gt; tag(siz);\n    for (int i = 0; i &lt; siz; ++i)\n        tag[i] = check(i);\n    std::vector&lt;long long&gt; f(siz);\n    f[0] = 1ll;\n    for (int i = 1; i &lt; siz; ++i)\n        for (int j = i; j; j = (j - 1) &amp; i)\n            if (tag[j])\n                (f[i] += ((__builtin_popcount(j) &amp; 1) ? 1 : mod - 1) * f[i ^ j]) %= mod;\n    std::cout &lt;&lt; f[siz - 1] * inv2 % mod * m % mod &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"d---balance-scale\">D - Balance Scale</h3>\n<p><a href=\"https://atcoder.jp/contests/abc306/tasks/abc306_h\" class=\"uri\">https://atcoder.jp/contests/abc306/tasks/abc306_h</a></p>\n<p>可以发现，如果将被 <code>=</code> 连起来的点缩起来，就可以转化成上一个问题。但枚举被缩的点集显然是不能通过的，这里介绍一种方法。</p>\n<p>不把缩点放在开头。在上一题中的 DP 式子 <span class=\"math inline\">\\(f(S)=\\sum\\limits_{T\\in S} (-1)^{|T|+1}\\cdot f(S - T)\\)</span> 中，考虑和我们最终的答案有什么差异：</p>\n<ol type=\"1\">\n<li>在现在的问题中，有的边是可以不选的！考虑这会给容斥带来怎样的影响。</li>\n</ol>\n<p>首先应该知道一件事情：你决定把一部分点缩到一起，当且仅当它们全部由 <code>=</code> 连接。要让一些边加入 DP，也就是让它们不是 <code>=</code>，当且仅当它们成为连通块的『割』——把连通块分成多个连通块。这种情况显然已经由另一条路径转移过了。也就是说，就用这个式子可以得到所有答案。 1. 另一个问题，在上一题中，我们可以轻易地判断 <span class=\"math inline\">\\(T\\)</span> 是否为独立集；但在本问中，不是独立集的点集也可能缩点成为独立集。</p>\n<p>发现有一种唯一方法，就是使 <span class=\"math inline\">\\(T\\)</span> 中位于同一连通块的点缩到一起；所以应该将 <span class=\"math inline\">\\(-1\\)</span> 的次数替换为 <span class=\"math inline\">\\(T\\)</span> 所在连通块个数 <span class=\"math inline\">\\(+1\\)</span>。</p>\n<p>注意这里说的连通块是 <span class=\"math inline\">\\(T\\)</span> 的导出子图中的连通块。</p>\n<p>这也启示我们不要把缩点和图的连通性等等关联得太死，需要把点等价的场景都可能用到缩点。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353, inv2 = (mod + 1) &gt;&gt; 1;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;int&gt; fa(n + 1);\n    std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;\n        return fa[x] == x ? x : fa[x] = find(fa[x]);\n    &#125;;\n    auto merge = [&amp;](int x, int y) &#123;\n        fa[find(x)] = find(y);\n        return;\n    &#125;;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int x, y; m--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    int siz = 1 &lt;&lt; n;\n    std::vector&lt;int&gt; cnt(siz);\n    for (int i = 0; i &lt; siz; ++i) &#123;\n        std::iota(fa.begin(), fa.end(), 0);\n        std::vector&lt;int&gt; tag(n + 1);\n        for (int j = 1; j &lt;= n; ++j)\n            if ((i &gt;&gt; (j - 1)) &amp; 1)\n                for (auto k : g[j])\n                    if ((i &gt;&gt; (k - 1)) &amp; 1)\n                        merge(k, j);\n        for (int j = 1; j &lt;= n; ++j)\n            if ((i &gt;&gt; (j - 1)) &amp; 1)\n                cnt[i] += (fa[j] == j);\n    &#125;\n    std::vector&lt;long long&gt; f(siz);\n    f[0] = 1ll;\n    for (int i = 1; i &lt; siz; ++i)\n        for (int j = i; j; j = (j - 1) &amp; i)\n            if (cnt[j])\n                (f[i] += ((cnt[j] &amp; 1) ? 1 : mod - 1) * f[i ^ j]) %= mod;\n    std::cout &lt;&lt; f[siz - 1] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"e---主旋律\">E - 主旋律</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P11714\" class=\"uri\">https://www.luogu.com.cn/problem/P11714</a></p>\n<p>即，给定一个有向图，问边集有多少个子集是强连通的。</p>\n<p>再次涉及到了连通性问题，但在这里需要结合 SCC 缩点来考虑。容易发现强连通即缩出来是一个点；故需要关注缩出来的点数。</p>\n<p>令 <span class=\"math inline\">\\(f(S)\\)</span> 表示 <span class=\"math inline\">\\(S\\)</span> 的导出子图内合法边子集的数量，<span class=\"math inline\">\\(g(S)\\)</span> 表示 <span class=\"math inline\">\\(S\\)</span> 的导出子图中非法边子集的数量；<span class=\"math inline\">\\(h(S,k)\\)</span> 表示 <span class=\"math inline\">\\(S\\)</span> 的导出子图中边的子集缩出来有 <span class=\"math inline\">\\(k\\)</span> 个点的数量， 令 <span class=\"math inline\">\\(E(S_1, S_2)\\)</span> 表示从 <span class=\"math inline\">\\(S_1\\)</span> 指向 <span class=\"math inline\">\\(S_2\\)</span> 的边数，则：</p>\n<p><span class=\"math display\">\\[\nf(S) = 2^{E(S,S)}-g(S)\\\\\ng(S)=\\sum_{T \\subseteq S}2^{E(T, S - T)}\\cdot 2^{E(T, T)}\\cdot \\sum_{k=1+[T=\\varnothing]} (-1)^{k+1}\\cdot h(S - T, k)\\\\\nh(S, k) = \\sum_{T\\subset S} f(T) \\cdot h(S - T, k-1)\n\\]</span></p>\n<p>注意为什么要用一个 <span class=\"math inline\">\\(h\\)</span> 来转移 <span class=\"math inline\">\\(g\\)</span> 呢？我们发现 <span class=\"math inline\">\\(-1\\)</span> 的次数和缩出来的点数是有关的，而光凭 <span class=\"math inline\">\\(g\\)</span> 无法表示点数信息，所以需要用 <span class=\"math inline\">\\(h\\)</span> 来搭个桥。</p>\n<p>直接 DP，复杂度 <span class=\"math inline\">\\(O(n\\cdot 3^n)\\)</span>。</p>\n",
            "tags": [
                "计数"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250421/",
            "url": "https://xsc062.netlify.app/20250421/",
            "title": "杂题",
            "date_published": "2025-04-21T06:42:31.000Z",
            "content_html": "<figure>\n<img src=\"/20250421/neko.png\" alt=\"猫\" style=\"width: 75px\">\n<figcaption>\n猫\n</figcaption>\n</figure>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a---t-shirt\">A - T-shirt</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/183/D\" class=\"uri\">https://codeforces.com/problemset/problem/183/D</a></p>\n<p>如果知道一个衣服序列，怎么算出期望呢？</p>\n<hr />\n<h2 id=\"b---two-melodies\">B - Two Melodies</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/813/D\" class=\"uri\">https://codeforces.com/problemset/problem/813/D</a></p>\n<p>如果设 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示第一个以 <span class=\"math inline\">\\(i\\)</span> 结尾，第二个以 <span class=\"math inline\">\\(j\\)</span> 结尾的方案数，就会有一个弊端——假设现在有 <span class=\"math inline\">\\(i&gt;j\\)</span>，又假设有 <span class=\"math inline\">\\(j&lt;j&#39;&lt;i\\)</span>，那么就不可以直接把 <span class=\"math inline\">\\(f_{i,j}\\)</span> 转移到 <span class=\"math inline\">\\(f_{i,j&#39;}\\)</span>，因为 <span class=\"math inline\">\\(j&#39;\\)</span> 可能已经被第一个选过了。但如果从 <span class=\"math inline\">\\(i\\)</span> 转移就没有这样的问题（不管 <span class=\"math inline\">\\(i&#39;\\)</span> 是比 <span class=\"math inline\">\\(j\\)</span> 大还是比 <span class=\"math inline\">\\(j\\)</span> 小）。</p>\n<p>那就可以固定从较大的一维转移，也可以枚举所有情况。但是这样就会有一个问题，这是一个 <span class=\"math inline\">\\(n^3\\)</span> 的过程，而且对于不单调的内层 <span class=\"math inline\">\\(j\\)</span>，维护它的数值只能用带 <span class=\"math inline\">\\(\\log\\)</span> 的数据结构优化，似乎不太过得了；但 <span class=\"math inline\">\\(i\\)</span> 却可以前缀优化。</p>\n<p>其实，两个组是无序的，这意味着可以强制 <span class=\"math inline\">\\(i&gt;j\\)</span> 再从 <span class=\"math inline\">\\(i\\)</span> 转移；这个时候转移就和 <span class=\"math inline\">\\(j\\)</span> 没有太大的关系了，可以把 <span class=\"math inline\">\\(j\\)</span> 放到外层，对 <span class=\"math inline\">\\(i\\)</span> 前缀优化。可能需要注意边界的处理。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, res = 0;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::vector&lt;std::vector&lt;int&gt; &gt; f(n + 1, std::vector&lt;int&gt; (n + 1));\n    for (int j = 0; j &lt; n; ++j) &#123;\n        std::vector&lt;int&gt; mx(100002), mmx(7);\n        for (int i = 1; i &lt; j; ++i) &#123;\n            mx[a[i]] = std::max(mx[a[i]], f[j][i]);\n            mmx[a[i] % 7] = std::max(mmx[a[i] % 7], f[j][i]);\n        &#125;\n        for (int i = j + 1; i &lt;= n; ++i) &#123;\n            f[i][j] = std::max(&#123; !!i + !!j, mx[a[i] - 1] + 1, mx[a[i] + 1] + 1, mmx[a[i] % 7] + 1, f[j][0] + 1 &#125;);\n            mx[a[i]] = std::max(mx[a[i]], f[i][j]);\n            mmx[a[i] % 7] = std::max(mmx[a[i] % 7], f[i][j]);\n            // printf(&quot;f[%d][%d] = %d\\n&quot;, i, j, f[i][j]);\n            res = std::max(res, f[i][j]);\n        &#125;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"cf633f-the-chocolate-spree\">CF633F The Chocolate Spree</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/633/F\" class=\"uri\">https://codeforces.com/problemset/problem/633/F</a></p>\n<p>树形 DP 求直径的时候，有一种方法是找到每个点下面的最大两条不交链。</p>\n<p>这里也可以有类似的求法。假设答案出现在子树 <span class=\"math inline\">\\(u\\)</span> 中（下面的 <span class=\"math inline\">\\(v_i\\)</span> 都是 <span class=\"math inline\">\\(u\\)</span> 的直接儿子），可以讨论 <span class=\"math inline\">\\(u\\)</span> 参与构成两条路径的情况：</p>\n<ol type=\"1\">\n<li>不参与构成任何一条路径，答案是 <span class=\"math inline\">\\(v_1,v_2\\)</span> 子树中的最长路径之和。</li>\n<li><p>参与构成其中一条：</p>\n<ol type=\"1\">\n<li>这一条与子树 <span class=\"math inline\">\\(v\\)</span> 完全相离，答案是 <span class=\"math inline\">\\(v\\)</span> 中最长路径，和 <span class=\"math inline\">\\(u\\)</span> 下面不经过 <span class=\"math inline\">\\(v\\)</span> 的最大两条不交链。</li>\n<li>这一条有一支来自 <span class=\"math inline\">\\(v\\)</span> 子树，但和 <span class=\"math inline\">\\(v\\)</span> 中最长路径没有重合的点。答案是 <span class=\"math inline\">\\(u\\)</span> 的点权、<span class=\"math inline\">\\(u\\)</span> 下面不经过 <span class=\"math inline\">\\(v\\)</span> 的最大链、<span class=\"math inline\">\\(v\\)</span> 中一条路径（不经过 <span class=\"math inline\">\\(v\\)</span>）和 <span class=\"math inline\">\\(v\\)</span> 下面一条链之和的最大值；</li>\n<li>这一条两支都来自 <span class=\"math inline\">\\(v\\)</span> 子树：有重合，不可能发生。</li>\n</ol></li>\n<li><p>参与构成其中两条，答案是 <span class=\"math inline\">\\(u\\)</span> 下面最长的四条链：路径重复经过 <span class=\"math inline\">\\(u\\)</span>，不可能发生。</p></li>\n</ol>\n<p><img src=\"2.png\" /></p>\n<p>可以记录 <span class=\"math inline\">\\(u\\)</span> 下方最大的四条不交链、<span class=\"math inline\">\\(u\\)</span> 中选取一条不经过 <span class=\"math inline\">\\(u\\)</span> 的路径和 <span class=\"math inline\">\\(u\\)</span> 下方一条链之和的最大值、<span class=\"math inline\">\\(u\\)</span> 中最长路径求解。</p>\n<details>\n<pre class=\"cpp language-cpp\" data-line=\"42-44\"><code class=\"cpp langauage-cpp\">#include &lt;bits/stdc++.h>\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(\".in\", \"r\", stdin);\n    std::freopen(\".out\", \"w\", stdout);\n#endif\n    int n;\n    std::cin >> n;\n    std::vector&lt;int> a(n + 1);\n    std::vector&lt;std::vector&lt;int> > g(n + 1);\n    for (int i = 1; i <= n; ++i)\n        std::cin >> a[i];\n    for (int i = 1, x, y; i < n; ++i) &#123;\n        std::cin >> x >> y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    auto res(0ll);\n    std::vector&lt;long long> s(n + 1), w(n + 1);\n    std::vector&lt;std::vector&lt;std::pair&lt;long long, int> > > f(n + 1, std::vector&lt;std::pair&lt;long long, int> > (4));\n    std::function&lt;void(int, int)> DFS = [&](int x, int fa) &#123;\n        f[x][0] = &#123; 0, x &#125;;\n        w[x] = s[x] = a[x];\n        for (auto i : g[x])\n            if (i != fa) &#123;\n                DFS(i, x);\n                &#123;\n                    if (f[i][0].first + a[i] > f[x][3].first)\n                        f[x][3].first = f[i][0].first + a[i], f[x][3].second = i;\n                    std::sort(f[x].begin(), f[x].end(), std::greater&lt;std::pair&lt;long long, int> > ());\n                &#125;\n                w[x] = std::max(w[x], w[i] + a[x]);\n            &#125;\n        auto mx(0ll);\n        for (auto i : g[x])\n            if (i != fa) &#123;\n                s[x] = std::max(&#123; s[x], s[i], f[x][0].first + f[x][1].first + a[x] &#125;);\n                w[x] = std::max(w[x], (f[x][0].second != i ? f[x][0] : f[x][1]).first + s[i] + a[x]);\n                res = std::max(&#123; res,\n                    mx + s[i], // 情况 1\n                    (f[x][0].second == i ? f[x][1].first + f[x][2].first : (f[x][1].second == i ? f[x][0].first + f[x][2].first : f[x][0].first + f[x][1].first)) + s[i] + a[x], // 情况 2.1\n                    (f[x][0].second == i ? f[x][1].first : f[x][0].first) + w[i] + a[x], // 情况 2.2\n                &#125;);\n                mx = std::max(mx, s[i]);\n            &#125;\n    //     printf(\"%d: res = %lld\\n  f: \\n\", a[x], res);\n    //     for (int i = 0; i < 4; ++i)\n    //         printf(\"    [%d] %lld\\n\", f[x][i].second, f[x][i].first);\n    //     printf(\"  s: %lld\\n  w: %lld\\n\", s[x], w[x]);\n    &#125;;\n    DFS(1, -1);\n    std::cout << res << '\\n';\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---巡逻\">C - 巡逻</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P3629\" class=\"uri\">https://www.luogu.com.cn/problem/P3629</a></p>\n<p>你可能需要注意：目的是遍历所有边而非所有点。</p>\n<p><span class=\"math inline\">\\(K=1\\)</span> 的时候，环上除了关键边的所有边经过次数会减 <span class=\"math inline\">\\(1\\)</span>。所以选树的直径就可以最优。</p>\n<p><span class=\"math inline\">\\(K=2\\)</span> 的时候，答案是 <span class=\"math inline\">\\(2\\times (m + 2)\\)</span> 减去两个边构成的环的 <em>并集减交集</em> 大小 <span class=\"math inline\">\\(L\\)</span>。环实际上是不存在的，<span class=\"math inline\">\\(L\\)</span> 其实是两条路径 <em>并集减交集</em> 再加上两条新边的值。</p>\n<p>两条路径有交的时候，可以等效成无交的情况：</p>\n<p><img src=\"1.png\" /></p>\n<p>就化归成上一个问题了。注意此时情况 3 可能发生；同时情况 2.2 可以选取经过 <span class=\"math inline\">\\(v\\)</span> 的路径。</p>\n<details>\n<pre class=\"cpp language-cpp\" data-line=\"55-56,64-67\"><code class=\"cpp langauage-cpp\">#include &lt;bits/stdc++.h>\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(\".in\", \"r\", stdin);\n    std::freopen(\".out\", \"w\", stdout);\n#endif\n    int n, k;\n    std::cin >> n >> k;\n    std::vector&lt;std::vector&lt;int> > g(n + 1);\n    for (int i = 1, x, y; i < n; ++i) &#123;\n        std::cin >> x >> y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    int res = 0;\n    if (k == 1) &#123;\n        std::vector&lt;std::vector&lt;std::pair&lt;int, int> > > f(n + 1, std::vector&lt;std::pair&lt;int, int> > (2));\n        std::function&lt;void(int, int)> DFS = [&](int x, int fa) &#123;\n            f[x][0] = &#123; 0, x &#125;;\n            for (auto i : g[x])\n                if (i != fa) &#123;\n                    DFS(i, x);\n                    &#123;\n                        if (f[i][0].first + 1 > f[x][1].first)\n                            f[x][1].first = f[i][0].first + 1, f[x][1].second = i;\n                        std::sort(f[x].begin(), f[x].end(), std::greater&lt;std::pair&lt;int, int> > ());\n                    &#125;\n                &#125;\n            res = std::max(res, f[x][0].first + f[x][1].first);\n        &#125;;\n        DFS(1, -1);\n        std::cout << 2 * n - res - 1 << '\\n';\n    &#125;\n    else &#123;\n        std::vector&lt;int> s(n + 1), w(n + 1);\n        std::vector&lt;std::vector&lt;std::pair&lt;int, int> > > f(n + 1, std::vector&lt;std::pair&lt;int, int> > (4));\n        std::function&lt;void(int, int)> DFS = [&](int x, int fa) &#123;\n            f[x][0] = &#123; 0, x &#125;;\n            for (auto i : g[x])\n                if (i != fa) &#123;\n                    DFS(i, x);\n                    &#123;\n                        if (f[i][0].first + 1 > f[x][3].first)\n                            f[x][3].first = f[i][0].first + 1, f[x][3].second = i;\n                        std::sort(f[x].begin(), f[x].end(), std::greater&lt;std::pair&lt;int, int> > ());\n                    &#125;\n                    w[x] = std::max(w[x], w[i] + 1);\n                &#125;\n            &#123;\n                int t = 0;\n                for (auto [v, id] : f[x])\n                    t += v;\n                res = std::max(res, t); // 情况 3\n                w[x] = std::max(w[x], t - f[x][3].first); // 路径可经过 u\n            &#125;\n            int mx = 0;\n            for (auto i : g[x])\n                if (i != fa) &#123;\n                    s[x] = std::max(&#123; s[x], s[i], f[x][0].first + f[x][1].first &#125;);\n                    w[x] = std::max(w[x], (f[x][0].second != i ? f[x][0] : f[x][1]).first + std::max(s[i], f[i][0].first + 1));\n                    res = std::max(&#123; res,\n                        mx + s[i], // 情况 1\n                        (f[x][0].second == i ? f[x][1].first + f[x][2].first : (f[x][1].second == i ? f[x][0].first + f[x][2].first : f[x][0].first + f[x][1].first)) + s[i], // 情况 2.1\n                        (f[x][0].second == i ? f[x][1].first : f[x][0].first) + w[i] + 1, // 情况 2.2\n                    &#125;);\n                    mx = std::max(mx, s[i]);\n                &#125;\n        &#125;;\n        DFS(1, -1);\n        std::cout << 2 * (n + 1) - res - 2 << '\\n';\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d---瞬间传送-teleport\">D - 瞬间传送 / Teleport</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P11915\" class=\"uri\">https://www.luogu.com.cn/problem/P11915</a></p>\n<p>需要观察到一个很厉害的贪心策略：如果钦定所有点的距离不大于 <span class=\"math inline\">\\(r\\)</span>，且存在 <span class=\"math inline\">\\(d(i,j)&gt;r\\)</span>。<strong>假设</strong> 一种满足条件的新边是 <span class=\"math inline\">\\((u,v)\\)</span>（由于两者无序，不妨钦定 <span class=\"math inline\">\\(d(i,u)&lt;d(i,v)\\)</span>），可以进行讨论：</p>\n<ol type=\"1\">\n<li><p><span class=\"math inline\">\\(d(j,v)&lt;d(j,u)\\)</span>：</p>\n此时最优路径为 <span class=\"math inline\">\\(i\\to u\\to v\\to j\\)</span>，判断一下这种方案是否不大于 <span class=\"math inline\">\\(r\\)</span> 就可以了。</li>\n<li><p><span class=\"math inline\">\\(d(j,v)\\ge d(j, u)\\)</span>：</p>\n<p>此时不管是走 <span class=\"math inline\">\\(i\\to u\\to v\\to j\\)</span> 还是 <span class=\"math inline\">\\(i\\to v\\to u\\to j\\)</span> 都不如走已经存在的 <span class=\"math inline\">\\(i\\to u\\to j\\)</span> 这条路径，也就是说如果要走新边，代价是一定比原距离大，更是比 <span class=\"math inline\">\\(r\\)</span> 大的；也就是说，<span class=\"math inline\">\\((u,v)\\)</span> 不能解决 <span class=\"math inline\">\\((i,j)\\)</span> 之间的问题，假设就不成立了。</p></li>\n</ol>\n<p>综上，只需要判断 <span class=\"math inline\">\\(i\\to u\\to v\\to j\\le r\\)</span> 是否成立，就可以判断 <span class=\"math inline\">\\((u,v)\\)</span> 是否合法。从大到小枚举 <span class=\"math inline\">\\(r\\)</span>，同时维护当前依然合法的 <span class=\"math inline\">\\((u,v)\\)</span>（显然是有单调性的），对于不合法的 <span class=\"math inline\">\\((i,j)\\)</span>，枚举每个 <span class=\"math inline\">\\(i\\)</span>，维护 <span class=\"math inline\">\\(\\max\\{d(v,j)\\}\\)</span>，精细实现（主要是利用各种均摊）一下就能 <span class=\"math inline\">\\(O(n^3)\\)</span>。</p>\n<p>这里具体提一下需要摊的几个点：</p>\n<ol type=\"1\">\n<li>枚举到 <span class=\"math inline\">\\(r\\)</span> 的时候用所有 <span class=\"math inline\">\\(d(i,j)=r+1\\)</span> 把 <span class=\"math inline\">\\(v\\)</span> 在 <span class=\"math inline\">\\(i\\)</span> 处的最大 <span class=\"math inline\">\\(d(v,j)\\)</span> 更新，方便后面 <span class=\"math inline\">\\(O(n)\\)</span> 地 check。摊出来是 <span class=\"math inline\">\\(O(n^3)\\)</span> 的。</li>\n<li>枚举仍然处在合法队列里的 <span class=\"math inline\">\\((u,v)\\)</span>，如果 check 合法，就说明对于当前 <span class=\"math inline\">\\(r\\)</span> 至少存在一个合法解，就可以 <code>break</code> 了；否则，把 <span class=\"math inline\">\\((u,v)\\)</span> 弹出，继续 check 下一条边。这样每条边只会被弹出一次，而未弹出边的 check 次数最多是 <span class=\"math inline\">\\(O(n)\\)</span>；加上 <span class=\"math inline\">\\(O(n)\\)</span> 的 check，摊出来是 <span class=\"math inline\">\\(O(n^3)\\)</span> 的。</li>\n</ol>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int inf = 0x3f3f3f3f;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n;\n        std::cin &gt;&gt; n;\n        std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1, std::vector&lt;int&gt; (n + 1, inf));\n        for (int i = 1; i &lt;= n; ++i)\n            for (int j = 1; j &lt;= n; ++j) &#123;\n                char t;\n                std::cin &gt;&gt; t;\n                if (t == &#39;1&#39; || i == j)\n                    g[i][j] = t - &#39;0&#39;;\n            &#125;\n        for (int k = 1; k &lt;= n; ++k)\n            for (int i = 1; i &lt;= n; ++i)\n                if (i != k)\n                    for (int j = 1; j &lt;= n; ++j)\n                        if (j != i &amp;&amp; j != k)\n                            g[i][j] = std::min(g[i][j], g[i][k] + g[k][j]);\n        std::queue&lt;std::pair&lt;int, int&gt; &gt; q;\n        std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; p(n + 1);\n        std::vector&lt;std::vector&lt;int&gt; &gt; mx(n + 1, std::vector&lt;int&gt; (n + 1));\n        for (int i = 1; i &lt; n; ++i)\n            for (int j = i + 1; j &lt;= n; ++j) &#123;\n                q.emplace(i, j);\n                p[g[i][j] - 1].emplace_back(i, j);\n            &#125;\n        auto check = [&amp;](int u, int v, int r) &#123;\n            for (int i = 1; i &lt;= n; ++i) &#123;\n                if (g[u][i] &gt; g[v][i])\n                    std::swap(u, v);\n                if (g[u][i] + mx[v][i] &gt; r)\n                    return false;\n            &#125;\n            return true;\n        &#125;;\n        for (int r = n; r &gt;= -1; --r) &#123;\n            for (auto [i, j] : p[r])\n                for (int v = 1; v &lt;= n; ++v) &#123;\n                    mx[v][i] = std::max(mx[v][i], g[v][j]);\n                    mx[v][j] = std::max(mx[v][j], g[v][i]);\n                &#125;\n            for (; !q.empty(); ) &#123;\n                auto [u, v] = q.front();\n                if (!check(u, v, r))\n                    q.pop();\n                else\n                    break;\n            &#125;\n            if (q.empty()) &#123;\n                std::cout &lt;&lt; r + 1 &lt;&lt; &#39;\\n&#39;;\n                break;\n            &#125;\n        &#125;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"e.-two-tanks\">E. Two Tanks</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1809/E\" class=\"uri\">https://codeforces.com/problemset/problem/1809/E</a></p>\n<p>果然还是不会简单 DP <img src=\"/em/ll.gif\" /></p>\n<p>可以观察到如果总水量相同，且某个时刻两种初始状态当前是相同状态，那么以后它们也会是相同状态。但光凭这个好像还是不太能做出来的样子 <img src=\"/em/kt.gif\" /></p>\n<p>这里大概算一个定式，对于类似这种两个元素总和不变的问题，可以把两个元素的容量画到数轴上，原点表示分界，当前水为一条定长线段，倒水就相当于左右平移这条线段：</p>\n<p><img src=\"3.png\" /></p>\n<p>需要意识到，<mark></mark></p>\n",
            "tags": [
                "DP",
                "贪心",
                "均摊"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250419/",
            "url": "https://xsc062.netlify.app/20250419/",
            "title": "网格图路径计数",
            "date_published": "2025-04-19T02:03:57.000Z",
            "content_html": "<figure>\n<img src=\"/20250419/neko.jpeg\" alt=\"猫\" style=\"width: 75px\">\n<figcaption>\n猫\n</figcaption>\n</figure>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"点到点的方案数\">点到点的方案数</h2>\n<p>从 <span class=\"math inline\">\\((x_1,y_1)\\)</span> 只能向右、向下走到 <span class=\"math inline\">\\((x_2,y_2)\\)</span> 的方案数：<span class=\"math inline\">\\(C_{x_2-x_1+y_2-y_1}^{x_2-x_1}\\)</span>。就是说，因为必须向下走 <span class=\"math inline\">\\(x_2-x_1\\)</span> 步，又必须向右走 <span class=\"math inline\">\\(y_2-y_1\\)</span> 步；但顺序是可以任意打乱的。</p>\n<hr />\n<h3 id=\"a---gerald-and-giant-chess\">A - Gerald and Giant Chess</h3>\n<p><a href=\"https://codeforces.com/problemset/problem/560/E\" class=\"uri\">https://codeforces.com/problemset/problem/560/E</a></p>\n<p>把不能走的点按 <span class=\"math inline\">\\(x\\)</span> 为第一关键字，<span class=\"math inline\">\\(y\\)</span> 为第二关键字排序，就可以得到它们按大致拓扑序排列的结果。</p>\n<p>令 <span class=\"math inline\">\\(f_i\\)</span> 表示不经过 <span class=\"math inline\">\\(1\\sim i-1\\)</span> 的非法点走到第 <span class=\"math inline\">\\(i\\)</span> 个非法点的方案数，就可以得到 <span class=\"math inline\">\\(f_i=C_{x_i+y_i,x_i}-\\sum_{j=1}^{i-1} f_j\\times C_{x_i-x_j+y_i-y_j}^{x_i-x_j}\\)</span>。可以发现后面减去的方案，因为碰到的第一个非法点不同，所以是两两不同的。</p>\n<p>让 <span class=\"math inline\">\\((h,w)\\)</span> 成为第 <span class=\"math inline\">\\((n+1)\\)</span> 个非法点，<span class=\"math inline\">\\(f_{n+1}\\)</span> 就是答案。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int h, w, n;\n    std::cin &gt;&gt; h &gt;&gt; w &gt;&gt; n, --h, --w;\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; a(n + 2);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i].first &gt;&gt; a[i].second;\n        --a[i].first, --a[i].second;\n    &#125;\n    a[n + 1] = &#123; h, w &#125;;\n    std::sort(a.begin() + 1, a.end());\n    std::vector&lt;long long&gt; fac(h + w + 1), inv(h + w + 1);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= h + w; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[h + w] = qkp(fac[h + w], mod - 2);\n    for (int i = h + w - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    std::vector&lt;long long&gt; f(n + 2);\n    for (int i = 1; i &lt;= n + 1; ++i) &#123;\n        f[i] = C(a[i].first + a[i].second, a[i].first);\n        for (int j = 1; j &lt; i; ++j)\n            if (a[j].second &lt;= a[i].second)\n                (f[i] += mod - f[j] * C(a[i].first - a[j].first + a[i].second - a[j].second, a[i].first - a[j].first) % mod) %= mod;\n        // printf(&quot;f[(%d, %d)] = %lld\\n&quot;, a[i].first, a[i].second, f[i]);\n    &#125;\n    std::cout &lt;&lt; f[n + 1] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"b---bbq-hard\">B - BBQ Hard</h3>\n<p><a href=\"https://atcoder.jp/contests/agc001/tasks/agc001_e\" class=\"uri\">https://atcoder.jp/contests/agc001/tasks/agc001_e</a></p>\n<p>不仅仅可以在关键点上 DP，也可以在网格上直接 DP。</p>\n<p><span class=\"math inline\">\\(A_i+B_i+A_j+B_j\\)</span> 就是 <span class=\"math inline\">\\(A_i+B_i-(-A_j)-(-B_j)\\)</span>。把棋盘扩大到 <span class=\"math inline\">\\(-2000\\to 2000\\)</span> 就可以了。</p>\n<p>设 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示可以到达 <span class=\"math inline\">\\((i,j)\\)</span> 的所有发出关键点 <span class=\"math inline\">\\((-A_j,-B_j)\\)</span> 带来的贡献，那么 <span class=\"math inline\">\\(f_{i,j}=f_{i-1,j}+f_{i,j-1}\\)</span>。枚举所有接收关键点 <span class=\"math inline\">\\((A_i,B_i)\\)</span>，<span class=\"math inline\">\\(\\sum f_{A_i,B_i}\\)</span> 就是答案的两倍，再减去对角线，也就是 <span class=\"math inline\">\\(\\sum (-A_i,B_i)\\to (A_i,B_i)\\)</span> 后的值。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int N = 2000;\nconst int mod = 1e9 + 7;\nconst int inv2 = 500000004;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;long long&gt; fac(4 * N + 1), inv(4 * N + 1);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= 4 * N; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[4 * N] = qkp(fac[4 * N], mod - 2);\n    for (int i = 4 * N - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; a(n + 1);\n    std::vector&lt;std::vector&lt;long long&gt; &gt; f(2 * N + 1, std::vector&lt;long long&gt; (2 * N + 1));\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i].first &gt;&gt; a[i].second;\n        ++f[N - a[i].first][N - a[i].second];\n    &#125;\n    for (int i = 0; i &lt;= 2 * N; ++i)\n        for (int j = 0; j &lt;= 2 * N; ++j) &#123;\n            if (i &gt;= 1)\n                (f[i][j] += f[i - 1][j]) %= mod;\n            if (j &gt;= 1)\n                (f[i][j] += f[i][j - 1]) %= mod;\n            // printf(&quot;f(%2d, %2d) = %lld\\n&quot;, i - N, j - N, f[i][j]);\n        &#125;\n    long long res = 0ll;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        (res += f[a[i].first + N][a[i].second + N]) %= mod;\n        (res += mod - C(a[i].first * 2 + a[i].second * 2, 2 * a[i].first)) %= mod;\n    &#125;\n    std::cout &lt;&lt; res * inv2 % mod &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"c---iroha-and-a-grid\">C - Iroha and a Grid</h3>\n<p><a href=\"https://atcoder.jp/contests/arc058/tasks/arc058_b\" class=\"uri\">https://atcoder.jp/contests/arc058/tasks/arc058_b</a></p>\n<p>先把绿色部分的答案计算出来：</p>\n<figure>\n<img src=\"1.png\" alt=\"网格\" /><figcaption>网格</figcaption>\n</figure>\n<p>如果把绿色的每一个格子到终点的方案数求和，就会算重，因为上面的绿色点可以走到下面的绿色点。</p>\n<p>让绿色点第一步只能往右走到黄色点，用这样的方案为黄色点赋初值，再让黄色点自由走就可以得到答案了。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int h, w, a, b;\n    std::cin &gt;&gt; h &gt;&gt; w &gt;&gt; a &gt;&gt; b;\n    std::vector&lt;long long&gt; fac(h + w + 1), inv(h + w + 1);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= h + w; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[h + w] = qkp(fac[h + w], mod - 2);\n    for (int i = h + w - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    auto res = 0ll;\n    for (int i = 1; i &lt;= h - a; ++i) &#123;\n        // (i, B)\n        auto f(C(i + b - 2, i - 1));\n        // printf(&quot;(%d, %d): %lld\\n&quot;, i, b, f);\n        // (i, B + 1)\n        (res += f * C(h - i + w - (b + 1), h - i) % mod) %= mod;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"点到矩形的方案数\">点到矩形的方案数</h2>\n<p>从 <span class=\"math inline\">\\((x_0,y_0)\\)</span> 走到矩形 <span class=\"math inline\">\\((x_1,y_1,x_2,y_2)\\)</span> 的方案数：</p>\n<p><span class=\"math display\">\\[\n\\sum\\limits_{i\\in [x_1,x_2],j\\in [y_1,y_2]} G(x_0,y_0, i, j) = G(x_0,y_0,x_2 + 1,y_2 + 1)-G(x_0,y_0,x_2+1,y_1)-G(x_0,y_0,x_1,y_2+1)+G(x_0,y_0,x_1,y_1)\n\\]</span></p>\n<p>证明：<span class=\"math inline\">\\(G(x_0,y_0,x_2+1,y_2+1)=\\sum\\limits_i G(x_0,y_0,i,y_2)=\\sum\\limits_{i,j} G(x_0,y_0,i,j)\\)</span>，类似的，把后面几项展开，可以得到前缀和的结构。</p>\n<p>现在，矩形就可以被概括成 4 个点了。</p>\n<hr />\n<h2 id=\"矩形到矩形的方案数\">矩形到矩形的方案数</h2>\n<p>枚举第一个矩形里的所有点，那么就可以得到关于第二个矩形里四个点的表达式。反过来把第一个矩形概括为 4 个点就可以快速求解了。</p>\n<p>具体一点，第一个矩形 <span class=\"math inline\">\\((x_1,y_1,x_2,y_2)\\)</span> 可以被概括为 <span class=\"math inline\">\\((x_1-1,y_1-1)\\)</span>，<span class=\"math inline\">\\((x_1-1,y_2)\\)</span>，<span class=\"math inline\">\\((x_2,y_1-1)\\)</span>，<span class=\"math inline\">\\((x_2,y_2)\\)</span>。注意方向颠倒导致符号发生变化。此时对 <span class=\"math inline\">\\(4\\times 4=16\\)</span> 个 <span class=\"math inline\">\\(G\\)</span> 按对应的 <span class=\"math inline\">\\(-1/1\\)</span> 系数求和就能得到答案。</p>\n<hr />\n<h3 id=\"d---sightseeing-plan\">D - Sightseeing Plan</h3>\n<p><a href=\"https://atcoder.jp/contests/agc018/tasks/agc018_e\" class=\"uri\">https://atcoder.jp/contests/agc018/tasks/agc018_e</a></p>\n<ol type=\"1\">\n<li>恒等式：<span class=\"math inline\">\\(\\sum\\limits_{i\\in [x_1,x_2]}G_(x_1,y_1,i,y_2-1)=G(x_1,y_1,x_2,y_2)\\)</span>，放在网格图上就是强制走到 <span class=\"math inline\">\\((i,y_2-1)\\)</span>，再强制向右走一步，然后向上走到 <span class=\"math inline\">\\((x_2,y_2)\\)</span>。和上一题类似的，可以发现不重不漏。</li>\n<li>三个矩形，<span class=\"math inline\">\\(M_1\\)</span> 经过 <span class=\"math inline\">\\(M_2\\)</span> 到达 <span class=\"math inline\">\\(M_3\\)</span> 的路径数量：经过 <span class=\"math inline\">\\(M_2\\)</span> 时，根据限制，只可能从下面或左边进入。枚举进入的点 <span class=\"math inline\">\\((x_0,y_0)\\)</span>（数量为 <span class=\"math inline\">\\(O(n)\\)</span>），再计算 <span class=\"math inline\">\\(G(x_0,y_0,M_3)\\)</span> 就能得到不重不漏的答案。</li>\n<li>原问题：要求 <span class=\"math inline\">\\(M_2\\)</span> 内部路径上点的贡献和，这个其实就是 <span class=\"math inline\">\\(M_2\\)</span> 内部路径长度。若从 <span class=\"math inline\">\\((x_1,y_1)\\)</span> 进入，再从 <span class=\"math inline\">\\((x_2,y_2)\\)</span> 离开，长度就是 <span class=\"math inline\">\\(x_2-x_1+y_2-y_1+1\\)</span>。拆成 <span class=\"math inline\">\\((x_2+y_2+1)\\)</span> 和 <span class=\"math inline\">\\(-(x_1+y_1)\\)</span> 后发现一次进入和一次离开的贡献是独立的。分别枚举进入点和离开点计算贡献就可以了。</li>\n</ol>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int N = 2e6;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int x1, x2, x3, x4, x5, x6, y1, y2, y3, y4, y5, y6;\n    std::cin &gt;&gt; x1 &gt;&gt; x2 &gt;&gt; x3 &gt;&gt; x4 &gt;&gt; x5 &gt;&gt; x6;\n    std::cin &gt;&gt; y1 &gt;&gt; y2 &gt;&gt; y3 &gt;&gt; y4 &gt;&gt; y5 &gt;&gt; y6;\n    std::vector&lt;long long&gt; fac(N + 1), inv(N + 1);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= N; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[N] = qkp(fac[N], mod - 2);\n    for (int i = N - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    std::vector&lt;std::tuple&lt;int, int, int&gt; &gt; f(4), g(4);\n    f[0] = &#123; x1 - 1, y1 - 1, 1 &#125;, f[1] = &#123; x1 - 1, y2, mod - 1 &#125;, f[2] = &#123; x2, y1 - 1, mod - 1 &#125;, f[3] = &#123; x2, y2, 1 &#125;;\n    g[0] = &#123; x5, y5, 1 &#125;, g[1] = &#123; x5, y6 + 1, mod - 1 &#125;, g[2] = &#123; x6 + 1, y5, mod - 1 &#125;, g[3] = &#123; x6 + 1, y6 + 1, 1 &#125;; \n    auto G = [&amp;](int x1, int y1, int x2, int y2) &#123;\n        auto a(std::abs(x1 - x2)), b(std::abs(y1 - y2));\n        return C(a + b, a);\n    &#125;;\n    auto res = 0ll;\n    for (auto [x1, y1, k1] : f)\n        for (auto [x2, y2, k2] : g) &#123;\n            auto t(0ll);\n            for (int x = x3; x &lt;= x4; ++x) &#123;\n                (t += G(x1, y1, x, y4) * G(x, y4 + 1, x2, y2) % mod * (x + y4 + 1) % mod) %= mod;\n                (t += mod - G(x1, y1, x, y3 - 1) * G(x, y3, x2, y2) % mod * (x + y3) % mod) %= mod;\n            &#125;\n            for (int y = y3; y &lt;= y4; ++y) &#123;\n                (t += G(x1, y1, x4, y) * G(x4 + 1, y, x2, y2) % mod * (x4 + y + 1) % mod) %= mod;\n                (t += mod - G(x1, y1, x3 - 1, y) * G(x3, y, x2, y2) % mod * (x3 + y) % mod) %= mod;\n            &#125;\n            // printf(&quot;(%d, %d, %d), (%d, %d, %d): %lld\\n&quot;, x1, y1, k1, x2, y2, k2, t * k1 % mod * k2 % mod);\n            (res += t * k1 % mod * k2 % mod) %= mod;\n        &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"不经过-yxc-的方案数\">不经过 <span class=\"math inline\">\\(y=x+c\\)</span> 的方案数</h2>\n<p>Catalan 数的一种推导方式是，在 <span class=\"math inline\">\\(n\\times n\\)</span> 的网格上，要求不能越过 <span class=\"math inline\">\\(y=x\\)</span> 的方案数。可以用总方案数减去越过的方案数。</p>\n<p>怎么计算非法的方案呢？越过 <span class=\"math inline\">\\(y=x\\)</span> 的路径必定存在一个点经过 <span class=\"math inline\">\\(y=x+1\\)</span>，原问题转化为不能碰到 <span class=\"math inline\">\\(y=x+1\\)</span> 的方案数。</p>\n<p>把终点 <span class=\"math inline\">\\((n, n)\\)</span> 翻折到 <span class=\"math inline\">\\(y=x+1\\)</span> 上方，得到 <span class=\"math inline\">\\((n-1, n + 1)\\)</span>；对于任意到达 <span class=\"math inline\">\\((n-1,n+1)\\)</span> 的路径，一定会接触 <span class=\"math inline\">\\(y=x+1\\)</span> 至少一次；将第一次接触以后的路径翻折到 <span class=\"math inline\">\\(y=x+1\\)</span> 下方，则一定和原图中的非法路径一一对应。</p>\n<p><img src=\"4.png\" /></p>\n<p>就可以得到 <span class=\"math inline\">\\(C_{2n}^n-C_{2n}^{n-1}\\)</span>。</p>\n<p>如果问题变得更加一般，求解到达 <span class=\"math inline\">\\((n, m)\\)</span> 不能碰到 <span class=\"math inline\">\\(y=x+c\\)</span> 的方案数，还是可以把 <span class=\"math inline\">\\((n,m)\\)</span> 翻折到 <span class=\"math inline\">\\((m-c,n+c)\\)</span>，答案是 <span class=\"math inline\">\\(C_{n+m}^n-C_{n+m}^{m-c}\\)</span>。</p>\n<hr />\n<h2 id=\"不经过-yx-l-和-yxr-的方案数\">不经过 <span class=\"math inline\">\\(y=x-l\\)</span> 和 <span class=\"math inline\">\\(y=x+r\\)</span> 的方案数</h2>\n<p>现在有 <span class=\"math inline\">\\(y=x-l\\)</span> 和 <span class=\"math inline\">\\(y=x+r\\)</span> 两条线作为限制，现在的翻折意义就会有一点改变。</p>\n<p><img src=\"5.png\" /></p>\n<p>比如图中的 <span class=\"math inline\">\\(A&#39;\\)</span>，是 <span class=\"math inline\">\\(A\\)</span> 沿着 <span class=\"math inline\">\\(y=x-l\\)</span> 翻折一次后的结果。还是按照之前的方式来理解，那么走到 <span class=\"math inline\">\\(A&#39;\\)</span> 的路径代表至少经过一次 <span class=\"math inline\">\\(y=x-l\\)</span> 的方案。<span class=\"math inline\">\\(A&#39;&#39;\\)</span> 是 <span class=\"math inline\">\\(A&#39;\\)</span> 沿着 <span class=\"math inline\">\\(y=x+r\\)</span> 翻折一次之后得到的结果，走到 <span class=\"math inline\">\\(A&#39;&#39;\\)</span> 的路径就代表至少先碰到一次 <span class=\"math inline\">\\(y=x-l\\)</span>，再碰到一次 <span class=\"math inline\">\\(y=x+r\\)</span> 的方案数。</p>\n<p>如果把相邻多次碰到 <span class=\"math inline\">\\(y=x-l\\)</span> 或 <span class=\"math inline\">\\(y=x+r\\)</span> 合并为一次，最终的非法路径就是 <code>LRLRLR...</code> 或者 <code>RLRLRL...</code> 的形式。因为可以计算的是「至少」的形式，用容斥原理得到，答案是 <span class=\"math inline\">\\(f_{\\varnothing}-(f_{\\texttt L} + f_{\\texttt R}) + (f_{\\texttt {LR}} + f_{\\texttt {RL}}) - \\cdots\\)</span>。对应计算每个翻折对应终点和答案就可以了。最后的答案是 <span class=\"math inline\">\\(C_{n+m}^n-C_{n+m}^{n+l}-C_{n+m}^{n + r}+C_{n+m}^{n+l-r}+C_{n+m}^{n+r-l}-\\cdots\\)</span>，可以简化成 <span class=\"math inline\">\\(\\sum\\limits_{k\\in \\mathbb{Z}} C_{n+m}^{n-k\\cdot (r-l)}-C_{n+m}^{n-k\\cdot (r-l)+r}\\)</span>。</p>\n<hr />\n<h3 id=\"e---骗我呢\">E - 骗我呢</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P3266\" class=\"uri\">https://www.luogu.com.cn/problem/P3266</a></p>\n<p>每行内部递增，而且选项只有 <span class=\"math inline\">\\([0,m]\\)</span>，那么每行就会刚好在 <span class=\"math inline\">\\([0,m]\\)</span> 里面跳过一个数。</p>\n<p>如果第 <span class=\"math inline\">\\(i\\)</span> 行跳过的数是 <span class=\"math inline\">\\(j\\)</span>，那么画一画图就可以发现第 <span class=\"math inline\">\\(i+1\\)</span> 可能跳过的数是 <span class=\"math inline\">\\([j-1,m]\\)</span>；反过来，第 <span class=\"math inline\">\\(i-1\\)</span> 行可能跳过的数就是 <span class=\"math inline\">\\([0,j+1]\\)</span>。</p>\n<p>如果让 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示确定了第 <span class=\"math inline\">\\(1\\to i\\)</span> 行，其中第 <span class=\"math inline\">\\(i\\)</span> 行跳过 <span class=\"math inline\">\\(j\\)</span> 的方案数，就可以得到 <span class=\"math inline\">\\(f_{i,j}=\\sum\\limits_{k=0}^{j+1} f_{i-1,k}\\)</span>。前缀和得到 <span class=\"math inline\">\\(f_{i,j}=f_{i,j-1}+f_{i-1,j+1}\\)</span>。注意边界：<span class=\"math inline\">\\(f_{0,j}=1\\)</span>；<span class=\"math inline\">\\(f_{i,0}=f_{i-1,0}+f_{i-1,1}\\)</span>；<span class=\"math inline\">\\(f_{i,m}=f_{i,m-1}\\)</span>。</p>\n<p>为了得到答案，让 <span class=\"math inline\">\\(g_{i,j}\\)</span> 表示 <span class=\"math inline\">\\(i\\times j\\)</span> 矩阵的方案数（这样就有机会通过手段优化了）：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\ng_{i,j}&amp;=\\sum_{k=0}^j f_{i,k}\\\\\n&amp;= f_{i-1,0}+f_{i-1,1}+\\sum_{k=1}^j f_{i,k-1}+f_{i-1,k+1}\\\\\n&amp;= g_{i,j-1}+g_{i-1,j+1}\n\\end{aligned}\n\\]</span></p>\n<p>边界情况呢， <span class=\"math inline\">\\(g_{i, 0} = f_{i,0} = f_{i-1, 0} + f_{i - 1, 1} = g_{i-1,1}\\)</span>；<span class=\"math inline\">\\(g_{i,m}=g_{i, m - 1} + f_{i,m}=g_{i-1,m}+g_{i,m-1}\\)</span>。 <span class=\"math inline\">\\(g_{i,m+1}=g_{i,m}\\)</span> 避免边界。</p>\n<p>那么在网格图上转移如下：</p>\n<p><img src=\"2.png\" /></p>\n<p>考虑将这个图形拉正，令 <span class=\"math inline\">\\((i+i,j)\\gets g_{i,j}\\)</span> 得到：</p>\n<p><img src=\"3.png\" /></p>\n<p>问题就转化为，从 <span class=\"math inline\">\\((0, 0)\\)</span> 走到 <span class=\"math inline\">\\((m+n+1,n)\\)</span> 且不能触碰 <span class=\"math inline\">\\(y=x+1\\)</span> 和 <span class=\"math inline\">\\(y=x-m-2\\)</span> 两条直线的方案数。</p>\n<details>\n</details>\n<hr />\n<h2 id=\"不经过一般过原点直线的方案数\">不经过一般过原点直线的方案数</h2>\n<ol type=\"1\">\n<li><p>类型一：<span class=\"math inline\">\\((0,0)\\to (n,m)\\)</span>，不经过 <span class=\"math inline\">\\(y=\\dfrac mnx\\)</span> 的方案，其中要求 <span class=\"math inline\">\\((m,n)=1\\)</span>。</p>\n<p>方案为 <span class=\"math inline\">\\(\\dfrac {C_{n+m}^n}{n+m}\\)</span>。</p></li>\n</ol>\n",
            "tags": [
                "排列组合",
                "容斥原理",
                "数学"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250418/",
            "url": "https://xsc062.netlify.app/20250418/",
            "title": "NOI 大纲 Upload",
            "date_published": "2025-04-18T08:51:53.000Z",
            "content_html": "<p><a href=\"NOI_Syllabus_Edition_2025.pdf\">link</a></p>\n<span id=\"more\"></span>\n",
            "tags": []
        },
        {
            "id": "https://xsc062.netlify.app/20250407/",
            "url": "https://xsc062.netlify.app/20250407/",
            "title": "组合计数",
            "date_published": "2025-04-07T06:57:14.000Z",
            "content_html": "<p>毅毅：统计不是数学（断章取义 ed）。<del>故删掉了数学标签。</del> 其实并没有。</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a.-二分图染色\">A. 二分图染色</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6181/problem/1\" class=\"uri\">http://222.180.160.110:61235/contest/6181/problem/1</a></p>\n<p>首先只看红色。显然一个左部点最多只能用红边连接一个右部点，反之同理。把左部点视为下标，其用红边相连的右部点视为值，则一个合法的方案为 <span class=\"math inline\">\\(n\\)</span> 的只保留一部分元素的排列。显然为 <span class=\"math inline\">\\(f(n)=\\sum\\limits_{i=0}^nC_n^i\\cdot A_n^i\\)</span>。</p>\n<p>再加上蓝色，<span class=\"math inline\">\\(f^2(n)\\)</span> 会给一条边涂两种颜色，故钦定有两种颜色的边数，容斥得到 <span class=\"math inline\">\\(\\sum\\limits_{i=0}^n(-1)^i\\cdot C_n^i\\cdot A_n^i\\cdot f^2(n-i)\\)</span>。发现 <span class=\"math inline\">\\(f\\)</span> 的计算可能需要优化一下。考虑已经知道 <span class=\"math inline\">\\(f(n-1)\\)</span>，此时对于新增的第 <span class=\"math inline\">\\(n\\)</span> 对点：</p>\n<ol type=\"1\">\n<li>任意连边（显然两个当中只能有一个点发出边），共有 <span class=\"math inline\">\\(2n-1\\)</span> 种方案，因为 <span class=\"math inline\">\\((n, n)\\)</span> 会被算重。</li>\n<li>不连，共 <span class=\"math inline\">\\(1\\)</span> 种方案。</li>\n<li>发现 1 中可能连到已经有连边的点上了，新边的目的地有 <span class=\"math inline\">\\(n-1\\)</span> 个选项，目的地原本连接的点也有 <span class=\"math inline\">\\(n-1\\)</span> 个选项，去掉两边共 <span class=\"math inline\">\\(4\\)</span> 个点，非法的即为 <span class=\"math inline\">\\((n-1)^2\\cdot f(n-2)\\)</span>。</li>\n</ol>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;long long&gt; f(n + 1), fac(n + 1), inv(n + 1);\n    f[0] = 1ll, f[1] = 2ll;\n    fac[0] = 1ll, fac[1] = 1ll, inv[0] = 1ll;\n    for (int i = 2; i &lt;= n; ++i) &#123;\n        fac[i] = fac[i - 1] * i % mod;\n        f[i] = (f[i - 1] * 2 * i % mod + mod - f[i - 2] * (i - 1) % mod * (i - 1) % mod) % mod;\n    &#125;\n    auto qkp = [](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[n] = qkp(fac[n], mod - 2);\n    for (int i = n - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    auto A = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod;\n    &#125;;\n    long long res = 0ll;\n    for (int i = 0, k = 1; i &lt;= n; ++i, k = mod - k)\n        (res += k * C(n, i) % mod * A(n, i) % mod * f[n - i] % mod * f[n - i]) %= mod;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b.-七选五\">B. 七选五</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6181/problem/2\" class=\"uri\">http://222.180.160.110:61235/contest/6181/problem/2</a></p>\n<p>首先 <span class=\"math inline\">\\(p\\)</span> 固定，钦定有 <span class=\"math inline\">\\(x\\)</span> 个数相等，有 <span class=\"math inline\">\\(C_k^x\\)</span> 个方案，剩下的就是从 <span class=\"math inline\">\\(n-x\\)</span> 个元素里选出 <span class=\"math inline\">\\(k-x\\)</span> 个来错排，考虑钦定相同的个数来容斥：</p>\n<p><span class=\"math display\">\\[\n\\sum_{i=0}^{k-x}(-1)^i\\cdot C_{k-x}^i\\cdot A_{n-x-i}^{k-x-i}\n\\]</span></p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k, x;\n    std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; x;\n    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);\n    fac[0] = 1ll, fac[1] = 1ll, inv[0] = 1ll;\n    for (int i = 2; i &lt;= n; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[n] = qkp(fac[n], mod - 2);\n    for (int i = n - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    auto A = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod;\n    &#125;;\n    long long res = C(k, x), sum = 0ll;\n    for (int i = 0, p = 1; i &lt;= k - x; ++i, p = mod - p)\n        (sum += p * C(k - x, i) % mod * A(n - x - i, k - x - i) % mod) %= mod;\n    std::cout &lt;&lt; res * sum % mod &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d.-硬币购物\">D. 硬币购物</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6181/problem/4\" class=\"uri\">http://222.180.160.110:61235/contest/6181/problem/4</a></p>\n<p>每次多重背包会超时，考虑用钦定每种硬币是否超额来容斥。令 <span class=\"math inline\">\\(f_s\\)</span> 表示凑出 <span class=\"math inline\">\\(s\\)</span> 的方案数（完全背包），那么 <span class=\"math inline\">\\(f_{s-c_1\\times (d_1 + 1)}\\)</span> 就表示钦定第 1 种硬币超额时凑出 <span class=\"math inline\">\\(s\\)</span> 的方案数，以此类推。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int c[4], T, m = 1e5;\n    std::vector&lt;long long&gt; f(m + 1);\n    f[0] = 1;\n    for (int i = 0; i &lt; 4; ++i) &#123;\n        std::cin &gt;&gt; c[i];\n        for (int j = c[i]; j &lt;= m; ++j)\n            f[j] += f[j - c[i]];\n    &#125;\n    std::cin &gt;&gt; T;\n    for (int d[4], m; T--; ) &#123;\n        for (int i = 0; i &lt; 4; ++i)\n            std::cin &gt;&gt; d[i];\n        std::cin &gt;&gt; m;\n        long long res = 0ll;\n        for (int i = 0; i &lt; (1 &lt;&lt; 4); ++i) &#123;\n            int s = m;\n            for (int j = 0; j &lt; 4; ++j)\n                if ((i &gt;&gt; j) &amp; 1)\n                    s -= (d[j] + 1) * c[j];\n            if (s &gt;= 0) &#123;\n                int k = (__builtin_popcount(i) &amp; 1) ? -1 : 1;\n                res += k * f[s];\n            &#125;\n        &#125;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"e.-distinct-multiples\">E. Distinct Multiples</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6181/problem/5\" class=\"uri\">http://222.180.160.110:61235/contest/6181/problem/5</a></p>\n<p>推式子题。题意转化为，给定 <span class=\"math inline\">\\(n\\)</span> 个位置可选的值集合，要求任意两个位置值不等，问方案数。</p>\n<p>如果把两个位置取等视作在团上选中边，那么有朴素做法钦定选边的集合 <span class=\"math inline\">\\(S\\)</span> 然后容斥，考虑它们构成的连通块 <span class=\"math inline\">\\(\\{s\\} \\subseteq S\\)</span>，有 <span class=\"math inline\">\\(res=\\sum\\limits_{S\\subseteq V}(-1)^{|S|}\\cdot \\prod\\limits_{s_i} \\left\\lfloor \\frac m{\\operatorname{lcm} s_i} \\right\\rfloor\\)</span>。</p>\n<p>有个很神奇的操作是把 <span class=\"math inline\">\\(S\\)</span> 丢掉，直接枚举 <span class=\"math inline\">\\(\\{s\\}\\)</span> 尝试子集 DP。有：<span class=\"math inline\">\\(res=\\sum\\limits_{\\{s\\}}\\prod\\limits_s f(s)\\cdot\\left\\lfloor \\frac m{\\operatorname{lcm} s} \\right\\rfloor\\)</span>。其中 <span class=\"math inline\">\\(f(s)\\)</span> 表示选取一个 <span class=\"math inline\">\\(s\\)</span> 的导出子图的容斥系数之和，其中次数为导出子图中边数。</p>\n<p>怎么把 <span class=\"math inline\">\\(f\\)</span> 算出来呢？容易发现其值只与 <span class=\"math inline\">\\(|s|\\)</span> 有关，考虑钦定与 <span class=\"math inline\">\\(1\\)</span> 连通的点数容斥，则有：</p>\n<p><span class=\"math display\">\\[\nf(n)=\\sum\\limits_{i=0}^{n - 1} (-1)^i \\times C_{n-1}^{i-1} \\times f(i) \\cdot \\sum_{j=0}^{m\\gets i\\times (i-1)\\div 2} (-1)^j\\cdot C_m^j\n\\]</span></p>\n<p>我们知道，二项式定理取 <span class=\"math inline\">\\(a=1, b = -1\\)</span> 有 <span class=\"math inline\">\\(0^m=[m=0]=\\sum_{j=0}^m(-1)^j\\cdot C_m^j\\)</span>，代入得：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nf(n)&amp;=\\sum\\limits_{i=0}^{n - 1} (-1)^i \\times C_{n-1}^{n-i-1} \\times f(n-i)\\cdot [m=0\\iff i=1]\\\\\n&amp;=(1 - n)\\cdot f(n-1)\n\\end{aligned}\n\\]</span></p>\n<p>然后就能线性求出。再用一个子集 DP，为了保证顺序枚举最小的未被确定的点所在连通块进行转移。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, l;\n    long long m;\n    std::cin &gt;&gt; n &gt;&gt; m, l = 1 &lt;&lt; n;\n    std::vector&lt;long long&gt; d(n), f(n + 1), dp(l), g(l);\n    f[1] = 1ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; d[i - 1];\n        if (i &gt;= 2)\n            f[i] = (1 + mod - i) * f[i - 1] % mod;\n        // printf(&quot;f[%d] = %lld\\n&quot;, i, f[i]);\n    &#125;\n    for (int i = 0; i &lt; l; ++i) &#123;\n        long long now = 1ll;\n        for (int j = 0; j &lt; n; ++j)\n            if ((i &gt;&gt; j) &amp; 1) &#123;\n                if (now / std::__gcd(now, d[j]) &gt; m / d[j])\n                    goto nosol;\n                now = now / std::__gcd(now, d[j]) * d[j];\n            &#125;\n        g[i] = (m / now) % mod;\n        // printf(&quot;lcm = %lld, g[%d] = %lld\\n&quot;, now, i, g[i]);\n    nosol: ;\n    &#125;\n    dp[0] = 1ll;\n    auto lowbit = [](int x) &#123;\n        return x &amp; -x;\n    &#125;;\n    for (int i = 1; i &lt; l; ++i) &#123;\n        int to = std::__lg(lowbit(i));\n        for (int j = i; j; j = (j - 1) &amp; i)\n            if ((j &gt;&gt; to) &amp; 1)\n                (dp[i] += dp[i ^ j] * f[__builtin_popcount(j)] % mod * g[j] % mod) %= mod;\n    &#125;\n    std::cout &lt;&lt; dp[l - 1] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"f.-permutation\">F. Permutation</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6181/problem/6\" class=\"uri\">http://222.180.160.110:61235/contest/6181/problem/6</a></p>\n<p>如果全是 <code>&lt;</code>，方案数为 <span class=\"math inline\">\\(1\\)</span>。</p>\n<p>现在把其中一些 <code>&lt;</code> 变成 <code>?</code>，比如 <code>&lt;&lt;??&lt;?&lt;&lt;&lt;&lt;</code> 的方案数，<del>太好了是多重集排列，我们没救了</del> 显然被 <code>&lt;</code> 连接起来的一段元素只有一种排列方式，所以可以视为多重集排列，方案数为 <span class=\"math inline\">\\(\\dfrac {11!}{3!\\times 2!\\times 5!}\\)</span>。</p>\n<p>似乎只需要枚举把 <code>&gt;</code> 变成 <code>&lt;</code> 或 <code>=</code> 的 <span class=\"math inline\">\\(2^k\\)</span> 种情况再计算就可以了，可惜 <span class=\"math inline\">\\(k\\)</span> 有点大。但我们发现它在一定程度上是没有后效性的，比如 <code>&lt;&lt;??&lt;</code> 和 <code>&lt;&lt;?&lt;&lt;</code>，前面的 <code>&lt;&lt;</code> 不会对后面的内容带来影响。</p>\n<p>故令 <span class=\"math inline\">\\(f_i\\)</span> 表示对于前 <span class=\"math inline\">\\(i\\)</span> 个元素的方案数，枚举最后一个被钦定为 <code>?</code> 的 <code>&gt;</code> <span class=\"math inline\">\\(j\\)</span>（即 <span class=\"math inline\">\\([j + 1, i-1]\\)</span> 间的 <code>&gt;</code> 都被替换为 <code>&lt;</code>），带上容斥系数，有 <span class=\"math inline\">\\(f_i=\\sum\\limits_{s_j=\\texttt{&#39;&gt;&#39;}}(-1)^{cnt_\\texttt{&#39;&gt;&#39;}[j + 1, i - 1]}\\times f_j\\times\\dfrac1{(i-j)!}\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);\n    fac[0] = 1ll, inv[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[n] = qkp(fac[n], mod - 2);\n    for (int i = n - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    std::vector&lt;char&gt; s(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; s[i];\n    std::vector&lt;long long&gt; f(n + 1);\n    s[0] = &#39;&gt;&#39;, f[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        int cnt = 0;\n        for (int j = i - 1; ~j; --j)\n            if (s[j] == &#39;&gt;&#39;) &#123;\n                long long k = (cnt &amp; 1) ? mod - 1 : 1;\n                (k *= f[j]) %= mod, (k *= inv[i - j]) %= mod;\n                (f[i] += k) %= mod;\n                ++cnt;\n            &#125;\n        // printf(&quot;f[%d] = %lld\\n&quot;, i, f[i]);\n    &#125;\n    std::cout &lt;&lt; f[n] * fac[n] % mod &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<p><em>忳郁邑余侘傺兮，余独穷困乎此时也。</em></p>\n<hr />\n<h2 id=\"h.-k-perm-counting\">H. ~K Perm Counting</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6181/problem/8\" class=\"uri\">http://222.180.160.110:61235/contest/6181/problem/8</a></p>\n<p>考虑钦定令几个元素不满足条件进行容斥，即答案为 <span class=\"math inline\">\\(\\sum\\limits_{i=0}^n (-1)^i\\cdot f(i)\\)</span>。但我们发现 <span class=\"math inline\">\\([n-k,n+k]\\)</span> 都有两个不能选的值，直接取 <span class=\"math inline\">\\(f(i)=\\prod 2\\)</span> 肯定会选到相同值，一个自然（？）的想法是再容斥一遍，可惜手玩一下发现似乎容不动。考虑把玩意儿拍在棋盘上：</p>\n<figure>\n<img src=\"1.png\" alt=\"以 k=2 为例\" /><figcaption>以 <span class=\"math inline\">\\(k=2\\)</span> 为例</figcaption>\n</figure>\n<p>其中 <span class=\"math inline\">\\(\\times\\)</span> 是非法格子，边是非法格子间的不同选关系，同颜色的边隶属同一条链。容易发现如果棋盘继续扩大，这些链还会继续延长。</p>\n<p>会发现这些链互不干扰，就是说我选了这条链上的某个点和链外的点没有任何关系（显然）。把这些链首尾相连拼起来，要做的就是拼接处可以选相邻，其余位置不能选相邻，选出来 <span class=\"math inline\">\\(i\\)</span> 个的方案数。提前预处理出来整个序列，令 <span class=\"math inline\">\\(tag_j\\)</span> 表示 <span class=\"math inline\">\\(j\\)</span> 是否能和 <span class=\"math inline\">\\(j-1\\)</span> 同选，设 <span class=\"math inline\">\\(dp_{j,i,0/1}\\)</span> 表示 DP 到了 <span class=\"math inline\">\\(j\\)</span>，已经选了 <span class=\"math inline\">\\(i\\)</span> 个数，第 <span class=\"math inline\">\\(j\\)</span> 个元素（不）选的方案数，那么有：</p>\n<p><span class=\"math display\">\\[\ndp_{j,i,0} = dp_{j - 1, i, 0} + dp_{j-1, i, 1}\\\\\ndp_{j,i,1} = \\begin{cases}\ndp_{j-1, i - 1, 1} + dp_{j-1,i - 1,0}&amp;tag_j=1\n\\\\\ndp_{j-1,i,0}&amp;\\text{otherwise}\n\\end{cases}\n\\]</span></p>\n<p>大力 DP 即可。<span class=\"math inline\">\\(f(i)\\)</span> 即为 <span class=\"math inline\">\\((n-i)!\\times (dp_{m, i, 0} + dp_{m, i, 1})\\)</span>，其中 <span class=\"math inline\">\\(m\\)</span> 为总链长。</p>\n<details>\n<p>注意不滚动可能会 MLE <img src=\"/em/kt.gif\" /></p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 924844033;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    std::vector&lt;int&gt; tag(1);\n    std::vector&lt;long long&gt; fac(n + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; vis(n + 1, std::vector&lt;int&gt; (n + 1));\n    auto calc = [&amp;](int i, int j, int s) &#123;\n        tag.push_back(1);\n        for (; ; s ^= 1) &#123;\n            // printf(&quot;(%d, %d) &quot;, i, j);\n            vis[i][j] = 1;\n            if (!s) &#123;\n                i = j + k;\n                if (i &lt;= n)\n                    tag.push_back(0);\n                else\n                    break;\n            &#125;\n            else &#123;\n                j = i + k;\n                if (j &lt;= n)\n                    tag.push_back(0);\n                else\n                    break;\n            &#125;\n        &#125;\n        // puts(&quot;&quot;);\n        return;\n    &#125;;\n    fac[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        fac[i] = fac[i - 1] * i % mod;\n        int j = i - k;\n        if (j &gt;= 1 &amp;&amp; !vis[i][j])\n            calc(i, j, 1);\n        j = i + k;\n        if (j &lt;= n &amp;&amp; !vis[i][j])\n            calc(i, j, 0);\n    &#125;\n    int m = (int)tag.size() - 1;\n    // printf(&quot;m = %d\\n&quot;, m);\n    std::vector&lt;std::vector&lt;std::vector&lt;long long&gt; &gt; &gt; dp(2, std::vector&lt;std::vector&lt;long long&gt; &gt; (n + 1, std::vector&lt;long long&gt; (2)));\n    dp[0][0][0] = 1ll;\n    for (int j = 1, now = 1; j &lt;= m; ++j, now ^= 1) &#123;\n        for (int i = 0; i &lt;= n &amp;&amp; i &lt;= j; ++i) &#123;\n            dp[now][i][0] = dp[!now][i][0];\n            dp[now][i][1] = 0ll;\n            if (i) &#123;\n                (dp[now][i][0] += dp[!now][i][1]) %= mod;\n                dp[now][i][1] = dp[!now][i - 1][0];\n                if (tag[j]) &#123;\n                    (dp[now][i][1] += dp[!now][i - 1][1]) %= mod;\n                    // assert(0);\n                &#125;\n            &#125;\n            // printf(&quot;dp[%d][%d] = %lld / %lld\\n&quot;, j, i, dp[j][i][0], dp[j][i][1]);\n        &#125;\n    &#125;\n    long long res = 0ll;\n    for (int i = 0, p = 1; i &lt;= n; ++i, p = mod - p)\n        (res += p * fac[n - i] % mod * (dp[m &amp; 1][i][0] + dp[m &amp; 1][i][1]) % mod) %= mod;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"a---positions-in-permutations\">A - Positions in Permutations</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/285/E\" class=\"uri\">https://codeforces.com/problemset/problem/285/E</a></p>\n<p><del>（看向上一题）这照片是你吗？</del></p>\n<p>在上一题的基础上，令 <span class=\"math inline\">\\(k=1\\)</span>。但是有个小小的问题——所求的「至少」不为 <span class=\"math inline\">\\(0\\)</span>，无法简单容斥。具体地，如果一个排列一共有 <span class=\"math inline\">\\(p\\)</span> 个非法排列，那么它会被 <span class=\"math inline\">\\(f(i)\\)</span> 统计 <span class=\"math inline\">\\(C_p^i\\)</span> 次。令 <span class=\"math inline\">\\(g(p)\\)</span> 表示非法格子数恰好为 <span class=\"math inline\">\\(p\\)</span> 的排列的真实数量，则 <span class=\"math inline\">\\(f(i)=\\sum\\limits_{j=i}^n C_j^i\\cdot g(j)\\)</span>，二项式反演即可得到真实值 <span class=\"math inline\">\\(g(m)=\\sum\\limits_{j=m}^n (-1)^{j-m}\\cdot C_j^m\\cdot f(j)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    std::vector&lt;int&gt; tag(1);\n    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; vis(n + 1, std::vector&lt;int&gt; (n + 1));\n    auto calc = [&amp;](int i, int j, int s) &#123;\n        tag.push_back(1);\n        for (; i &lt;= n &amp;&amp; j &lt;= n; s ^= 1) &#123;\n            vis[i][j] = 1;\n            if (!s) &#123;\n                i = j + 1;\n                if (i &lt;= n)\n                    tag.push_back(0);\n            &#125;\n            else &#123;\n                j = i + 1;\n                if (j &lt;= n)\n                    tag.push_back(0);\n            &#125;\n        &#125;\n        return;\n    &#125;;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    fac[0] = 1ll, inv[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        fac[i] = fac[i - 1] * i % mod;\n        int j = i - 1;\n        if (j &gt;= 1 &amp;&amp; !vis[i][j])\n            calc(i, j, 1);\n        j = i + 1;\n        if (j &lt;= n &amp;&amp; !vis[i][j])\n            calc(i, j, 0);\n    &#125;\n    inv[n] = qkp(fac[n], mod - 2);\n    for (int i = n - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    int m = (int)tag.size() - 1;\n    std::vector&lt;std::vector&lt;std::vector&lt;long long&gt; &gt; &gt; dp(2, std::vector&lt;std::vector&lt;long long&gt; &gt; (n + 1, std::vector&lt;long long&gt; (2)));\n    dp[0][0][0] = 1ll;\n    for (int j = 1, now = 1; j &lt;= m; ++j, now ^= 1) &#123;\n        for (int i = 0; i &lt;= n &amp;&amp; i &lt;= j; ++i) &#123;\n            dp[now][i][0] = dp[!now][i][0];\n            dp[now][i][1] = 0ll;\n            if (i) &#123;\n                (dp[now][i][0] += dp[!now][i][1]) %= mod;\n                dp[now][i][1] = dp[!now][i - 1][0];\n                if (tag[j])\n                    (dp[now][i][1] += dp[!now][i - 1][1]) %= mod;\n            &#125;\n        &#125;\n    &#125;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    long long res = 0ll;\n    for (int i = k, p = 1; i &lt;= n; ++i, p = mod - p) &#123;\n        // printf(&quot;%d: %lld\\n&quot;, i, C(i, k) * fac[n - i] % mod * (dp[m &amp; 1][i][0] + dp[m &amp; 1][i][1]) % mod);\n        (res += p * C(i, k) % mod * fac[n - i] % mod * (dp[m &amp; 1][i][0] + dp[m &amp; 1][i][1]) % mod) %= mod;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d---all-pairs-similarity-p\">D - All Pairs Similarity P</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P11458\" class=\"uri\">https://www.luogu.com.cn/problem/P11458</a></p>\n<p>省流：求 <span class=\"math inline\">\\(\\forall\\,i,f_i=\\sum\\limits_{j=1}^n \\dfrac{|a_i\\cap a_j|}{|a_i\\cup a_j|}\\)</span>。</p>\n<p>首先分离常数，有：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nf_i&amp;=\\sum\\limits_{j=1}^n \\dfrac{|a_i\\cap a_j|}{|a_i\\cup a_j|}\\\\\n&amp;=\\sum_{j=1}^n\\dfrac {|a_i|+|a_j|-|a_i\\cup a_j|}{|a_i\\cup a_j|}\\\\\n&amp;=\\sum_{j=1}^n \\dfrac {|a_i|+|a_j|}{|a_i\\cup a_j|}-1\n\\end{aligned}\n\\]</span></p>\n<p>尽量把分子变得更简：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nf_i&amp;=\\sum_{j=1}^n \\dfrac {|a_i|+|a_j|}{|a_i\\cup a_j|}-1\\\\\n&amp;=|a_i|\\cdot\\left(\\sum_{j=1}^n\\dfrac 1{|a_i\\cup a_j|}\\right)-n+\\sum_{j=1}^n \\dfrac {|a_j|}{|a_i\\cup a_j|}\n\\end{aligned}\n\\]</span></p>\n<p>问题转化为求解 <span class=\"math inline\">\\(\\sum\\limits_{j=1}^n\\dfrac 1{|a_i\\cup a_j|}\\)</span> 和 <span class=\"math inline\">\\(\\sum\\limits_{j=1}^n\\dfrac {|a_j|}{|a_i\\cup a_j|}\\)</span>，以 <span class=\"math inline\">\\(*=\\sum\\limits_{j=1}^n\\dfrac 1{|a_i\\cup a_j|}\\)</span> 为例。令 <span class=\"math inline\">\\(b_i\\)</span> 为 <span class=\"math inline\">\\(a_i\\)</span> 补集，则：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\n*&amp;=\\sum\\limits_{j=1}^n\\dfrac 1{|a_i\\cup a_j|}\\\\\n&amp;=\\sum_{j=1}^n\\dfrac 1{k-|b_i\\cap b_j|}\n\\end{aligned}\n\\]</span></p>\n<p>为什么要做这个转换呢？相比起并集运算，交集运算有着优秀的性质：<span class=\"math inline\">\\(s\\subseteq(b_i\\cap b_j)\\iff s\\subseteq b_i\\land s\\subseteq b_j\\)</span>，<del>直接取或当然也有相似的性质，但是太烧脑了</del>。</p>\n<p>基于这个性质，我们有一个想法：对于所有 <span class=\"math inline\">\\(j\\)</span>，在 <span class=\"math inline\">\\(\\forall \\, s\\subseteq b_j\\)</span> 处放置 <span class=\"math inline\">\\(\\dfrac 1{k-|s|}\\)</span> 的贡献；对于 <span class=\"math inline\">\\(i\\)</span>，将 <span class=\"math inline\">\\(\\forall \\, s\\subseteq b_i\\)</span> 处的贡献求和。但是这样肯定会拿到很多我们不想要的贡献，例如 <span class=\"math inline\">\\(\\forall \\, s\\subset (b_i\\cap b_j)\\)</span>。</p>\n<p>考虑精细布置贡献——构造 <span class=\"math inline\">\\(g(|s|)\\)</span> 满足 <span class=\"math inline\">\\(\\sum\\limits_{j=1}^n\\sum\\limits_{s\\subseteq b_j}g(|s|)=*\\)</span>。</p>\n<p>这里可以二项式反演得到 <span class=\"math inline\">\\(g\\)</span>，具体地，令 <span class=\"math inline\">\\(F(|S|)=\\dfrac 1{k-|S|}=\\sum\\limits_{s\\subseteq S}g(|s|)=\\sum\\limits_{j=0}^{|S|} C_{|S|}^j g(j)\\)</span>，则 <span class=\"math inline\">\\(g(i)=\\sum\\limits_{j=0}^iC_i^j\\cdot \\dfrac {(-1)^{i-j}}{k-j}\\)</span>。</p>\n<p>再令 <span class=\"math inline\">\\(h(s)=\\sum\\limits_{b_j\\supseteq s}g(|s|)=g(|s|)\\cdot \\sum\\limits_{b_j\\supseteq s}1\\)</span>，那么 <span class=\"math inline\">\\(h\\)</span> 就是高维后缀和。我们正在做的事情就是求解 <span class=\"math inline\">\\(*=\\sum\\limits_{s\\subseteq b_i}h(s)\\)</span>，这就又是一个高维前缀和了。</p>\n<p>对于 <span class=\"math inline\">\\(\\sum\\limits_{j=1}^n\\dfrac {|a_j|}{|a_i\\cup a_j|}\\)</span> 呢，令 <span class=\"math inline\">\\(h(s)=\\sum\\limits_{b_j\\supseteq s}g(|s|)\\cdot {\\color{red}{|a_j|}} = g(|s|) \\cdot \\sum\\limits_{b_j\\supseteq s} \\color{red}{k - |b_j|}\\)</span>，改变高维后缀和求和对象即可。</p>\n<p>复杂度就是 <span class=\"math inline\">\\(O(n+k\\cdot 2^k)\\)</span>，其中 <span class=\"math inline\">\\(k\\cdot 2^k\\)</span> 来自整体高维前 / 后缀和，<span class=\"math inline\">\\(n\\cdot k\\)</span> 来自枚举 <span class=\"math inline\">\\(i\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k, l;\n    std::cin &gt;&gt; n &gt;&gt; k, l = 1 &lt;&lt; k;\n    std::vector&lt;int&gt; a(n + 1), b(n + 1), cnt(l);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i], b[i] = (l - 1) ^ a[i];\n        ++cnt[b[i]];\n    &#125;\n    std::vector&lt;long long&gt; g(k + 1), fac(k + 1);\n    auto qkp = [&amp;](long long x, int y = mod - 2) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * qkp(fac[n - m]) % mod * qkp(fac[m]) % mod;\n    &#125;;\n    fac[0] = 1ll;\n    for (int i = 1; i &lt;= k; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    for (int i = 0; i &lt;= k; ++i) &#123;\n        for (int j = 0, p = (i &amp; 1) ? mod - 1 : 1; j &lt;= i; ++j, p = mod - p)\n            (g[i] += C(i, j) * p % mod * qkp(k - j) % mod) %= mod;\n        // printf(&quot;g[%d] = %lld\\n&quot;, i, g[i]);\n    &#125;\n    // for (int i = 0; i &lt;= k; ++i) &#123;\n    //     long long F = 0ll;\n    //     for (int j = 0; j &lt;= i; ++j)\n    //         (F += C(i, j) * g[j] % mod) %= mod;\n    //     printf(&quot;%d: %lld / %lld\\n&quot;, i, F, qkp(k - i));\n    // &#125;\n    std::vector&lt;long long&gt; h(l);\n    std::copy(cnt.begin(), cnt.end(), h.begin());\n    for (int i = 0; i &lt; k; ++i)\n        for (int j = l - 1; ~j; --j)\n            if (!((j &gt;&gt; i) &amp; 1))\n                (h[j] += h[j ^ (1 &lt;&lt; i)]) %= mod;\n    auto f1(h);\n    for (int i = 0; i &lt; l; ++i)\n        (f1[i] *= g[__builtin_popcount(i)]) %= mod;\n    for (int i = 0; i &lt; k; ++i)\n        for (int j = 0; j &lt; l; ++j)\n            if ((j &gt;&gt; i) &amp; 1)\n                (f1[j] += f1[j ^ (1 &lt;&lt; i)]) %= mod;\n    for (int i = 0; i &lt; l; ++i)\n        h[i] = cnt[i] * (k - __builtin_popcount(i));\n    for (int i = 0; i &lt; k; ++i)\n        for (int j = l - 1; ~j; --j)\n            if (!((j &gt;&gt; i) &amp; 1))\n                (h[j] += h[j ^ (1 &lt;&lt; i)]) %= mod;\n    auto f2(h);\n    for (int i = 0; i &lt; l; ++i)\n        (f2[i] *= g[__builtin_popcount(i)]) %= mod;\n    for (int i = 0; i &lt; k; ++i)\n        for (int j = 0; j &lt; l; ++j)\n            if ((j &gt;&gt; i) &amp; 1)\n                (f2[j] += f2[j ^ (1 &lt;&lt; i)]) %= mod;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        // fprintf(stderr, &quot;%d: %d * %lld - %d + %lld\\n&quot;, i, __builtin_popcount(a[i]), f1[b[i]], n, f2[b[i]]);\n        std::cout &lt;&lt; (__builtin_popcount(a[i]) * f1[b[i]] % mod + mod - n + f2[b[i]]) % mod &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"e---prefix-xors\">E - Prefix XORs</h2>\n<p><a href=\"https://atcoder.jp/contests/arc137/tasks/arc137_d\" class=\"uri\">https://atcoder.jp/contests/arc137/tasks/arc137_d</a></p>\n<p>省流：做 <span class=\"math inline\">\\(k\\)</span> 次前缀和，<span class=\"math inline\">\\(k=1,2,\\cdots,m\\)</span>，分别询问：令 <span class=\"math inline\">\\(x_i\\gets a_i\\)</span> 对 <span class=\"math inline\">\\(s_n\\)</span> 的贡献次数，则 <span class=\"math inline\">\\(\\sum a_i\\cdot (x_i\\bmod 2)\\)</span>？</p>\n<p>对于 <span class=\"math inline\">\\(a_p\\)</span>，容易发现第一轮其对任意 <span class=\"math inline\">\\(s_q\\)</span> 有 <span class=\"math inline\">\\(1\\)</span> 次贡献，拉开来就是常数列；第二轮有 <span class=\"math inline\">\\((q-p+1)\\)</span> 次贡献，是公差为 <span class=\"math inline\">\\(1\\)</span> 的等差数列；第三轮是类三角形数——至此，肯定和组合数有关了。手玩可以发现第 <span class=\"math inline\">\\(k\\)</span> 轮 <span class=\"math inline\">\\(a_p\\)</span> 对 <span class=\"math inline\">\\(s_n\\)</span> 的贡献为 <span class=\"math inline\">\\(C_{n-p+(k-2)}^{n-p}\\)</span>，尽量令其中一个不动，得到 <span class=\"math inline\">\\(C_{n-p+(k-2)}^{k-1}\\)</span>。</p>\n<p>但是我们发现直接枚举每轮每个数会起飞，而且模数为 <span class=\"math inline\">\\(2\\)</span> 似乎只能 Lucas（再带个 <span class=\"math inline\">\\(\\log\\)</span>），怎么办呢？</p>\n<p>那就 Lucas 呗。由其观察容易发现 <span class=\"math inline\">\\(C_{n-p+(k-2)}^{k-2}\\bmod2=1\\)</span> 当且仅当 <span class=\"math inline\">\\((k-2)\\subseteq (n-p+k-2)\\iff (k-2)\\subseteq \\complement_U(n-p)\\)</span>，故问题转化为高维后缀和，<del>当然你也可以做一次 and-FWT</del>，那么 <span class=\"math inline\">\\(res_k=\\sum (C_{n-p+(k-2)}^{k-2}\\bmod 2)\\cdot a_p=S_{k-2}\\)</span>，其中 <span class=\"math inline\">\\(S\\)</span> 为高维后缀和，初值为 <span class=\"math inline\">\\(S_{\\complement_u(n-i)}\\gets a_i\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m, l, k;\n    std::cin &gt;&gt; n &gt;&gt; m, k = std::__lg(n + m) + 1, l = 1 &lt;&lt; k;\n    std::vector&lt;int&gt; s(l);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; s[l - 1 - (n - i)];\n    for (int i = 0; i &lt; k; ++i)\n        for (int j = l - 1; ~j; --j)\n            if (!((j &gt;&gt; i) &amp; 1))\n                s[j] ^= s[j ^ (1 &lt;&lt; i)];\n    for (int i = 1; i &lt;= m; ++i)\n        std::cout &lt;&lt; s[i - 1] &lt;&lt; &#39; &#39;;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---the-top-scorer\">B - The Top Scorer</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1096/E\" class=\"uri\">https://codeforces.com/problemset/problem/1096/E</a></p>\n<p>鉴于每种方案等概率（翻译没说，但原题面有提到），考虑计算小明能够取胜的方案数，再对总方案数做除法。先枚举最高分 <span class=\"math inline\">\\(k\\ge r\\)</span>，再枚举包括小明在内恰有 <span class=\"math inline\">\\(c\\ge 1\\)</span> 个人 拿到 <span class=\"math inline\">\\(k\\)</span> 分。但剩下的人呢？显然是不能插板随机分配的，因为存在 <span class=\"math inline\">\\(&lt;k\\)</span> 的限制。</p>\n<p>考虑容斥，钦定剩下的 <span class=\"math inline\">\\(p-c\\)</span> 个人中拿到 <span class=\"math inline\">\\(\\ge k\\)</span> 分的人数后再可空地插板即可，则总方案数为：</p>\n<p><span class=\"math display\">\\[\n\\sum_{k=r}^s\\sum_{c=1}^p\\dfrac {C_{p - 1}^{c-1}}c\\cdot \\sum_{i=0}^{p-c}C_{p-c}^i\\cdot C_{s-k\\cdot (c+i)+(p-c-1)}^{p-c-1}\n\\]</span></p>\n<p>其中分母上的 <span class=\"math inline\">\\(c\\)</span> 来源于等概率分配给最高分，虽然不是整数，但也代表着「小明获胜可行方案数」。最后将答案除上总方案数 <span class=\"math inline\">\\(C_{s-r+p-1}^{p-1}\\)</span> 即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int p, s, r;\n    std::cin &gt;&gt; p &gt;&gt; s &gt;&gt; r;\n    std::vector&lt;long long&gt; fac(s + p), inv(s + p);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt; s + p; ++i) &#123;\n        fac[i] = fac[i - 1] * i % mod;\n    &#125;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv.back() = qkp(fac.back(), mod - 2);\n    for (int i = s + p - 2; i &gt; 0; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto C = [&amp;](int n, int m) &#123;\n        if (n == -1 &amp;&amp; m == -1)\n            return 1ll;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    auto res(0ll);\n    for (int k = r; k &lt;= s; ++k)\n        for (int c = 1; c &lt;= p; ++c)\n            if ((p - c) * (k - 1) + c * k &gt;= s) &#123;\n                auto t(0ll);\n                for (int i = 0, now = 1; i &lt;= p - c &amp;&amp; k * (c + i) &lt;= s; ++i, now = mod - now)\n                    (t += now * C(p - c, i) % mod * C(s - k * (c + i) + (p - c - 1), p - c - 1) % mod) %= mod;\n                (res += C(p - 1, c - 1) * qkp(c, mod - 2) % mod * t % mod) %= mod;\n            &#125;\n    std::cout &lt;&lt; res * qkp(C(s - r + p - 1, p - 1), mod - 2) % mod &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---sky-full-of-stars\">C - Sky Full of Stars</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/997/C\" class=\"uri\">https://codeforces.com/problemset/problem/997/C</a></p>\n<p>发现用 <span class=\"math inline\">\\(3^{n\\times n}\\)</span> 减去任意一行一列不同色的方案就是答案。</p>\n<p>考虑一元容斥，如令 <span class=\"math inline\">\\(f_i\\)</span> 表示至少 <span class=\"math inline\">\\(i\\)</span> 行 <span class=\"math inline\">\\(i\\)</span> 列同色的方案，但会发现 <span class=\"math inline\">\\(f_0\\)</span> 中包含 <span class=\"math inline\">\\(0\\)</span> 行 <span class=\"math inline\">\\(1\\)</span> 列同色等与预期不符的情况。受此启发考虑令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示至少 <span class=\"math inline\">\\(i\\)</span> 行 <span class=\"math inline\">\\(j\\)</span> 列同色进行二元容斥。容易发现当 <span class=\"math inline\">\\(i\\times j\\ne 0\\)</span> 时，被选中的 <span class=\"math inline\">\\(i\\)</span> 行 <span class=\"math inline\">\\(j\\)</span> 列全部连通，应为同一种颜色；将它们挪到角落，可以发现未被选中的格子共有 <span class=\"math inline\">\\((n-i)\\times (n-j)\\)</span> 个。故有：</p>\n<p><span class=\"math display\">\\[\nf_{i,j}=\\begin{cases}\nC_n^j\\times 3^j\\times 3^{n\\times(n - j)}&amp;i=0\\\\\nC_n^i\\times 3^i\\times 3^{n\\times(n-i)}&amp;j=0\\\\\nC_n^i\\times C_n^j\\times 3\\times 3^{(n-i)\\times (n-j)}&amp;\\text{otherwise}\n\\end{cases}\n\\]</span></p>\n<p>令 <span class=\"math inline\">\\(g_{i,j}\\)</span> 表示恰好 <span class=\"math inline\">\\(i\\)</span> 行 <span class=\"math inline\">\\(j\\)</span> 列同色的方案数，那么答案为 <span class=\"math inline\">\\(3^{n\\times n}-g_{0,0}\\)</span>。二项式反演 / 容斥原理得 <span class=\"math inline\">\\(g_{0,0}=\\sum\\limits_{i=0}^n\\sum\\limits_{j=0}^n (-1)^{i+j}\\cdot f_{i,j}\\)</span>。很惊讶地发现这是 <span class=\"math inline\">\\(O(n^2)\\)</span> 的！考虑优化。把 <span class=\"math inline\">\\(f_{1\\to n,1\\to n}\\)</span> 合并同类项，得到：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\ng_{0, 0}\n&amp;=\\left[\\sum_{j=0}^n (-1)^j\\cdot f_{0,j}\\right]+\\sum_{i=1}^n (-1)^i\\cdot f_{i,0}+\\sum_{j=1}^n (-1)^{i+j}\\cdot C_n^i\\times C_n^j\\times 3^{(n-i)\\times (n-j)+1}\\\\\n&amp;=\\left[\\sum_{j=0}^n (-1)^j\\cdot f_{0,j}\\right]+\\sum_{i=1}^n (-1)^i\\cdot f_{i,0}+(-1)^i\\cdot C_n^i\\times 3^{n^2-n\\times i+1}\\times\\sum_{j=1}^n (-1)^j\\cdot C_n^j\\times 3^{j\\times(-n+i)}\\\\\n&amp;=\\left[\\sum_{j=0}^n (-1)^j\\cdot f_{0,j}\\right]+\\sum_{i=1}^n (-1)^i\\cdot f_{i,0}+(-1)^i\\cdot C_n^i\\times 3^{n^2-n\\times i+1}\\times\\left[\\left(\\sum_{j=0}^n (-1)^j\\cdot C_n^j\\times (3^{-n+i})^j\\right)-1\\right]\\\\\n&amp;=\\left[\\sum_{j=0}^n (-1)^j\\cdot f_{0,j}\\right]+\\sum_{i=1}^n (-1)^i\\cdot f_{i,0}+(-1)^i\\cdot C_n^i\\times 3^{n^2-n\\times i+1}\\times\\left[(-3^{-n+i}+1)^n-1\\right]\n\\end{aligned}\n\\]</span></p>\n<p>由此便可 <span class=\"math inline\">\\(O(n\\log n)\\)</span> 计算。担心超时可以把所有 <span class=\"math inline\">\\(3^{-n+i}\\)</span> 和 <span class=\"math inline\">\\(3^{n\\times i}\\)</span> 线性预处理出来，复杂度不会变就是了。</p>\n<p>这里解释一下最后一步的二项式定理，非常遗憾地发现 <span class=\"math inline\">\\(-1\\)</span> 和 <span class=\"math inline\">\\(3^{-n+i}\\)</span> 都是 <span class=\"math inline\">\\(j\\)</span> 次的，没办法把二者相加减做二项式定理；但由于次数相同，这提示我们可以把 <span class=\"math inline\">\\(-1\\)</span> 乘到 <span class=\"math inline\">\\(3^{-n+i}\\)</span> 里去，给每一项配上 <span class=\"math inline\">\\(1^{n-k}\\)</span> 就可以做 <span class=\"math inline\">\\(-3^{n-i}\\)</span>（注意不是 <span class=\"math inline\">\\((-3)^{n-i}\\)</span>） 和 <span class=\"math inline\">\\(1\\)</span> 的二项式定理。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    long long n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1), invn(n + 1), invi(n + 1), powi(n + 1), pown(n + 1);\n    auto qkp = [&amp;](long long x, long long y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    const long long pnn = qkp(3ll, n * n), pn = qkp(3ll, n);\n    fac[0] = inv[0] = invn[0] = invi[0] = powi[0] = pown[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        fac[i] = fac[i - 1] * i % mod;\n        powi[i] = powi[i - 1] * 3 % mod;\n        pown[i] = pown[i - 1] * pn % mod;\n    &#125;\n    inv[n] = qkp(fac[n], mod - 2);\n    invi[n] = qkp(powi[n], mod - 2);\n    invn[n] = qkp(pown[n], mod - 2);\n    for (int i = n - 1; i; --i) &#123;\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n        invi[i] = invi[i + 1] * 3 % mod;\n        invn[i] = invn[i + 1] * pn % mod;\n    &#125;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    long long g = 0ll;\n    auto f = [&amp;](int i, int j) &#123; // make sure (!i || !j)\n        if (i == 0 &amp;&amp; j == 0)\n            return pnn;\n        else if (i == 0)\n            return C(n, j) * powi[j] % mod * pown[n - j] % mod;\n        return C(n, i) * powi[i] % mod * pown[n - i] % mod;\n    &#125;;\n    for (int j = 0, p = 1; j &lt;= n; ++j, p = mod - p)\n        (g += p * f(0, j)) %= mod;\n    for (int i = 1, p = mod - 1; i &lt;= n; ++i, p = mod - p)\n        (g += p * f(i, 0) % mod + p * C(n, i) % mod * pnn % mod * invn[i] % mod * 3 % mod * (qkp(mod - invi[n - i] + 1, n) + mod - 1) % mod) %= mod;\n    std::cout &lt;&lt; (pnn + mod - g) % mod &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d---去-m-nom\">D - 去 M / NoM</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P11316\" class=\"uri\">https://www.luogu.com.cn/problem/P11316</a></p>\n<p>假设 <span class=\"math inline\">\\(f(i)\\)</span> 为至少有 <span class=\"math inline\">\\(i\\)</span> 对不合法元素的方案数，则容斥得到答案 <span class=\"math inline\">\\(\\sum\\limits_{i=0}^n (-1)^i\\cdot f(i)\\)</span>。考虑怎么计算 <span class=\"math inline\">\\(f(i)\\)</span>。</p>\n<p><mark><span class=\"math inline\">\\(M\\)</span> 整除 <span class=\"math inline\">\\(dis(x, y) \\iff (pos_x - pos_y)\\bmod M=0\\iff pos_x\\equiv pos_y\\pmod M\\)</span>。</mark></p>\n<p>考虑把关于 <span class=\"math inline\">\\(M\\)</span> 同余的位置放在一个组，也就是说需要让一对元素不能选同一组的位置。</p>\n<p>考虑容斥，令 <span class=\"math inline\">\\(f(i)\\)</span> 表示至少有 <span class=\"math inline\">\\(i\\)</span> 对点选到一组的方案数，考虑怎么计算。假设我们要在第 <span class=\"math inline\">\\(k\\)</span> 组（size 为 <span class=\"math inline\">\\(s_k\\)</span>）中选出 <span class=\"math inline\">\\(x\\)</span> 对位置，实际上只需要选择 <span class=\"math inline\">\\(2x\\)</span> 个位置然后任意分配给这 <span class=\"math inline\">\\(x\\)</span> 对数，即 <span class=\"math inline\">\\(A_{s_k}^{2x}\\)</span>。设 <span class=\"math inline\">\\(dp_{i, j}\\)</span> 表示 DP 到第 <span class=\"math inline\">\\(i\\)</span> 个组，已经选了 <span class=\"math inline\">\\(j\\)</span> 对，那么有 <span class=\"math inline\">\\(dp_{i,j}=\\sum\\limits_{k=0}^jC_{n-(j - k)}^{j-k}\\times dp_{i-1,j-k}\\times A_{s_i}^{2k}\\)</span>。乍一看好像是 <span class=\"math inline\">\\(O(n^3)\\)</span> 的，但是别忘了 <span class=\"math inline\">\\(\\sum s_i=2n\\)</span>，所以只有 <span class=\"math inline\">\\(O(n^2)\\)</span>。<span class=\"math inline\">\\(f(i)\\)</span> 即为 <span class=\"math inline\">\\(dp_{m,i}\\times (2n-2i)!\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;int&gt; s(m + 1);\n    std::vector&lt;long long&gt; fac(2 * n + 1), inv(2 * n + 1);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= 2 * n; ++i)\n        ++s[i % m + 1], fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[2 * n] = qkp(fac[2 * n], mod - 2);\n    for (int i = 2 * n - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto A = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod;\n    &#125;;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    std::vector&lt;std::vector&lt;long long&gt; &gt; dp(m + 1, std::vector&lt;long long&gt; (n + 1));\n    dp[0][0] = 1ll;\n    for (int i = 1; i &lt;= m; ++i)\n        for (int j = 0; j &lt;= n; ++j) &#123;\n            for (int k = 0; k &lt;= j &amp;&amp; 2 * k &lt;= s[i]; ++k)\n                (dp[i][j] += C(n - (j - k), k) * dp[i - 1][j - k] % mod * A(s[i], 2 * k) % mod) %= mod;\n            // printf(&quot;s = %d, dp[%d][%d] = %lld\\n&quot;, s[i], i, j, dp[i][j]);\n        &#125;\n    long long res = 0ll;\n    for (int i = 0, p = 1; i &lt;= n; ++i, p = mod - p)\n        (res += p * dp[m][i] % mod * fac[2 * n - 2 * i] % mod) %= mod;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"e---kdoi-11彩灯晚会\">E - 「KDOI-11」彩灯晚会</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P11292\" class=\"uri\">https://www.luogu.com.cn/problem/P11292</a></p>\n<p>考虑 <span class=\"math inline\">\\({cnt_i}^2\\)</span> 的含义，即在所有颜色为 <span class=\"math inline\">\\(i\\)</span>、长度为 <span class=\"math inline\">\\(l\\)</span> 的链中有放回地选两次的方案数。</p>\n<p>显然复杂度里是不能包含 <span class=\"math inline\">\\(k\\)</span> 的，所以放弃直接统计 <span class=\"math inline\">\\(cnt_i\\)</span> 的想法。显然每种颜色是等价的，考虑计算选择两条链可以给答案带来的贡献：答案的形式是个和式；对于两条同色链 <span class=\"math inline\">\\(p,q\\)</span>，假设颜色为 <span class=\"math inline\">\\(i\\)</span>，那么会对 <span class=\"math inline\">\\({cnt_i}^2\\)</span> 带来 <span class=\"math inline\">\\(k^{n-2l-|p\\cap q|}\\)</span> 的贡献，对总答案带来 <span class=\"math inline\">\\(k^{n-2l-|p\\cap q| + 1}\\)</span> 的贡献。</p>\n<p>然而如果要枚举计算 <span class=\"math inline\">\\(|p\\cap q|\\)</span> 就无法避免 <span class=\"math inline\">\\(O(n^5)\\)</span>，考虑更有潜力的方法：将问题转化为对于每个 <span class=\"math inline\">\\(x\\)</span>，求交集大小恰好为 <span class=\"math inline\">\\(x\\)</span> 的链对个数。然而「恰好」是不方便计算的——假如当前两链在 <span class=\"math inline\">\\(u\\)</span> 次重合，如果假设下一次在 <span class=\"math inline\">\\(v\\)</span> 次重合，就需要保证在 <span class=\"math inline\">\\(u,v\\)</span> 之间不能重合——这并不好操作。二项式反演将恰好转化为至少，则限制减弱。</p>\n<p>令 <span class=\"math inline\">\\(f_{u,c,l_1,l_2}\\)</span> 表示 <span class=\"math inline\">\\(p,q\\)</span> 当前在 <span class=\"math inline\">\\(u\\)</span> 处重合，视野内的 <span class=\"math inline\">\\(p,q\\)</span> 长度为 <span class=\"math inline\">\\(l_1,l_2\\)</span>，至少已经重合了 <span class=\"math inline\">\\(c\\)</span> 次的方案数。预处理出走到 <span class=\"math inline\">\\(u\\)</span> 步数为 <span class=\"math inline\">\\(l_1,l_2\\)</span> 的方案数为初始值。枚举可能的后续重合点 <span class=\"math inline\">\\(v\\)</span>（满足 <span class=\"math inline\">\\(v\\)</span> 的拓扑序 <span class=\"math inline\">\\(&gt;u\\)</span>）有 <span class=\"math inline\">\\(f_{v,c+1,l_1&#39;,l_2&#39;}\\gets f_{v,c+1,l_1&#39;,l_2&#39;} + f_{u,c,l_1,l_2}\\)</span>。预处理出 <span class=\"math inline\">\\(u\\to v\\)</span> 长度为 <span class=\"math inline\">\\(\\Delta\\)</span> 的方案数（这是 <span class=\"math inline\">\\(O(n^3l)\\)</span> 的）优化转移，在算出 <span class=\"math inline\">\\(nex_{u,l}\\)</span> 表示从 <span class=\"math inline\">\\(u\\)</span> 出发走 <span class=\"math inline\">\\(l\\)</span> 步的方案数处理答案，则 <span class=\"math inline\">\\(F(i)=\\sum_{u,l_1,l_2}f_{u,l_1,l_2}\\cdot nex_{u,l-l_1}\\cdot nex_{u,l-l_2}\\)</span>，枚举 <span class=\"math inline\">\\(u,c,l_1,l_2,v,l_1&#39;,l_2&#39;\\)</span>，就可以达到优秀的 <span class=\"math inline\">\\(O(n^2l^5+n^3l)\\)</span>！简直是令人震撼 <img src=\"/em/kt.gif\" /></p>\n<p>给出第一个优化：发现 <span class=\"math inline\">\\(l_1\\)</span> 和 <span class=\"math inline\">\\(l_2\\)</span> 的转移彼此不干扰，考虑建立一个临时数组 <span class=\"math inline\">\\(g\\)</span>，先从 <span class=\"math inline\">\\(f_u,c\\)</span> 转移 <span class=\"math inline\">\\(l_1\\)</span> 到 <span class=\"math inline\">\\(g\\)</span>，再从 <span class=\"math inline\">\\(g\\)</span> 转移 <span class=\"math inline\">\\(l_2\\)</span> 到 <span class=\"math inline\">\\(f_{v,c+1}\\)</span>，则复杂度降为 <span class=\"math inline\">\\(O(n^2l^4+n^3l)\\)</span>，仍不足以通过。</p>\n<p>DP 过程上的优化已经万策尽，考虑从式子本身消元减少 DP 维度入手。令 <span class=\"math inline\">\\(h(i)\\)</span> 表示交集大小恰好恰好为 <span class=\"math inline\">\\(i\\)</span> 的方案数，则此时答案式为 <span class=\"math inline\">\\(\\sum\\limits_{i=0}^l k^{n-2l+i+1}\\times h(i)\\)</span>。又 <span class=\"math inline\">\\(F(i)=\\sum\\limits_{j=i}^lC_j^i\\cdot h(j)\\)</span>，二项式反演得：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nres&amp;=\\sum\\limits_{i=0}^lk^{n-2l+i+1}\\cdot \\sum_{j=i}^l(-1)^{j-i}\\cdot C_j^i\\cdot F(j)\\\\\n&amp;=k^{n-2l+1}\\cdot\\sum_{j=0}^l \\sum_{i=0}^j k^i\\cdot (-1)^{j-i}\\cdot C_j^i\\cdot F(j)\\\\\n&amp;=k^{n-2l+1}\\cdot \\sum_{j=0}^l (k-1)^j\\cdot F(j)\n\\end{aligned}\n\\]</span></p>\n<p><mark>注意这里利用了二项式反演的系数可以和交换求和顺序后的 <span class=\"math inline\">\\(i\\)</span> 次项（或 <span class=\"math inline\">\\(j-i\\)</span> 次项，参见 <a href=\"#c---sky-full-of-stars\">Sky Full of Stars 中最后一步的处理</a>）组成二项式定理的特点</mark>，以便基于式子结构尽可能消元。</p>\n<p>那么此时答案式已经和 <span class=\"math inline\">\\(c\\)</span> 无关，可以丢掉 <span class=\"math inline\">\\(c\\)</span> 这一维，和 <span class=\"math inline\">\\(c\\)</span> 有关的计算已经在转移时处理了。则 <span class=\"math inline\">\\(f_{v,l_1&#39;,l_2&#39;}=\\sum f_{u,l_1,l_2}\\times (k-1)\\)</span>，复杂度降为 <span class=\"math inline\">\\(O(n^2l^3+n^3l)\\)</span>。</p>\n<details>\n<p>记得还要算上 <span class=\"math inline\">\\(F(0)\\)</span>，即任选一条合法链的方案数平方。</p>\n<pre class=\"cpp\"><code>// 兄弟你好香\n// 兄弟你是依托打分，我踏马吃吃吃吃吃\n#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;party3.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    using arr = std::vector&lt;long long&gt;;\n    using arrr = std::vector&lt;arr&gt;;\n    using arrrr = std::vector&lt;arrr&gt;;\n    int n, k, l, m;\n    std::cin &gt;&gt; n, std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; l &gt;&gt; m;\n    std::vector&lt;int&gt; deg(n + 1), id;\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(n + 1);\n    for (int x, y, c; m--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; c;\n        ++deg[y], g[x].emplace_back(y, c);\n    &#125;\n    arrrr to(n + 1, arrr(n + 1, arr(l + 1)));\n    arrr pre(n + 1, arr(l + 1)), nex(n + 1, arr(l + 1));\n    &#123;\n        std::queue&lt;int&gt; q;\n        for (int i = 1; i &lt;= n; ++i)\n            if (!deg[i])\n                q.push(i);\n        for (int u; !q.empty(); ) &#123;\n            u = q.front(), q.pop();\n            to[u][u][0] = 1ll, id.push_back(u);\n            for (auto i : id)\n                for (int j = 0; j &lt;= l; ++j) &#123;\n                    (pre[u][j] += to[i][u][j]) %= mod;\n                    // printf(&quot;to[%d][%d][%d] = %lld\\n&quot;, i, u, j, to[i][u][j]);\n                &#125;\n            // for (int j = 0; j &lt;= l; ++j)\n            //     printf(&quot;pre[%d][%d] = %lld\\n&quot;, u, j, pre[u][j]);\n            for (auto [v, c] : g[u]) &#123;\n                for (auto i : id)\n                    for (int j = 1; j &lt;= l; ++j)\n                        (to[i][v][j] += to[i][u][j - 1] * c) %= mod;\n                if (!--deg[v])\n                    q.push(v);\n            &#125;\n        &#125;\n        for (int u = 1; u &lt;= n; ++u)\n            for (int v = 1; v &lt;= n; ++v)\n                for (int i = 0; i &lt;= l; ++i)\n                    (nex[u][i] += to[u][v][i]) %= mod;\n    &#125;\n    arrrr f(n + 1, arrr(l + 1, arr(l + 1)));\n    &#123;\n        for (int i = 1; i &lt;= n; ++i)\n            for (int l1 = 1; l1 &lt;= l; ++l1)\n                for (int l2 = 1; l2 &lt;= l; ++l2)\n                    f[i][l1][l2] = pre[i][l1 - 1] * pre[i][l2 - 1] % mod * (k - 1) % mod;\n        for (auto i = 0; i &lt; n; ++i) &#123;\n            int u = id[i];\n            // for (int l1 = 1; l1 &lt;= l; ++l1)\n            //     for (int l2 = 1; l2 &lt;= l; ++l2)\n            //         printf(&quot;f[%d][%d][%d] = %lld\\n&quot;, u, l1, l2, f[u][l1][l2]);\n            for (auto j = i + 1; j &lt; n; ++j) &#123;\n                arrr g(l + 1, arr(l + 1));\n                int v = id[j];\n                for (int l1 = 1; l1 &lt; l; ++l1)\n                    for (int _l1 = l1 + 1; _l1 &lt;= l; ++_l1) &#123;\n                        auto K = to[u][v][_l1 - l1];\n                        if (K)\n                            for (int l2 = 1; l2 &lt; l; ++l2)\n                                (g[_l1][l2] += f[u][l1][l2] * K) %= mod;\n                    &#125;\n                for (int _l1 = 2; _l1 &lt;= l; ++_l1)\n                    for (int l2 = 1; l2 &lt; l; ++l2)\n                        if (g[_l1][l2])\n                            for (int _l2 = l2 + 1; _l2 &lt;= l; ++_l2)\n                                (f[v][_l1][_l2] += g[_l1][l2] * to[u][v][_l2 - l2] % mod * (k - 1)) %= mod; \n            &#125;\n        &#125;\n    &#125;\n    auto qkp = [](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    auto res(0ll);\n    for (int u = 1; u &lt;= n; ++u)\n        for (int v = 1; v &lt;= n; ++v)\n            (res += to[u][v][l - 1]) %= mod;\n    (res *= res) %= mod;\n    for (int u = 1; u &lt;= n; ++u)\n        for (int l1 = 1; l1 &lt;= l; ++l1)\n            for (int l2 = 1; l2 &lt;= l; ++l2)\n                (res += f[u][l1][l2] * nex[u][l - l1] % mod * nex[u][l - l2] % mod) %= mod;\n    res = res % mod * (qkp(k, n + 1) * qkp(qkp(k, 2 * l), mod - 2) % mod) % mod;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"g---小星星\">G - 小星星</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P3349\" class=\"uri\">https://www.luogu.com.cn/problem/P3349</a></p>\n<p>首先考虑比较暴力的做法，那么有 <span class=\"math inline\">\\(f_{i,j,S}\\)</span> 表示在 <span class=\"math inline\">\\(i\\)</span> 这个子树里面选了集合 <span class=\"math inline\">\\(S\\)</span>，且 <span class=\"math inline\">\\(i\\)</span> 的颜色为 <span class=\"math inline\">\\(j\\)</span> 的方案数，维数里之所以有 <span class=\"math inline\">\\(j\\)</span> 是为了满足连边限制。</p>\n<p>然后树上子集 DP，发现是 <span class=\"math inline\">\\(O(n^4\\cdot 2^n)\\)</span> 的，</p>\n<hr />\n<h2 id=\"cf785d-anton-and-school---2\">CF785D Anton and School - 2</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/785/D\" class=\"uri\">https://codeforces.com/problemset/problem/785/D</a></p>\n<p>容易想到枚举每个 <code>(</code> 作为分界点的情况，那么钦定当前枚举的 <code>(</code> 是要选的。对于当前 <code>(</code>，若其左边（不含）的 <code>(</code> 有 <span class=\"math inline\">\\(n\\)</span> 个而右边的 <code>)</code> 有 <span class=\"math inline\">\\(m\\)</span> 个，枚举除了当前 <code>(</code> 还要选 <span class=\"math inline\">\\(i\\)</span> 个 <code>(</code>，那么答案为 <span class=\"math inline\">\\(\\sum_{i=0}C_n^{i-1}\\cdot C_m^i\\)</span>。</p>\n<p>发现这个形式可以范德蒙德卷积：<span class=\"math inline\">\\(\\sum_{i=0}C_n^{i-1}\\cdot C_m^i=\\sum_{i=0}C_n^{n-i+1}\\cdot C_m^i=C_{n+m}^{n+1}\\)</span>。</p>\n<p>关于怎么记忆范德蒙德卷积，发现上下相加，也可以从组合意义记忆：在 <span class=\"math inline\">\\(n\\)</span> 个球中选出 <span class=\"math inline\">\\(k-i\\)</span> 个球，再从 <span class=\"math inline\">\\(m\\)</span> 个球中选出 <span class=\"math inline\">\\(i\\)</span> 个球的总方案就是从 <span class=\"math inline\">\\(n+m\\)</span> 个球中直接选出 <span class=\"math inline\">\\(k\\)</span> 个球的方案。</p>\n<p>注意判断右侧没有 <code>)</code> 的时候贡献为 <span class=\"math inline\">\\(0\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    std::string s;\n    std::cin &gt;&gt; s;\n    int n = s.length();\n    s = &quot; &quot; + s;\n    std::vector&lt;int&gt; cnt1(n + 1), cnt2(n + 1);\n    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        fac[i] = fac[i - 1] * i % mod;\n        cnt1[i] = cnt1[i - 1] + (s[i] == &#39;(&#39;);\n    &#125;\n    auto qkp = [](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[n] = qkp(fac[n], mod - 2);\n    cnt2[n] = (s[n] == &#39;)&#39;);\n    for (int i = n - 1; i; --i) &#123;\n        cnt2[i] = cnt2[i + 1] + (s[i] == &#39;)&#39;);\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    &#125;\n    long long res = 0ll;\n    auto C = [&amp;](int n, int m) &#123;\n        if (n &lt; m)\n            return 0ll;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    for (int i = 1; i &lt;= n; ++i)\n        if (s[i] == &#39;(&#39;)\n            (res += C(cnt1[i] + cnt2[i] - 1, cnt1[i])) %= mod;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"cf1332e-height-all-the-same\">CF1332E Height All the Same</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1332/E\" class=\"uri\">https://codeforces.com/problemset/problem/1332/E</a></p>\n<p>容易发现第一个操作是用来改变两个数奇偶性的；而第二个操作能在全图奇偶性相同的任何情况下达成要求。</p>\n<p>注意到如果我们想同时仅改变任意两个数的奇偶性，可以在棋盘上任找一条路径一路使用操作一。只要某种奇偶性的元素个数共有偶数个，就能通过若干次操作一把它们全部变成另一种奇偶性。</p>\n<p>令 <span class=\"math inline\">\\(K_1\\)</span> 为 <span class=\"math inline\">\\(L\\sim R\\)</span> 中奇数的个数，<span class=\"math inline\">\\(K_2\\)</span> 为偶数，那么有：</p>\n<p><span class=\"math display\">\\[\nres=\\sum_{i=0}^{nm} C_{nm}^i\\times {K_1}^i\\cdot {K_2}^{nm-i}\\cdot [i\\bmod 2=0]\n\\]</span></p>\n<p>我们发现这个东西和二项式定理简直像得不能再像了！但多了一个系数导致没办法省略枚举过程。如果进行变形呢？</p>\n<p><span class=\"math display\">\\[\nres=(K_1+K_2)^{nm}-\\sum_{i=0}^{nm} C_{nm}^i\\times {K_1}^i\\cdot {K_2}^{nm-i}\\cdot [i\\bmod 2=1]\n\\]</span></p>\n<p>似乎依然没有出路！但这里有个神奇的操作：</p>\n<p><span class=\"math display\">\\[\nres=(-K_1+K_2)^{nm}+\\sum_{i=0}^{nm} C_{nm}^i\\times {K_1}^i\\cdot {K_2}^i\\cdot [i\\bmod 2=1]\n\\]</span></p>\n<p>二式相加就可以<mark>消元</mark>，得到 <span class=\"math inline\">\\(2\\cdot res=(K_1+K_2)^{nm}+(K_1-K_2)^{nm}\\)</span>。<mark>这启示我们二项式定理中的符号和奇偶性的深切联系。</mark></p>\n<details>\n<p>如果你使用费马小定理对次数进行了处理，你可能需要注意次数可能为 <span class=\"math inline\">\\(\\text{mod} -1\\)</span> 的倍数。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nconst int inv2 = 499122177;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    long long n, m, l, r, k1, k2;\n    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; l &gt;&gt; r, k1 = (r - l + 1) / 2, k2 = (r - l + 1) - k1;\n    auto qkp = [](long long x, long long y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    if (n * m % 2)\n        std::cout &lt;&lt; qkp(r - l + 1, n * m) &lt;&lt; &#39;\\n&#39;;\n    else\n        std::cout &lt;&lt; (qkp(r - l + 1, n * m) + qkp((k1 + mod - k2) % mod, n * m)) % mod * inv2 % mod &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"a---交错序列\">A - 交错序列</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P4456\" class=\"uri\">https://www.luogu.com.cn/problem/P4456</a></p>\n<figure>\n<img src=\"2.png\" alt=\"出题人疑似需要加强数学功底（？）\" /><figcaption>出题人疑似需要加强数学功底（？）</figcaption>\n</figure>\n<p>容易想到把答案用二项式定理拆开：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nres&amp;=\\sum_y f_y\\cdot y^b\\cdot (n-y)^a\\\\\n&amp;=\\sum_y f_y\\cdot y^b\\cdot \\sum_{i=0}^a C_a^i\\cdot n^i\\cdot(-y)^{a-i}\\\\\n&amp;=\\sum_y\\sum_{i=0}^a f_y\\cdot C_a^i\\cdot n^i\\cdot(-1)^{a-i}\\cdot y^{a+b-i}\\\\\n&amp;=\\sum_{i=0}^a C_a^i\\cdot n^i\\cdot(-1)^{a-i}\\cdot \\sum_y f_y\\cdot y^{a+b-i}\\\\\n\\end{aligned}\n\\]</span></p>\n<p>然后发现后面那个 sigma 不太有办法求。一个比较优雅的方法是把 <span class=\"math inline\">\\(y^{a+b-i}\\)</span> 直接作为系数而非下标塞到 <span class=\"math inline\">\\(f\\)</span> 里去，即令 <span class=\"math inline\">\\(f_{i}\\)</span> 表示 <span class=\"math inline\">\\(\\forall \\,y\\)</span>，<span class=\"math inline\">\\(\\sum y^i\\)</span> 之和。</p>\n<p>具体地，令 <span class=\"math inline\">\\(dp_{n,i,0/1}\\)</span> 表示当前 DP 到第 <span class=\"math inline\">\\(n\\)</span> 位，要求幂次为 <span class=\"math inline\">\\(i\\)</span>，最后一位为 <span class=\"math inline\">\\(0/1\\)</span> 的答案。则显然有 <span class=\"math inline\">\\(dp_{n,i,0}=dp_{n-1,i,0}+dp_{n-1,i,1}\\)</span>。对于 <span class=\"math inline\">\\(dp_{n,i,1}\\)</span>，因为此时 <span class=\"math inline\">\\(\\forall\\, k,k\\gets k+1\\)</span>，则 <span class=\"math inline\">\\((k+1)^i=\\sum\\limits_{j=0}^i C_i^j \\cdot k^j\\)</span> 即 <span class=\"math inline\">\\(dp_{n,i,1}=\\sum\\limits_{j=0}^i C_i^j\\cdot dp_{n-1,j,0}\\)</span>。发现 <span class=\"math inline\">\\(i,j\\)</span> 的范围是 <span class=\"math inline\">\\(90\\)</span>，很恐怖的事情是这是可以矩阵的。</p>\n<details>\n<p>就像我们都知道的那样，矩阵在加完之后再取模就会快很多……</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint mod;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, a, b;\n    std::cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; mod;\n    std::vector&lt;std::vector&lt;long long&gt; &gt; C(a + b + 1, std::vector&lt;long long&gt;(a + b + 1));\n    for (int i = 0; i &lt;= a + b; ++i) &#123;\n        C[i][0] = 1ll;\n        for (int j = 1; j &lt;= i; ++j)\n            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;\n    &#125;\n    struct mat &#123;\n        int n, m;\n        std::vector&lt;std::vector&lt;long long&gt; &gt; a;\n        mat(int n, int m, bool flag = 0): n(n), m(m), a(n, std::vector&lt;long long&gt; (m)) &#123;\n            if (flag)\n                for (int i = 0; i &lt; n; ++i)\n                    a[i][i] = 1ll;\n            return;\n        &#125;\n        mat operator* (const mat &amp;q) const &#123;\n            mat res(n, q.m);\n            for (int i = 0; i &lt; n; ++i)\n                for (int k = 0; k &lt; q.m; ++k) &#123;\n                    for (int j = 0; j &lt; m; ++j)\n                        res.a[i][k] += a[i][j] * q.a[j][k];\n                    res.a[i][k] %= mod;\n                &#125;\n            return res;\n        &#125;\n        mat operator^ (int q) const &#123;\n            mat res(n, n, 1), x(*this);\n            for (; q; x = x * x, q &gt;&gt;= 1)\n                if (q &amp; 1)\n                    res = res * x;\n            return res;\n        &#125;\n    &#125; f(1, 2 * (a + b + 1)), op(2 * (a + b + 1), 2 * (a + b + 1));\n    auto fun = [&amp;](int i, int j) &#123;\n        return i + j * (a + b + 1);\n    &#125;;\n    f.a[0][fun(0, 0)] = 1ll;\n    for (int i = 0; i &lt;= a + b; ++i)\n        op.a[fun(i, 0)][fun(i, 0)] = op.a[fun(i, 1)][fun(i, 0)] = 1ll;\n    for (int i = 0; i &lt;= a + b; ++i)\n        for (int j = 0; j &lt;= i; ++j)\n            op.a[fun(j, 0)][fun(i, 1)] = C[i][j];\n    f = f * (op ^ n);\n    // for (int i = 0; i &lt;= n; ++i) &#123;\n    //     if (i)\n    //         f = f * op;\n    //     for (int j = 0; j &lt;= a + b; ++j)\n    //         printf(&quot;f[%d][%d] = %lld / %lld\\n&quot;, i, j, f.a[0][fun(j, 0)], f.a[0][fun(j, 1)]);\n    // &#125;\n    auto res = 0ll;\n    for (int i = 0; i &lt;= a; ++i) &#123;\n        static auto p(1ll), k((a % 2) ? mod - 1ll : 1ll);\n        (res += C[a][i] * p % mod * k % mod * (f.a[0][fun(a + b - i, 0)] + f.a[0][fun(a + b - i, 1)]) % mod) %= mod;\n        (p *= n) %= mod, k = mod - k;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---different-subsets-for-all-tuples\">B - Different Subsets For All Tuples</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF660E\" class=\"uri\">https://www.luogu.com.cn/problem/CF660E</a></p>\n<p>首先你可能需要知道，如果已知一个序列，如何得到答案？</p>\n<p>令 <span class=\"math inline\">\\(f_i\\)</span> 表示在 <span class=\"math inline\">\\(i\\)</span> 处取一个子序列的末尾，枚举上一个元素 <span class=\"math inline\">\\(x\\)</span>，找到 <span class=\"math inline\">\\(i\\)</span> 之前最靠后的一个 <span class=\"math inline\">\\(a_j=x\\)</span>，那么有 <span class=\"math inline\">\\(f_i=\\sum f_j\\)</span>，换言之需要保证 <span class=\"math inline\">\\((j,i)\\)</span> 范围内没有 <span class=\"math inline\">\\(x\\)</span> 出现。</p>\n<p>此时序列未知，令 <span class=\"math inline\">\\(f_{i, x}\\)</span> 表示在 <span class=\"math inline\">\\(i\\)</span> 处取一个子序列末尾，且 <span class=\"math inline\">\\(i\\)</span> 的值为 <span class=\"math inline\">\\(x\\)</span>；按照贡献的视角来看待，每个可以和 <span class=\"math inline\">\\(i\\)</span> 组成新子序列的方案可以带来 <span class=\"math inline\">\\(m^{i-1}\\)</span> 的贡献（因为 <span class=\"math inline\">\\(a_i\\)</span> 已经固定为 <span class=\"math inline\">\\(x\\)</span>，其他位置可以任选），那么有 <span class=\"math inline\">\\(f_{i,x}=m^i\\times \\sum_{j&lt;i,y}f_{j,y}\\times (m-1)^{i-j-1}\\)</span>。</p>\n<p>然后就惊讶地发现式子和 <span class=\"math inline\">\\(x\\)</span> 这一维没有关系了。所以直接带上系数得到：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nf_i&amp;=m^i\\times \\sum_{j&lt;i} f_j\\times (m-1)^{i-j-1}\\times m\\\\\n&amp;=m^i\\times (m-1)^{i-1}\\times m\\cdot \\sum_{j&lt;i} f_j\\times (m-1)^{-j}\n\\end{aligned}\n\\]</span></p>\n<p>前缀和优化一下就可以快速求了。最终的答案就是 <span class=\"math inline\">\\(res=m^n+\\sum f_i\\times (m-1)^{n-i}\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    if (m == 1)\n        std::cout &lt;&lt; (n + 1) &lt;&lt; &#39;\\n&#39;;\n    else &#123;\n        std::vector&lt;long long&gt; f(n + 1), s(n + 1), pm1(n + 1);\n        pm1[0] = 1ll;\n        for (int i = 1; i &lt;= n; ++i)\n            pm1[i] = pm1[i - 1] * (m - 1) % mod;\n        auto qkp = [](long long x, int y) &#123;\n            auto res(1ll);\n            for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n                if (y &amp; 1)\n                    (res *= x) %= mod;\n            return res;\n        &#125;;\n        auto res(qkp(m, n));\n        const auto invm = qkp(m - 1, mod - 2);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            static long long p(m), inv(invm);\n            f[i] = (p + pm1[i - 1] * m % mod * s[i - 1] % mod) % mod;\n            s[i] = (s[i - 1] + f[i] * inv % mod) % mod;\n            (res += f[i] * pm1[n - i] % mod) %= mod;\n            (p *= m) %= mod, (inv *= invm) %= mod;\n        &#125;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;; \n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"g---gardens\">G - Gardens</h2>\n<p><a href=\"https://atcoder.jp/contests/abc235/tasks/abc235_g\" class=\"uri\">https://atcoder.jp/contests/abc235/tasks/abc235_g</a></p>\n<p>如果没有『每个人必须有一个元素』这个限制，就可以随便做了。现在加上了这个限制，很容易想到用没得到的人来容斥。钦定至少有 <span class=\"math inline\">\\(i\\)</span> 个人没拿到，得到答案为 <span class=\"math inline\">\\(\\sum\\limits_{i=0}^n (-1)^i\\cdot C_n^i\\cdot \\left(\\sum\\limits_{j=0}^a C_i^j\\right)\\cdot \\left(\\sum\\limits_{j=0}^b C_i^j\\right)\\cdot \\left(\\sum\\limits_{j=0}^c C_i^j\\right)\\)</span>。</p>\n<p>怎么算 <span class=\"math inline\">\\(\\sum\\limits_{j=0}^a C_i^j\\)</span> 呢？当 <span class=\"math inline\">\\(a&gt; i\\)</span> 时，二项式是好求的；当 <span class=\"math inline\">\\(a\\le i\\)</span> 时呢？看到这个式子很容易带到杨辉三角里去，也就是求一行的前 <span class=\"math inline\">\\(a\\)</span> 个数。注意到可以用上一行的前 <span class=\"math inline\">\\(a\\)</span> 个数 <span class=\"math inline\">\\(O(1)\\)</span> 得到（假设第 <span class=\"math inline\">\\(j-1\\)</span> 行前 <span class=\"math inline\">\\(a\\)</span> 个数之和为 <span class=\"math inline\">\\(f_a(j-1)\\)</span>）：<span class=\"math inline\">\\(f_a(j)=f_a(j-1)\\times 2-C_{j-1,a}\\)</span>。<mark>你需要意识到，由于上一行也是答案中要求的，所以可以使用递推解决问题。<strong>在组合计数中，递推 / DP 无论是在化简式子还是求容斥 / 二项式反演里具体某一限制下的方案数都是很有用的，在需要优化复杂度时，可以从递推 / DP、恒等式、前缀和、预处理等方法入手考虑</strong></mark>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, a, b, c;\n    std::cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1), fa(n + 1), fb(n + 1), fc(n + 1), pow2(n + 1);\n    fac[0] = inv[0] = pow2[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        fac[i] = fac[i - 1] * i % mod;\n        pow2[i] = pow2[i - 1] * 2 % mod;\n    &#125;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[n] = qkp(fac[n], mod - 2);\n    for (int i = n - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    for (int i = 0; i &lt;= a; ++i)\n        (fa[a] += C(a, i)) %= mod;\n    for (int i = a + 1; i &lt;= n; ++i)\n        fa[i] = (2 * fa[i - 1] % mod + mod - C(i - 1, a)) % mod;\n    for (int i = 0; i &lt;= b; ++i)\n        (fb[b] += C(b, i)) %= mod;\n    for (int i = b + 1; i &lt;= n; ++i)\n        fb[i] = (2 * fb[i - 1] % mod + mod - C(i - 1, b)) % mod;\n    for (int i = 0; i &lt;= c; ++i)\n        (fc[c] += C(c, i)) %= mod;\n    for (int i = c + 1; i &lt;= n; ++i)\n        fc[i] = (2 * fc[i - 1] % mod + mod - C(i - 1, c)) % mod;\n    auto res(0ll);\n    for (int i = n, p = 1; ~i; --i, p = mod - p)\n        (res += p * C(n, i) % mod * (i &gt;= a ? fa[i] : pow2[i]) % mod * (i &gt;= b ? fb[i] : pow2[i]) % mod * (i &gt;= c ? fc[i] : pow2[i]) % mod) %= mod;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "排列组合",
                "容斥原理",
                "数学",
                "二项式定理",
                "二项式反演"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250404/",
            "url": "https://xsc062.netlify.app/20250404/",
            "title": "杂题选谈",
            "date_published": "2025-04-04T07:31:09.000Z",
            "content_html": "<p>NOI Linux 2.0，拼尽全力无法战胜。</p>\n<span id=\"more\"></span>\n<p>比方说我试图对我一片狼藉的屏幕进行一个图的截，但是我并不知道 where the so-called <code>$PICTURE</code> is <img src=\"/em/kt.gif\" /></p>\n<hr />\n<p>这场有两个题都用到了 <mark>优先队列</mark> + <mark>最优答案扩展</mark> 的思路，可以记录一下。</p>\n<hr />\n<h2 id=\"a.-序列加法机\">A. 序列加法机</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6174/problem/1\" class=\"uri\">http://222.180.160.110:61235/contest/6174/problem/1</a></p>\n<p>转化题意可以发现，三个不下降的限制拼起来其实就是没有限制。若令 <span class=\"math inline\">\\(c_i=|a_i-b_i|\\)</span>，则题意转化如下：</p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(c_{1\\sim n}\\)</span>，定义一次操作为：</p>\n<ul>\n<li>选择一个 <span class=\"math inline\">\\(x&gt;0\\)</span>，再选择 <span class=\"math inline\">\\(c_i\\ge x\\)</span>，令 <span class=\"math inline\">\\(c_i\\gets c_i-x\\)</span>，并花费 <span class=\"math inline\">\\(x^2\\)</span> 的代价。</li>\n</ul>\n<p>现可进行不超过 <span class=\"math inline\">\\(m\\)</span> 次操作，问将 <span class=\"math inline\">\\(c_i\\)</span> 全部置为 <span class=\"math inline\">\\(0\\)</span> 的最小代价。</p>\n</blockquote>\n<p>有一个比较显然的事情，如果给 <span class=\"math inline\">\\(c_i\\)</span> 分配 <span class=\"math inline\">\\(k\\)</span> 次操作机会，那么每次减去 <span class=\"math inline\">\\(\\dfrac {c_i}k\\)</span> 是最优的。具体地，令 <span class=\"math inline\">\\(p=\\left\\lfloor\\dfrac {c_i}k\\right\\rfloor\\)</span>，那么给 <span class=\"math inline\">\\(k\\)</span> 个中的 <span class=\"math inline\">\\(c_i\\bmod k\\)</span> 分配 <span class=\"math inline\">\\(p+1\\)</span>，给剩余的 <span class=\"math inline\">\\(k-c_i\\bmod k\\)</span> 分配 <span class=\"math inline\">\\(p\\)</span> 即可。这个随便用反证什么的证一下即可。</p>\n<p>但是我们怎么知道应该给每个 <span class=\"math inline\">\\(c_i\\)</span> 分配多少次操作次数呢？这里有个 trick：初始先给每个 <span class=\"math inline\">\\(c_i\\)</span> 分配一次次数，<mark>对于每个 <span class=\"math inline\">\\(c_i\\)</span>，记录给其多分配一次后能减少的代价，全部丢进优先队列里，将最优的拿出来之后，记录再给其多分配一次后能减少的代价，再丢进去</mark>。能这样做的根本原因在于：</p>\n<ol type=\"1\">\n<li>每个元素的每一次扩展代价相同。</li>\n<li>对于同一个元素，丢到优先队列里的值是递减的（即无后效性，可以贪心）。</li>\n</ol>\n<details>\n<p>有人对着对的代码调了半个小时，是谁呢 <img src=\"/em/kt.gif\" /></p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;seq.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;seq.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;ex_seq2.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;long long&gt; c(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; c[i];\n    struct _ &#123;\n        int k;\n        long long org, d;\n        bool operator&lt; (const _ &amp;q) const &#123;\n            return d &lt; q.d; \n        &#125;\n    &#125;;\n    std::priority_queue&lt;_&gt; q;\n    long long res = 0ll;\n    auto calc = [&amp;](long long x, int k) &#123;\n        auto p = x / k;\n        return (x % k) * (p + 1) * (p + 1) + (k - x % k) * p * p;\n    &#125;;\n    for (int i = 1, x; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; x;\n        c[i] = std::abs(c[i] - x);\n        if (c[i]) &#123;\n            (res += calc(c[i], 1) % mod) %= mod;\n            q.push(&#123; 2, c[i], calc(c[i], 1) - calc(c[i], 2) &#125;);\n        &#125;\n    &#125;\n    // printf(&quot;res = %lld\\n&quot;, res);\n    if ((int)q.size() &gt; m)\n        std::cout &lt;&lt; -1 &lt;&lt; &#39;\\n&#39;;\n    else &#123;\n        m -= (int)q.size();\n        for (; m--; ) &#123;\n            auto [k, org, d] = q.top();\n            q.pop();\n            // printf(&quot;org = %lld, k = %d, d = %lld\\n&quot;, org, k, d);\n            (res += mod - d % mod) %= mod;\n            q.push(&#123; k + 1, org, calc(org, k) - calc(org, k + 1) &#125;);\n        &#125;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b.-摸鱼军训\">B. 摸鱼军训</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6174/problem/2\" class=\"uri\">http://222.180.160.110:61235/contest/6174/problem/2</a></p>\n<blockquote>\n<p>定义一次冒泡排序为：</p>\n<pre class=\"cpp\"><code>for (int i = 1; i &lt; n; ++i)\n    if (a[i] &gt; a[i + 1])\n        std::swap(a[i], a[i + 1]);</code></pre>\n<p>现给定一个排列和 <span class=\"math inline\">\\(m\\)</span> 次询问，问第 <span class=\"math inline\">\\(k\\)</span> 轮冒泡排序后元素 <span class=\"math inline\">\\(x\\)</span> 的位置。</p>\n</blockquote>\n<p>发现一个元素移动的原因有两种：</p>\n<ol type=\"1\">\n<li>前面有个比它大的元素「冒泡」到它后面去了，本轮该元素向前移动恰好一步。</li>\n<li>前面没有比它更大的元素，轮到它来向后面「冒泡」了。找到具体的位置是不容易的，但我们发现每次 <span class=\"math inline\">\\(i\\)</span> 向右移动一步，都一定会有一个比 <span class=\"math inline\">\\(i\\)</span> 更小的元素被它交换到 <span class=\"math inline\">\\(i\\)</span> 左边。找到有多少个在 <span class=\"math inline\">\\(i\\)</span> 右边且比 <span class=\"math inline\">\\(i\\)</span> 小的元素到了 <span class=\"math inline\">\\(i\\)</span> 左边就可以得到这一种情况下 <span class=\"math inline\">\\(i\\)</span> 的位置。</li>\n</ol>\n<p>容易发现，只要前面存在比它大的元素，那么第一条始终成立。树状数组统计 <span class=\"math inline\">\\(f_i\\)</span> 为元素 <span class=\"math inline\">\\(i\\)</span> 前比它大的元素个数，对于询问 <span class=\"math inline\">\\((k,i)\\)</span>，若 <span class=\"math inline\">\\(k\\le f_i\\)</span>，那么答案即为 <span class=\"math inline\">\\(pos_i-k\\)</span>。</p>\n<p>第 <span class=\"math inline\">\\(f_i+1\\)</span> 轮，<span class=\"math inline\">\\(i\\)</span> 向后「冒泡」，碰到一个比它更大的元素 <span class=\"math inline\">\\(j\\)</span> 即停止，此时 <span class=\"math inline\">\\(j\\)</span> 接替 <span class=\"math inline\">\\(i\\)</span> 向后「冒泡」，直到碰到一个 <span class=\"math inline\">\\(j&#39;&gt;j\\)</span> 为止，以此类推。</p>\n<p>如何将 <span class=\"math inline\">\\(k\\)</span> 轮后 <span class=\"math inline\">\\(i\\)</span> 停下的位置对应到原数组上呢？我们发现每一轮 <span class=\"math inline\">\\(i\\)</span> 跨越的元素一定是比 <span class=\"math inline\">\\(i\\)</span> 小的可空极长段，手玩可以发现段的数量不会因为 <span class=\"math inline\">\\(i\\)</span> 之后任何元素的移动而改变，故找到 <span class=\"math inline\">\\(i\\)</span> 后第 <span class=\"math inline\">\\(k\\)</span> 个比 <span class=\"math inline\">\\(i\\)</span> 大的元素，中间比 <span class=\"math inline\">\\(i\\)</span> 小的元素个数就是 <span class=\"math inline\">\\(i\\)</span> 的右移步数。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;bubble.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;bubble.out&quot;, &quot;w&quot;, stdout);\n    int n, m;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1), bit(n + 1), p(n + 1), f(n + 1), bit1(n + 1);\n    auto lowbit = [&amp;](int x) &#123;\n        return x &amp; -x;\n    &#125;;\n    auto add = [&amp;](std::vector&lt;int&gt; &amp;bit, int x, int v) &#123;\n        for (; x &lt;= n; x += lowbit(x))\n            bit[x] += v;\n        return;\n    &#125;;\n    auto qry = [&amp;](std::vector&lt;int&gt; &amp;bit, int x) &#123;\n        int res = 0;\n        for (; x; x -= lowbit(x))\n            res += bit[x];\n        return res;\n    &#125;;\n    auto ask = [&amp;](std::vector&lt;int&gt; &amp;bit, int l, int r) &#123;\n        if (l &gt; n || r &lt; 1)\n            return 0;\n        return qry(bit, r) - qry(bit, l - 1);\n    &#125;;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i], p[a[i]] = i;\n        f[a[i]] = ask(bit, a[i] + 1, n), add(bit, a[i], 1);\n    &#125;\n    struct _ &#123; int k, id; &#125;;\n    std::vector&lt;std::vector&lt;_&gt; &gt; t(n + 1);\n    std::cin &gt;&gt; m;\n    std::vector&lt;int&gt; res(m + 1);\n    for (int i = 1, x, k; i &lt;= m; ++i) &#123;\n        std::cin &gt;&gt; k &gt;&gt; x;\n        t[x].push_back(&#123; k, i &#125;);\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        add(bit, p[i], -1);\n        for (auto [k, id] : t[i])\n            if (k &lt;= f[i])\n                res[id] = p[i] - k;\n            else &#123;\n                int now = n;\n                for (int l = p[i] + 1, r = n, mid; l &lt;= r; ) &#123;\n                    mid = (l + r) &gt;&gt; 1;\n                    if (ask(bit, p[i] + 1, mid) &gt;= k - f[i])\n                        r = mid - 1, now = mid;\n                    else\n                        l = mid + 1;\n                &#125;\n                // printf(&quot;%d: now = %d\\n&quot;, i, now);\n                res[id] = p[i] - f[i] + ask(bit1, p[i] + 1, now);\n            &#125;\n        add(bit1, p[i], 1);\n    &#125;\n    for (int i = 1; i &lt;= m; ++i)\n        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c0.-超级钢琴\">C0. 超级钢琴</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P2048\" class=\"uri\">https://www.luogu.com.cn/problem/P2048</a></p>\n<p>首先做前缀和，容易想到枚举右端点，那么左端点就是一段连续的区间。显然在这里最优选择是选择左端点中 <span class=\"math inline\">\\(s\\)</span> 最小的一个。</p>\n<p>怎么求前 <span class=\"math inline\">\\(k\\)</span> 大呢？这里有一个很固定的 trick：把每个右端点及其对应的左端点区间丢到优先队列里，按照最优解（用 ST 表找一下即可）从优到劣排序。</p>\n<p><mark>每次取出最优解 <span class=\"math inline\">\\([l_1, l_2], r\\)</span>，假设最优决策为 <span class=\"math inline\">\\(x\\in [l_1, l_2]\\)</span>，那么把 <span class=\"math inline\">\\([l_1, x), r\\)</span> 和 <span class=\"math inline\">\\((x, l_2], r\\)</span> 分别丢到优先队列里去</mark>。这个做法成立的根本原因也是：</p>\n<ol type=\"1\">\n<li>任何一个元素都可以贡献一次答案。</li>\n<li>对于同一个 <span class=\"math inline\">\\(r\\)</span>，随着拆分次数的增加，最优解逐渐变劣（无后效性，可贪心）。</li>\n</ol>\n<details>\n<pre class=\"cpp language-cpp\" data-line=\"17\"><code class=\"cpp langauage-cpp\">#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(\".in\", \"r\", stdin);\n    std::freopen(\".out\", \"w\", stdout);\n#endif\n    int n, k, l, r;\n    std::cin >> n >> k >> l >> r;\n    std::vector&lt;long long> a(n + 1);\n    std::vector&lt;std::vector&lt;long long> > st(21, std::vector&lt;long long> (n + 1));\n    for (int i = 1; i <= n; ++i)\n        std::cin >> a[i], st[0][i] = i;\n    std::partial_sum(a.begin() + 1, a.end(), a.begin() + 1);\n    for (int j = 1; (1 << j) <= n + 1; ++j) // 一个优秀的笑话是，你的 ST 表需要从 0 开始。而长度自然也应该为 n + 1。\n        for (int i = 0; i + (1 << j) - 1 <= n; ++i)\n            st[j][i] = (a[st[j - 1][i]] <= a[st[j - 1][i + (1 << (j - 1))]] ? st[j - 1][i] : st[j - 1][i + (1 << (j - 1))]);\n    auto ask = [&](int l, int r) &#123;\n        int k = std::__lg(r - l + 1);\n        return a[st[k][l]] <= a[st[k][r - (1 << k) + 1]] ? st[k][l] : st[k][r - (1 << k) + 1];\n    &#125;;\n    struct _ &#123;\n        int l1, l2, r, x;\n        long long v;\n        bool operator< (const _ &q) const &#123;\n            return v < q.v;\n        &#125;\n    &#125;;\n    std::priority_queue<_> q;\n    for (int i = l; i <= n; ++i) &#123;\n        _ t;\n        t.l1 = std::max(i - r, 0), t.l2 = i - l, t.r = i, t.x = ask(t.l1, t.l2), t.v = a[i] - a[t.x];\n        q.push(t);\n    &#125;\n    long long res = 0ll;\n    for (int to; k--; ) &#123;\n        auto [l1, l2, r, x, v] = q.top();\n        q.pop();\n        res += v;\n        if (x != l1) &#123;\n            to = ask(l1, x - 1);\n            q.push(&#123; l1, x - 1, r, to, a[r] - a[to] &#125;);\n        &#125;\n        if (x != l2) &#123;\n            to = ask(x + 1, l2);\n            q.push(&#123; x + 1, l2, r, to, a[r] - a[to] &#125;);\n        &#125;\n    &#125;\n    std::cout << res << '\\n';\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c1.-皮卡丘\">C1. 皮卡丘</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6174/problem/3\" class=\"uri\">http://222.180.160.110:61235/contest/6174/problem/3</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(a_{1\\sim n}\\)</span> 和 <span class=\"math inline\">\\(m\\)</span> 个询问，每次问 <span class=\"math inline\">\\([l, r]\\)</span> 中前 <span class=\"math inline\">\\(k\\)</span> 大 <span class=\"math inline\">\\(a_l-a_r\\)</span> 的和。<span class=\"math inline\">\\(\\sum k\\le 3\\times 10^5\\)</span>。</p>\n</blockquote>\n<p>我们发现不能直接按照上一题的方法来做——每次询问都把 <span class=\"math inline\">\\(len\\)</span> 个元素丢进优先队列是不现实的。但我们似乎忽略了什么——这次的初始最优解是否可以直接在 <span class=\"math inline\">\\([l,r]\\)</span> 上全局求解？</p>\n<p>区间修改操作就是在明示线段树。显然我们可以差分过后线段树上求解最大子段和——不差分也可以照样维护答案，方法差不多。假设现在求得的最优解为 <span class=\"math inline\">\\((x, y)\\)</span>。</p>\n<p>但此时我们没有一个端点是固定的！应该怎样拆分呢？这里又要用到另一个经典的 trick——抽象一个矩阵 <span class=\"math inline\">\\(b_{i,j}=a_i-a_j\\)</span>，那么对于一次询问，可用的 <span class=\"math inline\">\\(b\\)</span> 构成一个三角形：</p>\n<p><img src=\"1.png\" /></p>\n<p>这里需要注意一个点，我们之所以可以通过最大子段和求得最优解是因为矩阵的行号范围和列号范围是一致的（记为情况 1）。除此之外，除了行号和列号完全相离（即 <span class=\"math inline\">\\(l_2&lt;r_1\\)</span>，记为情况 2） 时可以直接用 <span class=\"math inline\">\\(l_{\\max}-r_{\\min}\\)</span> 求解，其他情况都无法简单得到答案。</p>\n<p>也就是说，我们的拆分方式要尽可能地贴近上面两种可求解的情况。幸运地是，直觉地划分可以比较轻松地在初始状态下得到一种可能的方式：</p>\n<p><img src=\"2.png\" /></p>\n<p>容易注意到初始状态属于情况 1，可以按照图所示，按照行号与 <span class=\"math inline\">\\(x\\)</span> 的大小关系分类，得到：</p>\n<ol type=\"1\">\n<li>行 <span class=\"math inline\">\\(&lt;x\\)</span>，列 <span class=\"math inline\">\\(&lt;x\\)</span>；</li>\n<li>行 <span class=\"math inline\">\\(&lt;x\\)</span>，列 <span class=\"math inline\">\\(\\ge x\\)</span>；</li>\n<li>行 <span class=\"math inline\">\\(=x\\)</span>，列 <span class=\"math inline\">\\(=x\\)</span>；</li>\n<li>行 <span class=\"math inline\">\\(=x\\)</span>，列 <span class=\"math inline\">\\(\\in (x,y)\\)</span>；</li>\n<li>行 <span class=\"math inline\">\\(=x\\)</span>，列 <span class=\"math inline\">\\(&gt;y\\)</span>；</li>\n<li>行 <span class=\"math inline\">\\(&gt;x\\)</span>，列 <span class=\"math inline\">\\(&gt;x\\)</span>。</li>\n</ol>\n<p>几个 part。</p>\n<p>如果我们要对情况 2 进行划分呢？这也是轻松的，假设当前图形满足行： <span class=\"math inline\">\\([l_1, l_2]\\)</span>，列：<span class=\"math inline\">\\([r_1, r_2]\\)</span>（显然这是个完整的矩形），且最优解 <span class=\"math inline\">\\((x, y)\\)</span>。容易发现任意行、列一定相离，故根据 <span class=\"math inline\">\\((x, y)\\)</span> 划分即可：</p>\n<p><img src=\"3.png\" /></p>\n<p>也即以下几个 part：</p>\n<ol type=\"1\">\n<li>行 <span class=\"math inline\">\\(&lt;x\\)</span>；</li>\n<li>行 <span class=\"math inline\">\\(=x\\)</span>，列 <span class=\"math inline\">\\(&lt;y\\)</span>；</li>\n<li>行 <span class=\"math inline\">\\(=x\\)</span>，列 <span class=\"math inline\">\\(&gt;y\\)</span>；</li>\n<li>行 <span class=\"math inline\">\\(&gt;x\\)</span>。</li>\n</ol>\n<p>复杂度 <span class=\"math inline\">\\(O(\\sum k\\log)\\)</span>。注意到线段树的 <span class=\"math inline\">\\(\\log\\)</span> 和优先队列的 <span class=\"math inline\">\\(\\log\\)</span> 并不会叠起来。</p>\n<details>\n<p>意外的很难写 <img src=\"/em/qd.gif\" /></p>\n<p>主要是线段树写起来有点答辩了 <img src=\"/em/kt.gif\" /></p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e5 + 5;\nstruct __ &#123;\n    int l, r;\n    int i0, i1, s0, s1;\n    long long u, d, u0, u1;\n    __ operator+ (const __ &amp;q) const &#123;\n        __ res;\n        res.l = l, res.r = q.r, res.d = 0ll;\n        res.u = std::max(&#123; u, q.u, u1 - q.u0 &#125;);\n        if (res.u == u)\n            res.s0 = s0, res.s1 = s1;\n        else if (res.u == q.u)\n            res.s0 = q.s0, res.s1 = q.s1;\n        else\n            res.s1 = i1, res.s0 = q.i0;\n        if (u0 &lt; q.u0)\n            res.u0 = u0, res.i0 = i0;\n        else\n            res.u0 = q.u0, res.i0 = q.i0;\n        if (u1 &gt; q.u1)\n            res.u1 = u1, res.i1 = i1;\n        else\n            res.u1 = q.u1, res.i1 = q.i1;\n        return res;\n    &#125;\n&#125; t[maxn &lt;&lt; 2];\nlong long a[maxn];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid pushdown(int p) &#123;\n    if (t[p].d) &#123;\n        t[lt].d += t[p].d, t[rt].d += t[p].d;\n        t[lt].u0 += t[p].d, t[lt].u1 += t[p].d;\n        t[rt].u0 += t[p].d, t[rt].u1 += t[p].d;\n        t[p].d = 0;\n    &#125;\n    return;\n&#125;\nvoid pushup(int p) &#123;\n    t[p] = t[lt] + t[rt];\n    return;\n&#125;\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        t[p].i0 = t[p].i1 = t[p].s0 = t[p].s1 = l;\n        t[p].u0 = t[p].u1 = a[l];\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    pushup(p);\n    return;\n&#125;\nvoid add(int p, int l, int r, long long v) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        t[p].u0 += v, t[p].u1 += v, t[p].d += v;\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid)\n        add(lt, l, r, v);\n    if (r &gt; mid)\n        add(rt, l, r, v);\n    pushup(p);\n    return;\n&#125;\nauto ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p];\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (r &lt;= mid)\n        return ask(lt, l, r);\n    if (l &gt; mid)\n        return ask(rt, l, r);\n    return ask(lt, l, r) + ask(rt, l, r);\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;pi.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;pi.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;ex_pi2.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    bld(1, 1, n);\n    for (int op; m--; ) &#123;\n        std::cin &gt;&gt; op;\n        if (op == 1) &#123;\n            int l, r, x;\n            std::cin &gt;&gt; l &gt;&gt; r &gt;&gt; x;\n            add(1, l, r, x);\n        &#125;\n        else &#123;\n            int l, r, k;\n            std::cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;\n            struct _ &#123;\n                int ty, l1, l2, r1, r2, x, y;\n                long long v;\n                bool operator&lt; (const _ &amp;q) const &#123;\n                    return v &lt; q.v;\n                &#125;\n            &#125;;\n            long long res = 0ll;\n            std::priority_queue&lt;_&gt; q;\n            auto calc = [&amp;](int ty, int l1, int l2, int r1, int r2) &#123;\n                if (l1 &lt;= l2 &amp;&amp; r1 &lt;= r2) &#123;\n                    if (ty == 1) &#123;\n                        auto ts(ask(1, l1, l2));\n                        q.push(&#123; 1, l1, l2, r1, r2, ts.s1, ts.s0, ts.u &#125;);\n                    &#125;\n                    else &#123;\n                        auto ls(ask(1, l1, l2)), rs(ask(1, r1, r2));\n                        q.push(&#123; 2, l1, l2, r1, r2, ls.i1, rs.i0, ls.u1 - rs.u0 &#125;);\n                    &#125;\n                &#125;\n                return;\n            &#125;;\n            calc(1, l, r, l, r);\n            for (; k--; ) &#123;\n                auto [ty, l1, l2, r1, r2, x, y, v] = q.top();\n                res += v;\n                q.pop();\n                if (ty == 1) &#123;\n                    calc(1, l1, x - 1, r1, x - 1);\n                    calc(2, l1, x - 1, x, r2);\n                    if (x != y)\n                        calc(1, x, x, x, x);\n                    calc(2, x, x, x + 1, y - 1);\n                    calc(2, x, x, y + 1, r2);\n                    calc(1, x + 1, l2, x + 1, r2);\n                &#125;\n                else &#123;\n                    calc(2, l1, x - 1, r1, r2);\n                    calc(2, x, x, r1, y - 1);\n                    calc(2, x, x, y + 1, r2);\n                    calc(2, x + 1, l2, r1, r2);\n                &#125;\n            &#125;\n            std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n        &#125;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d.-银行的崛起\">D. 银行的崛起</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6174/problem/4\" class=\"uri\">http://222.180.160.110:61235/contest/6174/problem/4</a></p>\n<p>原题：<a href=\"https://www.codechef.com/problems/CTREE?tab=statement\">CodeChef CTREE - Chef and Chefcoin</a>。</p>\n<p>假设只需要一个关键点，那么容易想到换根 DP 的做法。但仅凭这个比较 naive 的思路是无法靠近正解的。找题解的时候看到一个惊为天人的式子：<mark><span class=\"math inline\">\\(res=\\sum\\limits_{(u, v): w} f(v)=w\\cdot \\min(s_v,n-s_v)\\)</span>，其中 <span class=\"math inline\">\\(s_v\\)</span> 表示 <span class=\"math inline\">\\(v\\)</span> 的 size</mark>。</p>\n<p>乍一看是在讨论关键点要选在 <span class=\"math inline\">\\(v\\)</span> 外部还是内部，但是 <span class=\"math inline\">\\(\\min\\)</span> 的含义很奇怪——假如有多个点都觉得应该往自己内部走呢？考虑如下普适场景：</p>\n<p><img src=\"4.png\" /></p>\n<p>假如 <span class=\"math inline\">\\(a\\)</span> 和 <span class=\"math inline\">\\(c\\)</span> 都觉得应该往自己内部走，就会有 <span class=\"math inline\">\\(\\begin{cases}a&gt;b+c\\\\c&gt;a+b\\end{cases}\\Rightarrow 0&gt;2\\times b\\)</span>，由此就反证了。</p>\n<p>那么显然 <span class=\"math inline\">\\(f(v)=w\\cdot s_v\\iff s_v\\le \\dfrac n2\\)</span>，转化成带权重心问题，可以 <span class=\"math inline\">\\(O(n)\\)</span> 一次 DFS 解决。那扩展到两个呢？手玩发现存在一条边作为两个选择倾向的点的分界，不会被任何一方经过（显然），枚举这条分割线切断就可以得到两个子树；在子树上分别作一次一个关键点的做法，加起来就是这条边的答案。</p>\n<p>显然这是 <span class=\"math inline\">\\(O(n^2)\\)</span> 的，需要优化。能够感受到枚举边的过程不太能被优化，考虑优化求解上面式子的过程。容易想到换根，记 <span class=\"math inline\">\\(s&#39;\\)</span> 为当前版本时刻变化的 size，<span class=\"math inline\">\\(s\\)</span> 为初始值，那么有：</p>\n<ul>\n<li><span class=\"math inline\">\\(u\\)</span> 侧，对于 <span class=\"math inline\">\\(u\\)</span> 的所有祖先 <span class=\"math inline\">\\(\\{fa\\}\\)</span>，<span class=\"math inline\">\\(s&#39;_{fa}=s_{fa}-s_v\\)</span>，<span class=\"math inline\">\\(n&#39;=n-s_v\\)</span>。</li>\n<li><span class=\"math inline\">\\(v\\)</span> 侧，所有点 <span class=\"math inline\">\\(\\{son\\}\\)</span> 有 <span class=\"math inline\">\\(s&#39;_{son}=s_{son}\\)</span>，<span class=\"math inline\">\\(n&#39;=s_v\\)</span>。</li>\n</ul>\n<p>我们需要维护所有 <span class=\"math inline\">\\(s&#39;\\)</span> 和 <span class=\"math inline\">\\(\\dfrac {n&#39;}2\\)</span> 的大小关系——发现这是一个类似二维偏序的问题，即求：</p>\n<ol type=\"1\">\n<li>DFN 在 <span class=\"math inline\">\\(v\\)</span> 子树范围内，且 <span class=\"math inline\">\\(s\\le \\dfrac {s_v}2\\)</span> 的权值。</li>\n<li>DFN 在 <span class=\"math inline\">\\(v\\)</span> 之前 / 之后，且 <span class=\"math inline\">\\(s\\le \\dfrac {n-s_v}2\\)</span> 的权值。</li>\n</ol>\n<p>记录询问的 DFN 区间，离线（？）下来按照 <span class=\"math inline\">\\(n&#39;\\)</span> 排序，随便用个 DFN 上的 DS 统计一下即可。但 <span class=\"math inline\">\\(u\\)</span> 侧的 <span class=\"math inline\">\\(s&#39;_{fa}\\)</span> 会发生变化，没办法离线处理，考虑<mark>费用提前计算消除误差——找到比 <span class=\"math inline\">\\(\\dfrac {n-s_v}2\\)</span> 大，但减去 <span class=\"math inline\">\\(s_v\\)</span> 后比之小的 <span class=\"math inline\">\\(fa\\)</span> 提前处理</mark>。</p>\n<p><mark>发现由于 <span class=\"math inline\">\\(s\\)</span> 随着 <span class=\"math inline\">\\(fa\\)</span> 往上是单调递增的，满足这个条件的 <span class=\"math inline\">\\(fa\\)</span> 是连续的。</mark>用树上倍增框出上下端点 <span class=\"math inline\">\\((fa_p\\to fa_q]\\)</span> 进行费用提前计算。那么就可以 <span class=\"math inline\">\\(O(n\\log)\\)</span> 的解决问题了。</p>\n<details>\n<p><summary>具体地，如何提前计算？</summary></p>\n<p>记 <span class=\"math inline\">\\(diw_x\\)</span> 为从 <span class=\"math inline\">\\(1\\)</span> 到 <span class=\"math inline\">\\(x\\)</span> 的路径上所有点 <span class=\"math inline\">\\(s\\cdot w\\)</span> 之和。</p>\n<p>那么有：</p>\n<table>\n<colgroup>\n<col style=\"width: 25%\" />\n<col style=\"width: 25%\" />\n<col style=\"width: 25%\" />\n<col style=\"width: 25%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th style=\"text-align: center;\">项</th>\n<th style=\"text-align: center;\">真实值</th>\n<th style=\"text-align: center;\">计算值</th>\n<th style=\"text-align: center;\"><span class=\"math inline\">\\(\\sum\\Delta\\)</span></th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(x\\notin\\{fa\\}\\land x\\notin\\{son\\}\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(w_x\\cdot \\min(s_x,n&#39;-s_x)\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(w_x\\cdot \\min(s_x,n&#39;-s_x)\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(0\\)</span></td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(x\\in[1\\to fa_p]\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(w_x\\cdot (s_x - s_v)\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(w_x\\cdot s_x\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(-dis_p\\times s_v\\)</span></td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(x\\in (fa_p\\to fa_q]\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(w_x\\cdot (n-s_x)\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(w_x\\cdot s_x\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(n\\times(dis_q-dis_p)-2\\times (diw_q - diw_p)\\)</span></td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(x\\in(fa_q,v)\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(w_x\\cdot (n-s_x)\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(w_x\\cdot (n-s_x-s_v)\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(s_v\\cdot (dis_u-dis_q)\\)</span></td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(x\\in \\{son\\}\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(w_x\\cdot \\min(s_x,n&#39;-s_x)\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(w_x\\cdot \\min(s_x,n&#39;-s_x)\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(0\\)</span></td>\n</tr>\n</tbody>\n</table>\n<p>即需将答案 <strong>减去</strong> <span class=\"math inline\">\\(n\\times(dis_q-dis_p)-2\\times (diw_q - diw_p)+s_v\\cdot (dis_u-dis_q-dis_p)\\)</span>。</p>\n</details>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#ifdef ONLINE_JUDGE\n    std::freopen(&quot;banking.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;banking.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n;\n        std::cin &gt;&gt; n;\n        std::vector&lt;long long&gt; a(n + 1);\n        long long sw = 0ll;\n        for (int i = 1; i &lt;= n; ++i)\n            std::cin &gt;&gt; a[i], sw += a[i];\n        std::vector&lt;std::vector&lt;std::pair&lt;int, long long&gt; &gt; &gt; g(n + 1);\n        for (int i = 1, x, y, w; i &lt; n; ++i) &#123;\n            std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;\n            g[x].emplace_back(y, w), g[y].emplace_back(x, w);\n        &#125;\n        struct _ &#123; int l, r, id; long long v; &#125;;\n        int now = 0;\n        std::vector&lt;_&gt; q;\n        std::vector&lt;int&gt; dfn(n + 1), rfn(n + 1);\n        std::vector&lt;std::vector&lt;int&gt; &gt; f(n + 1, std::vector&lt;int&gt; (21));\n        std::vector&lt;long long&gt; dis(n + 1), diw(n + 1), w(n + 1), res(n + 1), s(n + 1);\n        std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123; // 前置工作\n            dfn[x] = ++now, s[x] = a[x];\n            for (auto [i, tw] : g[x])\n                if (i != fa) &#123;\n                    w[i] = tw;\n                    f[i][0] = x;\n                    for (int j = 1; j &lt;= 20; ++j)\n                        f[i][j] = f[f[i][j - 1]][j - 1];\n                    DFS(i, x);\n                    s[x] += s[i];\n                &#125;\n            rfn[x] = now;\n            return;\n        &#125;;\n        DFS(1, -1);\n        DFS = [&amp;](int x, int fa) &#123;\n            for (auto [i, tw] : g[x])\n                if (i != fa) &#123;\n                    dis[i] = dis[x] + tw;\n                    diw[i] = diw[x] + tw * s[i];\n                    q.push_back(&#123; dfn[i], rfn[i], i, s[i] &#125;);\n                    q.push_back(&#123; 1, dfn[i] - 1, i, sw - s[i] &#125;);\n                    q.push_back(&#123; rfn[i] + 1, n, i, sw - s[i] &#125;);\n                    int p, q;\n                    long long t = (sw - s[i]) / 2;\n                    &#123;   // 找上端点（开的）\n                        p = i;\n                        for (int j = 20; ~j; --j)\n                            if (f[p][j] &amp;&amp; s[f[p][j]] - s[i] &lt;= t)\n                                p = f[p][j];\n                        p = f[p][0];\n                    &#125;\n                    &#123;   // 找下端点（闭的）\n                        q = i;\n                        for (int j = 20; ~j; --j)\n                            if (f[q][j] &amp;&amp; s[f[q][j]] &lt;= t)\n                                q = f[q][j];\n                        q = f[q][0];\n                    &#125;\n                    res[i] -= sw * (dis[q] - dis[p]) - 2 * (diw[q] - diw[p]) + (dis[x] - dis[p] - dis[q]) * s[i];\n                    DFS(i, x);\n                &#125;\n            return;\n        &#125;;\n        DFS(1, -1);\n        std::vector&lt;int&gt; id(n + 1);\n        std::iota(id.begin() + 1, id.end(), 1);\n        std::sort(id.begin() + 1, id.end(), [&amp;](int x, int y) &#123; return s[x] &lt; s[y]; &#125;);\n        std::sort(q.begin(), q.end(), [&amp;](_ x, _ y) &#123; return x.v &lt; y.v; &#125;);\n        std::vector&lt;std::pair&lt;long long, long long&gt; &gt; bit(n + 1);\n        auto lowbit = [&amp;](int x) &#123; return x &amp; -x; &#125;;\n        auto add = [&amp;](int x, std::pair&lt;long long, long long&gt; v) &#123;\n            for (; x &lt;= n; x += lowbit(x))\n                bit[x].first += v.first, bit[x].second += v.second;\n            return;\n        &#125;;\n        auto ask = [&amp;](int x) &#123;\n            std::pair&lt;long long, long long&gt; res;\n            for (; x; x -= lowbit(x))\n                res.first += bit[x].first, res.second += bit[x].second;\n            return res;\n        &#125;;\n        auto j = ++id.begin();\n        for (auto &amp;[l, r, x, v] : q) &#123;\n            for (; j != id.end() &amp;&amp; s[*j] &lt;= v / 2; ++j)\n                add(dfn[*j], &#123; w[*j], s[*j] * w[*j] &#125;);\n            auto ls(ask(l - 1)), rs(ask(r));\n            rs.first -= ls.first, rs.second -= ls.second;\n            res[x] += rs.second;\n        &#125;\n        bit.assign(n + 1, &#123; 0ll, 0ll &#125;);\n        std::reverse(q.begin(), q.end());\n        std::reverse(id.begin(), id.end());\n        j = ++id.begin();\n        for (auto &amp;[l, r, x, v] : q) &#123;\n            for (; j != id.end() &amp;&amp; s[*j] &gt; v / 2; ++j)\n                add(dfn[*j], &#123; w[*j], s[*j] * w[*j] &#125;);\n            auto ls(ask(l - 1)), rs(ask(r));\n            rs.first -= ls.first, rs.second -= ls.second;\n            res[x] += rs.first * v - rs.second;\n        &#125;\n        std::cout &lt;&lt; *std::min_element(res.begin() + 2, res.end()) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "堆",
                "树的重心"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250329/",
            "url": "https://xsc062.netlify.app/20250329/",
            "title": "学习笔记：FWT",
            "date_published": "2025-03-29T07:00:21.000Z",
            "content_html": "<p>活了哥们，复活了。</p>\n<span id=\"more\"></span>\n<hr />\n<p>考虑以下问题：</p>\n<ul>\n<li>对于 <span class=\"math inline\">\\(\\forall \\,i\\in U\\)</span>，求 <span class=\"math inline\">\\(c_i=\\sum\\limits_{j\\cup k=i}a_j\\cdot b_k\\)</span>。</li>\n</ul>\n<p>当然这里可以把集合看成二进制状态，那么取并集就是按位或了。</p>\n<p>咕咕咕</p>\n<hr />\n<h2 id=\"emiya-家明天的饭\">Emiya 家明天的饭</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P10242\" class=\"uri\">https://www.luogu.com.cn/problem/P10242</a></p>\n<p>冷知识：<em>Emiya 家明天的饭</em> 和 <em>Emiya 家今天的饭</em> 拥有相同的难度评级 <img src=\"/em/kt.gif\" alt=\"磕头\" /></p>\n<p>考虑暴力的做法，如果我们先钦定必须到达的人（这是 <span class=\"math inline\">\\(O(2^n)\\)</span> 的），再花费 <span class=\"math inline\">\\(O(nm)\\)</span> 的时间依次判定每道菜是否可以被选择，就可以 解决问题。但发现时间是不能承受的，这里我们选择优化 <span class=\"math inline\">\\(O(nm)\\)</span> 的判定。</p>\n<p>现在已知人员集合 <span class=\"math inline\">\\(s\\)</span>，对于一道菜 <span class=\"math inline\">\\(i\\)</span>，设它适配的人员集合为 <span class=\"math inline\">\\(T_i\\)</span>，那么有 <span class=\"math inline\">\\(s\\subseteq T_i\\)</span>。所求即为 <span class=\"math inline\">\\(\\max\\limits_s\\{\\sum\\limits_{T_i\\supseteq s}\\sum\\limits_{j\\in s}a_{i,j}\\}\\)</span>。<span class=\"math inline\">\\(O(nm)\\)</span> 预处理出 <span class=\"math inline\">\\(f_j(u)=\\sum\\limits_{T_i=u}a_{j, i}\\)</span>，那么待求即为 <span class=\"math inline\">\\(\\max\\limits_{s}\\{\\sum\\limits_{j\\in s}\\sum\\limits_{u\\supseteq s}f_j(u)\\}\\)</span>，发现这个东西可以用 FWT 求。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m, k;\n    std::cin &gt;&gt; k &gt;&gt; m, n = 1 &lt;&lt; k;\n    using arr = std::vector&lt;long long&gt;;\n    std::vector&lt;int&gt; t(m + 1);\n    std::vector&lt;arr&gt; a(k + 1, arr(m + 1)), f(k + 1, arr(n));\n    for (int i = 1; i &lt;= k; ++i)\n        for (int j = 1; j &lt;= m; ++j) &#123;\n            std::cin &gt;&gt; a[i][j];\n            if (a[i][j] &gt;= 0)\n                t[j] |= 1 &lt;&lt; (i - 1);\n        &#125;\n    for (int i = 1; i &lt;= k; ++i)\n        for (int j = 1; j &lt;= m; ++j)\n            if (a[i][j] &gt;= 0)\n                f[i][t[j]] += a[i][j];\n    &#123;\n        std::vector&lt;arr&gt; mT(2, arr(2));\n        mT[0][0] = 1ll, mT[0][1] = 1ll, mT[1][0] = 0ll, mT[1][1] = 1ll;\n        auto calc = [&amp;](arr a, arr &amp;f, std::vector&lt;arr&gt; &amp;w) &#123;\n            f = a;\n            for (int len = 2; len &lt;= n; len &lt;&lt;= 1) &#123;\n                for (int i = 0; i &lt; n; i += len)\n                    for (int p = i, q = i + len / 2; q &lt; i + len; ++p, ++q)\n                        std::tie(f[p], f[q]) = std::make_tuple(f[p] * w[0][0] + f[q] * w[0][1], f[p] * w[1][0] + f[q] * w[1][1]);\n            &#125;\n            return;\n        &#125;;\n        for (int i = 1; i &lt;= k; ++i)\n            calc(f[i], f[i], mT);\n    &#125;\n    long long res = 0ll;\n    for (int s = 0; s &lt; n; ++s) &#123;\n        long long sum = 0ll;\n        for (int i = 1; i &lt;= k; ++i)\n            if ((s &gt;&gt; (i - 1)) &amp; 1)\n                sum += f[i][s];\n        res = std::max(res, sum);\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"nim-counting\">Nim Counting</h2>\n<p><a href=\"https://atcoder.jp/contests/abc212/tasks/abc212_h\" class=\"uri\">https://atcoder.jp/contests/abc212/tasks/abc212_h</a></p>\n<p>即，从 <span class=\"math inline\">\\(A_N\\)</span> 中有放回地选择 <span class=\"math inline\">\\(\\le M\\)</span> 个数，问它们异或起来不为 <span class=\"math inline\">\\(0\\)</span> 的方案数。</p>\n<p>如果令 <span class=\"math inline\">\\(f_{i, j}\\)</span> 表示选了 <span class=\"math inline\">\\(i\\)</span> 次，异或和为 <span class=\"math inline\">\\(j\\)</span> 的方案数，显然 <span class=\"math inline\">\\(f_{1,i}=\\sum [a_j=i]\\)</span> 为关于 <span class=\"math inline\">\\(a\\)</span> 的桶。此时有 <span class=\"math inline\">\\(f_{i,j}=\\sum\\limits_{k=1}^n f_{i-1,j\\oplus a_k}=\\sum\\limits_{k=0}^V f_{i-1,j\\oplus k}\\cdot f_{1,k}\\)</span>，发现把 <span class=\"math inline\">\\(f_1\\)</span> 这个桶在 <span class=\"math inline\">\\(f\\)</span> 上做 <span class=\"math inline\">\\(N\\)</span> 次 xor-FWT 就可以得到 <span class=\"math inline\">\\(f_n\\)</span>。</p>\n<p>但如果直接卷 <span class=\"math inline\">\\(N\\)</span> 次是 <span class=\"math inline\">\\(O(N\\cdot V\\log V)\\)</span> 的，不太美好，但我们看看我们实际上需要做什么：</p>\n<ol type=\"1\">\n<li>求 <span class=\"math inline\">\\(f_i\\)</span> 的 FWT。</li>\n<li>求初始桶 <span class=\"math inline\">\\(f_1\\)</span> 的 FWT。</li>\n<li>对位相乘得到 <span class=\"math inline\">\\(f_{i+1}\\)</span> 的 FWT。</li>\n<li>通过 FWT 求得原本的 <span class=\"math inline\">\\(f_{i+1}\\)</span>。</li>\n</ol>\n<p>当这个操作被放在 <span class=\"math inline\">\\(i=1\\sim n\\)</span> 上依次进行时，我们发现第一步和最后一步会相互抵消，我们只需要求出 <span class=\"math inline\">\\(f_1\\)</span> 的 FWT，<span class=\"math inline\">\\(FWT_{i, j}(f)\\)</span> 即为 <span class=\"math inline\">\\(FWT_{1, j}(f)^i\\)</span>。因为我们要求的是 <span class=\"math inline\">\\(\\sum\\limits_{i, j}f_{i,j}\\)</span> 可以通过等比数列求和求出 <span class=\"math inline\">\\(FWT_j(s)=\\sum f_{i, j}\\)</span>。由前文推导可知直接做一次逆变换求得 <span class=\"math inline\">\\(s_j\\)</span> 即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    struct mint &#123;\n        const int mod = 998244353;\n        long long x;\n        mint(): x(0ll) &#123;&#125;\n        mint(long long x1): x((x1 + mod) % mod) &#123;&#125;\n        mint&amp; operator= (const mint q) &#123;\n            x = q.x;\n            return *this;\n        &#125;\n        bool operator== (const mint q) const &#123;\n            return x == q.x;\n        &#125;\n        mint operator* (const mint q) const &#123;\n            return x * q.x % mod;\n        &#125;\n        mint&amp; operator*= (const mint q) &#123;\n            return *this = *this * q;\n        &#125;\n        mint operator+ (const mint q) &#123;\n            return (x + q.x) % mod;\n        &#125;\n        mint&amp; operator+= (const mint q) &#123;\n            return *this = *this + q;\n        &#125;\n        mint operator- (const mint q) &#123;\n            return (x + mod - q.x) % mod;\n        &#125;\n        mint qkp(int y) &#123;\n            mint res(1ll), x(this-&gt;x);\n            for (; y; y &gt;&gt;= 1, x *= x)\n                if (y &amp; 1)\n                    res *= x;\n            return res;\n        &#125;\n        mint inv(void) &#123;\n            return qkp(mod - 2);\n        &#125;\n    &#125;;\n    int n, m, k = 16, l = 1 &lt;&lt; k;\n    std::cin &gt;&gt; m &gt;&gt; n;\n    using arr = std::vector&lt;mint&gt;;\n    arr a(n + 1), c(l);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i].x, c[a[i].x] += 1;\n    std::vector&lt;arr&gt; mT(2, arr(2)), mI(2, arr(2));\n    mT[0][0] = 1ll, mT[0][1] = 1ll, mT[1][0] = 1ll, mT[1][1] = -1ll;\n    mI[0][0] = mI[0][1] = mI[1][0] = mint(2ll).inv(), mI[1][1] = mint(-2ll).inv();\n    auto calc = [&amp;](arr a, arr &amp;f, std::vector&lt;arr&gt; &amp;w) &#123;\n        f = a;\n        for (int len = 2; len &lt;= l; len &lt;&lt;= 1)\n            for (int i = 0; i &lt; l; i += len)\n                for (int p = i, q = i + len / 2; q &lt; i + len; ++p, ++q)\n                    std::tie(f[p], f[q]) = std::make_tuple(f[p] * w[0][0] + f[q] * w[0][1], f[p] * w[1][0] + f[q] * w[1][1]);\n        return;\n    &#125;;\n    calc(c, c, mT);\n    arr s(l);\n    for (int i = 0; i &lt; l; ++i)\n        if (c[i] == 1ll)\n            s[i] = m;\n        else\n            s[i] = c[i] * (mint(1ll) - c[i].qkp(m)) * (mint(1ll) - c[i]).inv();\n    calc(s, s, mI);\n    mint res;\n    for (int i = 1; i &lt; l; ++i)\n        res += s[i];\n    std::cout &lt;&lt; res.x &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"binary-table\">Binary Table</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/662/C\" class=\"uri\">https://codeforces.com/problemset/problem/662/C</a></p>\n<p>发现这个题和 <em>Emiya 家今天的饭</em> 很像，都是有一个很小的维和一个相对比较大的维。</p>\n<p>显然，我们所有的操作顺序都可以任意调换；朴素地，我们枚举 <span class=\"math inline\">\\(2^n\\)</span> 种给这 <span class=\"math inline\">\\(n\\)</span> 行反转的情况；再对于每一列，<span class=\"math inline\">\\(O(n)\\)</span> 选择应该反转还是不反转，这样总共是 <span class=\"math inline\">\\(O(2^n\\cdot nm)\\)</span> 的。</p>\n<p>发现把一列初始状态压成一个二进制数 <span class=\"math inline\">\\(a\\)</span>，假设我们现在枚举的行反转状态为 <span class=\"math inline\">\\(s\\)</span>，显然用 <span class=\"math inline\">\\(s\\oplus a\\)</span> 可以得到当前状态。怎么利用这个去 FWT 呢？这引导我们依然枚举 <span class=\"math inline\">\\(s\\)</span>，用一个和 <span class=\"math inline\">\\(s\\oplus a\\)</span> 有关的量跟一个和 <span class=\"math inline\">\\(a\\)</span> 有关的量相乘得到关于 <span class=\"math inline\">\\(s\\)</span> 的答案。</p>\n<p>容易发现令 <span class=\"math inline\">\\(f_{s\\oplus a}\\)</span> 表示 <span class=\"math inline\">\\(s\\oplus a\\)</span> 这个状态反转和不反转两个选项中可以获取的最少 1 的个数；再令 <span class=\"math inline\">\\(c_s\\)</span> 表示状态为 <span class=\"math inline\">\\(s\\)</span> 的列的个数，那么 <span class=\"math inline\">\\(\\sum\\limits_s c_s\\times f_{s\\oplus a}\\)</span> 就可以得到枚举的反转方案为 <span class=\"math inline\">\\(s\\)</span> 的答案，求最小即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    struct mint &#123;\n        const int mod = 998244353;\n        long long x;\n        mint(): x(0ll) &#123;&#125;\n        mint(long long x1): x((x1 + mod) % mod) &#123;&#125;\n        mint&amp; operator= (const mint q) &#123;\n            x = q.x;\n            return *this;\n        &#125;\n        bool operator== (const mint q) const &#123;\n            return x == q.x;\n        &#125;\n        mint operator* (const mint q) const &#123;\n            return x * q.x % mod;\n        &#125;\n        mint&amp; operator*= (const mint q) &#123;\n            return *this = *this * q;\n        &#125;\n        mint operator+ (const mint q) &#123;\n            return (x + q.x) % mod;\n        &#125;\n        mint&amp; operator+= (const mint q) &#123;\n            return *this = *this + q;\n        &#125;\n        mint operator- (const mint q) &#123;\n            return (x + mod - q.x) % mod;\n        &#125;\n        mint qkp(int y) &#123;\n            mint res(1ll), x(this-&gt;x);\n            for (; y; y &gt;&gt;= 1, x *= x)\n                if (y &amp; 1)\n                    res *= x;\n            return res;\n        &#125;\n        mint inv(void) &#123;\n            return qkp(mod - 2);\n        &#125;\n    &#125;;\n    int n, m, l;\n    std::cin &gt;&gt; n &gt;&gt; m, l = 1 &lt;&lt; n;\n    using arr = std::vector&lt;mint&gt;;\n    arr c(l), f(l);\n    std::vector&lt;std::vector&lt;char&gt; &gt; a(n + 1, std::vector&lt;char&gt; (m + 1));\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = 1; j &lt;= m; ++j)\n            std::cin &gt;&gt; a[i][j];\n    for (int j = 1; j &lt;= m; ++j) &#123;\n        int s = 0;\n        for (int i = 1; i &lt;= n; ++i)\n            s = (s &lt;&lt; 1) + a[i][j] - &#39;0&#39;;\n        c[s] += 1;\n    &#125;\n    for (int i = 0, t; i &lt; l; ++i)\n        t = (__builtin_popcount(i)), f[i] = std::min(t, n - t);\n    std::vector&lt;arr&gt; mT(2, arr(2)), mI(2, arr(2));\n    mT[0][0] = 1ll, mT[0][1] = 1ll, mT[1][0] = 1ll, mT[1][1] = -1ll;\n    mI[0][0] = mI[0][1] = mI[1][0] = mint(2ll).inv(), mI[1][1] = mint(-2ll).inv();\n    auto calc = [&amp;](arr a, arr &amp;f, std::vector&lt;arr&gt; &amp;w) &#123;\n        f = a;\n        for (int len = 2; len &lt;= l; len &lt;&lt;= 1)\n            for (int i = 0; i &lt; l; i += len)\n                for (int p = i, q = i + len / 2; q &lt; i + len; ++p, ++q)\n                    std::tie(f[p], f[q]) = std::make_tuple(f[p] * w[0][0] + f[q] * w[0][1], f[p] * w[1][0] + f[q] * w[1][1]);\n        return;\n    &#125;;\n    calc(c, c, mT), calc(f, f, mT);\n    arr s(l);\n    for (int i = 0; i &lt; l; ++i)\n        s[i] = c[i] * f[i];\n    calc(s, s, mI);\n    int res = 0x3f3f3f3f;\n    for (int i = 0; i &lt; l; ++i)\n        res = std::min(res, (int)s[i].x);\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"hard-nim\">Hard Nim</h2>\n<p><a href=\"https://hydro.ac/p/bzoj-P4589\" class=\"uri\">https://hydro.ac/p/bzoj-P4589</a></p>\n<p><em>Nim Counting</em> 然后缝了个筛子。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nconst int inv2 = 5e8 + 4;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    std::vector&lt;int&gt; p, tag(50001);\n    for (int i = 2; i &lt;= 50000; ++i)\n        if (!tag[i]) &#123;\n            p.push_back(i);\n            for (int j = 2 * i; j &lt;= 50000; j += i)\n                tag[j] = 1;\n        &#125;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        long long res = 1ll;\n        for (; y; y &gt;&gt;= 1, (x *= x) %= mod)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    for (int n, m; std::cin &gt;&gt; n &gt;&gt; m; ) &#123;\n        int k = std::__lg(m) + 1, l = 1 &lt;&lt; k;\n        using arr = std::vector&lt;long long&gt;;\n        arr c(l);\n        for (auto i : p)\n            if (i &lt;= m)\n                c[i] += 1;\n            else\n                break;\n        std::vector&lt;arr&gt; mT(2, arr(2)), mI(2, arr(2));\n        mT[0][0] = 1ll, mT[0][1] = 1ll, mT[1][0] = 1ll, mT[1][1] = mod - 1ll;\n        mI[0][0] = mI[0][1] = mI[1][0] = inv2, mI[1][1] = mod - inv2;\n        auto calc = [&amp;](arr &amp;f, std::vector&lt;arr&gt; &amp;w) &#123;\n            for (int len = 2; len &lt;= l; len &lt;&lt;= 1)\n                for (int i = 0; i &lt; l; i += len)\n                    for (int p = i, q = i + len / 2; q &lt; i + len; ++p, ++q)\n                        std::tie(f[p], f[q]) = std::make_tuple((f[p] * w[0][0] + f[q] * w[0][1]) % mod, (f[p] * w[1][0] + f[q] * w[1][1]) % mod);\n            return;\n        &#125;;\n        calc(c, mT);\n        arr s(l);\n        for (int i = 0; i &lt; l; ++i)\n            s[i] = qkp(c[i], n);\n        calc(s, mI);\n        std::cout &lt;&lt; s[0] &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"子集卷积\">子集卷积</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P6097\" class=\"uri\">https://www.luogu.com.cn/problem/P6097</a></p>\n<p>这个是在许多 DP 中都可能见到过的结构，相信大家都深有体会。</p>\n<p>等价于求 <span class=\"math inline\">\\(c_s=\\sum\\limits_{i\\cap j=\\varnothing\\land i\\cup j=s}a_i\\cdot b_j\\)</span>，首先关注 <span class=\"math inline\">\\(i\\cup j=s\\)</span>，可以用 FWT 解决；对于 <span class=\"math inline\">\\(i\\cap j = \\varnothing\\)</span> 呢？</p>\n<p>有一个很聪明的办法，我们发现 <span class=\"math inline\">\\(i\\cap j=\\varnothing\\land i\\cup j = s\\iff \\operatorname{ctz}(i)+\\operatorname{ctz}(j)=\\operatorname{ctz}(s)\\)</span>，其中 <span class=\"math inline\">\\(\\operatorname{ctz}(i)\\)</span> 表示 <span class=\"math inline\">\\(i\\)</span> 中 <span class=\"math inline\">\\(1\\)</span> 的个数，即 <code>popcount(i)</code>。</p>\n<p>显然后者是个简单的加法运算，这里又有一个很聪明又很基本的办法，我们令 <span class=\"math inline\">\\(A_{\\operatorname{ctz}(i),i}=a_i,B_{\\operatorname{ctz}(j),j}=b_j\\)</span>，那么答案就转化为 <span class=\"math inline\">\\(\\sum\\limits_{i}\\sum\\limits_{j\\cup k=s}A_{i,j}\\cdot B_{\\operatorname{ctz}(s)-i,j}\\)</span>，就可以 <span class=\"math inline\">\\(O(n\\log^2n)\\)</span> 地解决问题了。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 9;\nusing arr = std::vector&lt;long long&gt;;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    int l = 1 &lt;&lt; n;\n    std::vector&lt;arr&gt; a(n + 1, arr(l)), b(n + 1, arr(l)), c(n + 1, arr(l));\n    for (int i = 0, x; i &lt; l; ++i)\n        std::cin &gt;&gt; x, a[__builtin_popcount(i)][i] = x;\n    for (int i = 0, x; i &lt; l; ++i)\n        std::cin &gt;&gt; x, b[__builtin_popcount(i)][i] = x;\n    std::vector&lt;arr&gt; mT(2, arr(2)), mI(2, arr(2));\n    mT[0][0] = 1ll, mT[0][1] = 0ll, mT[1][0] = 1ll, mT[1][1] = 1ll;\n    mI[0][0] = 1ll, mI[0][1] = 0ll, mI[1][0] = mod - 1ll, mI[1][1] = 1ll;\n    auto calc = [&amp;](arr &amp;f, std::vector&lt;arr&gt; &amp;w) &#123;\n        for (int len = 2; len &lt;= l; len &lt;&lt;= 1)\n            for (int i = 0; i &lt; l; i += len)\n                for (int p = i, q = i + len / 2; q &lt; i + len; ++p, ++q)\n                    std::tie(f[p], f[q]) = std::make_tuple((f[p] * w[0][0] + f[q] * w[0][1]) % mod, (f[p] * w[1][0] + f[q] * w[1][1]) % mod);\n        return;\n    &#125;;\n    for (int i = 0; i &lt;= n; ++i)\n        calc(a[i], mT), calc(b[i], mT);\n    for (int i = 0; i &lt;= n; ++i) &#123;\n        for (int k = 0; k &lt;= i; ++k)\n            for (int j = 0; j &lt; l; ++j)\n                (c[i][j] += a[k][j] * b[i - k][j]) %= mod;\n        calc(c[i], mI);\n    &#125;\n    for (int j = 0; j &lt; l; ++j)\n        std::cout &lt;&lt; c[__builtin_popcount(j)][j] &lt;&lt; &#39; &#39;;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"州区划分\">州区划分</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P4221\" class=\"uri\">https://www.luogu.com.cn/problem/P4221</a></p>\n<p>人话：把 <span class=\"math inline\">\\(n\\)</span> 个点划分成若干个点集，保证每个点集的导出子图不是欧拉回路（每个点的度数为偶且图连通）。</p>\n<p>那么枚举每一个点集判定是否合法，再令 <span class=\"math inline\">\\(f_{i}={w_i}^{-p}\\times\\sum\\limits_{j\\cup k = i\\land j\\cap k=\\varnothing}f_{j}\\times {w_k}^p\\)</span>。</p>\n<p>发现后面那个 sigma 里面是一个简单的子集卷积；但是我们发现前面有一个和 <span class=\"math inline\">\\(i\\)</span> 有关的常数，导致没办法直接卷 <span class=\"math inline\">\\(n\\)</span> 次。</p>\n<p>但我们发现这个 DP 其实是有一定隐含条件的——都是按照 <span class=\"math inline\">\\(\\text{ctz}\\)</span> 从小到大转移。考虑子集卷积的第一维，得到 <span class=\"math inline\">\\(FWT_{f_i}\\)</span> 后先 IFWT 回来，乘上 <span class=\"math inline\">\\({w_i}^{-p}\\)</span>，再 FWT 回去即可。考察子集卷积的结构，发现这个是可以想办法套进去的。</p>\n<p>复杂度 <a href=\"https://atcoder.jp/contests/abc400/tasks/abc400_c\"><span class=\"math inline\">\\(O(n^2\\cdot 2^n)\\)</span></a>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nusing arr = std::vector&lt;long long&gt;;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m, p;\n    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; p;\n    int l = 1 &lt;&lt; n;\n    auto qkp = [&amp;](long long x, int y = mod - 2) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    arr w(n), inv(l);\n    std::vector&lt;arr&gt; f(n + 1, arr(l)), s(n + 1, arr(l));\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n);\n    for (int x, y; m--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y, --x, --y;\n        g[x].push_back(y);\n    &#125;\n    auto check = [&amp;](int s) &#123;\n        std::vector&lt;int&gt; f(n), deg(n);\n        std::iota(f.begin(), f.end(), 0);\n        std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;\n            return x == f[x] ? x : f[x] = find(f[x]);\n        &#125;;\n        auto merge = [&amp;](int x, int y) &#123;\n            f[find(x)] = find(y);\n            return;\n        &#125;;\n        for (int i = 0; i &lt; n; ++i)\n            if ((s &gt;&gt; i) &amp; 1)\n                for (auto j : g[i])\n                    if ((s &gt;&gt; j) &amp; 1)\n                        merge(i, j), ++deg[i], ++deg[j];\n        int fa = -1;\n        for (int i = 0; i &lt; n; ++i)\n            if ((s &gt;&gt; i) &amp; 1) &#123;\n                if (deg[i] &amp; 1)\n                    return 1;\n                if (fa == -1 || fa == find(i))\n                    fa = find(i);\n                else\n                    return 1;\n            &#125;\n        return 0;\n    &#125;;\n    for (int i = 0; i &lt; n; ++i)\n        std::cin &gt;&gt; w[i];\n    for (int i = 0; i &lt; l; ++i) &#123;\n        int ctz = __builtin_popcount(i);\n        for (int j = 0; j &lt; n; ++j)\n            if ((i &gt;&gt; j) &amp; 1) \n                s[ctz][i] += w[j];\n        s[ctz][i] = qkp(s[ctz][i], p);\n        inv[i] = qkp(s[ctz][i]);\n        if (!check(i))\n            s[ctz][i] = 0ll;\n    &#125;\n    std::vector&lt;arr&gt; mT(2, arr(2)), mI(2, arr(2));\n    mT[0][0] = 1ll, mT[0][1] = 0ll, mT[1][0] = 1ll, mT[1][1] = 1ll;\n    mI[0][0] = 1ll, mI[0][1] = 0ll, mI[1][0] = mod - 1ll, mI[1][1] = 1ll;\n    auto calc = [&amp;](arr &amp;f, std::vector&lt;arr&gt; &amp;w) &#123;\n        for (int len = 2; len &lt;= l; len &lt;&lt;= 1)\n            for (int i = 0; i &lt; l; i += len)\n                for (int p = i, q = i + len / 2; q &lt; i + len; ++p, ++q)\n                    std::tie(f[p], f[q]) = std::make_tuple((f[p] * w[0][0] + f[q] * w[0][1]) % mod, (f[p] * w[1][0] + f[q] * w[1][1]) % mod);\n        return;\n    &#125;;\n    f[0][0] = 1ll;\n    for (int i = 0; i &lt;= n; ++i)\n        calc(s[i], mT);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        calc(f[i - 1], mT);\n        for (int k = 0; k &lt; i; ++k)\n            for (int j = 0; j &lt; l; ++j)\n                (f[i][j] += f[k][j] * s[i - k][j]) %= mod;\n        calc(f[i], mI);\n        for (int j = 0; j &lt; l; ++j)\n            (f[i][j] *= inv[j]) %= mod;\n    &#125;\n    std::cout &lt;&lt; f[n][l - 1] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---sum-the-fibonacci\">B - Sum the Fibonacci</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/914/G\" class=\"uri\">https://codeforces.com/problemset/problem/914/G</a></p>\n<p>首先，对于每个元素的 <span class=\"math inline\">\\(cnt\\)</span> 是好做的——做一次子集卷积得到 <span class=\"math inline\">\\(cnt_1(a\\cup b)\\)</span>，做一次 xor-FWT 得到 <span class=\"math inline\">\\(cnt_2(d\\oplus e)\\)</span>，中间的 <span class=\"math inline\">\\(cnt(c)\\)</span> 就是原样。</p>\n<p>值得注意的是可以在一次 and-FWT 后把 <span class=\"math inline\">\\(cnt,cnt_1,cnt_2\\)</span> 直接卷起来——由矩阵乘法结合律得（哈哈大笑了）。但怎么把 <span class=\"math inline\">\\(f\\)</span> 塞进去呢？如果你拥有小学生的数学水平，你可以很容易地想到直接在 <span class=\"math inline\">\\(cnt,cnt_1,cnt_2\\)</span> IFWT 后的结果分别对位乘上 <span class=\"math inline\">\\(f\\)</span> 即可，很可惜我并没有这样的数学能力 <img src=\"/em/kt.gif\" /></p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int N = 17;\nconst int mod = 1e9 + 7;\nusing arr = std::vector&lt;long long&gt;;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, l;\n    std::cin &gt;&gt; n, l = 1 &lt;&lt; N;\n    std::vector&lt;int&gt; a(n + 1);\n    arr f(l), cnt(l), cnt1(l), cnt2(l);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i], ++cnt[a[i]];\n    f[0] = 0ll, f[1] = 1ll;\n    for (int i = 2; i &lt; l; ++i)\n        f[i] = (f[i - 1] + f[i - 2]) % mod;\n    auto qkp = [&amp;](long long x, int y = mod - 2) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    const int inv2 = qkp(2ll);\n    std::vector&lt;arr&gt; mT(2, arr(2)), mI(2, arr(2));\n    auto calc = [&amp;](arr a, arr &amp;f, std::vector&lt;arr&gt; &amp;w) &#123;\n        f = a;\n        for (int len = 2; len &lt;= l; len &lt;&lt;= 1)\n            for (int i = 0; i &lt; l; i += len)\n                for (int p = i, q = i + len / 2; q &lt; i + len; ++p, ++q)\n                    std::tie(f[p], f[q]) = std::make_tuple((f[p] * w[0][0] + f[q] * w[0][1]) % mod, (f[p] * w[1][0] + f[q] * w[1][1]) % mod);\n        return;\n    &#125;;\n    &#123; // orFWT\n        mT[0][0] = 1ll, mT[0][1] = 0ll, mT[1][0] = 1ll, mT[1][1] = 1ll;\n        mI[0][0] = 1ll, mI[0][1] = 0ll, mI[1][0] = mod - 1ll, mI[1][1] = 1ll;\n        std::vector&lt;arr&gt; u(N + 1, arr(l)), d(N + 1, arr(l));\n        for (int i = 0; i &lt; l; ++i)\n            u[__builtin_popcount(i)][i] = cnt[i];\n        for (int i = 0; i &lt;= N; ++i)\n            calc(u[i], u[i], mT);\n        for (int i = 0; i &lt;= N; ++i) &#123;\n            for (int j = 0; j &lt; l; ++j)\n                for (int k = 0; k &lt;= i; ++k)\n                    (d[i][j] += u[k][j] * u[i - k][j]) %= mod;\n            calc(d[i], d[i], mI);\n        &#125;\n        for (int i = 0; i &lt; l; ++i)\n            cnt1[i] = d[__builtin_popcount(i)][i] * f[i] % mod;\n    &#125;\n    &#123; // xor FWT\n        mT[0][0] = 1ll, mT[0][1] = 1ll, mT[1][0] = 1ll, mT[1][1] = mod - 1ll;\n        mI[0][0] = mI[0][1] = mI[1][0] = inv2, mI[1][1] = mod - inv2;\n        calc(cnt, cnt2, mT);\n        for (int i = 0; i &lt; l; ++i)\n            (cnt2[i] *= cnt2[i]) %= mod;\n        calc(cnt2, cnt2, mI);\n        for (int i = 0; i &lt; l; ++i)\n            (cnt2[i] *= f[i]) %= mod;\n    &#125;\n    &#123; // andFWT\n        mT[0][0] = 0ll, mT[0][1] = 1ll, mT[1][0] = 1ll, mT[1][1] = 1ll;\n        mI[0][0] = mod - 1ll, mI[0][1] = 1ll, mI[1][0] = 1ll, mI[1][1] = 0ll;\n        for (int i = 0; i &lt; l; ++i) // 这一步要放在 FWT 之前，原因显然 🤗\n            (cnt[i] *= f[i]) %= mod;\n        calc(cnt2, cnt2, mT), calc(cnt1, cnt1, mT), calc(cnt, cnt, mT);\n        for (int i = 0; i &lt; l; ++i)\n            cnt[i] = cnt[i] * cnt1[i] % mod * cnt2[i] % mod % mod;\n        calc(cnt, cnt, mI);\n    &#125;\n    long long res = 0ll;\n    for (int i = 0; i &lt; N; ++i)\n        (res += cnt[1 &lt;&lt; i] % mod) %= mod;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "高维前缀和",
                "FWT"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250222/",
            "url": "https://xsc062.netlify.app/20250222/",
            "title": "中等题目 Practice",
            "date_published": "2025-02-22T09:31:36.000Z",
            "content_html": "\n",
            "tags": []
        },
        {
            "id": "https://xsc062.netlify.app/20250219/",
            "url": "https://xsc062.netlify.app/20250219/",
            "title": "杂题集",
            "date_published": "2025-02-19T07:33:17.000Z",
            "content_html": "<p>不在沉默中躺平，就在喧嚣中躺平。</p>\n<span id=\"more\"></span>\n<p>但谁说人一定要躺平？我要 work work work work work work work work 勤劳又勇敢的 XSC062 为了 OI 的关键杂题集 她作出了巨大的贡献 巨大的牺牲 巨大的 carry 无敌了 无敌了 <img src=\"/em/kt.gif\" alt=\"磕头\" /></p>\n<hr />\n<h2 id=\"usaco23jan-moo-route-g\">[USACO23JAN] Moo Route G</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P9018\" class=\"uri\">https://www.luogu.com.cn/problem/P9018</a></p>\n<p>关键词：<mark>由小推大</mark> <mark>思维</mark></p>\n<p>希望大家不要和我一样忽略了重要条件：终点也是 <span class=\"math inline\">\\(0\\)</span>。这意味着每个点都会被左右成对地经过，那么不妨令 <span class=\"math inline\">\\(A_i\\gets \\frac 2{A_i}\\)</span>。</p>\n<p>观察到给了 <span class=\"math inline\">\\(N=2\\)</span> 的一档分，考虑该情况。</p>\n<ol type=\"1\">\n<li><p>若 <span class=\"math inline\">\\(A_1&gt; A_2\\)</span>：</p>\n<details>\n<p><summary>此时最优策略为……</summary></p>\n<pre class=\"plain{data-line=&quot;1,2,5,6,9,10&quot;}\"><code>|---------&gt;\n&lt;---------|\n|---------&gt;\n&lt;---------|\n|---------&gt;\n&lt;---------|\n|----&gt;\n&lt;----|\n|----&gt;\n&lt;----|\n===========\n0    1    2</code></pre>\n</details>\n只要不拆开一组，箭头排列顺序任意。显然方案数为 <span class=\"math inline\">\\({A_1}\\choose {A_2}\\)</span>。</li>\n<li><p>Otherwise：</p>\n<details>\n<p><summary>此时最优策略为……</summary></p>\n<pre class=\"plain{data-line=&quot;4,5,7,8&quot;}\"><code>|----------&gt;\n      &lt;----|\n      |----&gt;\n      &lt;----|\n      |----&gt;\n &lt;---------|\n |---------&gt;\n &lt;---------|\n ===========\n 0    1    2</code></pre>\n</details>\n<p>相似地，只要不拆开一组，箭头排列顺序任意，可以注意到除了第一个，每个长 <code>|---&gt;</code> 的前面一定是一个长 <code>&lt;---|</code>，那么问题转化为选择 <span class=\"math inline\">\\(A_1-1\\)</span> 个短 <code>&lt;---|</code> 拉长，方案数为 <span class=\"math inline\">\\({A_2-1}\\choose{A_1-1}\\)</span>。</p></li>\n</ol>\n<p>进一步，考虑 <span class=\"math inline\">\\(N=3\\)</span> 的情况。若已知子问题 <span class=\"math inline\">\\(0\\to1\\to2\\)</span> 的方案和子问题 <span class=\"math inline\">\\(1\\to2\\to3\\)</span> 的方案，可以直接乘起来合并。为什么呢？</p>\n<p>二者经过 <span class=\"math inline\">\\(2\\)</span> 的次数相等；在子问题 <span class=\"math inline\">\\(0\\to1\\to2\\)</span> 中，<span class=\"math inline\">\\(1\\to2\\)</span> 的下一步一定是 <span class=\"math inline\">\\(2\\to 1\\)</span>；我们把该过程替换为子问题 <span class=\"math inline\">\\(1\\to 2\\to 3\\)</span> 中对应的一段 <span class=\"math inline\">\\(1\\to2\\to\\cdots\\to2\\to1\\)</span> 的路径即可。</p>\n<p>那么两两合并起来，可以得到最终答案为 <span class=\"math inline\">\\(\\prod\\limits_{i=1}^{n-1}\\begin{cases}{\\binom{A_i}{A_{i+1}}}&amp;A_i&gt;A_{i+1}\\\\{\\binom{A_{i+1}-1}{A_i-1}}&amp;\\text{otherwise}\\end{cases}\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int lim = 5e5;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i], a[i] /= 2;\n    std::vector&lt;long long&gt; inv(lim + 1), fac(lim + 1);\n    auto qkp = [&amp;](long long x, int y) &#123;\n        long long res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[0] = fac[0] = 1ll;\n    for (int i = 1; i &lt;= lim; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    inv[lim] = qkp(fac[lim], mod - 2);\n    for (int i = lim - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    long long res = 1ll;\n    for (int i = 1; i &lt; n; ++i)\n        if (a[i] &gt; a[i + 1])\n            (res *= C(a[i], a[i + 1])) %= mod;\n        else\n            (res *= C(a[i + 1] - 1, a[i] - 1)) %= mod;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"gdkoi2024-普及组-正方形扩展\">[GDKOI2024 普及组] 正方形扩展</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P10078\" class=\"uri\">https://www.luogu.com.cn/problem/P10078</a></p>\n<p>关键词：<mark>分类讨论</mark> <mark>扫描线</mark></p>\n<p>理论上看懂了就是弱智题，可惜看不懂。</p>\n<p>就是说，一个点如果被染了某种颜色，并且以它为中心的边长为 <span class=\"math inline\">\\(2\\)</span> 的正方形中没有其他颜色的点，就把这个正方形里的点都染成这个颜色，问每个颜色面积是否能达到无穷大。</p>\n<p>考虑无法达到无穷大的原因，一定是因为向四个方向都无法延伸到无穷远。以右边为例，考虑点 <span class=\"math inline\">\\(i\\)</span> 什么时候不能在 <span class=\"math inline\">\\(x\\)</span> 轴正方向上延伸到无穷远：</p>\n<ul>\n<li><p>对于 <span class=\"math inline\">\\(\\forall \\, j,x_j\\le x_i\\)</span>，<span class=\"math inline\">\\(j\\)</span> <strong>不会</strong>对 <span class=\"math inline\">\\(i\\)</span> 向右的延伸带来任何影响——所有点的延伸速度相同。</p></li>\n<li><p>对于 <span class=\"math inline\">\\(x_j&gt;x_i\\)</span> 且 <span class=\"math inline\">\\(y_j=y_i\\)</span>，<span class=\"math inline\">\\(j\\)</span> 可以堵住 <span class=\"math inline\">\\(i\\)</span>。</p>\n<p>这时候不免产生疑问：<span class=\"math inline\">\\(i\\)</span> 不能从上下「翻越」过 <span class=\"math inline\">\\(j\\)</span> 的统治吗？</p>\n<p>显而易见地，由于延伸速度相同，<span class=\"math inline\">\\(i\\)</span> 在某时刻能够在 <span class=\"math inline\">\\(y\\)</span> 轴上到达的高度，<span class=\"math inline\">\\(j\\)</span> 也能达到，所以 <span class=\"math inline\">\\(j\\)</span> <strong>能够</strong>把 <span class=\"math inline\">\\(i\\)</span> 堵死，参见题面中给出的例子。</p></li>\n<li><p>对于 <span class=\"math inline\">\\(x_j&gt;x_i\\)</span> 且 <span class=\"math inline\">\\(y_j \\ne y_i\\)</span>，由上所述，<span class=\"math inline\">\\(j\\)</span> 在 <span class=\"math inline\">\\(y\\)</span> 轴下 / 上方向<strong>无法</strong>追上 <span class=\"math inline\">\\(i\\)</span>，<span class=\"math inline\">\\(i\\)</span> 可以从该方向越过 <span class=\"math inline\">\\(j\\)</span>，在 <span class=\"math inline\">\\(x\\)</span> 轴正方向上延伸到无穷远；但 <span class=\"math inline\">\\(j\\)</span> 在自己所在的一侧（上 / 下）<strong>可以</strong>堵住 <span class=\"math inline\">\\(i\\)</span>。</p></li>\n<li><p>对于 <span class=\"math inline\">\\(x_j,x_k&gt;x_i\\)</span> 且 <span class=\"math inline\">\\((y_j-y_i)(y_k-y_i)&lt;0\\)</span>（即二者分居 <span class=\"math inline\">\\(i\\)</span> 点上下），<span class=\"math inline\">\\(j\\)</span> 和 <span class=\"math inline\">\\(k\\)</span> <strong>可以</strong>在两个方向分别拦截住 <span class=\"math inline\">\\(i\\)</span>。</p>\n<p>此时可能有疑问：<span class=\"math inline\">\\(i\\)</span> 可不可以先越过 <span class=\"math inline\">\\(j\\)</span> ，再越过 <span class=\"math inline\">\\(k\\)</span> 呢？答案是否定的。由上，<span class=\"math inline\">\\(j\\)</span> 和 <span class=\"math inline\">\\(k\\)</span> 会分别在 <span class=\"math inline\">\\(y\\)</span> 轴自身对应方向上堵住 <span class=\"math inline\">\\(i\\)</span>，在越过其中之一后无法从这一侧越过另一个点，所以 <span class=\"math inline\">\\(i\\)</span> 会被两个点合作堵死。</p></li>\n</ul>\n<p>由此我们总结出，<span class=\"math inline\">\\(i\\)</span> 能在 <span class=\"math inline\">\\(x\\)</span> 轴正方向被拦截，当且仅当：</p>\n<ul>\n<li>存在 <span class=\"math inline\">\\(x_j&gt;x_i\\)</span> 且 <span class=\"math inline\">\\(y_j=y_i\\)</span>；</li>\n<li>抑或，存在 <span class=\"math inline\">\\(x_j,x_k&gt;x_i\\)</span> 且 <span class=\"math inline\">\\(y_j&lt;y_i,y_k&gt;y_i\\)</span>。</li>\n</ul>\n<p>那么可以从四个方向分别用扫描线求解。鉴于和实际坐标数值没有什么直接关系，可以离散化后树状数组以避免被卡常。</p>\n<hr />\n<h2 id=\"金鱼草\">金鱼草</h2>\n<p><a href=\"/20250819/#金鱼草区间覆盖信息\">link</a></p>\n",
            "tags": []
        },
        {
            "id": "https://xsc062.netlify.app/20250217/",
            "url": "https://xsc062.netlify.app/20250217/",
            "title": "线段树维护前缀最值序列信息",
            "date_published": "2025-02-17T11:09:57.000Z",
            "content_html": "<p>人类不应该使用 <code>std::vector</code> 实现线段树的 2 个原因：</p>\n<span id=\"more\"></span>\n<ol type=\"1\">\n<li>当你的参数包含引用时，扩容操作，包括显式的 <code>resize()</code> 和隐式的 <code>push_back()</code> 均会导致引用失效。</li>\n<li>当你的左值为引用时，由于 <code>=</code> 左右计算顺序是不确定的（C++14），由于 1 中所述原因，引用可能失效。</li>\n<li><code>terminate called after throwing an instance of 'std::bad_alloc' what():  std::bad_alloc</code></li>\n</ol>\n<p>笑点解析：首先通过「……的 2 个原因」暗示声明一个长度为 2 的 <code>vector</code>，接着在试图访问第 3 个元素时抛出错误。</p>\n<p>什么？你说我的下标是从 1 开始的？恭喜你发现了 <code>vector</code> 的第 0 个笑点。</p>\n<hr />\n<h2 id=\"楼房重建\">楼房重建</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P4198\" class=\"uri\">https://www.luogu.com.cn/problem/P4198</a></p>\n<p>考虑用线段树解决问题。难点在于如何合并两个区间的信息——直觉地，大区间的信息一定与两个子区间有关。</p>\n<p>考虑理想的情况：我们现在知道左右两边区间的答案序列。显然我们需要保留左边整段区间，对于左区间序列末的元素 <span class=\"math inline\">\\(rv_l\\)</span>，我们在右区间内找到第一个大于之的元素 <span class=\"math inline\">\\(x\\)</span>，从它开始的序列就是答案。</p>\n<p>反证法易得 <span class=\"math inline\">\\(x\\)</span> 一定在右区间答案序列内：若 <span class=\"math inline\">\\(x\\)</span> 不在答案序列内，则右区间内存在一个 <span class=\"math inline\">\\(&gt;x\\)</span> 且位于 <span class=\"math inline\">\\(x\\)</span> 之前的元素，那么 <span class=\"math inline\">\\(x\\)</span> 就不是第一个 <span class=\"math inline\">\\(&gt;rv_l\\)</span> 的元素，矛盾。</p>\n<p>那么现在对于左右序列未知的情况，我们取左区间的答案，再在右区间中单 <span class=\"math inline\">\\(\\log\\)</span> 查找能够接上去的区间长度，加起来即可。</p>\n<p>题目只要求总区间答案，故不需要查询。动态开点可能需要小心处理一下。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e5 + 5;\nstruct &#123;\n    int l, r, u;\n    double lv, rv, mv;\n&#125; t[maxn &lt;&lt; 2];\nint tot;\n#define lt t[p].l\n#define rt t[p].r\nint askt(int p, int l, int r, double v) &#123;\n    if (l == r)\n        return t[p].u;\n    int mid = (l + r) &gt;&gt; 1;\n    if (lt &amp;&amp; t[p].mv &gt; v)\n        return t[p].u - t[lt].u + askt(lt, l, mid, v);\n    return askt(rt, mid + 1, r, v);\n&#125;\nvoid pushup(int p, int l, int r) &#123;\n    t[p].mv = t[lt].rv;\n    if (lt &amp;&amp; rt) &#123;\n        t[p].lv = t[lt].lv;\n        t[p].rv = std::max(t[lt].rv, t[rt].rv);\n        if (t[lt].rv &lt; t[rt].lv)\n            t[p].u = t[lt].u + t[rt].u;\n        else if (t[lt].rv &gt;= t[rt].rv)\n            t[p].u = t[lt].u;\n        else &#123;\n            int mid = (l + r) &gt;&gt; 1;\n            t[p].u = t[lt].u + askt(rt, mid + 1, r, t[lt].rv);\n        &#125;\n    &#125;\n    else &#123;\n        t[p].u = t[lt + rt].u;\n        t[p].lv = t[lt + rt].lv, t[p].rv = t[lt + rt].rv;\n    &#125;\n    return;\n&#125;\nvoid upd(int &amp;p, int l, int r, int x, double v) &#123;\n    if (!p)\n        p = ++tot;\n    if (l == r) &#123;\n        t[p].lv = t[p].rv = v, t[p].u = 1;\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        upd(lt, l, mid, x, v);\n    else\n        upd(rt, mid + 1, r, x, v);\n    pushup(p, l, r);\n    return;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;P4198_2.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m, rt = 0;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;double&gt; a(n + 1);\n    for (int x; m--; ) &#123;\n        double y;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        a[x] = y / x;\n        upd(rt, 1, n, x, y / x);\n        std::cout &lt;&lt; t[1].u &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "线段树"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250216/",
            "url": "https://xsc062.netlify.app/20250216/",
            "title": "Public Round 15 前两题",
            "date_published": "2025-02-16T11:44:38.000Z",
            "content_html": "<p><a href=\"https://pjudge.ac/contest/1914\">PR #15</a> 前两题题解。</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"最小表示法\">最小表示法</h2>\n<p><a href=\"https://pjudge.ac/contest/1914/problem/21888\" class=\"uri\">https://pjudge.ac/contest/1914/problem/21888</a></p>\n<p>首先不妨假设每个 <span class=\"math inline\">\\(f\\)</span> 在值域内等概率取值以简化问题。那么手玩一下可以轻松地得到规律：不妨将 <span class=\"math inline\">\\(\\{s\\}\\)</span> 循环右移一位的结果记为 <span class=\"math inline\">\\(\\{t\\}\\)</span>，那么 <span class=\"math inline\">\\(res=\\sum\\frac 1{\\max(|s_i|,|t_i|)}\\)</span>。</p>\n<p>这看起来令人疑惑：对于不同的 <span class=\"math inline\">\\(i\\)</span>，<span class=\"math inline\">\\([f(s_i)=f(t_i)]\\)</span> 的期望似乎是彼此独立的，十分奇怪。这其实与表达式的来源有关，记 <span class=\"math inline\">\\(g(s_i, j)\\)</span> 表示 <span class=\"math inline\">\\(f(s_i)=j\\)</span> 的概率，那么上述等式可以转写为 <span class=\"math inline\">\\(res=\\sum\\limits_i\\sum\\limits_jg({s_i},j)\\times g(t_i,j)\\)</span>。</p>\n<p>那么将最小表示法带来的偏差纳入考虑范围，我们发现 <span class=\"math inline\">\\(g(s,j)\\)</span> 对于不同的 <span class=\"math inline\">\\(j\\)</span> 并不永远相等。具体地，当 <span class=\"math inline\">\\(s\\)</span> 具有循环节时，最小循环节的第一处结尾会享有更大的取得概率。</p>\n<p>枚举 <span class=\"math inline\">\\(s_i\\)</span> 的因数作为最小循环节长度的情况，显然，对于最小循环节为 <span class=\"math inline\">\\(j\\)</span> 的情况（该情况出现的概率，容斥得到 <span class=\"math inline\">\\(p_j=26^j-\\sum_{k\\mid j}p_k\\)</span>），<span class=\"math inline\">\\(f(s_i)\\)</span> 的取值在 <span class=\"math inline\">\\(1\\sim j\\)</span> 上等概率分布，差分即可统计每个值在不同循环节长度下被取到的概率和。</p>\n<p>用埃筛解决每个数的因数和 <span class=\"math inline\">\\(p\\)</span> 值，那么此时复杂度瓶颈在于 <span class=\"math inline\">\\(g(s_i, j)\\)</span> 和 <span class=\"math inline\">\\(\\sum\\limits_i\\sum\\limits_jg({s_i},j)\\times g(t_i,j)\\)</span> 的求解。容易发现只有每个 <span class=\"math inline\">\\(g(s_i,j),j\\mid |s_i|\\)</span> 的值是有效的（其他的和它们值都相同），考虑只求解和利用这些值，类 <code>std::merge</code>（即归并排序）地求解答案。</p>\n<p>注意特判 <span class=\"math inline\">\\(n=1\\)</span>。会得到错误答案的原因是此时存在 <span class=\"math inline\">\\(s_i=t_i\\)</span>，不满足基本要求。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int lim = 1e5;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    if (n == 1) &#123;\n        std::cout &lt;&lt; 1 &lt;&lt; &#39;\\n&#39;;\n        return 0;\n    &#125;\n    auto qkp = [](long long x, int y) &#123;\n        long long res = 1ll;\n        for (; y; y &gt;&gt;= 1, (x *= x) %= mod)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    auto inv = [&amp;](int x) &#123;\n        return qkp(x, mod - 2);\n    &#125;;\n    std::vector&lt;long long&gt; f(lim + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; fac(lim + 1);\n    for (int i = 1; i &lt;= lim; ++i) &#123;\n        static long long now = 26;\n        (f[i] += now) %= mod;\n        fac[i].push_back(i);\n        for (int j = 2 * i; j &lt;= lim; j += i)\n            (f[j] += mod - f[i]) %= mod, fac[j].push_back(i);\n        (now *= 26) %= mod;\n    &#125;\n    for (int i = 1; i &lt;= lim; ++i)\n        (f[i] *= inv(i)) %= mod;\n    std::vector&lt;int&gt; a(n + 1);\n    struct _ &#123; int l, r; long long f; &#125;;\n    std::vector&lt;std::vector&lt;_&gt; &gt; g(lim + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        if (g[a[i]].empty()) &#123;\n            g[a[i]].resize(fac[a[i]].size());\n            for (int j = 0; j &lt; (int)fac[a[i]].size(); ++j) &#123;\n                g[a[i]][j].l = (j ? g[a[i]][j - 1].r + 1 : 1);\n                g[a[i]][j].r = fac[a[i]][j];\n                (g[a[i]][0].f += f[fac[a[i]][j]]) %= mod;\n                if (j != (int)fac[a[i]].size() - 1)\n                    (g[a[i]][j + 1].f += mod - f[fac[a[i]][j]]) %= mod;\n            &#125;\n            for (int j = 1; j &lt; (int)fac[a[i]].size(); ++j)\n                (g[a[i]][j].f += g[a[i]][j - 1].f) %= mod;\n            int getinv = inv(qkp(26, a[i]));\n            for (int j = 0; j &lt; (int)fac[a[i]].size(); ++j)\n                (g[a[i]][j].f *= getinv) %= mod;\n        &#125;\n    &#125;\n    std::vector&lt;int&gt; b(n + 1);\n    std::rotate_copy(a.begin() + 1, --a.end(), a.end(), b.begin() + 1);\n    long long res = 0ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = 0, k = 0, now = 0;\n            j &lt; (int)fac[a[i]].size() &amp;&amp; k &lt; (int)fac[b[i]].size(); )\n            if (g[a[i]][j].r &lt; g[b[i]][k].r) &#123;\n                (res += g[a[i]][j].f * g[b[i]][k].f % mod\n                    * (g[a[i]][j].r - now) % mod) %= mod;\n                now = g[a[i]][j].r, ++j;\n            &#125;\n            else if (g[a[i]][j].r == g[b[i]][k].r) &#123;\n                (res += g[a[i]][j].f * g[b[i]][k].f % mod\n                    * (g[a[i]][j].r - now) % mod) %= mod;\n                now = g[a[i]][j].r, ++j, ++k;\n            &#125;\n            else &#123;\n                (res += g[a[i]][j].f * g[b[i]][k].f % mod\n                    * (g[b[i]][k].r - now) % mod) %= mod;\n                now = g[b[i]][k].r, ++k;\n            &#125;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"二叉搜索树\">二叉搜索树</h2>\n<p><a href=\"https://pjudge.ac/contest/1914/problem/21889\" class=\"uri\">https://pjudge.ac/contest/1914/problem/21889</a></p>\n<p>当我们处理链的部分分时，很容易想到用差分解决问题。把更新 <span class=\"math inline\">\\([l, r]\\)</span> 看作在差分数组 <span class=\"math inline\">\\(l\\)</span> 处插入，在 <span class=\"math inline\">\\(r+1\\)</span> 处删除，离线下来再从左到右扫一遍操作，考虑如何解决查询问题。</p>\n<p>考虑如何获取 <span class=\"math inline\">\\(i\\)</span> 树上 <span class=\"math inline\">\\(t_0\\)</span> 时刻点 <span class=\"math inline\">\\(x\\)</span> 的所有祖先。根据前面的操作，我们可以获取 <span class=\"math inline\">\\(i\\)</span> 树上存在过的所有元素。</p>\n<p>对于比 <span class=\"math inline\">\\(x\\)</span> 大的元素，考虑祖先 <span class=\"math inline\">\\(p_a\\)</span> 和非祖先 <span class=\"math inline\">\\(p\\)</span> 有什么区别。根据 BST 的性质易得，对于最低的右侧祖先 <span class=\"math inline\">\\({p_a}_0\\)</span>，其是 <span class=\"math inline\">\\(\\ge x\\)</span> 的最小的元素（当然其加入时刻 <span class=\"math inline\">\\(t_a&lt;t_0\\)</span>）；那么同理可以找到 <span class=\"math inline\">\\({p_a}_0\\)</span> 右侧最低的祖先（其左侧的祖先显然也 <span class=\"math inline\">\\(x\\)</span> 左侧），该祖先满足 <span class=\"math inline\">\\(t&lt;t_a\\)</span>。那么我们就从左右两边分别得到 <span class=\"math inline\">\\(x\\)</span> 的所有祖先。容易证明该过程对于不在树上的 <span class=\"math inline\">\\(x\\)</span> 也是正确的。</p>\n<p>具体地，我们需要一个数据结构，能够求出 <span class=\"math inline\">\\(\\ge x\\)</span> 的元素中，以 <span class=\"math inline\">\\(t_0\\)</span> 为起点的前缀最小值序列的区间和。</p>\n<p>欸 ☝🤓 这是什么？<a href=\"/20250217\">楼房重建</a>！秒一下！</p>\n<p>进一步地，本题需要完成对于 <span class=\"math inline\">\\(t_0\\)</span> 为序列头的查询。再次利用性质，每次 <span class=\"math inline\">\\(O(\\log V)\\)</span> 地合并答案。</p>\n<p>好的那么怎么把链搞到树上呢？把差分放到树上，写个线段树合并即可。</p>\n<p><strong>注意由于这题细节太多了，所以你可能需要舍弃不必要的时空优化换取代码简洁度以方便调试。</strong></p>\n<details>\n<pre data-line=\"12\" class=\"cpp language-cpp\"><code data-line=\"12\" class=\"cpp language-cpp\">#include &lt;bits/stdc++.h&gt;\nconst int lim = 2e5;\nconst int maxn = 2e7 + 5;\nconst int inf = 0x3f3f3f3f;\nstruct &#123;\n    int l, r, rv;\n    long long u;\n&#125; t[maxn];\nstd::vector&lt;int> tr;\n#define lt t[p].l\n#define rt t[p].r\nint newnode(void) &#123;         // 我知道你要说什么，但这属于「必要的」空间优化 😥\n    static int tot = 0;\n    if (tr.empty())\n        return ++tot;\n    auto p(tr.back());\n    t[p].l = t[p].r = 0;\n    tr.pop_back();\n    return p;\n&#125;\nlong long askv(int p, int l, int r, int v) &#123;\n    if (l == r)\n        return t[p].rv < v ? t[p].u : 0;\n    int mid = (l + r) >> 1;\n    if (v > t[lt].rv)\n        return t[p].u - t[lt].u + askv(lt, l, mid, v);\n    return askv(rt, mid + 1, r, v);\n&#125;\nvoid pushup(int p, int l, int r) &#123;\n    t[p].rv = std::min(t[lt].rv, t[rt].rv);\n    int mid = (l + r) >> 1;\n    t[p].u = t[lt].u + askv(rt, mid + 1, r, t[lt].rv);\n    return;\n&#125;\nvoid upd(int &p, int l, int r, int x, int v, int u) &#123;\n    if (!p)\n        p = newnode();\n    if (l == r) &#123;\n        t[p].rv = v, t[p].u = u;\n        return;\n    &#125;\n    int mid = (l + r) >> 1;\n    if (x <= mid)\n        upd(lt, l, mid, x, v, u);\n    else\n        upd(rt, mid + 1, r, x, v, u);\n    pushup(p, l, r);\n    return;\n&#125;\nvoid merge(int &p, int q, int l, int r) &#123;\n    if (!p || !q) &#123;\n        p += q;\n        return;\n    &#125;\n    if (l == r) &#123;\n        t[p].rv = std::min(t[p].rv, t[q].rv);\n        t[p].u = std::max(t[p].u, t[q].u);\n        return;\n    &#125;\n    int mid = (l + r) >> 1;\n    merge(t[p].l, t[q].l, l, mid), merge(t[p].r, t[q].r, mid + 1, r);\n    pushup(p, l, r), tr.push_back(q);\n    return;\n&#125;\nint qv = inf;\nlong long ask(int p, int l, int r, int ql, int qr) &#123;\n    if (ql <= l && r <= qr) &#123;\n        auto s(askv(p, l, r, qv));\n        qv = std::min(qv, t[p].rv);\n        return s;\n    &#125;\n    int mid = (l + r) >> 1;\n    long long res = 0ll;\n    if (ql <= mid)\n        res = ask(lt, l, mid, ql, qr);\n    if (qr > mid)\n        res += ask(rt, mid + 1, r, ql, qr);\n    return res;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(\"ex_problem4.in\", \"r\", stdin);\n    std::freopen(\".out\", \"w\", stdout);\n#endif\n    int n, m;\n    std::cin >> n >> m;\n    std::vector&lt;std::vector&lt;int> > g(n + 1);\n    for (int i = 1, x, y; i < n; ++i) &#123;\n        std::cin >> x >> y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int> top(n + 1), fa(n + 1), siz(n + 1), son(n + 1), dep(n + 1);\n    std::function&lt;void(int, int)> DFS = [&](int x, int faa) &#123;\n        siz[x] = 1;\n        for (auto i : g[x])\n            if (i != faa) &#123;\n                fa[i] = x, dep[i] = dep[x] + 1;\n                DFS(i, x), siz[x] += siz[i];\n                if (siz[i] > siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1, -1);\n    DFS = [&](int x, int topp) &#123;\n        top[x] = topp;\n        if (son[x])\n            DFS(son[x], topp);\n        for (auto i : g[x])\n            if (i != fa[x] && i != son[x])\n                DFS(i, i);\n        return;\n    &#125;;\n    DFS(1, 1);\n    auto getLCA = [&](int x, int y) &#123;\n        for (; top[x] != top[y]; x = fa[top[x]])\n            if (dep[top[y]] > dep[top[x]])\n                std::swap(x, y);\n        return (dep[x] < dep[y] ? x : y);\n    &#125;;\n    std::vector&lt;std::vector&lt;int> > d(n + 1);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int> > > u(n + 1);\n    std::vector&lt;std::vector&lt;std::tuple&lt;int, int, int> > > q(n + 1);\n    int cnt = 0;\n    for (int i = 1; i <= m; ++i) &#123;\n        int op;\n        std::cin >> op;\n        if (op == 0) &#123;\n            int x, v;\n            std::cin >> x >> v;\n            q[x].emplace_back(++cnt, i, v);\n        &#125; else &#123;\n            int x, y, v;\n            std::cin >> x >> y >> v;\n            int faa = getLCA(x, y);\n            u[x].emplace_back(i, v), u[y].emplace_back(i, v);\n            if (fa[faa])\n                d[fa[faa]].emplace_back(v);\n        &#125;\n    &#125;\n    std::vector&lt;long long> res(cnt + 1);\n    std::vector&lt;std::vector&lt;int> > rt(2, std::vector&lt;int> (n + 1));\n    t[0].rv = inf;\n    DFS = [&](int x, int fa) &#123;\n        for (auto i : g[x])\n            if (i != fa) &#123;\n                DFS(i, x);\n                merge(rt[0][x], rt[0][i], 1, lim);\n                merge(rt[1][x], rt[1][i], 1, lim);\n            &#125;\n        for (auto [t, v] : u[x]) &#123;\n            upd(rt[0][x], 1, lim, v, t, v);\n            upd(rt[1][x], 1, lim, lim - v + 1, t, v);\n        &#125;\n        for (auto v : d[x]) &#123;\n            upd(rt[0][x], 1, lim, v, inf, 0);\n            upd(rt[1][x], 1, lim, lim - v + 1, inf, 0);\n        &#125;\n        for (auto [id, t, v] : q[x]) &#123;\n            qv = t, res[id] = ask(rt[0][x], 1, lim, v, lim);\n            qv = t, res[id] += ask(rt[1][x], 1, lim, lim - v + 1, lim);\n            qv = t, res[id] -= ask(rt[0][x], 1, lim, v, v);\n        &#125;\n    &#125;;\n    DFS(1, -1);\n    for (int i = 1; i <= cnt; ++i)\n        std::cout << res[i] << '\\n';\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "线段树",
                "数学",
                "树上差分"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250202/",
            "url": "https://xsc062.netlify.app/20250202/",
            "title": "学习笔记：后缀数组",
            "date_published": "2025-02-02T00:27:44.000Z",
            "content_html": "<p>非常后知后觉地意识到 SA(Suffix Array) 和 SAM(Suffix Automaton) 的 A 不是同一个 A <img src=\"/em/fad.gif\" /></p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"定义\">定义</h2>\n<p>显而易见一个长度为 <span class=\"math inline\">\\(n\\)</span> 的字符串中有 <span class=\"math inline\">\\(n\\)</span> 个长度分别为 <span class=\"math inline\">\\(1\\sim n\\)</span> 的后缀，如果我们对其按字典序排序，分别存储下排名 <span class=\"math inline\">\\(i\\)</span> 的后缀 <span class=\"math inline\">\\(sa_i\\)</span> 和每个后缀 <span class=\"math inline\">\\(i\\)</span> 的排名 <span class=\"math inline\">\\(rk_i\\)</span>。虽然看着挺没头没尾的，但是很有用。</p>\n<h2 id=\"求解\">求解</h2>\n<h3 id=\"哈希-排序\">哈希 + 排序</h3>\n<p>直接把所有后缀拿来排序的话，字符串比较是 <span class=\"math inline\">\\(O(n)\\)</span> 的。如果我们用哈希 + 二分优化比较过程，就可以把整个排序优化到 <span class=\"math inline\">\\(O(n\\log^2 n)\\)</span>。</p>\n<h3 id=\"倍增\">倍增</h3>\n<p>先对所有后缀按 <strong>第一个字符</strong> 排序，记排序后排名序列为 <span class=\"math inline\">\\(a\\)</span>。</p>\n<p>那么怎么按 <strong>前两个字符</strong> 排序呢？对于第 <span class=\"math inline\">\\(i\\)</span> 组字符，我们用 <span class=\"math inline\">\\((a_i,a_{i+1})\\)</span> 双关键字排序即可。记此时排名序列为 <span class=\"math inline\">\\(b\\)</span>，那么如果需要按照前四个字符排序，用 <span class=\"math inline\">\\((b_i,b_{i+2})\\)</span> 进行双关键字排序即可。总共需要进行 <span class=\"math inline\">\\(\\log n\\)</span> 次排序。复杂度为 <span class=\"math inline\">\\(O(n\\log^2n)\\)</span>。</p>\n<p>此时我们注意到排名数组的值域为 <span class=\"math inline\">\\(n\\)</span>，那么我们用桶排就能少一个 <span class=\"math inline\">\\(\\log\\)</span>。</p>\n<h2 id=\"实现\">实现</h2>\n<p>哈希很好实现，这里就按下不表，主要讲解倍增法的实现。</p>\n<p>描述起来很简单，实现起来很要命。OI wiki 上的实现算是相对好理解的：</p>\n<p>首先了解双关键字桶排的方法，首先用单关键字桶排完成对 <strong>第二关键字</strong> 的排序；对于第一关键字，令桶 <span class=\"math inline\">\\(i\\)</span> 记录前 <span class=\"math inline\">\\(i\\)</span> 个元素的数量；遍历排序后的第二关键字数组，将元素放到桶中记录数值对应的下标中，并将桶中数值 <span class=\"math inline\">\\(-1\\)</span>。实际上桶 <span class=\"math inline\">\\(c\\)</span> 充当计算下标范围的作用，<span class=\"math inline\">\\((c_{i-1},c_i]\\)</span> 即为 <span class=\"math inline\">\\(i\\)</span> 分布的范围。</p>\n<p>显然，当且仅当排名种类为 <span class=\"math inline\">\\(n\\)</span>，即没有并列排名时，排序完成。设本轮区间长度为 <span class=\"math inline\">\\(w\\)</span>，对于一轮操作：</p>\n<ol type=\"1\">\n<li>计算每个区间按后半段 <span class=\"math inline\">\\(\\frac w2\\)</span> 长度字符排序的结果：<span class=\"math inline\">\\((n-w,n]\\)</span> 开头的区间后半段均为空，直接放在序列首端；接着按照上一轮 <span class=\"math inline\">\\(sa\\)</span> 结果，把能够作为后半段的元素依次放入。</li>\n<li>依照上一轮的 <span class=\"math inline\">\\(rk\\)</span> 作为前半段排名，进行双关键字桶排。</li>\n<li>依照 <span class=\"math inline\">\\(sa\\)</span> 和第二关键字（处理并列），求出 <span class=\"math inline\">\\(rk\\)</span>。</li>\n</ol>\n<details>\n<pre class=\"cpp\"><code>std::vector&lt;int&gt; la(n + 2);\nstd::copy(s.begin(), s.end(), rk.begin());\nint m = 128;\n&#123;\n    std::vector&lt;int&gt; c(m + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        ++c[rk[i]];\n    std::partial_sum(c.begin(), c.end(), c.begin());\n    for (int i = n; i; --i)\n        sa[c[rk[i]]--] = i;\n&#125; \nfor (int w = 1, p; ; w &lt;&lt;= 1, m = p) &#123;\n    std::vector&lt;int&gt; id(1);\n    for (int i = n - w + 1; i &lt;= n; ++i)\n        id.push_back(i);\n    for (int i = 1; i &lt;= n; ++i)\n        if (sa[i] &gt; w)\n            id.push_back(sa[i] - w);\n    std::vector&lt;int&gt; c(m + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        ++c[rk[i]];\n    std::partial_sum(c.begin(), c.end(), c.begin());\n    for (int i = n; i; --i)\n        sa[c[rk[id[i]]]--] = id[i];\n    p = 0;\n    std::copy(rk.begin(), rk.end(), la.begin());\n    for (int i = 1; i &lt;= n; ++i)\n        if (la[sa[i]] == la[sa[i - 1]] &amp;&amp; la[sa[i] + w] == la[sa[i - 1] + w])\n            rk[sa[i]] = p;\n        else\n            rk[sa[i]] = ++p;\n    if (p == n)\n        break;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"纯-sa-的应用\">纯 SA 的应用</h2>\n<h3 id=\"最小表示法\">最小表示法</h3>\n<p>模板：<a href=\"https://www.luogu.com.cn/problem/P1368\" class=\"uri\">https://www.luogu.com.cn/problem/P1368</a>。</p>\n<p>对于循环位移相关要求，首先考虑将字符串重复一遍。</p>\n<p>在 <span class=\"math inline\">\\(ss\\)</span> 中找到排名第一个 <span class=\"math inline\">\\(sa_i\\le n\\)</span> 即为答案。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; s(2 * n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; s[i], s[n + i] = s[i];\n    std::vector&lt;int&gt; sa(2 * n + 1), rk(s);\n    &#123;\n        int m = 29;\n        &#123;\n            std::vector&lt;int&gt; c(m + 1);\n            for (int i = 1; i &lt;= 2 * n; ++i)\n                ++c[rk[i]];\n            std::partial_sum(c.begin(), c.end(), c.begin());\n            for (int i = 2 * n; i; --i)\n                sa[c[rk[i]]--] = i;\n        &#125;\n        for (int w = 1, p; ; w &lt;&lt;= 1, m = p) &#123;\n            std::vector&lt;int&gt; id(1);\n            for (int i = 2 * n - w + 1; i &lt;= 2 * n; ++i)\n                id.push_back(i);\n            for (int i = 1; i &lt;= 2 * n; ++i)\n                if (sa[i] &gt; w)\n                    id.push_back(sa[i] - w);\n            std::vector&lt;int&gt; c(m + 1);\n            for (int i = 1; i &lt;= 2 * n; ++i)\n                ++c[rk[i]];\n            std::partial_sum(c.begin(), c.end(), c.begin());\n            for (int i = 2 * n; i; --i)\n                sa[c[rk[id[i]]]--] = id[i];\n            auto la(rk);\n            p = 0;\n            for (int i = 1; i &lt;= 2 * n; ++i)\n                if (i != 1 &amp;&amp; la[sa[i]] == la[sa[i - 1]] &amp;&amp; la[sa[i] + w] == la[sa[i - 1] + w])\n                    rk[sa[i]] = p;\n                else\n                    rk[sa[i]] = ++p;\n            if (p == 2 * n)\n                break;\n        &#125;\n    &#125;\n    for (int i = 1; i &lt;= 2 * n; ++i)\n        if (sa[i] &lt;= n) &#123;\n            for (int j = sa[i]; j &lt; n + sa[i]; ++j)\n                std::cout &lt;&lt; s[j] &lt;&lt; &#39; &#39;;\n            std::cout &lt;&lt; &#39;\\n&#39;;\n            break;\n        &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"字符串匹配\">字符串匹配</h3>\n<p>二分，复杂度 <span class=\"math inline\">\\(O(|S|\\log |T|)\\)</span>。求出现次数则二分左右边界。</p>\n<p>太麻烦了且没有实际应用价值，代码略。</p>\n<hr />\n<h2 id=\"height-数组\">height 数组</h2>\n<p>定义 <span class=\"math inline\">\\(h_i=\\text {lcp}(sa_i, sa_i-1)\\)</span>，特别地，<span class=\"math inline\">\\(h_1=0\\)</span>。</p>\n<blockquote>\n<p>有引理：<span class=\"math inline\">\\(h_{rk_i}\\ge h_{rk_{i-1}}-1\\)</span>。</p>\n</blockquote>\n<p>假设已经求出 <span class=\"math inline\">\\(h_{rk_{i-1}}\\)</span>，那么可以从 <span class=\"math inline\">\\(h_{rk_{i-1}}-1\\)</span> 出发暴力看下一个字符是否相等得到答案。那么我们会发现从前往后 <span class=\"math inline\">\\(h\\)</span> 值每次最多 <span class=\"math inline\">\\(-1\\)</span>，所以复杂度摊下来是 <span class=\"math inline\">\\(O(n)\\)</span> 的。</p>\n<p><mark>记住记住一定是 <span class=\"math inline\">\\(rk_{i-1}\\)</span> 而不是下意识的 <span class=\"math inline\">\\(rk_i-1\\)</span>！！！</mark>所以为了保证求解顺序循环枚举的一定是下标而非排名。但是注意定义却是和 <span class=\"math inline\">\\(rk_i-1\\)</span> 的 lcp！！！所以求 height 的写法是相对固定的，不能觉得好像是对的就随便乱改。</p>\n<hr />\n<h2 id=\"height-数组的应用\">height 数组的应用</h2>\n<p>相当于背板子，因为应用太多且形式大多固定。</p>\n<h3 id=\"求任意两个后缀的-lcp\">求任意两个后缀的 lcp</h3>\n<p>易得 <span class=\"math inline\">\\(\\text{lcp}(sa_i, sa_j)=\\min\\{h_{i+1}, \\cdots, h_j\\}\\)</span>。<strong>故应将一些复杂 lcp 问题的解决方式和 RMQ 联系起来</strong>。</p>\n<hr />\n<h3 id=\"子串大小关系\">子串大小关系</h3>\n<p>即比较 <span class=\"math inline\">\\(S_{l_1, r_1}\\)</span> 和 <span class=\"math inline\">\\(S_{l_2, r_2}\\)</span> 的大小关系。比较导致 lcp 不能继续延伸的元素大小即可。</p>\n<hr />\n<h3 id=\"本质不同子串数量\">本质不同子串数量</h3>\n<p><strong>子串等价于「后缀的前缀」</strong>。按顺序枚举每个后缀，减去和已枚举的所有后缀的 lcp 即可。鉴于 <span class=\"math inline\">\\(\\min\\{h_{j+1},\\cdots,h_i\\}\\)</span> 单调不减，直接减去 <span class=\"math inline\">\\(h_i\\)</span> 即可。</p>\n<p>最后答案即为 <span class=\"math inline\">\\(\\frac {n(n-1)}2 - \\sum\\limits_{i=2}^nh_i\\)</span>。</p>\n<hr />\n<h3 id=\"至少出现-k-次子串的最大长度\">至少出现 <span class=\"math inline\">\\(k\\)</span> 次子串的最大长度</h3>\n<p>模板：<a href=\"https://www.luogu.com.cn/problem/P2852\" class=\"uri\">https://www.luogu.com.cn/problem/P2852</a>。</p>\n<p>出现 <span class=\"math inline\">\\(k\\)</span> 次 <span class=\"math inline\">\\(\\iff\\)</span> 在后缀数组中连续出现 <span class=\"math inline\">\\(k\\)</span> 次 <span class=\"math inline\">\\(\\iff\\)</span> 是任意连续 <span class=\"math inline\">\\(k-1\\)</span> 个 <span class=\"math inline\">\\(h\\)</span> 的最小值，需要最大化该最小值，考虑滑动窗口。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;P2852_7.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k, --k;\n    std::vector&lt;int&gt; s(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; s[i];\n    std::vector&lt;int&gt; sa(n + 1), rk(s), h(n + 1);\n    &#123;\n        int m = 1000001;\n        &#123;\n            std::vector&lt;int&gt; c(m + 1);\n            for (int i = 1; i &lt;= n; ++i)\n                ++c[rk[i]];\n            std::partial_sum(c.begin(), c.end(), c.begin());\n            for (int i = n; i; --i)\n                sa[c[rk[i]]--] = i;\n        &#125;\n        for (int w = 1, p; ; w &lt;&lt;= 1, m = p) &#123;\n            std::vector&lt;int&gt; id(1);\n            for (int i = n - w + 1; i &lt;= n; ++i)\n                id.push_back(i);\n            for (int i = 1; i &lt;= n; ++i)\n                if (sa[i] &gt; w)\n                    id.push_back(sa[i] - w);\n            std::vector&lt;int&gt; c(m + 1);\n            for (int i = 1; i &lt;= n; ++i)\n                ++c[rk[i]];\n            std::partial_sum(c.begin(), c.end(), c.begin());\n            for (int i = n; i; --i)\n                sa[c[rk[id[i]]]--] = id[i];\n            auto la(rk);\n            p = 0;\n            for (int i = 1; i &lt;= n; ++i)\n                if (i != 1 &amp;&amp; la[sa[i]] == la[sa[i - 1]] &amp;&amp; la[sa[i] + w] == la[sa[i - 1] + w])\n                    rk[sa[i]] = p;\n                else\n                    rk[sa[i]] = ++p;\n            if (p == n)\n                break;\n        &#125;\n        for (int i = 1, to = 0; i &lt;= n; ++i)\n            if (rk[i]) &#123;\n                for (to = std::max(to - 1, 0); s[i + to] == s[sa[rk[i] - 1] + to]; ++to);\n                h[rk[i]] = to;\n            &#125;\n    &#125;\n    std::vector&lt;int&gt; q(n + 1);\n    int res = 0;\n    for (int i = 1, l = 1, r = 0; i &lt;= n; ++i) &#123;\n        // printf(&quot;%d\\n&quot;, h[i]);\n        for (; l &lt;= r &amp;&amp; i - q[l] &gt;= k; ++l);\n        for (; l &lt;= r &amp;&amp; h[i] &lt;= h[q[r]]; --r);\n        q[++r] = i;\n        if (i &gt;= k)\n            res = std::max(res, h[q[l]]);\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"最长不重叠多次出现子串\">最长不重叠多次出现子串</h3>\n<p><del>bb：定式太多太杂以至于让人怀疑某些定式是否存在应用场景</del> <img src=\"/em/kt.gif\" /></p>\n<p>发现满足单调性，二分子串长度 <span class=\"math inline\">\\(len\\)</span>，那么显然 <span class=\"math inline\">\\(\\text {lcp}\\ge len\\)</span>；将 <span class=\"math inline\">\\(h\\)</span> 划分为连续 <span class=\"math inline\">\\(\\ge len\\)</span> 的段，在每段内找到下标极差与 <span class=\"math inline\">\\(len\\)</span> 比较即可。</p>\n<p>也可以用于判定是否存在不重叠多次出现子串。</p>\n<p>甚至可以考虑限制至少出现次数为 <span class=\"math inline\">\\(k\\)</span>，那大概多个 <span class=\"math inline\">\\(\\log\\)</span>，看看一段里有没有 <span class=\"math inline\">\\(\\ge k\\)</span> 个相互相差 <span class=\"math inline\">\\(\\ge len\\)</span> 的。排序贪心求解。</p>\n<p>那么上面的至少出现 <span class=\"math inline\">\\(k\\)</span> 次子串也可以用这个方法来解，但是多个 <span class=\"math inline\">\\(\\log\\)</span> 没必要。</p>\n<p>也可以限制多次出现但长度至少为 <span class=\"math inline\">\\(len\\)</span>，那甚至少了二分的 <span class=\"math inline\">\\(\\log\\)</span>，直接跑一遍 check 即可。</p>\n<p><del>？？？到底为什么会有这么多奇怪的定式，是因为真的有题这么出吗？？？</del> <img src=\"/em/oh.gif\" /></p>\n<hr />\n<h3 id=\"最长公共子串问题\">最长公共子串问题</h3>\n<p>求 <span class=\"math inline\">\\(S\\)</span> 和 <span class=\"math inline\">\\(T\\)</span> 的最长公共子串（注意不是 LCS）。设 <span class=\"math inline\">\\(S\\)</span> 长为 <span class=\"math inline\">\\(n\\)</span>，<span class=\"math inline\">\\(T\\)</span> 长为 <span class=\"math inline\">\\(m\\)</span>，那么将 <span class=\"math inline\">\\(S\\)</span> 与 <span class=\"math inline\">\\(T\\)</span> 拼接，答案就是 <span class=\"math inline\">\\(\\max \\{\\text{lcp}(i,j)\\},i\\le n&lt;j\\)</span>。</p>\n<p>但这里不直接枚举 <span class=\"math inline\">\\(i\\)</span> 和 <span class=\"math inline\">\\(j\\)</span>，还是照例先从 <span class=\"math inline\">\\(h\\)</span> 下手再卡条件，若 <span class=\"math inline\">\\(sa_{i-1}\\le n&lt;sa_{i}\\)</span>（或者反过来），就可以用 <span class=\"math inline\">\\(h_i\\)</span> 更新答案。容易证明这样总可以找到最大值。</p>\n<h4 id=\"eg1.-找相同字符\">eg1. 找相同字符</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P3181\" class=\"uri\">https://www.luogu.com.cn/problem/P3181</a></p>\n<p>要求方案数，那么答案为 <span class=\"math inline\">\\(\\text{lcp}(i,j),i\\le n&lt;j\\)</span>。（我已经帮你们试过了容斥比直接做更麻烦），考虑用单调栈维护左 / 右侧区间 lcp 求解右 / 左侧答案。关于单调栈的描述可见 <a href=\"#结合单调栈\">本页后部内容</a>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, n1;\n    std::string s, t;\n    std::cin &gt;&gt; s &gt;&gt; t;\n    n = (int)s.length(), n1 = n + (int)t.length() + 1;\n    s = &quot;#&quot; + s + &quot;$&quot; + t;\n    std::vector&lt;int&gt; sa(n1 + 1), rk(n1 + 1), h(n1 + 1);\n    &#123;\n        std::copy(s.begin() + 1, s.end(), rk.begin() + 1);\n        int m = 128;\n        &#123;\n            std::vector&lt;int&gt; c(m + 1);\n            for (int i = 1; i &lt;= n1; ++i)\n                ++c[rk[i]];\n            std::partial_sum(c.begin(), c.end(), c.begin());\n            for (int i = n1; i; --i)\n                sa[c[rk[i]]--] = i;\n        &#125;\n        for (int w = 1, p; ; w &lt;&lt;= 1, m = p) &#123;\n            std::vector&lt;int&gt; id(w + 1);\n            std::iota(id.begin() + 1, id.end(), n1 - w + 1);\n            for (int i = 1; i &lt;= n1; ++i)\n                if (sa[i] &gt; w)\n                    id.push_back(sa[i] - w);\n            std::vector&lt;int&gt; c(m + 1);\n            for (int i = 1; i &lt;= n1; ++i)\n                ++c[rk[i]];\n            std::partial_sum(c.begin(), c.end(), c.begin());\n            for (int i = n1; i; --i)\n                sa[c[rk[id[i]]]--] = id[i];\n            p = 0;\n            auto la(rk);\n            for (int i = 1; i &lt;= n1; ++i)\n                if (i != 1 &amp;&amp; la[sa[i]] == la[sa[i - 1]] &amp;&amp; la[sa[i] + w] == la[sa[i - 1] + w])\n                    rk[sa[i]] = p;\n                else\n                    rk[sa[i]] = ++p;\n            if (p == n1)\n                break;\n        &#125;\n        for (int i = 1, to = 0; i &lt;= n1; ++i) &#123;\n            for (to = std::max(to - 1, 0); s[i + to] == s[sa[rk[i] - 1] + to]; ++to);\n            h[rk[i]] = to;\n        &#125;\n    &#125;\n    std::vector&lt;std::pair&lt;int, long long&gt; &gt; q1, q2;\n    std::vector&lt;int&gt; tot1(n1 + 1), tot2(n1 + 1);\n    for (int i = 1; i &lt;= n1; ++i) &#123;\n        tot1[i] = tot1[i - 1] + (sa[i] &lt;= n);\n        tot2[i] = tot2[i - 1] + (sa[i] &gt; n + 1);\n    &#125;\n    long long res = 0ll;\n    q1.emplace_back(1, 0ll), q2.emplace_back(1, 0ll);\n    for (int i = 1; i &lt;= n1; ++i) &#123;\n        for (; !q1.empty() &amp;&amp; h[i] &lt; h[q1.back().first]; q1.pop_back());\n        q1.emplace_back(i, (tot1[i - 1] - tot1[q1.back().first - 1]) * h[i] + q1.back().second);\n        if (sa[i] &gt; n + 1)\n            res += q1.back().second;\n        for (; !q2.empty() &amp;&amp; h[i] &lt; h[q2.back().first]; q2.pop_back());\n        q2.emplace_back(i, (tot2[i - 1] - tot2[q2.back().first - 1]) * h[i] + q2.back().second);\n        if (sa[i] &lt;= n)\n            res += q2.back().second;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<h4 id=\"eg2.-公共串\">eg2. 公共串</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P5546\" class=\"uri\">https://www.luogu.com.cn/problem/P5546</a></p>\n<p>要求多串最长公共子串，仍然考虑将多个串拼在一起。仿照前面二分的方式处理，问题转化为找到最长的 <span class=\"math inline\">\\(len\\)</span>，使得存在一段最小值 <span class=\"math inline\">\\(\\ge len\\)</span> 的区间，其覆盖了 <span class=\"math inline\">\\(n\\)</span> 段串。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, l = 0, r = 0;\n    std::cin &gt;&gt; n;\n    std::string s;\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; lim(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::string t;\n        std::cin &gt;&gt; t;\n        lim[i] = &#123; (int)s.length() + 1, s.length() + t.length() &#125;;\n        s += &quot;#&quot; + t;\n        r = std::max(r, (int)t.length());\n        // printf(&quot;[%d, %d]\\n&quot;, lim[i].first, lim[i].second);\n    &#125;\n    int n1 = lim.back().second;\n    std::vector&lt;int&gt; sa(n1 + 1), rk(n1 + 1), h(n1 + 1);\n    &#123;\n        std::copy(s.begin() + 1, s.end(), rk.begin() + 1);\n        int m = 128;\n        &#123;\n            std::vector&lt;int&gt; c(m + 1);\n            for (int i = 1; i &lt;= n1; ++i)\n                ++c[rk[i]];\n            std::partial_sum(c.begin(), c.end(), c.begin());\n            for (int i = n1; i; --i)\n                sa[c[rk[i]]--] = i;\n        &#125;\n        for (int w = 1, p; ; w &lt;&lt;= 1, m = p) &#123;\n            std::vector&lt;int&gt; id(w + 1);\n            std::iota(id.begin() + 1, id.end(), n1 - w + 1);\n            for (int i = 1; i &lt;= n1; ++i)\n                if (sa[i] &gt; w)\n                    id.push_back(sa[i] - w);\n            std::vector&lt;int&gt; c(m + 1);\n            for (int i = 1; i &lt;= n1; ++i)\n                ++c[rk[i]];\n            std::partial_sum(c.begin(), c.end(), c.begin());\n            for (int i = n1; i; --i)\n                sa[c[rk[id[i]]]--] = id[i];\n            p = 0;\n            auto la(rk);\n            for (int i = 1; i &lt;= n1; ++i)\n                if (i != 1 &amp;&amp; la[sa[i]] == la[sa[i - 1]] &amp;&amp; la[sa[i] + w] == la[sa[i - 1] + w])\n                    rk[sa[i]] = p;\n                else\n                    rk[sa[i]] = ++p;\n            if (p == n1)\n                break;\n        &#125;\n        for (int i = 1, to = 0; i &lt;= n1; ++i) &#123;\n            for (to = std::max(to - 1, 0); s[i + to] == s[sa[rk[i] - 1] + to]; ++to);\n            h[rk[i]] = to;\n        &#125;\n    &#125;\n    // for (int i = 1; i &lt;= n1; ++i)\n    //     printf(&quot;h[%d] = %d\\n&quot;, sa[i], h[i]);\n    int res = 0;\n    auto check = [&amp;](int len) &#123;\n        // printf(&quot;check %d: \\n&quot;, len);\n        std::vector&lt;int&gt; cnt(n + 1);\n        for (int i = 1; i &lt;= n1; ++i) &#123;\n            if (h[i] &lt; len) &#123;\n                if (*std::min_element(cnt.begin() + 1, cnt.end()))\n                    return 1;\n                cnt.assign(n + 1, 0);\n            &#125;\n            else\n                for (int j = 1; j &lt;= n; ++j) &#123;\n                    if (lim[j].first &lt;= sa[i - 1] &amp;&amp; sa[i - 1] &lt;= lim[j].second)\n                        cnt[j] = 1;\n                    if (lim[j].first &lt;= sa[i] &amp;&amp; sa[i] &lt;= lim[j].second)\n                        cnt[j] = 1;\n                &#125;\n        &#125;\n        // printf(&quot;\\n%d\\n&quot;, *std::min_element(cnt.begin() + 1, cnt.end()));\n        return *std::min_element(cnt.begin() + 1, cnt.end());\n    &#125;;\n    for (int mid; l &lt;= r; ) &#123;\n        mid = (l + r) &gt;&gt; 1;\n        if (check(mid))\n            l = mid + 1, res = mid;\n        else\n            r = mid - 1;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<p>但是看了题解发现居然还有线性做法（当然不看建 SA 的 <span class=\"math inline\">\\(\\log\\)</span>），对于覆盖全部 <span class=\"math inline\">\\(n\\)</span> 段串找区间最小值，发现需要最小化区间，考虑双指针。</p>\n<p>区间最小值用单调队列求解，细想可能会觉得不太对劲，但是容易证明答案不大于队首且不小于最大队首，所以最大队首就是答案。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, l = 0, r = 0;\n    std::cin &gt;&gt; n;\n    std::string s;\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; lim(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::string t;\n        std::cin &gt;&gt; t;\n        lim[i] = &#123; (int)s.length() + 1, s.length() + t.length() &#125;;\n        s += (char)(&#39;A&#39; + i - 1) + t;\n        r = std::max(r, (int)t.length());\n    &#125;\n    int n1 = lim.back().second;\n    std::vector&lt;int&gt; sa(n1 + 1), rk(n1 + 1), h(n1 + 1);\n    &#123;\n        std::copy(s.begin() + 1, s.end(), rk.begin() + 1);\n        int m = 128;\n        &#123;\n            std::vector&lt;int&gt; c(m + 1);\n            for (int i = 1; i &lt;= n1; ++i)\n                ++c[rk[i]];\n            std::partial_sum(c.begin(), c.end(), c.begin());\n            for (int i = n1; i; --i)\n                sa[c[rk[i]]--] = i;\n        &#125;\n        for (int w = 1, p; ; w &lt;&lt;= 1, m = p) &#123;\n            std::vector&lt;int&gt; id(w + 1);\n            std::iota(id.begin() + 1, id.end(), n1 - w + 1);\n            for (int i = 1; i &lt;= n1; ++i)\n                if (sa[i] &gt; w)\n                    id.push_back(sa[i] - w);\n            std::vector&lt;int&gt; c(m + 1);\n            for (int i = 1; i &lt;= n1; ++i)\n                ++c[rk[i]];\n            std::partial_sum(c.begin(), c.end(), c.begin());\n            for (int i = n1; i; --i)\n                sa[c[rk[id[i]]]--] = id[i];\n            p = 0;\n            auto la(rk);\n            for (int i = 1; i &lt;= n1; ++i)\n                if (i != 1 &amp;&amp; la[sa[i]] == la[sa[i - 1]] &amp;&amp; la[sa[i] + w] == la[sa[i - 1] + w])\n                    rk[sa[i]] = p;\n                else\n                    rk[sa[i]] = ++p;\n            if (p == n1)\n                break;\n        &#125;\n        for (int i = 1, to = 0; i &lt;= n1; ++i) &#123;\n            for (to = std::max(to - 1, 0); s[i + to] == s[sa[rk[i] - 1] + to]; ++to);\n            h[rk[i]] = to;\n        &#125;\n    &#125;\n    int res = 0;\n    std::vector&lt;int&gt; q(n1 + 1), cnt(n + 1);\n    // for (int i = 1; i &lt;= n1; ++i)\n    //     printf(&quot;%d: %d\\n&quot;, sa[i], h[i]);\n    for (int l = 1, r = 0, ql = 1, qr = 0; l &lt;= n1; ++l) &#123;\n        for (; r &lt; n1 &amp;&amp; !*std::min_element(cnt.begin() + 1, cnt.end()); ) &#123;\n            ++r;\n            for (int i = 1; i &lt;= n; ++i)\n                if (lim[i].first &lt;= sa[r] &amp;&amp; sa[r] &lt;= lim[i].second) &#123;\n                    ++cnt[i];\n                    break;\n                &#125;\n            for (; ql &lt;= qr &amp;&amp; h[r] &lt;= h[q[qr]]; --qr);\n            q[++qr] = r;\n        &#125;\n        if (*std::min_element(cnt.begin() + 1, cnt.end())) &#123;\n            // printf(&quot;[%d, %d]: %d\\n&quot;, l, r, h[q[ql]]);\n            res = std::max(res, h[q[ql]]);\n        &#125;\n        for (; ql &lt;= qr &amp;&amp; q[ql] &lt;= l; ++ql);\n        if (l != 1) &#123;\n            for (int i = 1; i &lt;= n; ++i)\n                if (lim[i].first &lt;= sa[l - 1] &amp;&amp; sa[l - 1] &lt;= lim[i].second) &#123;\n                    --cnt[i];\n                    break;\n                &#125;\n        &#125;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"texttt-aa-式子串处理\"><span class=\"math inline\">\\(\\texttt {AA}\\)</span> 式子串处理</h3>\n<p>即对于连续相同子串问题的处理，有一个定的思路，由例题分析。</p>\n<h4 id=\"eg1.-优秀的拆分\">eg1. 优秀的拆分</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P1117\" class=\"uri\">https://www.luogu.com.cn/problem/P1117</a></p>\n<p>还是从中间分开，按前后分别处理。这里有个 trick，我们枚举 <span class=\"math inline\">\\(\\texttt B\\)</span> 的长度 <span class=\"math inline\">\\(len\\)</span>，在 <span class=\"math inline\">\\(S\\)</span> 中每隔 <span class=\"math inline\">\\(len\\)</span> 打一个标记。那么显然，任意一个长度为 <span class=\"math inline\">\\(2\\times len\\)</span> 的子串都会经过恰好两个标记（充分的），这样就可以筛选出所有可能的串。</p>\n<p>我们枚举所有连续两个标记（总复杂度为调和级数），求它们对应后缀的 lcp 和对应前缀的 lcs（翻转求 SA 即可），如果二者加起来 <span class=\"math inline\">\\(\\ge len\\)</span> 就说明存在这样的 <span class=\"math inline\">\\(\\texttt {AA}\\)</span>。在 <span class=\"math inline\">\\(\\text {lcs}+\\text {lcp}\\)</span> 中任取 <span class=\"math inline\">\\(len\\)</span> 长度即为一对 <span class=\"math inline\">\\(\\texttt {AA}\\)</span>。用差分给可能的起点和终点区间加即可。</p>\n<p>小细节：lcp 和 lcs 均需要对 <span class=\"math inline\">\\(len\\)</span> 取 <span class=\"math inline\">\\(\\min\\)</span>，否则取到的串可能不会经过当前选中的两个标记。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nclass SA &#123;\npublic:\n    std::vector&lt;int&gt; sa, rk, h;\n    std::vector&lt;std::vector&lt;int&gt;  &gt; st;\n    SA(int n, std::string s): sa(n + 1), rk(n + 2), h(n + 1), st(20, std::vector&lt;int&gt; (n + 1)) &#123;\n        std::vector&lt;int&gt; la(n + 2);\n        std::copy(s.begin(), s.end(), rk.begin());\n        int m = 128;\n        &#123;\n            std::vector&lt;int&gt; c(m + 1);\n            for (int i = 1; i &lt;= n; ++i)\n                ++c[rk[i]];\n            std::partial_sum(c.begin(), c.end(), c.begin());\n            for (int i = n; i; --i)\n                sa[c[rk[i]]--] = i;\n        &#125;\n        for (int w = 1, p; ; w &lt;&lt;= 1, m = p) &#123;\n            std::vector&lt;int&gt; id(1);\n            for (int i = n - w + 1; i &lt;= n; ++i)\n                id.push_back(i);\n            for (int i = 1; i &lt;= n; ++i)\n                if (sa[i] &gt; w)\n                    id.push_back(sa[i] - w);\n            std::vector&lt;int&gt; c(m + 1);\n            for (int i = 1; i &lt;= n; ++i)\n                ++c[rk[i]];\n            std::partial_sum(c.begin(), c.end(), c.begin());\n            for (int i = n; i; --i)\n                sa[c[rk[id[i]]]--] = id[i];\n            p = 0;\n            std::copy(rk.begin(), rk.end(), la.begin());\n            for (int i = 1; i &lt;= n; ++i)\n                if (la[sa[i]] == la[sa[i - 1]] &amp;&amp; la[sa[i] + w] == la[sa[i - 1] + w])\n                    rk[sa[i]] = p;\n                else\n                    rk[sa[i]] = ++p;\n            if (p == n)\n                break;\n        &#125;\n        for (int i = 1, to = 0; i &lt;= n; ++i)\n            if (rk[i]) &#123;\n                for (to = std::max(to - 1, 0); s[i + to] == s[sa[rk[i] - 1] + to]; ++to);\n                h[rk[i]] = to;\n            &#125;\n        for (int i = 1; i &lt;= n; ++i)\n            st[0][i] = h[i];\n        for (int j = 1; (1 &lt;&lt; j) &lt;= n; ++j)\n            for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i)\n                st[j][i] = std::min(st[j - 1][i], st[j - 1][i + (1 &lt;&lt; (j - 1))]);\n        rk.emplace_back();\n        return;\n    &#125;\nprivate:\n    int ask(int l, int r) &#123;\n        // fprintf(stderr, &quot;l = %d, r = %d\\n&quot;, l, r);\n        int k = std::__lg(r - l + 1);\n        return std::min(st[k][l], st[k][r - (1 &lt;&lt; k) + 1]);\n    &#125;\npublic:\n    int lcp(int l, int r) &#123;\n        return ask(std::min(rk[l], rk[r]) + 1, std::max(rk[l], rk[r]));\n    &#125;\n&#125;;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        std::string s;\n        std::cin &gt;&gt; s;\n        int n = (int)s.length();\n        s = &quot;#&quot; + s;\n        SA p(n, s);\n        std::reverse(s.begin() + 1, s.end());\n        SA q(n, s);\n        std::vector&lt;int&gt; f(n + 2), g(n + 2);\n        for (int len = 1; len &lt;= n / 2; ++len)\n            for (int i = len; i + len &lt;= n; i += len) &#123;\n                int l = i, r = i + len, lcp = std::min(len, p.lcp(l, r)), lcs = std::min(len - 1, q.lcp(n - l + 2, n - r + 2));\n                if (lcp + lcs &gt;= len) &#123;\n                    int t = lcp + lcs - len + 1;\n                    // fprintf(stderr, &quot;(%d, %d), %d, %d\\n&quot;, l, r, lcp, lcs);\n                    ++g[l - lcs], --g[l - lcs + t], ++f[r + lcp - t], --f[r + lcp];\n                &#125;\n            &#125;\n        std::partial_sum(f.begin(), f.end(), f.begin());\n        std::partial_sum(g.begin(), g.end(), g.begin());\n        long long res = 0ll;\n        for (int i = 1; i &lt; n; ++i)\n            res += (long long)f[i] * g[i + 1];\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h4 id=\"eg2.-tandem\">eg2. tandem</h4>\n<p><a href=\"https://www.codechef.com/problems/TANDEM\" class=\"uri\">https://www.codechef.com/problems/TANDEM</a></p>\n<p>注意到多了一个限制，前一个好处理，找到经过 <span class=\"math inline\">\\(3\\)</span> 个标记的串即可。对于后一个限制，画图可以发现对于 interesting ones，每次只会出现最多一个；当且仅当 <span class=\"math inline\">\\(\\text {lcp}&gt;len\\)</span> 时不存在。</p>\n<p>对于 uninteresting ones，用每次能提供的总数减去 interesting ones 的数量即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nclass SA &#123;\npublic:\n    std::vector&lt;int&gt; sa, rk, h;\n    std::vector&lt;std::vector&lt;int&gt;  &gt; st;\n    SA(int n, std::string s): sa(n + 1), rk(n + 2), h(n + 1), st(20, std::vector&lt;int&gt; (n + 1)) &#123;\n        std::vector&lt;int&gt; la(n + 2);\n        std::copy(s.begin(), s.end(), rk.begin());\n        int m = 128;\n        &#123;\n            std::vector&lt;int&gt; c(m + 1);\n            for (int i = 1; i &lt;= n; ++i)\n                ++c[rk[i]];\n            std::partial_sum(c.begin(), c.end(), c.begin());\n            for (int i = n; i; --i)\n                sa[c[rk[i]]--] = i;\n        &#125;\n        for (int w = 1, p; ; w &lt;&lt;= 1, m = p) &#123;\n            std::vector&lt;int&gt; id(1);\n            for (int i = n - w + 1; i &lt;= n; ++i)\n                id.push_back(i);\n            for (int i = 1; i &lt;= n; ++i)\n                if (sa[i] &gt; w)\n                    id.push_back(sa[i] - w);\n            std::vector&lt;int&gt; c(m + 1);\n            for (int i = 1; i &lt;= n; ++i)\n                ++c[rk[i]];\n            std::partial_sum(c.begin(), c.end(), c.begin());\n            for (int i = n; i; --i)\n                sa[c[rk[id[i]]]--] = id[i];\n            p = 0;\n            std::copy(rk.begin(), rk.end(), la.begin());\n            for (int i = 1; i &lt;= n; ++i)\n                if (la[sa[i]] == la[sa[i - 1]] &amp;&amp; la[sa[i] + w] == la[sa[i - 1] + w])\n                    rk[sa[i]] = p;\n                else\n                    rk[sa[i]] = ++p;\n            if (p == n)\n                break;\n        &#125;\n        for (int i = 1, to = 0; i &lt;= n; ++i)\n            if (rk[i]) &#123;\n                for (to = std::max(to - 1, 0); s[i + to] == s[sa[rk[i] - 1] + to]; ++to);\n                h[rk[i]] = to;\n            &#125;\n        for (int i = 1; i &lt;= n; ++i)\n            st[0][i] = h[i];\n        for (int j = 1; (1 &lt;&lt; j) &lt;= n; ++j)\n            for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i)\n                st[j][i] = std::min(st[j - 1][i], st[j - 1][i + (1 &lt;&lt; (j - 1))]);\n        rk.emplace_back();\n        return;\n    &#125;\nprivate:\n    int ask(int l, int r) &#123;\n        // fprintf(stderr, &quot;l = %d, r = %d\\n&quot;, l, r);\n        int k = std::__lg(r - l + 1);\n        return std::min(st[k][l], st[k][r - (1 &lt;&lt; k) + 1]);\n    &#125;\npublic:\n    int lcp(int l, int r) &#123;\n        return ask(std::min(rk[l], rk[r]) + 1, std::max(rk[l], rk[r]));\n    &#125;\n&#125;;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    std::string s;\n    std::cin &gt;&gt; s;\n    int n = (int)s.length();\n    s = &quot;#&quot; + s;\n    SA p(n, s);\n    std::reverse(s.begin() + 1, s.end());\n    SA q(n, s);\n    std::reverse(s.begin() + 1, s.end());\n    long long res1 = 0ll, res2 = 0ll;\n    for (int len = 1; len &lt;= n; ++len)\n        for (int i = len, j = 2 * len, k = 3 * len; k &lt;= n; i += len, j += len, k += len) &#123;\n            int lcp = std::min(p.lcp(i, j), p.lcp(j, k)), lcs = std::min(&#123; len - 1, q.lcp(n - i + 2, n - j + 2), q.lcp(n - j + 2, n - k + 2) &#125;);\n            if (std::min(len, lcp) + lcs &gt;= len) &#123;\n                // printf(&quot;(%d, %d, %d), %d, %d, %d\\n&quot;, i, j, k, lcs, lcp, len);\n                int t = (lcp &lt;= len);\n                res1 += t, res2 += std::min(len, lcp) + lcs - len + 1 - t;\n            &#125;\n            // else\n            //     printf(&quot;# (%d, %d, %d), %d, %d, %d\\n&quot;, i, j, k, lcs, lcp, len);\n        &#125;\n    std::cout &lt;&lt; res1 &lt;&lt; &#39; &#39; &lt;&lt; res2 &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h4 id=\"eg3.-repeats\">eg3. repeats</h4>\n<p><a href=\"https://www.spoj.com/problems/REPEATS/\" class=\"uri\">https://www.spoj.com/problems/REPEATS/</a></p>\n<p>重复次数最多，只需经过标记点最多。显然经过标记点的数量就是该字符串长除以 <span class=\"math inline\">\\(len\\)</span> 向下取整就可以得到重复次数减 <span class=\"math inline\">\\(1\\)</span> 的值。</p>\n<p>选择两个连续标记点，对于 lcp 和 lcs（显然此时不需要对 <span class=\"math inline\">\\(len\\)</span> 取 <span class=\"math inline\">\\(\\min\\)</span>），计算 <span class=\"math inline\">\\(\\dfrac {\\text{lcp}+\\text{lcs}}{len}+1\\)</span> 取最大即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nclass SA &#123;\npublic:\n    std::vector&lt;int&gt; sa, rk, h;\n    std::vector&lt;std::vector&lt;int&gt;  &gt; st;\n    SA(int n, std::string s): sa(n + 1), rk(n + 2), h(n + 1), st(20, std::vector&lt;int&gt; (n + 1)) &#123;\n        std::vector&lt;int&gt; la(n + 2);\n        std::copy(s.begin(), s.end(), rk.begin());\n        int m = 128;\n        &#123;\n            std::vector&lt;int&gt; c(m + 1);\n            for (int i = 1; i &lt;= n; ++i)\n                ++c[rk[i]];\n            std::partial_sum(c.begin(), c.end(), c.begin());\n            for (int i = n; i; --i)\n                sa[c[rk[i]]--] = i;\n        &#125;\n        for (int w = 1, p; ; w &lt;&lt;= 1, m = p) &#123;\n            std::vector&lt;int&gt; id(1);\n            for (int i = n - w + 1; i &lt;= n; ++i)\n                id.push_back(i);\n            for (int i = 1; i &lt;= n; ++i)\n                if (sa[i] &gt; w)\n                    id.push_back(sa[i] - w);\n            std::vector&lt;int&gt; c(m + 1);\n            for (int i = 1; i &lt;= n; ++i)\n                ++c[rk[i]];\n            std::partial_sum(c.begin(), c.end(), c.begin());\n            for (int i = n; i; --i)\n                sa[c[rk[id[i]]]--] = id[i];\n            p = 0;\n            std::copy(rk.begin(), rk.end(), la.begin());\n            for (int i = 1; i &lt;= n; ++i)\n                if (la[sa[i]] == la[sa[i - 1]] &amp;&amp; la[sa[i] + w] == la[sa[i - 1] + w])\n                    rk[sa[i]] = p;\n                else\n                    rk[sa[i]] = ++p;\n            if (p == n)\n                break;\n        &#125;\n        for (int i = 1, to = 0; i &lt;= n; ++i)\n            if (rk[i]) &#123;\n                for (to = std::max(to - 1, 0); s[i + to] == s[sa[rk[i] - 1] + to]; ++to);\n                h[rk[i]] = to;\n            &#125;\n        for (int i = 1; i &lt;= n; ++i)\n            st[0][i] = h[i];\n        for (int j = 1; (1 &lt;&lt; j) &lt;= n; ++j)\n            for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i)\n                st[j][i] = std::min(st[j - 1][i], st[j - 1][i + (1 &lt;&lt; (j - 1))]);\n        rk.emplace_back();\n        return;\n    &#125;\nprivate:\n    int ask(int l, int r) &#123;\n        // fprintf(stderr, &quot;l = %d, r = %d\\n&quot;, l, r);\n        int k = std::__lg(r - l + 1);\n        return std::min(st[k][l], st[k][r - (1 &lt;&lt; k) + 1]);\n    &#125;\npublic:\n    int lcp(int l, int r) &#123;\n        return ask(std::min(rk[l], rk[r]) + 1, std::max(rk[l], rk[r]));\n    &#125;\n&#125;;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n;\n        std::cin &gt;&gt; n;\n        std::string s = &quot;#&quot;;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            char t;\n            std::cin &gt;&gt; t;\n            s.push_back(t);\n        &#125;\n        SA p(n, s);\n        std::reverse(s.begin() + 1, s.end());\n        SA q(n, s);\n        int res = 0;\n        for (int len = 1; len &lt;= n; ++len)\n            for (int i = len, j = 2 * len; j &lt;= n; i += len, j += len) &#123;\n                int lcp = p.lcp(i, j), lcs = q.lcp(n - i + 2, n - j + 2);\n                if (lcp + lcs &gt;= len)\n                    res = std::max(res, (lcp + lcs) / len + 1);\n            &#125;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"结合并查集\">结合并查集</h3>\n<hr />\n<h3 id=\"结合单调栈\">结合单调栈</h3>\n",
            "tags": [
                "字符串",
                "SA"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250124/",
            "url": "https://xsc062.netlify.app/20250124/",
            "title": "网络流",
            "date_published": "2025-01-24T00:35:47.000Z",
            "content_html": "<p>想当年叱诧风云左牵字符串右擎网络流，而今飘零憔悴沦落到需要学而时习之的地步 <img src=\"/em/kx.gif\" /></p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"定义\">定义</h2>\n<p>对于有一个源点 <span class=\"math inline\">\\(s\\)</span> 和汇点 <span class=\"math inline\">\\(t\\)</span> 的有向图，每条边都有一个权值 <span class=\"math inline\">\\(c\\)</span> 作为容量，称这个有向图 <span class=\"math inline\">\\(G\\)</span> 是一个网络。</p>\n<p>假设现在有 <span class=\"math inline\">\\(f\\)</span> 升水从 <span class=\"math inline\">\\(s\\)</span> 流入，而我们可以自由分配每个点的水可以朝哪个方向流出，那么显然地：</p>\n<ul>\n<li>流出 <span class=\"math inline\">\\(t\\)</span> 的水为 <span class=\"math inline\">\\(f\\)</span> 升。</li>\n<li>对于除 <span class=\"math inline\">\\(s\\)</span> 和 <span class=\"math inline\">\\(t\\)</span> 以外的所有点，流入的水量等于流出的水量。</li>\n<li>对于任意一条边，流经的水量不超过容量。</li>\n</ul>\n<p>对于这个网络，任选出一部分点与 <span class=\"math inline\">\\(s\\)</span> 分为一组，剩下与 <span class=\"math inline\">\\(t\\)</span> 分为一组，该操作称为「割」。一个割的「容量」定义为 <span class=\"math inline\">\\(s\\)</span> 组与 <span class=\"math inline\">\\(t\\)</span> 组间连边的容量和。</p>\n<p>那么接下来就会由这个模型衍生出许多问题：</p>\n<ul>\n<li>最大流问题：找到一种分配方式最大化 <span class=\"math inline\">\\(f\\)</span>。</li>\n<li>最小割问题：找到一种割的方案最小化割的容量。</li>\n<li>最小费用最大流问题：给每条边除容量 <span class=\"math inline\">\\(c\\)</span> 外外加一个费用权值 <span class=\"math inline\">\\(w\\)</span>，需要在保证最大化 <span class=\"math inline\">\\(f\\)</span> 的前提下最小化 <span class=\"math inline\">\\(\\sum f(u, v)\\times w(u, v)\\)</span>。</li>\n</ul>\n<p>接下来会分别介绍解决这几种不同问题的方法。</p>\n<hr />\n<h2 id=\"最大流问题\">最大流问题</h2>\n<p>一个主要的思想是 <strong>贪心寻找增广路更新当前答案</strong>。</p>\n",
            "tags": [
                "网络流"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250121/",
            "url": "https://xsc062.netlify.app/20250121/",
            "title": "技巧：字符串拆分",
            "date_published": "2025-01-21T03:47:06.000Z",
            "content_html": "<p>神刘家在走前体育课上问我听没听过 <em>Die For You - The Weekend</em>。我让他哼一段，刘家便展示了自己的天籁之音，我理所当然地连旋律都没辨认出来。</p>\n<span id=\"more\"></span>\n<hr />\n<p>有的时候，对于一个完整的匹配串，我们需要「枚举断点」，分为前半段和后半段分别和模式串匹配解决问题。当然这样的技巧不止局限于字符串，我们在之前的学习中在诸如动态规划等题目中遇到了相似的情景。</p>\n<p>在字符串题目中，一个典型的标志是「模式串的拼接」，将两截模式串拼接到一起，形成的新模式串并不利好我们的处理，我们需要尽量利用已知的模式串。当然我们不会将新模式串重新拆成两半，而是考虑转换，枚举匹配串的断点，将前半段的后缀和后半段的前缀分别匹配。</p>\n<hr />\n<h2 id=\"一个模板cf1202e-you-are-given-some-strings\">一个模板：CF1202E You Are Given Some Strings…</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1202/E\" class=\"uri\">https://codeforces.com/problemset/problem/1202/E</a></p>\n<p>虽然对于每种不同拼接需要求解分别的出现次数，但是注意到最后只需要输出 <span class=\"math inline\">\\(f\\)</span> 的总和，所以就可以不再顾及不同拼接方式间的区别。</p>\n<p>枚举匹配串的断点。一个自然的想法是将前后缀与 AC 自动机匹配，但如果逐个放进去显然复杂度起飞。这里就又有一个实现小技巧，我们在原串的 AC 自动机上把原串过一遍，每个位置所在的状态就是这个位置对应后缀可能处在的后缀。</p>\n<p>记录每个状态可能处在的模式串末尾个数，这一点直接在 fail 树上从上到下转移即可。反串同理。</p>\n<p>二者相乘即为答案。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 2e5 + 5;\nstruct &#123;\n    int T[maxn][26], tot, cnt[maxn], fail[maxn], deg[maxn];\n    void ins(std::string &amp;t) &#123;\n        int p = 0;\n        for (auto i : t) &#123;\n            if (!T[p][i - &#39;a&#39;])\n                T[p][i - &#39;a&#39;] = ++tot;\n            p = T[p][i - &#39;a&#39;];\n        &#125;\n        ++cnt[p];\n        return;\n    &#125;\n    void bld(void) &#123;\n        std::queue&lt;int&gt; q;\n        for (int i = 0; i &lt; 26; ++i)\n            if (T[0][i])\n                q.push(T[0][i]);\n        for (; !q.empty(); ) &#123;\n            int u = q.front();\n            q.pop();\n            for (int i = 0; i &lt; 26; ++i)\n                if (T[u][i]) &#123;\n                    int v = T[u][i];\n                    fail[v] = T[fail[u]][i], cnt[v] += cnt[fail[v]];\n                    q.push(v);\n                &#125;\n                else\n                    T[u][i] = T[fail[u]][i];\n        &#125;\n        return;\n    &#125;\n&#125; p, q;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    std::string s;\n    std::cin &gt;&gt; s;\n    int n;\n    std::cin &gt;&gt; n;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::string t;\n        std::cin &gt;&gt; t;\n        p.ins(t);\n        std::reverse(t.begin(), t.end());\n        q.ins(t);\n    &#125;\n    p.bld(), q.bld();\n    int len = s.length();\n    std::vector&lt;std::array&lt;int, 2&gt; &gt; f(len + 1);\n    &#123;\n        int u = 0;\n        for (int i = 1; i &lt;= len; ++i) &#123;\n            u = p.T[u][s[i - 1] - &#39;a&#39;];\n            f[i][0] = p.cnt[u];\n        &#125;\n    &#125;\n    &#123;\n        int u = 0;\n        for (int i = len; i; --i) &#123;\n            u = q.T[u][s[i - 1] - &#39;a&#39;];\n            f[i][1] = q.cnt[u];\n        &#125;\n    &#125;\n    long long res = 0ll;\n    for (int i = 1; i &lt; len; ++i)\n        res += (long long)f[i][0] * f[i + 1][1];\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"变式优秀的拆分\">变式：优秀的拆分</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P1117\" class=\"uri\">https://www.luogu.com.cn/problem/P1117</a></p>\n",
            "tags": [
                "字符串"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250120/",
            "url": "https://xsc062.netlify.app/20250120/",
            "title": "学习笔记：AC 自动机",
            "date_published": "2025-01-20T03:21:15.000Z",
            "content_html": "<p>耳机声音疑似有点小了，用心旷神怡的话来说大致会是「比果蝇↑嗡嗡声还小」。</p>\n<span id=\"more\"></span>\n<p>？卧槽耳机上居然可以调音量 <img src=\"/em/oh.gif\" /></p>\n<hr />\n<h2 id=\"前置知识\">前置知识</h2>\n<p>首先可能需要知道专有名词「自动机」的含义。</p>\n<p>大致可以简单理解为，一个 DAG，其中点表示状态，边表示转移。给进去一个字符串之类，就可以在 DAG 上游走，根据最后所处结点，可以得到字符串相关特征。</p>\n<p>这个定义让我们想到了 Trie。事实上，Trie 就是一种相当基础的自动机。</p>\n<hr />\n<p>接下来，让我们复习 KMP 相关概念。</p>\n<p>假想一个场景：你需要求得 <span class=\"math inline\">\\(T\\)</span> 在 <span class=\"math inline\">\\(S\\)</span> 中的出现次数。</p>\n<p>拥有一定题目经验的你，会使用 KMP 求出 <span class=\"math inline\">\\(T\\)</span> 的 <code>next</code> 数组，令 <span class=\"math inline\">\\(T\\)</span> 在 <span class=\"math inline\">\\(S\\)</span> 上进行匹配，失配或完全匹配时回到 <span class=\"math inline\">\\(T\\)</span> 在该处的 <code>next</code>，<span class=\"math inline\">\\(S\\)</span> 上的指针始终向右，<span class=\"math inline\">\\(T\\)</span> 上的指针如果向右，每次只能移动一位；如果向左，最左移到开头，均摊下来复杂度即为 <span class=\"math inline\">\\(O(|S| + |T|)\\)</span>。</p>\n<p>假如场景变得更复杂：给定 <span class=\"math inline\">\\(\\{T_m\\}\\)</span>，你需要求出每个 <span class=\"math inline\">\\(T_j\\)</span> 在 <span class=\"math inline\">\\(S\\)</span> 中的出现次数。</p>\n<p>那么如果我们对每个 <span class=\"math inline\">\\(T_j\\)</span> 进行一次 KMP，复杂度将会上升到 <span class=\"math inline\">\\(O(m|S|)\\)</span>，难以承受。有没有优化的方法呢？</p>\n<hr />\n<h2 id=\"ac-自动机的建立\">AC 自动机的建立</h2>\n<p>结合上面的知识，我们下意识想到，能不能将 <span class=\"math inline\">\\(\\{T_m\\}\\)</span> 建成一个树状结构，令 <span class=\"math inline\">\\(S\\)</span> 在其上进行 KMP 呢？</p>\n<p>将 <span class=\"math inline\">\\(\\{T_m\\}\\)</span> 全部加入 Trie，由于 <code>next</code> 只会由更深的点指向更浅的点，似乎从直觉上是有规则的。但随之而来的是一个问题：点 <span class=\"math inline\">\\(u\\)</span> 的 <code>next</code> 不一定在 <span class=\"math inline\">\\(\\text{root}\\to u\\)</span> 的链上（由于 Trie 的性质，可知指向的点是唯一的）。鉴于这一点不同，我们结合其「失配指针」的定义，将 <code>next</code> 在 Trie 上的同分异构体唤为 <code>fail</code>。</p>\n<p>考察 Trie 上该 <code>fail</code> 边的性质。现欲求解 <span class=\"math inline\">\\(u\\)</span> 的 <code>fail</code> 指向的 <span class=\"math inline\">\\(c\\)</span>，结合 KMP 中 <code>next</code> 的性质，假设 <span class=\"math inline\">\\(u\\)</span> 的父节点的 <code>fail</code> 边指向 <span class=\"math inline\">\\(v&#39;\\)</span>，那么 <span class=\"math inline\">\\(v\\)</span> 的值为：</p>\n<ul>\n<li><span class=\"math inline\">\\(v&#39;\\)</span> 上有边权相同的边，那么 <span class=\"math inline\">\\(v\\)</span> 就是该边指向的点。</li>\n<li>否则，前往 <span class=\"math inline\">\\(v&#39;\\)</span> 的 <code>fail</code>，重复以上判定。</li>\n</ul>\n<p>那么就完成了失配的处理。相应地，完全匹配时的跳转应如何处理？直接将 <code>fail</code> 的儿子全部接到 <span class=\"math inline\">\\(u\\)</span> 下面即可。如果 <span class=\"math inline\">\\(u\\)</span> 和 <code>fail</code> 具有同一个边权的边时，保留 <span class=\"math inline\">\\(u\\)</span> 的这条边 <span class=\"math inline\">\\(u\\to v\\)</span>，因为 <span class=\"math inline\">\\(v\\)</span> 的 <code>fail</code> 必定指向 <span class=\"math inline\">\\(u\\)</span> 的 <code>fail</code> 的对应儿子。</p>\n<p>两点结合，我们发现从实现上，可以直接令 <span class=\"math inline\">\\(v\\)</span> 的 <code>fail</code> 指向 <span class=\"math inline\">\\(u\\)</span> 的 <code>fail</code> 的对应儿子（那么时间复杂度显而易见是 <span class=\"math inline\">\\(O(26\\sum |T|)\\)</span> 的）。</p>\n<p>匹配时，对于每个点和其返回到根的 <code>fail</code> 链，全部标记。则一个模式串匹配的次数即为被打标记的次数。</p>\n<p>那么可以发现 AC 自动机的本质就是添加了 <code>fail</code> 边的 Trie。</p>\n<hr />\n<p>那么根据上述要求，我们需要按照深度顺序求得 <code>fail</code>，考虑 BFS。</p>\n<details>\n<p>哦哦好神奇复活之后记得啥是 KMP 但忘了啥是 C++ 了。甚至花了一点时间学习怎么创建一个函数？？？</p>\n<p>大家写 AC 自动机 Trie 根节点下标一定要设成 0 啊 <img src=\"/em/ll.gif\" /> 设成 1 被各种细节坑惨了 <img src=\"/em/ll.gif\" /></p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 2e5 + 5;\nint T[maxn][26], tot, cnt[maxn], fail[maxn];\nint ins(std::string &amp;t) &#123;\n    int p = 0;\n    for (auto i : t) &#123;\n        if (!T[p][i - &#39;a&#39;])\n            T[p][i - &#39;a&#39;] = ++tot;\n        p = T[p][i - &#39;a&#39;];\n    &#125;\n    return p;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; tail(n + 1);\n    std::vector&lt;std::string&gt; t(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; t[i], tail[i] = ins(t[i]);\n    &#123;\n        std::queue&lt;int&gt; q;\n        for (int i = 0; i &lt; 26; ++i)\n            if (T[0][i])\n                q.push(T[0][i]);\n        for (; !q.empty(); ) &#123;\n            int u = q.front();\n            q.pop();\n            for (int i = 0; i &lt; 26; ++i)\n                if (T[u][i]) &#123;\n                    int v = T[u][i];\n                    fail[v] = T[fail[u]][i];\n                    q.push(v);\n                &#125;\n                else\n                    T[u][i] = T[fail[u]][i];\n        &#125;\n    &#125;\n    std::string s;\n    std::cin &gt;&gt; s;\n    &#123;\n        int p = 0;\n        for (auto i : s) &#123;\n            p = T[p][i - &#39;a&#39;];\n            for (int fa = p; fa; fa = fail[fa])\n                ++cnt[fa];\n        &#125;\n    &#125;\n    for (int i = 1; i &lt;= n; ++i)\n        std::cout &lt;&lt; cnt[tail[i]] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<p>肉眼可见该查询方式是极其低效的，故考虑优化跳 <code>fail</code> 打标记的过程。</p>\n<p>既然自动机结构不变，不如将跳 <code>fail</code> 的步骤放在最后统一进行。容易在发现 <code>fail</code> 树上进行拓扑排序转移即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 2e5 + 5;\nint T[maxn][26], tot, cnt[maxn], fail[maxn], deg[maxn];\nint ins(std::string &amp;t) &#123;\n    int p = 0;\n    for (auto i : t) &#123;\n        if (!T[p][i - &#39;a&#39;])\n            T[p][i - &#39;a&#39;] = ++tot;\n        p = T[p][i - &#39;a&#39;];\n    &#125;\n    return p;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; tail(n + 1);\n    std::vector&lt;std::string&gt; t(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; t[i], tail[i] = ins(t[i]);\n    &#123;\n        std::queue&lt;int&gt; q;\n        for (int i = 0; i &lt; 26; ++i)\n            if (T[0][i])\n                q.push(T[0][i]);\n        for (; !q.empty(); ) &#123;\n            int u = q.front();\n            q.pop();\n            for (int i = 0; i &lt; 26; ++i)\n                if (T[u][i]) &#123;\n                    int v = T[u][i];\n                    fail[v] = T[fail[u]][i], ++deg[T[fail[u]][i]];\n                    q.push(v);\n                &#125;\n                else\n                    T[u][i] = T[fail[u]][i];\n        &#125;\n    &#125;\n    std::string s;\n    std::cin &gt;&gt; s;\n    &#123;\n        int p = 0;\n        for (auto i : s)\n            p = T[p][i - &#39;a&#39;], ++cnt[p];\n    &#125;\n    &#123;\n        std::queue&lt;int&gt; q;\n        for (int i = 1; i &lt;= tot; ++i)\n            if (!deg[i])\n                q.push(i);\n        for (; !q.empty(); ) &#123;\n            int u = q.front();\n            q.pop();\n            cnt[fail[u]] += cnt[u];\n            if (!--deg[fail[u]])\n                q.push(fail[u]);\n        &#125;\n    &#125;\n    for (int i = 1; i &lt;= n; ++i)\n        std::cout &lt;&lt; cnt[tail[i]] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"ac-自动机的应用与识别\">AC 自动机的应用与识别</h2>\n<p>我们知道其最典型的特征是 <strong>多模式串</strong>、<strong>静态 / 离线</strong>。当碰到类似特点时，大概率就是 AC 自动机。</p>\n<p>其中，可以设置的难点有：</p>\n<ol type=\"1\">\n<li>字符串难点，和其他字符串题可设置的难点相同。</li>\n<li>fail 树维护，可能结合数据结构、拓扑排序、树形 DP 等考察。</li>\n<li>DP 的设计。</li>\n</ol>\n<hr />\n<h2 id=\"字符串难点设计\">字符串难点设计</h2>\n<h3 id=\"eg.-indie-album\">eg. Indie Album</h3>\n<p><a href=\"https://codeforces.com/problemset/problem/1207/G\" class=\"uri\">https://codeforces.com/problemset/problem/1207/G</a></p>\n<p>题目的「可持久化」试图误导我们用操作串建立自动机，但这样就会有一个比较严重的问题，我们没办法求 <span class=\"math inline\">\\(t\\)</span> 的出现次数。</p>\n<p>为了保证答案可求我们仍然在 <span class=\"math inline\">\\(t\\)</span> 上建立 ACAM。容易发现操作串以 Trie 形式给出，我们可以在遍历 Trie 时同时完成游走，通过回溯完成询问。</p>\n<p>假设当前 DFS 中，遍历到 Trie 树中的 <span class=\"math inline\">\\(x\\)</span> 点和自动机中的 <span class=\"math inline\">\\(u\\)</span> 状态，那么对于 <span class=\"math inline\">\\(x\\)</span> 点所对应的一个询问串 <span class=\"math inline\">\\(t\\)</span>，相当于询问经过的所有状态有多少个在 <span class=\"math inline\">\\(t\\)</span> 引导的 fail 树子树中。我们求出 fail 树的 dfn，用树状数组简单统计即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 4e5 + 5;\nstd::vector&lt;int&gt; g[maxn], q[maxn];\nint fail[maxn], T[maxn][26], tot, bit[maxn], to[maxn][26], cnt[maxn];\nint ins(std::string s) &#123;\n    int p = 0;\n    for (auto i : s) &#123;\n        if (!T[p][i - &#39;a&#39;])\n            T[p][i - &#39;a&#39;] = ++tot;\n        p = T[p][i - &#39;a&#39;];\n    &#125;\n    return p;\n&#125;\nint lowbit(int x) &#123;\n    return x &amp; -x;\n&#125;\nvoid add(int x, int v) &#123;\n    for (; x &lt;= tot + 1; x += lowbit(x))\n        bit[x] += v;\n    return;\n&#125;\nint ask(int x) &#123;\n    int res = 0;\n    for (; x; x -= lowbit(x))\n        res += bit[x];\n    return res;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, now = 0;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; id(n + 1);\n    for (int i = 1, op; i &lt;= n; ++i) &#123;\n        char t;\n        std::cin &gt;&gt; op;\n        if (op == 1) &#123;\n            std::cin &gt;&gt; t;\n            if (!to[0][t - &#39;a&#39;])\n                to[0][t - &#39;a&#39;] = ++now;\n            ++cnt[to[0][t - &#39;a&#39;]], id[i] = to[0][t - &#39;a&#39;];\n        &#125;\n        else &#123;\n            int j; \n            std::cin &gt;&gt; j &gt;&gt; t;\n            if (!to[id[j]][t - &#39;a&#39;])\n                to[id[j]][t - &#39;a&#39;] = ++now;\n            ++cnt[to[id[j]][t - &#39;a&#39;]], id[i] = to[id[j]][t - &#39;a&#39;];\n        &#125;\n    &#125;\n    int m;\n    std::cin &gt;&gt; m;\n    std::vector&lt;int&gt; tail(m + 1), res(m + 1);\n    for (int i = 1, x; i &lt;= m; ++i) &#123;\n        std::string t;\n        std::cin &gt;&gt; x &gt;&gt; t, tail[i] = ins(t);\n        q[id[x]].push_back(i);\n    &#125;\n    &#123;\n        std::queue&lt;int&gt; q;\n        for (int i = 0; i &lt; 26; ++i)\n            if (T[0][i])\n                q.push(T[0][i]), g[0].push_back(T[0][i]);\n        for (; !q.empty(); ) &#123;\n            int u = q.front();\n            q.pop();\n            for (int i = 0; i &lt; 26; ++i)\n                if (T[u][i]) &#123;\n                    int v = T[u][i];\n                    fail[v] = T[fail[u]][i];\n                    q.push(v), g[fail[v]].push_back(v);\n                &#125;\n                else\n                    T[u][i] = T[fail[u]][i];\n        &#125;\n    &#125;\n    std::vector&lt;int&gt; dfn(tot + 1), rfn(tot + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        dfn[x] = ++now;\n        // printf(&quot;%d &quot;, x);\n        for (auto i : g[x])\n            DFS(i);\n        rfn[x] = now;\n        return;\n    &#125;;\n    DFS(0);\n    std::function&lt;void(int, int)&gt; DFS1 = [&amp;](int x, int u) &#123;\n        add(dfn[u], 1);\n        for (auto i : q[x])\n            res[i] += ask(rfn[tail[i]]) - ask(dfn[tail[i]] - 1);\n        for (int i = 0; i &lt; 26; ++i)\n            if (to[x][i])\n                DFS1(to[x][i], T[u][i]);\n        add(dfn[u], -1);\n        return;\n    &#125;;\n    DFS1(0, 0);\n    for (int i = 1; i &lt;= m; ++i)\n        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"fail-树的维护\">fail 树的维护</h2>\n<h3 id=\"eg.-divljak\">eg. Divljak</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P5840\" class=\"uri\">https://www.luogu.com.cn/problem/P5840</a></p>\n<h4 id=\"法一把动态问题离线\">法一：把动态问题离线</h4>\n<p>问题相当于将模式串 <span class=\"math inline\">\\(T:\\{P\\}\\)</span> 动态化，但我们仍可以无脑离线下来解决问题。</p>\n<p>考虑原本的答案计算过程，即在经过的所有状态及其 fail 链上打标记。现在我们需要离线并区分标记的来源（并且标记类型为布尔值），下意识想到使用线段树维护。</p>\n<p>我们对每个状态建立动态开点线段树，最后拓扑排序时使用线段树合并处理信息。容易证明时间复杂度相较原来多了一个 <span class=\"math inline\">\\(\\log\\)</span>。</p>\n<p><del>理论可行，开始实践</del> 出题人似乎不是很喜欢线段树选手所以决定剥夺你的 Memory Limit。想要用这种做法通过本题可见 <a href=\"https://www.luogu.com.cn/article/jaxk3sno\" class=\"uri\">https://www.luogu.com.cn/article/jaxk3sno</a>。</p>\n<h4 id=\"法二转而处理静态问题\">法二：转而处理静态问题</h4>\n<p>注意到题目中的静态的 <span class=\"math inline\">\\(S_x\\)</span> 比起 <span class=\"math inline\">\\(T:\\{P\\}\\)</span> 更适合用来做模式串，我们在 <span class=\"math inline\">\\(S_x\\)</span> 上构建 AC 自动机，考虑在线解决问题。</p>\n<p>在每次 <code>1</code> 操作时，更新模式串信息。对于途径的所有状态 <span class=\"math inline\">\\(\\{u\\}\\)</span>，考虑更新其所在 fail 链上的信息。</p>\n<p>注意到我们需要修改整条 fail 链上的信息，询问则是询问单点。这个时候可以考虑使用树上差分。</p>\n<p>但是 here comes a problem，我们对于这一整个串只能在整个树上每个点上更新一次。怎么消去相同的影响呢？</p>\n<p>这里实现上我们将经过的点按 fail 树上 dfn 排序，并且对于序列中相邻的两点在其 LCA 上减去一次标记。为什么这是正确的呢？参考虚树，我们只需要让序列中相邻的两个点尽量近就可以保证重复的被删除完毕。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 2e6 + 5;\nint tot, bit[maxn], T[maxn][26], fail[maxn];\nint ins(std::string &amp;t) &#123;\n    int p = 0;\n    for (auto i : t) &#123;\n        if (!T[p][i - &#39;a&#39;])\n            T[p][i - &#39;a&#39;] = ++tot;\n        p = T[p][i - &#39;a&#39;];\n    &#125;\n    return p;\n&#125;\nint lowbit(int x) &#123;\n    return x &amp; -x;\n&#125;\nvoid add(int x, int v) &#123;\n    // printf(&quot;add (%d, %d)\\n&quot;, x, v);\n    for (; x &lt;= tot + 1; x += lowbit(x))\n        bit[x] += v;\n    return;\n&#125;\nint ask(int x) &#123;\n    int res = 0, to = x;\n    for (; x; x -= lowbit(x))\n        res += bit[x];\n    // printf(&quot;ask(%d) = %d\\n&quot;, to, res);\n    return res;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, q;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; tail(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::string t;\n        std::cin &gt;&gt; t, tail[i] = ins(t);\n    &#125;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(tot + 2);\n    &#123;\n        std::queue&lt;int&gt; q;\n        for (int i = 0; i &lt; 26; ++i)\n            if (T[0][i])\n                q.push(T[0][i]);\n        for (; !q.empty(); ) &#123;\n            int u = q.front();\n            q.pop();\n            for (int i = 0; i &lt; 26; ++i)\n                if (T[u][i]) &#123;\n                    int v = T[u][i];\n                    fail[v] = T[fail[u]][i];\n                    q.push(v);\n                &#125;\n                else\n                    T[u][i] = T[fail[u]][i];\n        &#125;\n        for (int i = 1; i &lt;= tot; ++i)\n            g[fail[i] + 1].push_back(i + 1);\n    &#125;\n    std::vector&lt;std::array&lt;int, 22&gt; &gt; f(tot + 2);\n    std::vector&lt;int&gt; dep(tot + 2), dfn(tot + 2), siz(tot + 2);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        siz[x] = 1, dfn[x] = ++now;\n        // printf(&quot;%d\\n&quot;, x);\n        for (auto i : g[x]) &#123;\n            dep[i] = dep[x] + 1;\n            f[i][0] = x;\n            for (int j = 1; j &lt;= 21; ++j)\n                f[i][j] = f[f[i][j - 1]][j - 1];\n            DFS(i), siz[x] += siz[i];\n        &#125;\n        return;\n    &#125;;\n    dep[1] = 1, DFS(1);\n    auto askLCA = [&amp;](int x, int y) &#123;\n        if (x == y)\n            return x;\n        if (dep[x] &lt; dep[y])\n            std::swap(x, y);\n        for (int i = 21; ~i; --i)\n            if (dep[f[x][i]] &gt;= dep[y])\n                x = f[x][i];\n        if (x == y)\n            return x;\n        for (int i = 21; ~i; --i)\n            if (f[x][i] != f[y][i])\n                x = f[x][i], y = f[y][i];\n        return f[x][0];\n    &#125;;\n    std::cin &gt;&gt; q;\n    for (; q--; ) &#123;\n        int op;\n        std::cin &gt;&gt; op;\n        if (op == 1) &#123;\n            std::string s;\n            std::cin &gt;&gt; s;\n            int p = 0, len = (int)s.length();\n            std::vector&lt;int&gt; id(len + 1);\n            for (int i = 1; i &lt;= len; ++i)\n                p = T[p][s[i - 1] - &#39;a&#39;], id[i] = p + 1;\n            std::sort(id.begin() + 1, id.end(), [&amp;](int x, int y) &#123; return dfn[x] &lt; dfn[y]; &#125;);\n            // for (int i = 1; i &lt;= len; ++i)\n            //     printf(&quot;%d &quot;, id[i]);\n            // puts(&quot;&quot;);\n            for (int i = 1; i &lt;= len; ++i) &#123;\n                // printf(&quot;%d %d %d\\n&quot;, i, id[i], dfn[id[i]]);\n                // assert(0);\n                add(dfn[id[i]], 1);\n                if (i != 1)\n                    add(dfn[askLCA(id[i], id[i - 1])], -1);\n            &#125;\n        &#125;\n        else &#123;\n            int x;\n            std::cin &gt;&gt; x;\n            x = tail[x] + 1;\n            std::cout &lt;&lt; ask(dfn[x] + siz[x] - 1) - ask(dfn[x] - 1) &lt;&lt; &#39;\\n&#39;;\n        &#125;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"ac-自动机上的-dp\">AC 自动机上的 DP</h2>\n<p>鉴于 AC 自动机的优秀结构与性质，并不经常作为字符串匹配工具出现，其一个应用是作为 DP 的载体。</p>\n<h3 id=\"eg1.-l-语言\">eg1. L 语言</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P2292\" class=\"uri\">https://www.luogu.com.cn/problem/P2292</a></p>\n<p>我们想到要在自动机上匹配，但此时 <code>fail</code> 作为「断句」的唯一手段（断句的位置在链上当前点深度 - <code>fail</code> 深度处），不再仅当失配时才能经过。我们考虑朴素的 DP：在经过的每个状态考虑断句，那么这要求断句处是一个单词的结尾，那么此时 <code>fail</code> 最长匹配长度即可被更新。最后遍历所有单词的末结点，取最大答案。这里的 <code>fail</code> 其实是 <code>fail</code> 链上任意一点。</p>\n<p>考虑复杂度。容易发现对于每一个点我们跳了其整条 fail 链，那么复杂度就是最劣 <span class=\"math inline\">\\(n^2\\)</span> 的。考虑优化这个过程至 <span class=\"math inline\">\\(O(1)\\)</span>。</p>\n<p>题目里有一个很重要的条件还没有用到：单个单词长度 <span class=\"math inline\">\\(\\le 20\\)</span>，这让我们想到状态压缩。对于每一个状态，记录其断出来单词的可能长度。</p>\n<p>我们在 DAG 上游走的时候记录目前可以断的所有位置，如果其和当前可断出来的长度之交不为空，就可以将此处加入「可以断的所有位置」并更新答案。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 2e5 + 5;\nint T[maxn][26], tot, fail[maxn], len[maxn], dep[maxn], tag[maxn];\nint ins(std::string &amp;t) &#123;\n    int p = 0;\n    for (auto i : t) &#123;\n        if (!T[p][i - &#39;a&#39;])\n            T[p][i - &#39;a&#39;] = ++tot, dep[tot] = dep[p] + 1;\n        p = T[p][i - &#39;a&#39;];\n    &#125;\n    ++tag[p];\n    return p;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;int&gt; tail(n + 1);\n    std::vector&lt;std::string&gt; t(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; t[i], tail[i] = ins(t[i]);\n    &#123;\n        std::queue&lt;int&gt; q;\n        for (int i = 0; i &lt; 26; ++i)\n            if (T[0][i])\n                q.push(T[0][i]);\n        for (; !q.empty(); ) &#123;\n            int u = q.front();\n            q.pop();\n            len[u] = len[fail[u]];\n            if (tag[u])\n                len[u] |= (1 &lt;&lt; dep[u]);\n            for (int i = 0; i &lt; 26; ++i)\n                if (T[u][i]) &#123;\n                    int v = T[u][i];\n                    fail[v] = T[fail[u]][i];\n                    q.push(v);\n                &#125;\n                else\n                    T[u][i] = T[fail[u]][i];\n        &#125;\n    &#125;\n    for (; m--; ) &#123;\n        std::string s;\n        std::cin &gt;&gt; s;\n        int p = 0, q = 1, res = 0;\n        for (int i = 0; i &lt; (int)s.length(); ++i) &#123;\n            p = T[p][s[i] - &#39;a&#39;], q &lt;&lt;= 1;\n            if (len[p] &amp; q)\n                q |= 1, res = i + 1;\n        &#125;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"eg2.-popcount-words\">eg2. Popcount Words</h3>\n<p><a href=\"https://codeforces.com/gym/103409/problem/H\" class=\"uri\">https://codeforces.com/gym/103409/problem/H</a></p>\n<p><del>咋上强度了啊。</del></p>\n<p>先把整个序列写出来，即 <span class=\"math inline\">\\(w=\\texttt{01101001100101}\\cdots\\)</span>，尝试进一步探究形式化的规律，可以得到：</p>\n<ol type=\"1\">\n<li><span class=\"math inline\">\\(w_{[0, 2^n), 0}=w_{[0, 2^{n-1}),0}+w_{[0, 2^n), 1}\\)</span>，其中 <span class=\"math inline\">\\(w_{[l, r], 0/1}\\)</span> 表示 <span class=\"math inline\">\\([l, r]\\)</span> 内，原串 / 取反的值。</li>\n<li>对于不以 <span class=\"math inline\">\\(0\\)</span> 开头的整段，可以从上述规则转化为 <span class=\"math inline\">\\(0\\)</span> 开头的整段。</li>\n</ol>\n<p>接着不难想到一种类似线段树的方式，将待求的 <span class=\"math inline\">\\(w_{[l, r], 0}\\)</span> 分到 <span class=\"math inline\">\\(O(\\log V)\\)</span> 个整段上，那么 <span class=\"math inline\">\\(S\\)</span> 就可以被 <span class=\"math inline\">\\(O(n\\log V)\\)</span> 个整段（也是 <span class=\"math inline\">\\(\\log V\\)</span> 个本质不同整段）描述。</p>\n<p>我们对 <span class=\"math inline\">\\({p_m}\\)</span> 建立 AC 自动机，需要知道这 <span class=\"math inline\">\\(\\log V\\)</span> 个整段在每个点上的出现次数。对于自动机上任意状态 <span class=\"math inline\">\\(u\\)</span>，设 <span class=\"math inline\">\\(to_{u, n, 0/1}\\)</span> 表示 <span class=\"math inline\">\\(u\\)</span> 经过 <span class=\"math inline\">\\(w_{[0, 2^n), 0/1}\\)</span> 后到达的点，则可倍增（嘶，这里是不是应该反过来叫分治啊）简单解决。</p>\n<p>那么接下来我们就可以用 <span class=\"math inline\">\\(to\\)</span> 来进行快速游走了。顺便打个 <span class=\"math inline\">\\(cnt\\)</span> 记录一下每个 <span class=\"math inline\">\\(u\\)</span> 作为不同整段的开头被经过的次数。然后做一个 DP，类似于线段树上 <code>pushdown</code> 的操作把所有整段下放到单点上的单个字符。</p>\n<p>有一说一用 DP 来处理这个东西还挺难想的。可能也是基于前面的倍增吧。最后拓扑排序就行了。</p>\n<details>\n<p>大家数组一定要用 C-style array 啊，<code>std::vector&lt;&gt;</code> 计算的是申请空间包 MLE 的 <img src=\"/em/ll.gif\" /></p>\n<p>大家大数组一定要内存连续访问优化啊，TLE <span class=\"math inline\">\\(\\to\\)</span> 100ms 泪目了 <img src=\"/em/ll.gif\" /></p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 5e5 + 5;\nlong long sum[maxn], f[2][30][maxn];\nint cnt[2][30][maxn], to[2][30][maxn];\nint T[maxn][2], tot, fail[maxn], deg[maxn];\nint ins(std::string &amp;t) &#123;\n    int p = 0;\n    for (auto i : t) &#123;\n        if (!T[p][i - &#39;0&#39;])\n            T[p][i - &#39;0&#39;] = ++tot;\n        p = T[p][i - &#39;0&#39;];\n    &#125;\n    return p;\n&#125;\nvoid ask(std::vector&lt;std::pair&lt;int, int&gt; &gt; &amp;s, int ql, int qr, int l = 0, int r = (1 &lt;&lt; 30) - 1, int len = 30, int v = 0) &#123;\n    if (ql &lt;= l &amp;&amp; r &lt;= qr) &#123;\n        s.emplace_back(len, v);\n        return;\n    &#125;\n    int mid = l + (r - l) / 2;\n    if (ql &lt;= mid)\n        ask(s, ql, qr, l, mid, len - 1, v);\n    if (qr &gt; mid)\n        ask(s, ql, qr, mid + 1, r, len - 1, v ^ 1);\n    return;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; s;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        int l, r;\n        std::cin &gt;&gt; l &gt;&gt; r;\n        ask(s, l, r);\n    &#125;\n    std::vector&lt;int&gt; tail(m + 1);\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        std::string t;\n        std::cin &gt;&gt; t;\n        tail[i] = ins(t);\n    &#125;\n    &#123;\n        std::queue&lt;int&gt; q;\n        for (int i = 0; i &lt; 2; ++i)\n            if (T[0][i])\n                q.push(T[0][i]);\n        for (; !q.empty(); ) &#123;\n            int u = q.front();\n            q.pop();\n            for (int i = 0; i &lt; 2; ++i)\n                if (T[u][i]) &#123;\n                    int v = T[u][i];\n                    fail[v] = T[fail[u]][i], ++deg[T[fail[u]][i]];\n                    q.push(v);\n                &#125;\n                else\n                    T[u][i] = T[fail[u]][i];\n        &#125;\n    &#125;\n    for (int i = 0; i &lt;= tot; ++i)\n        to[0][0][i] = T[i][0], to[1][0][i] = T[i][1];\n    for (int j = 1; j &lt; 30; ++j)\n        for (int i = 0; i &lt;= tot; ++i) &#123;\n            to[0][j][i] = to[1][j - 1][to[0][j - 1][i]];\n            to[1][j][i] = to[0][j - 1][to[1][j - 1][i]];\n        &#125;\n    &#123;\n        int p = 0;\n        for (auto [n, i] : s) &#123;\n            // printf(&quot;# %d %d\\n&quot;, n, i);\n            ++cnt[i][n][p], p = to[i][n][p];\n        &#125;\n    &#125;\n    for (int j = 29; ~j; --j)\n        for (int i = 0; i &lt;= tot; ++i) &#123;\n            if (j != 29) &#123;\n                f[0][j][i] += f[0][j + 1][i];\n                f[1][j][i] += f[1][j + 1][i];\n                f[0][j][to[1][j][i]] += f[1][j + 1][i];\n                f[1][j][to[0][j][i]] += f[0][j + 1][i];\n            &#125;\n            f[1][j][i] += cnt[1][j][i];\n            f[0][j][i] += cnt[0][j][i];\n        &#125;\n    for (int i = 0; i &lt;= tot; ++i) &#123;\n        sum[T[i][0]] += f[0][0][i], sum[T[i][1]] += f[1][0][i];\n        // printf(&quot;%d %d\\n&quot;, f[i][0][0], f[i][0][1]);\n    &#125;\n    &#123;\n        std::queue&lt;int&gt; q;\n        for (int i = 0; i &lt;= tot; ++i)\n            if (!deg[i])\n                q.push(i);\n        for (; !q.empty(); ) &#123;\n            int u = q.front();\n            q.pop();\n            sum[fail[u]] += sum[u];\n            if (!--deg[fail[u]])\n                q.push(fail[u]);\n        &#125;\n    &#125;\n    for (int i = 1; i &lt;= m; ++i)\n        std::cout &lt;&lt; sum[tail[i]] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"eg3.-legen\">eg3. Legen…</h3>\n<p><a href=\"https://codeforces.com/problemset/problem/696/D\" class=\"uri\">https://codeforces.com/problemset/problem/696/D</a></p>\n<p>先在 fail 树上把每个状态的实际价值计算出来。我们发现匹配串是未知的，也就是我们需要主动决定游走路径。注意到 <span class=\"math inline\">\\(l=10^{14}\\)</span>，考虑矩阵。</p>\n<p>令 <span class=\"math inline\">\\(f_{u, i}\\)</span> 表示在 <span class=\"math inline\">\\(u\\)</span> 状态时已经走了 <span class=\"math inline\">\\(i\\)</span> 步，可以得到的最大价值。那么显然有：</p>\n<p><span class=\"math display\">\\[\nf_{v,i+1}=f_{u,i}+s_v.\n\\]</span></p>\n<p>其中 <span class=\"math inline\">\\(v\\)</span> 是自动机上 <span class=\"math inline\">\\(u\\)</span> 的任意出边。图的大小为 <span class=\"math inline\">\\(200\\)</span>，可以放到 <span class=\"math inline\">\\(+\\max\\)</span> 矩阵里加速转移。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 2e5 + 5;\nconst long long inf = 1e18;\nint fail[maxn], T[maxn][26], tot;\nint ins(std::string s) &#123;\n    int p = 0;\n    for (auto i : s) &#123;\n        if (!T[p][i - &#39;a&#39;])\n            T[p][i - &#39;a&#39;] = ++tot;\n        p = T[p][i - &#39;a&#39;];\n    &#125;\n    return p;\n&#125;\nstruct matrix &#123;\n    int n, m;\n    std::vector&lt;std::vector&lt;long long&gt; &gt; a;\n    matrix(int n1, int m1, long long v = -inf, bool op = 0): n(n1), m(m1), a(n + 1, std::vector&lt;long long&gt; (m + 1, v)) &#123;\n        if (op)\n            for (int i = 0; i &lt;= n; ++i)\n                a[i][i] = 0;\n        return;\n    &#125;\n    std::vector&lt;long long&gt; &amp;operator[] (int i) &#123;\n        return a[i];\n    &#125;\n    matrix operator* (matrix &amp;q) const &#123;\n        matrix res(n, q.m);\n        for (int k = 0; k &lt;= m; ++k)\n            for (int i = 0; i &lt;= n; ++i)\n                for (int j = 0; j &lt;= q.m; ++j)\n                    res[i][j] = std::max(res[i][j], a[i][k] + q[k][j]);\n        return res;\n    &#125;\n    matrix&amp; operator*= (matrix q) &#123;\n        return *this = *this * q;\n    &#125;\n    matrix operator^ (long long q) &#123;\n        matrix res(n, n, -inf, 1), x(*this);\n        for (; q; q &gt;&gt;= 1, x *= x)\n            if (q &amp; 1)\n                res *= x;\n        return res;\n    &#125;\n&#125;;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    long long m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;long long&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::vector&lt;int&gt; tail(n + 1);\n    std::vector&lt;std::string&gt; t(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; t[i];\n        tail[i] = ins(t[i]);\n    &#125;\n    std::vector&lt;long long&gt; s(tot + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        s[tail[i]] += a[i];\n    &#123;\n        std::queue&lt;int&gt; q;\n        for (int i = 0; i &lt; 26; ++i)\n            if (T[0][i])\n                q.push(T[0][i]); \n        for (; !q.empty(); ) &#123;\n            int u = q.front();\n            q.pop();\n            for (int i = 0; i &lt; 26; ++i)\n                if (T[u][i]) &#123;\n                    int v = T[u][i];\n                    fail[v] = T[fail[u]][i], s[v] += s[fail[v]];\n                    q.push(v);\n                &#125;\n                else\n                    T[u][i] = T[fail[u]][i];\n        &#125;\n    &#125;\n    matrix f(0, tot), op(tot, tot);\n    f[0][0] = 0;\n    for (int i = 0; i &lt;= tot; ++i)\n        for (int j = 0; j &lt; 26; ++j)\n            op[i][T[i][j]] = s[T[i][j]];\n    f *= (op * m);\n    std::cout &lt;&lt; *std::max_element(f[0].begin(), f[0].end()) &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;\n</code></pre>\n</details>\n<hr />\n<h3 id=\"eg4.-you-are-given-some-strings\">eg4. You Are Given Some Strings…</h3>\n<p>goto <a href=\"/20250121/#%E4%B8%80%E4%B8%AA%E6%A8%A1%E6%9D%BFcf1202e-you-are-given-some-strings...\">link</a>.</p>\n",
            "tags": [
                "DP",
                "字符串",
                "AC 自动机"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20241104/",
            "url": "https://xsc062.netlify.app/20241104/",
            "title": "杂题",
            "date_published": "2024-11-04T01:05:07.000Z",
            "content_html": "<p>哭いた閃光が目に刺さる / お別かれの鐘が鳴る / 神が成した歴史の / 結ぶ答えは砂の味がする</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a.-美味しい美味しいハンバーグ\">A. 美味しい美味しいハンバーグ</h2>\n<p><a href=\"https://vjudge.net/contest/669299#problem/A\" class=\"uri\">https://vjudge.net/contest/669299#problem/A</a></p>\n<p>有一个很神奇的随机化做法：我们从前往后串签子，最开始签子数为 <span class=\"math inline\">\\(0\\)</span>，如果当前任何一个签子都没办法再串这一个就新增签子。如果没有签子可以用了，就说明这块肉不合法，挪到前 <span class=\"math inline\">\\(k\\)</span> 块中的随机位置使其优先被选择。</p>\n<p>你会发现这个做法跑得很快，spdarkle 说因为 <span class=\"math inline\">\\(K\\)</span> 很小还保证有解，所以期望次数是非常对的。我太菜了他也没细说所以开摆。</p>\n<p>由于神秘原因，我的 <code>std::mt19937::operator()</code> 如果外边不套一层 abs 就会起飞 <img src=\"/em/yun.gif\" alt=\"晕\" /></p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    struct _ &#123; int l, r, u, d; &#125;;\n    std::vector&lt;_&gt; a(n + 1), b(k + 1);\n    std::mt19937 rand(time(nullptr));\n    auto random = [&amp;](int l, int r) &#123;\n        return l + std::abs((int)rand()) % (r - l + 1);\n    &#125;;\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i].l &gt;&gt; a[i].u &gt;&gt; a[i].r &gt;&gt; a[i].d;\n    for (;;) &#123;\n        std::copy(a.begin() + 1, a.begin() + k + 1, b.begin() + 1);\n        for (int i = k + 1; i &lt;= n; ++i) &#123;\n            for (int j = 1; j &lt;= k; ++j) &#123;\n                if (std::min(b[j].r, a[i].r) &gt;= std::max(b[j].l, a[i].l) &amp;&amp; std::min(b[j].d, a[i].d) &gt;= std::max(b[j].u, a[i].u)) &#123;\n                    b[j].l = std::max(b[j].l, a[i].l);\n                    b[j].r = std::min(b[j].r, a[i].r);\n                    b[j].u = std::max(b[j].u, a[i].u);\n                    b[j].d = std::min(b[j].d, a[i].d);\n                    goto issol;\n                &#125;\n            &#125;\n            std::swap(a[i], a[random(1, i)]);\n            goto nosol;\n        issol: ;\n        &#125;\n        for (int i = 1; i &lt;= k; ++i)\n            std::cout &lt;&lt; b[i].l &lt;&lt; &#39; &#39; &lt;&lt; b[i].u &lt;&lt; &#39;\\n&#39;;\n        break;\n    nosol: ;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b.-shik-and-travel\">B. Shik and Travel</h2>\n<p><a href=\"https://vjudge.net/contest/669299#problem/B\" class=\"uri\">https://vjudge.net/contest/669299#problem/B</a></p>\n<p>最小化最大，显然需要二分答案，check 打个 DP。具体怎么 DP 呢？首先考虑暴力，设 <span class=\"math inline\">\\(f_{u, a, b}\\)</span> 表示在当前 <span class=\"math inline\">\\(mid\\)</span> 的限制下，从 <span class=\"math inline\">\\(u\\)</span> 出发到第一个叶子距离为 <span class=\"math inline\">\\(a\\)</span>，最后一个距离为 <span class=\"math inline\">\\(b\\)</span> 的可行性。那么有 <span class=\"math inline\">\\(f_{u,a,b} = (f_{l,a,i}\\land f_{r,j,b})\\lor (f_{r,a,i}\\land f_{l,j,b})\\)</span>。</p>\n<p>先不说转移，状态数已经难以接受。所以我们从状态数入手，显然如果存在一个 <span class=\"math inline\">\\(a&#39;\\le a\\)</span> 和 <span class=\"math inline\">\\(b&#39;\\le b\\)</span>，那么 <span class=\"math inline\">\\((a&#39;,b&#39;)\\)</span> 就是无用状态。也就是说，我们把所有有用的 <span class=\"math inline\">\\((a, b)\\)</span> 按 <span class=\"math inline\">\\(a\\)</span> 从小到大排序，<span class=\"math inline\">\\(b\\)</span> 应该是单调递减的；考虑这个抽象的过程，相当于从头到尾遍历一串状态，在路上碰到的所有较大的 <span class=\"math inline\">\\(b\\)</span> 都会被当场丢弃。</p>\n<p>感性思考可以发现<mark>当我们试图让 <span class=\"math inline\">\\(b\\)</span> 最小的时候，这个状态最有用（即最不可能被丢弃）</mark>。对于一个 <span class=\"math inline\">\\(f_{l,a,i}\\)</span>，我们找到能够转移的 <span class=\"math inline\">\\(f_{r,j,b_{\\min}}\\)</span> 来转移。正确性很好证明，我们的 check 只要求在根节点上存在任意合法状态，那只需要让最不可能被丢弃的不被丢弃即可，更可能被丢弃的状态是否被丢弃就不会产生影响了。</p>\n<p>优化后的状态数在 <span class=\"math inline\">\\(u\\)</span> 上只会增加 <span class=\"math inline\">\\(\\min(|a_l|,|b_r|)+\\min(|a_r|,|b_l|)\\)</span>，即两个儿子上的状态数较小者，参考 DSU on tree，是 <span class=\"math inline\">\\(O(n\\log)\\)</span> 的。加上对状态排序的数据结构，复杂度 <span class=\"math inline\">\\(O(n\\log^2 n\\log V)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst long long inf = 1e18;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(n + 1);\n    for (int i = 2, x, w; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; w;\n        g[x].emplace_back(i, w);\n    &#125;\n    long long res = -1;\n    for (long long l = 0, r = inf, mid; l &lt;= r; ) &#123;\n        mid = (l + r) &gt;&gt; 1;\n        if ([&amp;](void) -&gt; bool &#123;\n            std::vector&lt;std::vector&lt;std::pair&lt;long long, long&gt; &gt; &gt; f(n + 1);\n            std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n                if (g[x].empty()) &#123;\n                    f[x].emplace_back(0, 0);\n                    return;\n                &#125;\n                long long lim = mid;\n                for (auto [i, w] : g[x])\n                    DFS(i), lim -= w;\n                std::vector&lt;std::pair&lt;long long, long long&gt; &gt; t;\n                for (int i = 0; i &lt; 2; ++i) &#123;\n                    int j = 0;\n                    auto l = g[x][0], r = g[x][1];\n                    for (auto [a, b] : f[l.first]) &#123;\n                        for (; j + 1 &lt; (int)f[r.first].size() &amp;&amp; f[r.first][j + 1].first + b &lt;= lim; ++j);\n                        if (j &lt; (int)f[r.first].size() &amp;&amp; f[r.first][j].first + b &lt;= lim)\n                            t.emplace_back(a + l.second, f[r.first][j].second + r.second);\n                    &#125;\n                    std::swap(g[x][0], g[x][1]);\n                &#125;\n                std::sort(t.begin(), t.end());\n                for (auto [a, b] : t)\n                    if (f[x].empty() || f[x].back().second &gt; b)\n                        f[x].emplace_back(a, b);\n                return;\n            &#125;;\n            DFS(1);\n            return !f[1].empty();\n        &#125; ())\n            res = mid, r = mid - 1;\n        else \n            l = mid + 1;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d.-candy-piles\">D. Candy Piles</h2>\n<p><a href=\"https://vjudge.net/contest/669299#problem/D\" class=\"uri\">https://vjudge.net/contest/669299#problem/D</a></p>\n<p>不难发现我们可以把题意转化为，把所有列从大到小排列，每次可以选择删掉最左边一列或最下边一行，删空者胜。</p>\n<p>把该柱状图转化为网格图，定义边界为胜利点，对于非边界上的点，其一定可以往右走、往上走。若一个点上方、右侧点均为胜利点，此点为失败点；否则，此点为胜利点。</p>\n",
            "tags": []
        },
        {
            "id": "https://xsc062.netlify.app/20241027/",
            "url": "https://xsc062.netlify.app/20241027/",
            "title": "CSP-S",
            "date_published": "2024-10-27T00:48:02.000Z",
            "content_html": "<p>弟娃年方十一。方出考场之时，余问弟娃曰：「T1 用时几何？」。弟娃对曰：「及过大样例，已半炷香矣。」余大恸，为余 T1 大样例既过，已两柱香有余。古谚有云：「若有一人年少于吾亦强于吾，吾为之单调队列也。」吾弟娃年少于吾，殊难易之；今吾弟娃已四倍而强于吾，吾盍为单调队列哉！</p>\n<span id=\"more\"></span>\n<hr />\n<p>忆往昔昔（初二），1=。忆往昔昔昔（初一），1=。忆往昔（初三），135pts 喜提 2=。</p>\n<p>看今朝，300pts 应该有 1=。哇恭喜恭喜，2= 到 1=，一年来你有很大进步呢！</p>\n<hr />\n<h2 id=\"a.-duel\">A. duel</h2>\n<p>非常遗憾地，被橙题<mark>硬控 1h+</mark>。问就是上场之后先花了 59min 下载 <em>大脑.tar.gz</em>，然后 1s 知道做法，59s 实现。</p>\n<p>其实我们是注意到了众数的那个奇妙结论的，但是因为太奇怪并且担心是因为大样例太水所以没敢写，不服来战。</p>\n<hr />\n<h2 id=\"b.-detect\">B. detect</h2>\n<p>我们在求解出区间后被精度问题<mark>硬控 1h+</mark>。在按照右端点排序后超厉害地使用 <strong>线段树优化 DP</strong> 解决了初一简单线性贪心问题。哈哈哈。</p>\n<p>笑话：被精度问题控的 1h 里有 40min 扑在因为调精度而打出来的 <em>死循环</em> 上 <img src=\"/em/kx.gif\" /></p>\n<hr />\n<h2 id=\"c.-color\">C. color</h2>\n<p>在 5min 解决费用提前计算式子后删除了 node_modules &gt; 大脑，稍加思考得出了「大抵是不存在不带 <span class=\"math inline\">\\(\\log\\)</span> 的全局修改、单点修改、单点查询的数据结构的」的结论，超厉害地使用 <strong>线段树优化 DP</strong>，并且被全局修改懒标记没传给树根<mark>硬控 1h+</mark>。</p>\n<p>不过因为知道 1e6 的数据给线段树确实挺奇怪的，所以大力卡常，赛时代码跑民间数据跑得挺快。也就是线性所有点加起来 500ms，我一个点就要跑 500ms 的水平 <img src=\"/em/kx.gif\" /> 虽然肯定 T 是不可能 T 的。</p>\n<hr />\n<h2 id=\"d.-arena\">D. arena</h2>\n<p>坏消息：前三题均被硬控 1h+，T4 连暴力都打不完了，甚而至于，输入都打不完喜提零蛋。</p>\n<p>好消息：看开点，至少 T4 不会被<mark>硬控 1h+</mark> <img src=\"/em/kx.gif\" /></p>\n<p>这道题有个好写的做法，先胡一胡，等会儿开一篇具体写一写。</p>\n<p>还原到每场比赛胜出者能力值（线性），还需要注意到一个单调性：若在加入一个人后某场比赛的胜者就不可能成为全局胜者（相当于知道其祖先中某个元素的具体胜者，且该胜者不是自己），那么加入更多的人也不行。故记录这个人（假设对于比赛 <span class=\"math inline\">\\(x\\)</span> 为 <span class=\"math inline\">\\(id_x\\)</span>），那么知道了所有叶子的 <span class=\"math inline\">\\(id\\)</span> 就可以随便乱搞了。至于求 <span class=\"math inline\">\\(id\\)</span> 的过程，直接把 <span class=\"math inline\">\\(1\\sim n\\)</span> 的人加入二叉树，如果某个点被确定了胜者，就往败者子树打一个标记，完了过后遍历整个树下传标记即可。</p>\n<hr />\n<p>小知识：在 2024 CSP-S2 中，99% 的人打了 0 个 <strong>线段树优化 DP</strong>，而你打了 2 个 <strong>线段树优化 DP</strong> <img src=\"/em/kx.gif\" /></p>\n<hr />\n<p>可怜捏。100 + 100 + 100 + 0 = 300。由于 T4 输入没写完是没机会浮动了。拜拜 WC。</p>\n<p>草草草，wc 都拜拜了我今年是不是直接原地 afo 了啊。不要啊不要啊。</p>\n",
            "tags": [
                "下饭"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20241021-1/",
            "url": "https://xsc062.netlify.app/20241021-1/",
            "title": "长链剖分 学习笔记",
            "date_published": "2024-10-21T08:33:47.000Z",
            "content_html": "<p><em>半端な生命の関数を / 少々ここらでオーバーライド</em></p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"内容-性质\">内容 &amp; 性质</h2>\n<p>把重链剖分选的 siz 最大的儿子换成高度最大的儿子就是长剖了。同样具有一些美妙的性质。</p>\n<ul>\n<li><p>任意点到根节点经过的链数最劣为 <span class=\"math inline\">\\(\\sqrt n\\)</span>。</p>\n<p>考虑构造一条经过了 <span class=\"math inline\">\\(\\sqrt n+1\\)</span> 条链的路径，发现构造不出来。得证。（？）</p>\n这点也决定了长剖和重剖走的不是一条赛道，更多的是处理一些和深度有关的场景下的问题。用法有点像 dsu on tree。</li>\n<li><p>任意点 <span class=\"math inline\">\\(x\\)</span> 的 <span class=\"math inline\">\\(k\\)</span> 级祖先 <span class=\"math inline\">\\(fa\\)</span> 所在链长 <span class=\"math inline\">\\(\\ge k\\)</span>。</p>\n<p>考虑反证。若 <span class=\"math inline\">\\(fa\\)</span> 所在链长度 <span class=\"math inline\">\\(&lt;k\\)</span>，则 <span class=\"math inline\">\\(fa\\to x\\)</span> 更优，矛盾。故原命题成立。</p></li>\n</ul>\n<hr />\n<h2 id=\"求-k-级祖先\">求 k 级祖先</h2>\n<p>长剖的一个典型应用是 <span class=\"math inline\">\\(O(n\\log n)-O(1)\\)</span> 求 <span class=\"math inline\">\\(k\\)</span> 级祖先。先考虑相对暴力的做法，可以 <span class=\"math inline\">\\(O(n\\sqrt n)\\)</span> 预处理每个点的 <span class=\"math inline\">\\(1\\sim \\sqrt n\\)</span> 级祖先然后块间块内随便跳一跳就是 <span class=\"math inline\">\\(O(\\sqrt n)\\)</span> 的单次查询了。</p>\n<p>把这个暴力结合「任意点 <span class=\"math inline\">\\(k\\)</span> 级祖先所在链长 <span class=\"math inline\">\\(\\ge k\\)</span>」的性质，令 <span class=\"math inline\">\\(r=\\dfrac k2\\)</span>，那么 <span class=\"math inline\">\\(x\\)</span> 的 <span class=\"math inline\">\\(r\\)</span> 级祖先所在链长 <span class=\"math inline\">\\(\\ge r\\)</span>。假设我们现在已经知道 <span class=\"math inline\">\\(r\\)</span> 级祖先 <span class=\"math inline\">\\(fa_r\\)</span>，预处理出链内点序列、链顶向上的链长个祖先（均摊 <span class=\"math inline\">\\(O(n)\\)</span>），就可以 <span class=\"math inline\">\\(O(1)\\)</span> 访问 <span class=\"math inline\">\\(fa_k\\)</span>。</p>\n<p>怎么找到 <span class=\"math inline\">\\(fa_r\\)</span> 呢？这看似是递归的问题，实际上发现 <span class=\"math inline\">\\(r\\)</span> 的取值只需 <span class=\"math inline\">\\(\\ge \\dfrac k2\\)</span>，对于 <span class=\"math inline\">\\(1\\sim n\\)</span> 的每一个 <span class=\"math inline\">\\(k\\)</span>，找到其最高二进制位 <span class=\"math inline\">\\(r\\)</span>（显然 <span class=\"math inline\">\\(r\\)</span> 的可能取值有 <span class=\"math inline\">\\(\\log n\\)</span> 种），对于每个点，预处理出其 <span class=\"math inline\">\\(\\log n\\)</span> 个不同的 <span class=\"math inline\">\\(r\\)</span> 级祖先。这个就是倍增了。</p>\n<details>\n<pre class=\"cpp\"><code>for (int i = 1, mx = 0; i &lt;= n; ++i) &#123;\n    if (i &gt;= (1 &lt;&lt; mx) * 2)\n        ++mx;\n    to[i] = mx;\n&#125;\nstd::vector&lt;std::array&lt;int, 21&gt; &gt; fa(n + 1);\nstd::vector&lt;int&gt; h(n + 1, 1), son(n + 1), dep(n + 1);\nh[0] = 0;\nstd::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n    for (auto i : g[x])\n        if (i != fa[x][0]) &#123;\n            fa[i][0] = x;\n            for (int j = 1; j &lt;= 20; ++j)\n                fa[i][j] = fa[fa[i][j - 1]][j - 1];\n            dep[i] = dep[x] + 1;\n            DFS(i);\n            if (h[i] &gt;= h[son[x]])\n                son[x] = i, h[x] = h[i] + 1;\n        &#125;\n    return;\n&#125;;\ndep[1] = 1, DFS(1);\nstd::vector&lt;int&gt; top(n + 1), id(n + 1);\nstd::vector&lt;std::vector&lt;int&gt; &gt; anc(n + 1), des(n + 1, std::vector&lt;int&gt; (1));\nstd::function&lt;void(int, int)&gt; DFS1 = [&amp;](int x, int toq) &#123;\n    top[x] = toq;\n    if (son[x])\n        DFS1(son[x], toq);\n    for (auto i : g[x])\n        if (i != fa[x][0] &amp;&amp; i != son[x])\n            DFS1(i, i);\n    des[toq].push_back(x);\n    id[x] = (int)des[toq].size() - 1;\n    if (x == toq) &#123;\n        anc[x].push_back(x);\n        for (int j = 1, now = x; j &lt;= id[x]; ++j, now = fa[now][0])\n            anc[x].push_back(fa[now][0]);\n    &#125;\n    return;\n&#125;;\nDFS1(1, 1);\nauto ask = [&amp;](int x, int k) &#123;\n    int x1 = x;\n    if (!k)\n        return x;\n    x = fa[x][to[k]];\n    if (dep[x] - dep[top[x]] &gt;= k - (1 &lt;&lt; to[k]))\n        return des[top[x]][id[x] + k - (1 &lt;&lt; to[k])];\n    return anc[top[x]][k - (1 &lt;&lt; to[k]) - (dep[x] - dep[top[x]])];\n&#125;;</code></pre>\n</details>\n<hr />\n<h2 id=\"优化-dp\">优化 DP</h2>\n<blockquote>\n<p>yly：管它这那的，只要是有关深度直接上长剖就是了。</p>\n</blockquote>\n<p>和 DSU on tree 类似，主要利用每条链只会被算一次实现 <span class=\"math inline\">\\(O(n)\\)</span> DP。具体地，尽可能地『继承』长链的信息，『短链』则暴力合并。</p>\n<p>值得注意的是，一般『深度』这一维信息会以『与 <span class=\"math inline\">\\(u\\)</span> 的距离』的形式，结合指针来维护（因为直接记录深度会更史）。</p>\n<p>具体地，用一个全局大数组容纳所有信息，为每个点分配相应的数组头指针。正常情况下需要用到的元素最多为 <span class=\"math inline\">\\(2n\\)</span>，但如果存在一些诡异的前移后移操作就另当别论了。</p>\n<hr />\n<h3 id=\"p5904-poi-2014-hot-hotels-加强版\">P5904 [POI 2014] HOT-Hotels 加强版</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P5904\" class=\"uri\">https://www.luogu.com.cn/problem/P5904</a></p>\n<p>首先 <del>不难</del> 得到 <span class=\"math inline\">\\(O(n^2)\\)</span> 做法：显然存在一个点到三个点距离相等。这个点既可能是它们的 LCA，也可能是其中一个点的子孙，另外两个点的 LCA。综上，<strong>在 LCA 处统计答案是可行的</strong>。</p>\n<p>令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示 <span class=\"math inline\">\\(i\\)</span> 子树中距离 <span class=\"math inline\">\\(i\\)</span> 为 <span class=\"math inline\">\\(j\\)</span> 的点数；<span class=\"math inline\">\\(g_{i,j}\\)</span> 表示 <span class=\"math inline\">\\(i\\)</span> 子树中距离 <span class=\"math inline\">\\(i\\)</span> 为 <span class=\"math inline\">\\(j\\)</span>、或者距 LCA 为 <span class=\"math inline\">\\(d\\)</span> 且 LCA 距离 <span class=\"math inline\">\\(i\\)</span> 为 <span class=\"math inline\">\\(d-j\\)</span> 的点对数；随便做就可以了。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g1[x].push_back(y), g1[y].push_back(x);\n    &#125;\n    auto res(0ll);\n    std::vector&lt;int&gt; h(n + 1);\n    std::vector&lt;std::vector&lt;long long&gt; &gt; f(n + 1), g(n + 1);\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        h[x] = 1;\n        for (auto i : g1[x])\n            if (i != fa) &#123;\n                DFS(i, x);\n                h[x] = std::max(h[x], h[i] + 1);\n            &#125;\n        f[x].resize(h[x] + 1), g[x].resize(h[x] + 1);\n        f[x][0] = 1ll;\n        for (auto i : g1[x])\n            if (i != fa) &#123;\n                for (int j = 0; j &lt;= h[i]; ++j) &#123;\n                    if (j &gt;= 1)\n                        res += g[x][j] * f[i][j - 1];\n                    if (j &gt;= 1 &amp;&amp; j + 1 &lt;= h[i])\n                        res += f[x][j] * g[i][j + 1];\n                    if (j &gt;= 1) &#123;\n                        g[x][j] += f[x][j] * f[i][j - 1];\n                        f[x][j] += f[i][j - 1];\n                    &#125;\n                    if (j + 1 &lt;= h[i])\n                        g[x][j] += g[i][j + 1];\n                &#125;\n                std::vector&lt;long long&gt;().swap(f[i]);\n                std::vector&lt;long long&gt;().swap(g[i]);\n            &#125;\n        res += g[x][0];\n        return;\n    &#125;;\n    DFS(1, -1);\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<p>然后对于每个 <span class=\"math inline\">\\(u\\)</span>，类似 DSU on tree，继承其长儿子的数据（整体前移 / 后移一位，使用指针实现），再把短儿子暴力合并上来。</p>\n<p>每次合并短儿子，数组长为短儿子链长；<span class=\"math inline\">\\(u\\)</span> 向上合并时，数组长为长儿子链长。故所有链被合并恰好一次，复杂度 <span class=\"math inline\">\\(O(n)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g1[x].push_back(y), g1[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; h(n + 1), son(n + 1);\n    std::vector&lt;long long&gt; df(5 * n + 1), dg(5 * n + 1);\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        h[x] = 1;\n        for (auto i : g1[x])\n            if (i != fa) &#123;\n                DFS(i, x);\n                h[x] = std::max(h[x], h[i] + 1);\n                if (h[i] &gt; h[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1, -1);\n    auto pos(dg.begin() + 3 * n);\n    std::vector&lt;decltype(df.begin())&gt; f(n + 1), g(n + 1);\n    auto res(0ll);\n    DFS = [&amp;](int x, int fa) &#123;\n        f[x][0] = 1ll;\n        if (son[x]) &#123;\n            f[son[x]] = std::next(f[x]), g[son[x]] = std::prev(g[x]);\n            DFS(son[x], x);\n        &#125;\n        for (auto i : g1[x])\n            if (i != fa &amp;&amp; i != son[x]) &#123;\n                f[i] = std::next(f[x], h[x] + 1);\n                std::fill(f[i], f[i] + h[i] + 2, 0ll);\n                g[i] = std::next(pos, h[i]), pos = std::next(g[i], h[i]);\n                std::fill(std::prev(g[i]), g[i] + h[i] + 2, 0ll);\n                DFS(i, x);\n                for (int j = 0; j &lt;= h[i]; ++j) &#123;\n                    if (j &gt;= 1)\n                        res += g[x][j] * f[i][j - 1];\n                    if (j &gt;= 1 &amp;&amp; j + 1 &lt;= h[i])\n                        res += f[x][j] * g[i][j + 1];\n                    if (j &gt;= 1) &#123;\n                        g[x][j] += f[x][j] * f[i][j - 1];\n                        f[x][j] += f[i][j - 1];\n                    &#125;\n                    if (j + 1 &lt;= h[i])\n                        g[x][j] += g[i][j + 1];\n                &#125;\n            &#125;\n        res += g[x][0];\n        return;\n    &#125;;\n    f[1] = df.begin(), g[1] = dg.begin() + 2 * n;\n    DFS(1, -1);\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"cf1585g-poachers\">CF1585G Poachers</h3>\n<p><a href=\"https://codeforces.com/problemset/problem/1585/G\" class=\"uri\">https://codeforces.com/problemset/problem/1585/G</a></p>\n<p>公平博弈。我们现在要算每个根的 SG 值。设 <span class=\"math inline\">\\(f_{u,j}\\)</span> 表示在点 <span class=\"math inline\">\\(u\\)</span>，删了距离它为 <span class=\"math inline\">\\(j\\)</span> 这一层的 SG 值，那么有：</p>\n<p><span class=\"math display\">\\[\nf_{u,j}=\n\\begin{cases}\n\\text{mex}\\{f_{v,0}\\}&amp;j=0\\\\\n\\bigoplus f_{v,j-1}&amp;\\text{otherwise}\n\\end{cases}\n\\]</span></p>\n<p>然后发现有深度维。大力长剖。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int inf = 0x3f3f3f3f;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n;\n        std::cin &gt;&gt; n;\n        std::vector&lt;int&gt; rt;\n        std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n        for (int i = 1, x; i &lt;= n; ++i) &#123;\n            std::cin &gt;&gt; x;\n            if (x)\n                g[x].push_back(i);\n            else\n                rt.push_back(i);\n        &#125;\n        std::vector&lt;int&gt; h(n + 1), son(n + 1), to(n + 1, inf);\n        std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n            h[x] = 1;\n            for (auto i : g[x]) &#123;\n                DFS(i);\n                h[x] = std::max(h[x], h[i] + 1);\n                to[x] = std::min(to[x], to[i] + 1);\n                if (h[i] &gt; h[son[x]])\n                    son[x] = i;\n            &#125;\n            to[x] = std::min(to[x], h[x]);\n            return;\n        &#125;;\n        for (auto i : rt)\n            DFS(i);\n        std::vector&lt;int&gt; _f(5 * n + 1), top(n + 1);\n        std::vector&lt;decltype(_f.begin())&gt; f(n + 1);\n        std::vector&lt;std::unordered_set&lt;int&gt; &gt; s(n + 1);\n        auto p(_f.begin());\n        DFS = [&amp;](int x) &#123;\n            if (son[x]) &#123;\n                f[son[x]] = std::next(f[x]);\n                top[son[x]] = top[x], DFS(son[x]);\n            &#125;\n            if ((int)g[x].size() == 1) &#123;\n                s[top[x]].insert(f[son[x]][0]);\n                for (int now = f[son[x]][0] + 1; ; ++now)\n                    if (!s[top[x]].count(now)) &#123;\n                        f[x][0] = now;\n                        break;\n                    &#125;\n                return;\n            &#125;\n            for (auto i : g[x])\n                if (i != son[x]) &#123;\n                    f[i] = p, p = std::next(p, h[i] + 1);\n                    top[i] = i, DFS(i);\n                    for (int j = 1; j &lt;= to[i] + 1; ++j)\n                        f[x][j] ^= f[i][j - 1];\n                &#125;\n            std::unordered_set&lt;int&gt;().swap(s[top[x]]);\n            for (int j = 1; j &lt;= to[x]; ++j)\n                s[top[x]].insert(f[x][j]);\n            for (int now = 0; ; ++now)\n                if (!s[top[x]].count(now)) &#123;\n                    f[x][0] = now;\n                    break;\n                &#125;\n            return;\n        &#125;;\n        int res = 0;\n        for (auto i : rt) &#123;\n            f[i] = p, p = std::next(p, h[i] + 1);\n            DFS(i), res ^= f[i][0];\n        &#125;\n        std::cout &lt;&lt; (res ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n",
            "tags": [
                "树链剖分",
                "长链剖分"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20241021/",
            "url": "https://xsc062.netlify.app/20241021/",
            "title": "字符串",
            "date_published": "2024-10-21T00:32:59.000Z",
            "content_html": "<p>标题本来叫「哈希」，后来发现第二天的很多题虽然打了哈希的 tag 但是只有 KMP 做法，故忍痛改成「字符串」。</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a.-two-permutations\">A. Two Permutations</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/5653/problem/1\" class=\"uri\">http://222.180.160.110:61235/contest/5653/problem/1</a></p>\n<p>有个很重要的性质是 <span class=\"math inline\">\\(a\\)</span> 和 <span class=\"math inline\">\\(b\\)</span> 都是排列。然后我们就知道了 <span class=\"math inline\">\\(x\\in [0,m-n]\\)</span>，且每个 <span class=\"math inline\">\\(a_i+x\\)</span> 在 <span class=\"math inline\">\\(b\\)</span> 中有元素与之唯一对应。<mark>于是问题可以转化成，<span class=\"math inline\">\\(b\\)</span> 中在 <span class=\"math inline\">\\([1+x,n+x]\\)</span> 范围中的元素按顺序哈希起来和 <span class=\"math inline\">\\(a\\)</span> 序列是否完全一致</mark>。</p>\n<p>我们就有了一个想法：枚举这个 <span class=\"math inline\">\\(x\\)</span>，通过某种方法快速查询这个长度固定的值域区间按顺序哈希起来的值。<mark>然后就是典中典之线段树维护哈希，只需在枚举 <span class=\"math inline\">\\(x\\)</span> 时滑动窗口，剔除头部元素，新增尾部元素，查询全局哈希值即可</mark>。</p>\n<p>还有一个小细节是关于实时维护全局加 <span class=\"math inline\">\\(x\\)</span> 后的 <span class=\"math inline\">\\(a\\)</span>。由于哈希用乘的肯定拆不开，只能用加哈希了。每次 <span class=\"math inline\">\\(x\\)</span> 加一的时候全局哈希值加上 <span class=\"math inline\">\\(\\sum p_i\\)</span> 即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int p = 998244353;\nconst int mod = 1e9 + 7;\nconst int maxn = 2e5 + 5;\nstruct &#123;\n    int l, r, s;\n    long long u;\n&#125; t[maxn &lt;&lt; 2];\nlong long base[maxn];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid pushup(int p) &#123;\n    t[p].u = (t[lt].u * base[t[rt].s] % mod + t[rt].u) % mod;\n    return;\n&#125;\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    if (l == r)\n        return;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    return;\n&#125;\nvoid add(int p, int x, int v) &#123;\n    t[p].s += (v &gt;= 0 ? 1 : -1);\n    if (t[p].l == t[p].r) &#123;\n        t[p].u += v;\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        add(lt, x, v);\n    else\n        add(rt, x, v);\n    pushup(p);\n    return;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;int&gt; a(n + 1), b(m + 1), pos(m + 1);\n    base[0] = 1;\n    long long s = 1;\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        base[i] = base[i - 1] * p % mod;\n        if (i &lt; n)\n            (s += base[i]) %= mod;\n    &#125;\n    long long now = 0;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        now = (now * p % mod + a[i]) % mod;\n    &#125;\n    for (int i = 1; i &lt;= m; ++i)\n        std::cin &gt;&gt; b[i], pos[b[i]] = i;\n    int res = 0;\n    bld(1, 1, m);\n    for (int x = 0; x &lt;= m - n; ++x) &#123;\n        for (static int l = 1; l &lt; 1 + x; add(1, pos[l], -l), ++l);\n            // printf(&quot;add %d: %d\\n&quot;, pos[l], -l);\n        for (static int r = 1; r &lt;= n + x; add(1, pos[r], r), ++r);\n            // printf(&quot;add %d: %d\\n&quot;, pos[r], r);\n        (res += (now == t[1].u));\n        // printf(&quot;x = %d, now = %lld, t[1].u = %lld\\n&quot;, x, now, t[1].u);\n        (now += s) %= mod;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b.-k-substrings\">B. k-substrings</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/5653/problem/2\" class=\"uri\">http://222.180.160.110:61235/contest/5653/problem/2</a></p>\n<p>我们可以发现这 <span class=\"math inline\">\\(\\left\\lceil\\dfrac n2\\right\\rceil\\)</span> 个串都有共同中点，而<mark>不管其位于元素还是元素间的空隙，两边的 border 都应关于其对称</mark>。啥叫奇 border 呢，就是每个 border 都能取到元素上的中点，<mark>也就是说这俩中点是关于全串中点对称的</mark>。</p>\n<p>我们枚举这 <span class=\"math inline\">\\(\\left\\lfloor\\dfrac n2\\right\\rfloor\\)</span> 对可能的 border 中点，分别二分 border 长度。假设最后该对中点最长合法 border 为 <span class=\"math inline\">\\([l_1,r_1]\\)</span> 与 <span class=\"math inline\">\\([l_2,r_2]\\)</span>，用 <span class=\"math inline\">\\(r_1-l_1+1-2\\times k\\)</span> 更新 <span class=\"math inline\">\\(l_1+k\\)</span> 处的答案即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int p = 131;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;char&gt; a(n + 1);\n    std::vector&lt;int&gt; res(n + 1, -1);\n    std::vector&lt;long long&gt; h(n + 1), base(n + 1);\n    base[0] = 1;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        h[i] = (h[i - 1] * p + a[i]) % mod;\n        base[i] = base[i - 1] * p % mod;\n    &#125;\n    auto geth = [&amp;](int l, int r) &#123;\n        return (h[r] + mod - h[l - 1] * base[r - l + 1] % mod) % mod;\n    &#125;;\n    for (int l = n / 2, r = (n + 1) / 2 + 1; r &lt;= n; --l, ++r)\n        if (a[l] == a[r]) &#123;\n            int t = 0;\n            for (int ll = 1, rr = l, mid; ll &lt;= rr; ) &#123;\n                mid = (ll + rr) &gt;&gt; 1;\n                if (geth(l - mid + 1, l + mid - 1) == geth(r - mid + 1, r + mid - 1))\n                    t = mid, ll = mid + 1;\n                else\n                    rr = mid - 1;\n            &#125;\n            res[l - t + 1] = std::max(res[l - t + 1], 2 * t - 1);\n        &#125;\n    for (int i = 1; i &lt;= (n + 1) / 2; ++i) &#123;\n        res[i] = std::max(res[i - 1] - 2, res[i]);\n        std::cout &lt;&lt; res[i] &lt;&lt; &#39; &#39;;\n    &#125;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c.-kefa-and-watch\">C. Kefa and Watch</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/5653/problem/3\" class=\"uri\">http://222.180.160.110:61235/contest/5653/problem/3</a></p>\n<p>一个挺常用的 trick 是，<mark><span class=\"math inline\">\\(S_{l\\sim r}\\)</span> 存在长度为 <span class=\"math inline\">\\(d\\)</span> 的循环节 <span class=\"math inline\">\\(\\iff S_{l\\sim (r-d)}=S_{(l+d+)\\sim r}\\)</span></mark>。而题目要求为混循环节，刚好也可以用这个方法判定。线段树随便维护一下哈希就行。assign 操作就是将长度为 <span class=\"math inline\">\\(len\\)</span> 的区间哈希值更改为 <span class=\"math inline\">\\(t\\times \\sum_{i=0}^{len-1}p^i\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int p = 131;\nconst int mod = 1e9 + 7;\nconst int maxn = 1e5 + 5;\nstruct &#123;\n    int l, r, d;\n    long long u;\n&#125; t[maxn &lt;&lt; 2];\nint a[maxn];\nlong long base[maxn], s[maxn];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid pushup(int p) &#123;\n    t[p].u = (t[lt].u * base[t[rt].r - t[rt].l + 1] % mod + t[rt].u) % mod;\n    return;\n&#125;\nvoid pushdown(int p) &#123;\n    if (~t[p].d) &#123;\n        t[lt].d = t[rt].d = t[p].d;\n        t[lt].u = t[p].d * s[t[lt].r - t[lt].l] % mod;\n        t[rt].u = t[p].d * s[t[rt].r - t[rt].l] % mod;\n        t[p].d = -1;\n    &#125;\n    return;\n&#125;\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r, t[p].d = -1;\n    if (l == r) &#123;\n        t[p].u = a[l];\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    pushup(p);\n    return;\n&#125;\nvoid ass(int p, int l, int r, int v) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        t[p].d = v;\n        t[p].u = v * s[t[p].r - t[p].l] % mod;\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid)\n        ass(lt, l, r, v);\n    if (r &gt; mid)\n        ass(rt, l, r, v);\n    pushup(p);\n    return;\n&#125;\nlong long ask(int p, int l, int r) &#123;\n    // printf(&quot;p = %d, u = %lld, [%d, %d] of [%d, %d]\\n&quot;, p, t[p].u, t[p].l, t[p].r, l, r);\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].u;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (r &lt;= mid)\n        return ask(lt, l, r);\n    if (l &gt; mid)\n        return ask(rt, l, r);\n    return (ask(lt, l, r) * base[std::min(r, t[p].r) - mid] % mod + ask(rt, l, r)) % mod;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m, k;\n    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;\n    base[0] = s[0] = 1;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        char t;\n        std::cin &gt;&gt; t;\n        a[i] = t - &#39;0&#39;;\n        base[i] = base[i - 1] * p % mod;\n        s[i] = (s[i - 1] + base[i]) % mod;\n    &#125;\n    bld(1, 1, n);\n    for (int q = m + k; q--; ) &#123;\n        int op;\n        std::cin &gt;&gt; op;\n        if (op == 1) &#123;\n            int l, r, t;\n            std::cin &gt;&gt; l &gt;&gt; r &gt;&gt; t;\n            ass(1, l, r, t);\n        &#125;\n        else &#123;\n            int l, r, d;\n            std::cin &gt;&gt; l &gt;&gt; r &gt;&gt; d;\n            // if (d != r - l + 1)\n            //     printf(&quot;%lld / %lld\\n&quot;, ask(1, l, r - d), ask(1, l + d, r));\n            std::cout &lt;&lt; ((d == r - l + 1 || ask(1, l, r - d) == ask(1, l + d, r)) ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; &#39;\\n&#39;;\n        &#125;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d.-misha-and-lcp-on-tree\">D. Misha and LCP on Tree</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/5653/problem/4\" class=\"uri\">http://222.180.160.110:61235/contest/5653/problem/4</a></p>\n<p>一个很显然的做法是，我们二分一个长度，然后在 <span class=\"math inline\">\\(a\\to fa\\)</span> 上正哈希，<span class=\"math inline\">\\(b\\to fa\\)</span> 上反哈希，<span class=\"math inline\">\\(O(1)\\)</span> check。</p>\n<p>笑话：本来想用倍增求 <span class=\"math inline\">\\(a\\to fa\\)</span> 和 <span class=\"math inline\">\\(b\\to fa\\)</span> 的哈希（当然双 <span class=\"math inline\">\\(\\log\\)</span> 肯定是会被卡飞的），后来发现<mark>哈希具有可减性，我们又只需求一条链上的哈希值，直接减掉就行</mark>。</p>\n<p>还有一个点就是 <span class=\"math inline\">\\(O(1)\\)</span> 求 <span class=\"math inline\">\\(k\\)</span> 级祖先，有长剖预处理的做法。<a href=\"/20241021-1\">具体做法</a>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int p = 131;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; to(n + 1);\n    std::vector&lt;char&gt; a(n + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    std::vector&lt;long long&gt; base(n + 1), inv(n + 1);\n    auto qkp = [](long long x, int y) &#123;\n        long long res = 1;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    base[0] = inv[0] = 1;\n    for (int i = 1, mx = 0; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        base[i] = base[i - 1] * p % mod;\n        inv[i] = qkp(base[i], mod - 2);\n        if (i &gt;= (1 &lt;&lt; mx) * 2)\n            ++mx;\n        to[i] = mx;\n    &#125;\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;long long&gt; h1(n + 1), h2(n + 1);\n    std::vector&lt;std::array&lt;int, 21&gt; &gt; fa(n + 1);\n    std::vector&lt;int&gt; h(n + 1, 1), son(n + 1), dep(n + 1);\n    h[0] = 0;\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        h1[x] = (h1[fa[x][0]] * p % mod + a[x]) % mod;\n        h2[x] = (h2[fa[x][0]] + a[x] * base[dep[x] - 1]) % mod;\n        for (auto i : g[x])\n            if (i != fa[x][0]) &#123;\n                fa[i][0] = x;\n                for (int j = 1; j &lt;= 20; ++j)\n                    fa[i][j] = fa[fa[i][j - 1]][j - 1];\n                dep[i] = dep[x] + 1;\n                DFS(i);\n                if (h[i] &gt;= h[son[x]])\n                    son[x] = i, h[x] = h[i] + 1;\n            &#125;\n        return;\n    &#125;;\n    dep[1] = 1, DFS(1);\n    std::vector&lt;int&gt; top(n + 1), id(n + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; anc(n + 1), des(n + 1, std::vector&lt;int&gt; (1));\n    std::function&lt;void(int, int)&gt; DFS1 = [&amp;](int x, int toq) &#123;\n        top[x] = toq;\n        if (son[x])\n            DFS1(son[x], toq);\n        for (auto i : g[x])\n            if (i != fa[x][0] &amp;&amp; i != son[x])\n                DFS1(i, i);\n        des[toq].push_back(x);\n        id[x] = (int)des[toq].size() - 1;\n        if (x == toq) &#123;\n            anc[x].push_back(x);\n            for (int j = 1, now = x; j &lt;= id[x]; ++j, now = fa[now][0])\n                anc[x].push_back(fa[now][0]);\n        &#125;\n        return;\n    &#125;;\n    DFS1(1, 1);\n    auto getLCA = [&amp;](int x, int y) &#123;\n        if (dep[x] &lt; dep[y])\n            std::swap(x, y);\n        for (int i = 20; ~i; --i)\n            if (dep[fa[x][i]] &gt;= dep[y])\n                x = fa[x][i];\n        if (x == y)\n            return x;\n        for (int i = 20; ~i; --i)\n            if (fa[x][i] != fa[y][i])\n                x = fa[x][i], y = fa[y][i];\n        return fa[x][0];\n    &#125;;\n    auto ask = [&amp;](int x, int k) &#123;\n        assert(dep[x] - 1 &gt;= k);\n        int x1 = x;\n        if (!k)\n            return x;\n        x = fa[x][to[k]];\n        if (dep[x] - dep[top[x]] &gt;= k - (1 &lt;&lt; to[k]))\n            return des[top[x]][id[x] + k - (1 &lt;&lt; to[k])];\n        return anc[top[x]][k - (1 &lt;&lt; to[k]) - (dep[x] - dep[top[x]])];\n    &#125;;\n    auto dis = [&amp;](int x, int y, int fa) &#123;\n        return dep[x] + dep[y] - 2 * dep[fa];\n    &#125;;\n    auto gethash = [&amp;](int x, int y, int f, int k) &#123;\n        if (!k)\n            return 0ll;\n        if (k &lt;= dep[x] - dep[f] + 1) &#123;\n            f = ask(x, k - 1);\n            return (h2[x] + mod - h2[fa[f][0]]) % mod * inv[dep[f] - 1] % mod;\n        &#125;\n        long long h = (h2[x] + mod - h2[fa[f][0]]) % mod * inv[dep[f] - 1] % mod;\n        k -= (dep[x] - dep[f] + 1);\n        y = ask(y, (dep[y] - dep[f]) - k);\n        h = (h * base[dep[y] - dep[f]] % mod + (h1[y] + mod - h1[f] * base[dep[y] - dep[f]] % mod) % mod) % mod;\n        return h;\n    &#125;;\n    int m;\n    std::cin &gt;&gt; m;\n    for (int x, y, a, b; m--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; a &gt;&gt; b;\n        int fa1 = getLCA(x, y), fa2 = getLCA(a, b), res = 0;\n        for (int l = 0, r = std::min(dis(x, y, fa1), dis(a, b, fa2)) + 1, mid; l &lt;= r; ) &#123;\n            mid = (l + r) &gt;&gt; 1;\n            if (gethash(x, y, fa1, mid) == gethash(a, b, fa2, mid))\n                res = mid, l = mid + 1;\n            else\n                r = mid - 1;\n        &#125;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"a.-song-of-the-sirens\">A. Song of the Sirens</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/5658/problem/1\" class=\"uri\">http://222.180.160.110:61235/contest/5658/problem/1</a></p>\n<p>笑话：是 <span class=\"math inline\">\\(s_it_is_i\\)</span> 而不是 <span class=\"math inline\">\\(s_its_i\\)</span>。</p>\n<p>我们发现 <span class=\"math inline\">\\(s_0\\)</span> 很短，所以直接枚举起始位置把 <span class=\"math inline\">\\(s_0\\)</span> 和匹配串大力匹配，把空位挖出来组成新的匹配串再考虑 <span class=\"math inline\">\\(t\\)</span> 的问题（因为所有 <span class=\"math inline\">\\(s_i\\)</span> 最开头都有一个完整的 <span class=\"math inline\">\\(s_0\\)</span>，所以可以随便选断点）。</p>\n<p>我们知道 <span class=\"math inline\">\\(t\\)</span> 的下标是一个自底向上从 <span class=\"math inline\">\\(1\\)</span> 到 <span class=\"math inline\">\\(n\\)</span> 的满二叉树的中序遍历，其中 <mark><span class=\"math inline\">\\(t_1\\)</span> 间隔一位出现；于是我们仿照对 <span class=\"math inline\">\\(s\\)</span> 的处理方式，再把 <span class=\"math inline\">\\(t_1\\)</span> 挖掉。注意到此时 <span class=\"math inline\">\\(t_2\\)</span> 又成为二叉树最底层，间隔一位出现，这就变成了一个 <span class=\"math inline\">\\(\\mathcal O(n\\log n)\\)</span> 递归的问题</mark>。</p>\n<p>至于答案，当 <span class=\"math inline\">\\(t\\)</span> 被删空时，假设删掉的最后一个元素为 <span class=\"math inline\">\\(t_p\\)</span>，<span class=\"math inline\">\\(t\\)</span> 的出现次数即为二叉树中 <span class=\"math inline\">\\(p\\)</span> 层点数，为 <span class=\"math inline\">\\(2^{k-p}\\)</span>。</p>\n<p>有一个细节，就是如果当前删到 <span class=\"math inline\">\\(i\\)</span> 了，<span class=\"math inline\">\\(t\\)</span> 的长度只剩 <span class=\"math inline\">\\(1\\)</span>，就会有一个很尴尬的问题——这个元素不一定就是 <span class=\"math inline\">\\(t_i\\)</span>，而应该是 <span class=\"math inline\">\\(\\{j \\mid j\\ge i\\land t_j=t_i\\}\\)</span>。统计 <span class=\"math inline\">\\(t_{i\\sim k}\\)</span> 中值为 <span class=\"math inline\">\\(t_i\\)</span> 的元素个数（前缀和），乘上对应的层数即可。这个可以用一点小技巧搞定，前缀和时忽略 <span class=\"math inline\">\\(k\\)</span> 乘上 <span class=\"math inline\">\\(k=n\\)</span> 时的系数，统计答案时乘上 <span class=\"math inline\">\\(2^{n-k}\\)</span> 即可。</p>\n<p>不是，那我缺的哈希这块谁来补啊？？？</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;sirens1.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, q, m;\n    std::string s;\n    std::cin &gt;&gt; n &gt;&gt; q &gt;&gt; s;\n    s = &#39;\\0&#39; + s, m = (int)s.length() - 1;\n    std::vector&lt;char&gt; t(n + 1);\n    std::vector&lt;long long&gt; base(n + 1), inv(n + 1);\n    std::vector&lt;std::array&lt;long long, 26&gt; &gt; a(n + 1);\n    auto qkp = [](long long x, int y) &#123;\n        long long res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    base[0] = 1ll, inv[0] = 1ll, inv[1] = qkp(2, mod - 2);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; t[i];\n        base[i] = base[i - 1] * 2 % mod;\n        if (i != 1)\n            inv[i] = inv[i - 1] * inv[1] % mod;\n    &#125;\n    for (int i = 1; i &lt;= n; ++i)\n        a[i] = a[i - 1], (a[i][t[i] - &#39;a&#39;] += base[n - i]) %= mod;\n    for (int k; q--; ) &#123;\n        std::string p;\n        std::cin &gt;&gt; k &gt;&gt; p;\n        p = &#39;\\0&#39; + p;\n        long long res = 0;\n        int l = (int)p.length() - 1;\n        std::vector&lt;char&gt; u;\n        std::function&lt;void(int, std::vector&lt;char&gt; &amp;)&gt; calc = [&amp;](int x, std::vector&lt;char&gt; &amp;p) &#123;\n            int m = (int)p.size() - 1;\n            if (m == 0) &#123;\n                // puts(&quot;# 45&quot;);\n                // printf(&quot;0, += %lld\\n&quot;, base[k - x + 1]);\n                (res += base[k - x + 1]) %= mod;\n                return;\n            &#125;\n            if (x &gt; k)\n                return;\n            if (m == 1) &#123;\n                // puts(&quot;# 50&quot;);\n                // printf(&quot;1, += %lld(%lld)\\n&quot;, (a[k][p[1] - &#39;a&#39;] + mod - a[x - 1][p[1] - &#39;a&#39;]) % mod * inv[n - k] % mod, inv[n - k] % mod);\n                (res += (a[k][p[1] - &#39;a&#39;] + mod - a[x - 1][p[1] - &#39;a&#39;]) % mod * inv[n - k] % mod) %= mod;\n                return;\n            &#125;\n            bool flag0 = 1, flag1 = 1;\n            std::vector&lt;char&gt; t0(1), t1(1);\n            for (int i = 1; i &lt;= m; ++i)\n                if (!(i &amp; 1)) &#123;\n                    if (flag0)\n                        t0.push_back(p[i]);\n                    flag1 &amp;= (p[i] == t[x]);\n                &#125;\n                else &#123;\n                    if (flag1)\n                        t1.push_back(p[i]);\n                    flag0 &amp;= (p[i] == t[x]);\n                &#125;\n            if (flag0)\n                calc(x + 1, t0);\n            if (flag1)\n                calc(x + 1, t1);\n            return;\n        &#125;;\n        for (int i = 1; i &lt;= m + 1; ++i) &#123;\n            std::vector&lt;char&gt;(1).swap(u);\n            for (int j = i, now = 1; now &lt;= l; ++now) &#123;\n                if (j == m + 1)\n                    j = 1, u.push_back(p[now]);\n                else if (p[now] != s[j])\n                    goto nosol;\n                else\n                    ++j;\n            &#125;\n            // printf(&quot;u: &quot;);\n            // for (int i = 1; i &lt; (int)u.size(); ++i)\n            //     std::cout &lt;&lt; u[i];\n            // puts(&quot;&quot;);\n            calc(1, u);\n        nosol: ;\n        &#125;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b.-prefix-of-suffixes\">B. Prefix of Suffixes</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/5658/problem/2\" class=\"uri\">http://222.180.160.110:61235/contest/5658/problem/2</a></p>\n<p>还是太科幻了。哦哦 border 我的 border。</p>\n<h3 id=\"法一\">法一</h3>\n<p>考虑每次增量，若加入 <span class=\"math inline\">\\(S_i\\)</span> 后有 <span class=\"math inline\">\\(z_j\\)</span> 的值增加 <span class=\"math inline\">\\(1\\)</span>，那么这对 <span class=\"math inline\">\\((i, j)\\)</span> 就会贡献 <span class=\"math inline\">\\(A_j\\cdot B_i\\)</span> 的增量；<mark>反之，<span class=\"math inline\">\\(z_j\\)</span> 在以后也不会增加</mark>。</p>\n<p>我们维护当前没有确定下来的所有 <span class=\"math inline\">\\(z_j\\)</span>，对于每个 <span class=\"math inline\">\\(i\\)</span> 暴力 check <span class=\"math inline\">\\(z_j\\)</span> 是否确定并更新答案，<strong>因为数据比较弱</strong>，在 CF 神机上跑得飞快 <img src=\"/em/dy.gif\" /> 但是 QOJ 上死活过不了 <img src=\"/em/ll.gif\" /></p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    long long res = 0, s = 0;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; now;\n    std::vector&lt;int&gt; a(n + 1), b(n + 1), t(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; t[i] &gt;&gt; a[i] &gt;&gt; b[i];\n        t[i] = (res + t[i]) % n;\n        if (t[i] == t[1])\n            s += b[i], now.push_back(i);\n        std::vector&lt;int&gt; g(std::move(now));\n        for (auto j : g)\n            if (t[i] == t[i - j + 1])\n                now.push_back(j);\n            else\n                s -= b[j];\n        res += a[i] * s;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<h3 id=\"法二\">法二</h3>\n<p>依然考虑增量。<mark><span class=\"math inline\">\\(z_j\\)</span> 增加 <span class=\"math inline\">\\(\\iff S_{j\\to i}\\)</span> 为 <span class=\"math inline\">\\(S_{1\\sim i}\\)</span> 的一个 border</mark>。考虑对于每一个 <span class=\"math inline\">\\(S_i\\)</span>，border 的组成。</p>\n<ol type=\"1\">\n<li>若 <span class=\"math inline\">\\(S_1=S_i\\)</span>，那么将会新增一个长度为 <span class=\"math inline\">\\(1\\)</span> 的 border。</li>\n<li>对于在 <span class=\"math inline\">\\(i-1\\)</span> 处合法的 border <span class=\"math inline\">\\(S_{j\\sim i-1}\\)</span>，若 <span class=\"math inline\">\\(S_i=S_{i-j+1}\\)</span>，则该 border 仍合法；否则非法。</li>\n</ol>\n<p>我们的法一其实相当于是暴力 check 了所有合法 border 是否仍然合法，但这显然最坏是 <span class=\"math inline\">\\(O(n^2)\\)</span> 的。我们考虑从 border 角度优化一下。</p>\n<p>我们发现，比如说 <span class=\"math inline\">\\(\\texttt{abababa + b}\\)</span>，我们会进行很多次不必要的 check，当然这个时候我们会本能大力跳 fail，但是这里有一个 <a href=\"https://www.luogu.com/article/e08ebmz6\">border 的等差数列性质</a>，若 <span class=\"math inline\">\\(x+1\\)</span> 与 <span class=\"math inline\">\\(i\\)</span> 能够匹配，那么与 <span class=\"math inline\">\\(x\\)</span> 同属一个等差数列的所有 <span class=\"math inline\">\\(x&#39;+1\\)</span> 都应和 <span class=\"math inline\">\\(i\\)</span> 匹配。</p>\n<p>对于正在 check 的 <span class=\"math inline\">\\(x\\)</span>，如果 check 成功则跳到上一条链的链尾；否则跳到链头。总的复杂度是 <span class=\"math inline\">\\(O(n\\log n)\\)</span> 的。找一下和每个 <span class=\"math inline\">\\(i\\)</span> 匹配不了的第一个链头，甚至可以因为某些我太菜了所以不知道的不明原因整到线性。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    long long res = 0, s = 0;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1), b(n + 1), t(n + 1), ne(n + 1), to(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; t[i] &gt;&gt; a[i] &gt;&gt; b[i];\n        t[i] = (res + t[i]) % n;\n        if (i == 1)\n            s += b[i], res = (long long)a[i] * b[i];\n        else &#123;\n            int j = ne[i - 1];\n            for (; j &amp;&amp; t[j + 1] != t[i]; j = ne[j]);\n            if (t[j + 1] == t[i])\n                ++j;\n            ne[i] = j;\n            if (t[i] == t[1])\n                s += b[i];\n            to[i - 1] = (t[ne[i - 1] + 1] == t[i] ? to[ne[i - 1]] : ne[i - 1]);\n            for (int j = i - 1; j; )\n                if (t[j + 1] == t[i])\n                    j = to[j];\n                else\n                    for (int at = to[j]; j != at; s -= b[i - j], j = ne[j]);\n            res += a[i] * s;\n        &#125;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c.-matching\">C. Matching</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/5658/problem/3\" class=\"uri\">http://222.180.160.110:61235/contest/5658/problem/3</a></p>\n<p>我们发现，如果我们直接要 check 一段 <span class=\"math inline\">\\(a\\)</span> 和 <span class=\"math inline\">\\(p\\)</span>，感觉不太好整。</p>\n<p>然后考虑这么一个问题，假如我们通过神秘方法让我们每次 check 的 <span class=\"math inline\">\\(a\\)</span></p>\n",
            "tags": [
                "哈希",
                "线段树",
                "KMP",
                "border"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20241017/",
            "url": "https://xsc062.netlify.app/20241017/",
            "title": "模拟赛",
            "date_published": "2024-10-16T12:32:34.000Z",
            "content_html": "<p>好消息：会简单数学题 <img src=\"/em/dy.gif\" /></p>\n<p>更好的消息：忘取模了 <img src=\"/em/dy.gif\" /></p>\n<span id=\"more\"></span>\n<hr />\n<h3 id=\"a.-distorted\">A. distorted</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/5611/problem/1\" class=\"uri\">http://222.180.160.110:61235/contest/5611/problem/1</a></p>\n<p>考虑最多需要多少个元素。最坏情况是选取四个角的元素，已经可以覆盖整个矩阵。进一步考虑感性反证发现无论如何都选不出来五个，故最多选择四个。</p>\n<p>我们发现，选取中间一个就可以覆盖整个矩阵。扩展一下，选择中间列就可以覆盖上 / 下半个矩阵，选择中间行就可以覆盖左 / 右半个矩阵。剩下的选择过后只能保证照顾到对应的 1/4 矩阵且一定不会完全覆盖其他的 1/4 矩阵。</p>\n<p>我们发现，中心元素地位高于中间行 / 列元素高于左上、左下、右上、右下元素。由此出发讨论选择元素的个数。</p>\n<ul>\n<li>1 个：选择中心元素。</li>\n<li>2 个：在中间行的左右两边各选一个 / 在中间列的上下两边各选一个。</li>\n<li>3 个：选一个中间行 / 列 + 两个其他元素，或两个中间行 / 列 + 一个其他元素。</li>\n<li>4 个：左上、左下、右上、右下各选一个。</li>\n</ul>\n<p>统计各个方向的最小值，选最小组合即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\n#define putchar\nconst long long inf = 0x3f3f3f3f;\nint main() &#123;\n    freopen(&quot;distorted.in&quot;, &quot;r&quot;, stdin);\n    freopen(&quot;distorted.out&quot;, &quot;w&quot;, stdout);\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n;\n        std::cin &gt;&gt; n;\n        long long to = inf, u = inf, d = inf, l = inf, r = inf, q = inf, z = inf, p = inf, m = inf;\n        for (int i = 1; i &lt;= n; ++i)\n            for (int j = 1; j &lt;= n; ++j) &#123;\n                long long x;\n                std::cin &gt;&gt; x;\n                if (i * 2 - 1 == n &amp;&amp; j * 2 - 1 == n)\n                    to = x;\n                else if (i * 2 - 1 == n &amp;&amp; j * 2 - 1 &lt; n)\n                    l = std::min(l, x);\n                else if (i * 2 - 1 == n)\n                    r = std::min(r, x);\n                else if (i * 2 - 1 &lt; n &amp;&amp; j * 2 - 1 == n)\n                    u = std::min(u, x);\n                else if (j * 2 - 1 == n)\n                    d = std::min(d, x);\n                else if (i * 2 - 1 &lt; n &amp;&amp; j * 2 - 1 &lt; n)\n                    q = std::min(q, x);\n                else if (i * 2 - 1 &lt; n)\n                    p = std::min(p, x);\n                else if (j * 2 - 1 &lt; n)\n                    z = std::min(z, x);\n                else\n                    m = std::min(m, x);\n            &#125;\n        std::cout &lt;&lt; std::min(&#123; to, l + r, u + d, l + u + m, l + d + p, r + u + z, r + d + q, u + z + m, d + q + p, l + p + m, r + q + z, q + p + z + m &#125;) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"b.-fate\">B. fate</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/5611/problem/2\" class=\"uri\">http://222.180.160.110:61235/contest/5611/problem/2</a></p>\n<p>诈骗题。对于前半段，考虑取差分数组 <span class=\"math inline\">\\(d\\)</span>，容易发现如果直接在差分数组上做减法，一定满足后面减得不比前面少。故只要满足差分数组每一项至少为 <span class=\"math inline\">\\(0\\)</span> 即可，答案为 <span class=\"math inline\">\\(\\prod {i\\le p} a_i - a_{i-1} + 1\\)</span>。</p>\n<p>对于后半段，我们考虑转化成和前半段相似的问题，将后半段翻转，同样取差分数组，则此时在该差分数组上满足后面减得不比前面少，同时需要满足差分数组每一项至多为 <span class=\"math inline\">\\(0\\)</span>，前面的所有项初始为负，操作为减，自然满足；但第 <span class=\"math inline\">\\(p\\)</span> 项在把前面减去的全部加上后不一定满足。故前面最多减去 <span class=\"math inline\">\\(d_p\\)</span>，随便在哪里减都无所谓，组合意义一下，就是无标号球放有标号盒子可空放可不放，插板得答案为 <span class=\"math inline\">\\(\\displaystyle {-d_p + n - p\\choose n - p}\\)</span>。</p>\n<p>前后乘起来即为答案。注意不要在最后一步乘起来的时候忘记取模，否则你会获得 76pts 的高分 <img src=\"/em/xk.gif\" /></p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n    freopen(&quot;fate.in&quot;, &quot;r&quot;, stdin);\n    freopen(&quot;fate.out&quot;, &quot;w&quot;, stdout);\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    int n, m;\n    std::cin &gt;&gt; n;\n    std::vector&lt;long long&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::cin &gt;&gt; m;\n    long long res = 1;\n    for (int i = 1; i &lt; m; ++i) &#123;\n        auto x = a[i] - a[i - 1];\n        (res *= x + 1) %= mod;\n    &#125;\n    auto qkp = [](long long x, int y) &#123;\n        long long res = 1;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    auto C = [&amp;](int n, int m) &#123;\n        long long res = 1ll;\n        for (int i = n; i &gt; n - m; --i)\n            (res *= i) %= mod;\n        for (int i = m; i; --i)\n            (res *= qkp(i, mod - 2)) %= mod;    \n        return res;\n    &#125;;\n    if (m != n)\n        (res *= C(a[m + 1] - a[m] + n - m, n - m)) %= mod;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"c.-abstruse\">C. abstruse</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P9731\" class=\"uri\">https://www.luogu.com.cn/problem/P9731</a></p>\n<p>注意到有挺高的一档 <span class=\"math inline\">\\(S=2\\)</span> 的分，考虑其启示意义。</p>\n<p>我们对于一对 <span class=\"math inline\">\\((a_i, b_i)\\)</span>，在 <span class=\"math inline\">\\(a_i\\)</span> 和 <span class=\"math inline\">\\(b_i\\)</span> 间连边，则原问题转化为给无向图的每条边选择方向，使对于每个 <span class=\"math inline\">\\(x\\)</span>，<span class=\"math inline\">\\(|in_x-out_x|\\le 1\\)</span>。</p>\n<p>我们知道对于一条欧拉回路，有对于任意 <span class=\"math inline\">\\(x\\)</span>，<span class=\"math inline\">\\(in_x=out_x\\)</span>。然后这个时候为了把问题转化成欧拉回路问题我们建一个虚点朝度数为奇的点连条边然后跑欧拉回路即可。</p>\n<p>至于 <span class=\"math inline\">\\(S=2^k\\)</span>，就是在明示分治。即对于任意 <span class=\"math inline\">\\(x\\)</span>，要求其在前后 <span class=\"math inline\">\\(2^{k-1}\\)</span> 次出现次数相差不超过 <span class=\"math inline\">\\(1\\)</span>。注意到非常幸福的有前后两个部分大小相等，又有一个天才的建图，<mark>即在每个点和自己所属的行连边，然后跑欧拉回路，出边表示选前半部分，入边表示选后半部分，这样就保证了一行中各有 <span class=\"math inline\">\\(2^{k-1}\\)</span> 个选前后半部分，也保证了每个点在前后半边出现的次数相差不超过 <span class=\"math inline\">\\(1\\)</span>。对于后面一个性质，分治最终可得到点在每一列出现次数相差不超过 <span class=\"math inline\">\\(1\\)</span></mark>。</p>\n<p>打个当前弧优化然后注意计算细节复杂度然后多卡几（十）遍就过了 <img src=\"/em/dy.gif\" /></p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nnamespace fastIO &#123;\nconst int LEN = (1 &lt;&lt; 20);\n#ifdef ONLINE_JUDGE\nint nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF;\n        p = buf;\n    &#125;\n    return *p++;\n&#125;\n#else\n#define nec getchar\n#endif\nbool read(int &amp;x) &#123;\n    x = 0;\n    bool f = 0;\n    char ch = nec();\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nvoid print(int x) &#123;\n    if (x &lt; 0)\n        putchar(&#39;-&#39;), x = -x;\n    if (x &gt;= 10) print(x / 10);\n    putchar(x % 10 + &#39;0&#39;);\n    return;\n&#125;\nvoid print(int x, char ch) &#123;\n    print(x), putchar(ch);\n    return;\n&#125;\n&#125; using namespace fastIO;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    freopen(&quot;abstruse.in&quot;, &quot;r&quot;, stdin);\n    freopen(&quot;abstruse.out&quot;, &quot;w&quot;, stdout);\n#else\n    freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m, k;\n    read(n), read(m), read(k);\n    std::vector&lt;std::vector&lt;int&gt; &gt; a(n + 1, std::vector&lt;int&gt; (m + 1));\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = 1; j &lt;= m; ++j)\n            read(a[i][j]);\n    std::vector&lt;int&gt; to(k + n + 1), tag(n * m + n + k + 1);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(k + n + 1); \n    std::function&lt;void(int, int)&gt; calc = [&amp;](int l, int r) &#123;\n        if (l + 1 == r) &#123;\n            for (int i = 1; i &lt;= n; ++i) &#123;\n                g[a[i][l]].emplace_back(a[i][r], i);\n                g[a[i][r]].emplace_back(a[i][l], i);\n            &#125;\n            int cnt = n;\n            for (int i = 1; i &lt;= n; ++i) &#123;\n                if ((int)g[a[i][l]].size() &amp; 1)\n                    g[0].emplace_back(a[i][l], ++cnt), g[a[i][l]].emplace_back(0, cnt);\n                if ((int)g[a[i][r]].size() &amp; 1)\n                    g[0].emplace_back(a[i][r], ++cnt), g[a[i][r]].emplace_back(0, cnt);\n            &#125;\n            std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n                for (int i = to[x]; i &lt; (int)g[x].size(); i = to[x]) &#123;\n                    to[x] = i + 1;\n                    auto [v, id] = g[x][i];\n                    if (!tag[id]) &#123;\n                        tag[id] = 1;\n                        if (x &amp;&amp; v)\n                            a[id][l] = x, a[id][r] = v;\n                        DFS(v);\n                    &#125;\n                &#125;\n                return;\n            &#125;;\n            DFS(0);\n            for (int i = 1; i &lt;= n; ++i)\n                DFS(a[i][l]), DFS(a[i][r]);\n            to[0] = 0, g[0].clear();\n            for (int i = 1; i &lt;= n; ++i) &#123;\n                to[a[i][l]] = 0, g[a[i][l]].clear();\n                to[a[i][r]] = 0, g[a[i][r]].clear();\n            &#125;\n            std::fill(tag.begin() + 1, tag.begin() + cnt + 1, 0);\n            return;\n        &#125;\n        int mid = (l + r) &gt;&gt; 1, cnt = 0;\n        std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(k + n + 1);\n        for (int i = 1; i &lt;= n; ++i)\n            for (int j = l; j &lt;= r; ++j) &#123;\n                g[a[i][j]].emplace_back(i + k, ++cnt);\n                g[i + k].emplace_back(a[i][j], cnt);\n            &#125;\n        for (int i = 1; i &lt;= n; ++i)\n            for (int j = l; j &lt;= r; ++j)\n                if ((int)g[a[i][j]].size() &amp; 1)\n                    g[0].emplace_back(a[i][j], ++cnt), g[a[i][j]].emplace_back(0, cnt);\n        std::vector&lt;int&gt; L(n + 1, l - 1), R(n + 1, r + 1);\n        std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n            for (int i = to[x]; i &lt; (int)g[x].size(); i = to[x]) &#123;\n                to[x] = i + 1;\n                auto [v, id] = g[x][i];\n                if (!tag[id]) &#123;\n                    tag[id] = 1;\n                    if (x &amp;&amp; v) &#123;\n                        if (v &lt;= k)\n                            a[x - k][++L[x - k]] = v;\n                        else\n                            a[v - k][--R[v - k]] = x;\n                    &#125;\n                    DFS(v);\n                &#125;\n            &#125;\n            return;\n        &#125;;\n        DFS(0);\n        for (int i = 1; i &lt;= n; ++i)\n            DFS(i + k);\n        for (int i = 1; i &lt;= n; ++i)\n            for (int j = l; j &lt;= r; ++j)\n                DFS(a[i][j]);\n        to[0] = 0, g[0].clear();\n        for (int i = 1; i &lt;= n; ++i)\n            to[i + k] = 0, g[i + k].clear();\n        for (int i = 1; i &lt;= n; ++i)\n            for (int j = l; j &lt;= r; ++j)\n                to[a[i][j]] = 0, g[a[i][j]].clear();\n        std::fill(tag.begin() + 1, tag.begin() + cnt + 1, 0);\n        calc(l, mid), calc(mid + 1, r);\n        return;\n    &#125;;\n    calc(1, m);\n    for (int i = 1; i &lt;= n; ++i, putchar(&#39;\\n&#39;))\n        for (int j = 1; j &lt;= m; ++j)\n            print(a[i][j], &#39; &#39;);\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "分治",
                "欧拉回路"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20240906/",
            "url": "https://xsc062.netlify.app/20240906/",
            "title": "动态规划 10 题 - I",
            "date_published": "2024-09-06T07:30:38.000Z",
            "content_html": "<p>现在是 10 题。虽然看着很掉价，但是写够了 10 就改成 20 题。以此类推，免得我摆烂（）</p>\n<p>自用向，不写太详细，把破题点写出来就差不多了。哦哦这里的破题是动词不是名词。</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"字符合并\">1. 字符合并</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P3736\" class=\"uri\">https://www.luogu.com.cn/problem/P3736</a></p>\n<blockquote>\n<p>给定长度为 <span class=\"math inline\">\\(n\\)</span> 的 <span class=\"math inline\">\\(01\\)</span> 串和 <span class=\"math inline\">\\(2^k\\)</span> 条规则，第 <span class=\"math inline\">\\(i\\)</span> 条规则形如：</p>\n<ul>\n<li>对于序列中的 <span class=\"math inline\">\\(k\\)</span> 位二进制数 <span class=\"math inline\">\\(i\\)</span>，可以将它合并为 <span class=\"math inline\">\\(c(c\\in\\{0,1\\})\\)</span>，并产生 <span class=\"math inline\">\\(v\\)</span> 的价值。</li>\n</ul>\n<p>进行任意次合并，求出能取得的最大总价值。<span class=\"math inline\">\\(n\\le 300,k\\le 8\\)</span>。</p>\n</blockquote>\n<p><strong>状压</strong>，<strong>区间 DP</strong>。</p>\n<p>注意到 <span class=\"math inline\">\\(k\\)</span> 只有 <span class=\"math inline\">\\(8\\)</span>，独特的输入方式也引导我们注意到状态数为 <span class=\"math inline\">\\(10^2\\)</span> 级别。合并的背景又让我们本能想到区间 DP，所以刚好盲猜这题是个 <span class=\"math inline\">\\(O(2^k\\times n^2)\\)</span> 的区间状压 DP。</p>\n<ul>\n<li><p>然后我觉得最神的一个地方是什么呢？最后的答案一定是一个长度小于 <span class=\"math inline\">\\(k\\)</span> 的串，<mark>每位展开还原，可以知道，每个合并操作选取的区间可能包含但不相交。</mark></p>\n<p>看起来很蠢很显然，但这是我们 <span class=\"math inline\">\\(n^2\\)</span> 区间 DP 的基础啊（（（</p></li>\n</ul>\n<p>然后我们区间 DP 套路，枚举对于 <span class=\"math inline\">\\([l,r]\\)</span> 最左边一位，然后就可以开始大力转移了。</p>\n<p>但是这里我们会发现，这一位原本的样子有点多，可以是任何一个长度为 <span class=\"math inline\">\\(1 + d\\times (k-1)\\)</span> 的数，所以只能再来一层 <span class=\"math inline\">\\(\\dfrac nk\\)</span> 的枚举，极限情况是个有点难绷的 3e9，作为正解只能说这个数据范围的提示性有点令人难评了。</p>\n<p>实现着实现着把自己整懵了：<code>00000</code> 和 <code>0</code> 压出来都是 <code>0</code>，但二者代表的含义显然不同，又无法简单区别。但其实<mark>长度为 <span class=\"math inline\">\\(1+d\\times (k-1)\\)</span> 的区间和长度为 <span class=\"math inline\">\\(d\\)</span> 的最终结果是一一对应的，所以在我们设计的包含了区间作右端点的状态中，压出来的就是我们想要的那个。</mark></p>\n<details>\n<p>这里的实现比<strong>所有</strong>我找到的题解都更像人打出来的。导致我想对比疗法都找不到合适的代码 <img src=\"/em/lh.gif\" /></p>\n<p>换言之，这最像是一份通常的区间 DP 代码，不存在其他题解中乱七八糟的填表啊相互影响啊之类的恶心 feature。</p>\n<p>sto rybp orz</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 305;\nconst int maxm = (1 &lt;&lt; 8) + 5;\nchar a[maxn];\nint c[maxm], w[maxm];\nlong long f[maxn][maxn][maxm];\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n#else\n    freopen(&quot;in.in&quot;, &quot;r&quot;, stdin);\n    freopen(&quot;out.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    int siz = (1 &lt;&lt; k), si = (1 &lt;&lt; (k - 1));\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    for (int i = 0; i &lt; siz; ++i)\n        std::cin &gt;&gt; c[i] &gt;&gt; w[i];\n    memset(f, -0x3f, sizeof(f));\n    for (int l = 1; l &lt; k; ++l)\n        for (int i = 1; i &lt;= n - l + 1; ++i) &#123;\n            int j = i + l - 1, now = 0;\n            for (int p = i; p &lt;= j; ++p)\n                now = now * 2 + a[p] - &#39;0&#39;;\n            f[i][j][now] = 0;\n        &#125;\n    for (int i = 1; i &lt;= n - k + 1; ++i) &#123;\n        int now = 0;\n        for (int j = i; j &lt;= i + k - 1; ++j)\n            now = now * 2 + a[j] - &#39;0&#39;;\n        f[i][i + k - 1][c[now]] = w[now];\n    &#125;\n    for (int l = k + 1; l &lt;= n; ++l)\n        for (int i = 1; i &lt;= n - l + 1; ++i) &#123;\n            int j = i + l - 1;\n            for (int p = i; p &lt; j; p += k - 1) &#123;\n                for (int q = 0; q &lt; si; ++q)\n                    if (!(q &gt;&gt; ((l - 1) % (k - 1) + 1)))\n                        f[i][j][q] = std::max(f[i][j][q], f[i][p][q &gt;&gt; ((l - 1) % (k - 1))] + f[p + 1][j][q &amp; ((1 &lt;&lt; ((l - 1) % (k - 1))) - 1)]);\n                if (l % (k - 1) == 1 || k == 2)\n                    for (int q = 0; q &lt; siz; ++q)\n                        f[i][j][c[q]] = std::max(f[i][j][c[q]], f[i][p][q &gt;&gt; (k - 1)] + f[p + 1][j][q &amp; ((1 &lt;&lt; (k - 1)) - 1)] + w[q]);\n            &#125;\n        &#125;\n    std::cout &lt;&lt; *std::max_element(f[1][n], f[1][n] + si) &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<p>其实一开始挺担心会不会因为写博客影响做题时间之类的。</p>\n<p>直到发现我可以看知乎看一个上午然后代码动都不动一下 <img src=\"/em/lh.gif\" /></p>\n<hr />\n<h2 id=\"mod-mod-mod\">2. Mod Mod Mod</h2>\n<p><a href=\"https://codeforces.com/contest/889/problem/E\" class=\"uri\">https://codeforces.com/contest/889/problem/E</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(a_{1\\sim n}\\)</span>，对于所有非负整数 <span class=\"math inline\">\\(x\\)</span> 定义 <span class=\"math inline\">\\(f(x,n)=x\\bmod a_n\\)</span>，<span class=\"math inline\">\\(f(x,i)=x\\bmod a_i+f(x\\bmod a_i,i+1)\\)</span>。</p>\n<p>求 <span class=\"math inline\">\\(f(x,1)\\)</span> 最大值。<span class=\"math inline\">\\(n\\le 2\\times 10^5\\)</span>。</p>\n</blockquote>\n<p><strong>技巧 / 特殊性质类 DP</strong>。</p>\n<p>小神题。注意到题意可以转化为，找到一个 <span class=\"math inline\">\\(x\\)</span>，最大化：</p>\n<p><span class=\"math display\">\\[\nx\\bmod a_1 + x\\bmod a_1\\bmod a_2 + \\cdots + x\\bmod a_1\\bmod a_2\\bmod\\cdots\\bmod a_n.\n\\]</span></p>\n<p>简称 <span class=\"math inline\">\\(x\\bmod a_1\\bmod a_2\\bmod \\cdots\\bmod a_i\\)</span> 的值为 <span class=\"math inline\">\\(f_i\\)</span>。</p>\n<p>这个时候我们不难注意到，<span class=\"math inline\">\\(f_i\\)</span> 肯定是<mark>单调不升</mark>的。形象化地，整个 <span class=\"math inline\">\\(f\\)</span> 序列肯定是由若干个单调下降的段组成的。并且，<mark>必定存在至少一个 <span class=\"math inline\">\\(i\\)</span>，使得 <span class=\"math inline\">\\(f_i = a_i-1\\)</span>，否则可以将所有 <span class=\"math inline\">\\(f_i\\gets f_i+1\\)</span>，同时 <span class=\"math inline\">\\(\\sum f\\gets (\\sum f) + n\\)</span></mark>。</p>\n<p>这启示我们关注 <span class=\"math inline\">\\(f_i\\)</span> 的值域。假设已经确定了 <span class=\"math inline\">\\(f\\)</span> 序列的一个前缀 <span class=\"math inline\">\\(f_1\\sim i\\)</span>，对于任意 <span class=\"math inline\">\\(0\\le k\\le f_{\\min}\\)</span>（注意由于单调不降，<span class=\"math inline\">\\(f_{\\min} = f_i\\)</span>），我们可以将所有 <span class=\"math inline\">\\(f_j\\gets f_j-k\\)</span>，得到一个新的合法的 <span class=\"math inline\">\\(f&#39;_{1\\sim i}\\)</span>。</p>\n<p>形象化地，将 <span class=\"math inline\">\\(f_{1\\sim i}\\)</span> 想象为一个逐渐降低的柱状图，任意切去了一个高度的底部，并且这个高度不高于最矮的元素（即第 <span class=\"math inline\">\\(i\\)</span> 个元素）。</p>\n<p>这时候有一个很美妙的性质，就是我们<mark>对于切之前和切之后的柱状图，其 <strong>最矮元素以上的部分</strong> 长得完全相同</mark>。然后就是神中神之 DP 状态设计。很难想象是在什么样的精神状态下凑出来这种神奇状态的，可能是某种我不了解的 trick？</p>\n<p>令 <span class=\"math inline\">\\(dp_{i, j}\\)</span> 表示对于前缀 <span class=\"math inline\">\\(f_{1, i}\\)</span>，当切去的高度为 <span class=\"math inline\">\\(0\\sim j\\)</span> 时，<strong>最矮元素以上的部分</strong> 的和都为 <span class=\"math inline\">\\(dp_{i, j}\\)</span>。那么易得 <span class=\"math inline\">\\(\\sum f_{1\\sim i}=j\\times i + dp_{i, j}\\)</span>。</p>\n<p>考虑转移。假设已知所有 <span class=\"math inline\">\\(dp_{i - 1, j}\\)</span>，需转移到 <span class=\"math inline\">\\(i\\)</span>，我们有三种转移路径：</p>\n<ol type=\"1\">\n<li><p><span class=\"math inline\">\\(j &lt; a_i\\)</span>：</p>\n对 <span class=\"math inline\">\\(a_i\\)</span> 取模取不动，不会产生任何影响。<span class=\"math inline\">\\(dp_{i, j}\\gets dp_{i - 1, j}\\)</span>。</li>\n<li><p><span class=\"math inline\">\\(j\\ge a_i\\)</span>：</p>\n<ul>\n<li><p>让 <span class=\"math inline\">\\(i\\)</span> 承担 <span class=\"math inline\">\\(f_i=a_i-1\\)</span> 的责任。我们从 <span class=\"math inline\">\\(0\\sim j\\)</span> 中找到一个满足 <span class=\"math inline\">\\(j&#39;\\bmod a_i=a_i-1\\)</span> 的 <span class=\"math inline\">\\(j&#39;\\)</span>，<span class=\"math inline\">\\(j&#39;\\)</span> 肯定是越大越好，故 <span class=\"math inline\">\\(j&#39;=(\\left\\lfloor \\dfrac {j}{a_i}\\right\\rfloor-1)\\times a_i+(a_i-1)\\)</span>。</p>\n此时便有 <span class=\"math inline\">\\(dp_{i, a_i-1}\\gets dp_{i - 1, j&#39;} + [j&#39; - (a_i-1)]\\times (i-1)\\)</span>。</li>\n<li><p>盲猜 <span class=\"math inline\">\\(0\\sim i - 1\\)</span> 或 <span class=\"math inline\">\\(i+1\\sim n\\)</span> 中会出现承担 <span class=\"math inline\">\\(f_{i&#39;}=a_{i&#39;-1}\\)</span> 的 <span class=\"math inline\">\\(i&#39;\\)</span>，故按照 <span class=\"math inline\">\\(j\\)</span> 取最大来转移。</p>\n<p>此时有 <span class=\"math inline\">\\(dp_{i, j\\bmod a_i}=dp_{i-1,j}+(j-j\\bmod a_i)\\times (i-1)\\)</span>。</p></li>\n</ul></li>\n</ol>\n<p>答案即为 <span class=\"math inline\">\\(\\max\\{j\\times n+dp_{n, j}\\}\\)</span>。由于不存在 <span class=\"math inline\">\\(f_i=a_i-1\\)</span> 的 <span class=\"math inline\">\\(f\\)</span> 肯定比存在的要劣，所以我们肯定选到的是正确的答案。</p>\n<p>注意到每个 <span class=\"math inline\">\\(i\\)</span> 只会新增 <span class=\"math inline\">\\(a_i-1\\)</span> 一个状态，故状态总数为 <span class=\"math inline\">\\(O(n)\\)</span>。把 <span class=\"math inline\">\\(dp\\)</span> 开成 map 就可以 <span class=\"math inline\">\\(O(n\\log n)\\)</span> 地解决问题。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n#else\n    freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;long long&gt; a(n + 1);\n    std::map&lt;long long, long long&gt; t;\n    std::cin &gt;&gt; a[1];\n    t[a[1] - 1] = 0;\n    for (int i = 2; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        for (;;) &#123;\n            auto p = t.lower_bound(a[i]);\n            if (p == t.end())\n                break;\n            long long j = p-&gt;first, f = p-&gt;second;\n            t[j % a[i]] = std::max(t[j % a[i]], f + (j - j % a[i]) * (i - 1));\n            if (j &gt;= a[i]) &#123;\n                j = (j / a[i] - 1) * a[i] + a[i] - 1;\n                t[a[i] - 1] = std::max(t[a[i] - 1], f + (j - (a[i] - 1)) * (i - 1));\n            &#125;\n            t.erase(p);\n        &#125;\n    &#125;\n    long long res = 0;\n    for (auto i : t)\n        res = std::max(res, i.first * n + i.second);\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"stalinsort-algorithm\">3. StalinSort Algorithm</h2>\n<p><a href=\"https://qoj.ac/problem/1456\" class=\"uri\">https://qoj.ac/problem/1456</a></p>\n<blockquote>\n<p>给定排列 <span class=\"math inline\">\\(A_{1\\sim n}\\)</span>。从 <span class=\"math inline\">\\(i=2\\)</span> 开始往右扫，每一步执行以下操作：</p>\n<ul>\n<li>若 <span class=\"math inline\">\\(A_i&gt; A_{i-1}\\)</span>，什么也不做。</li>\n<li>否则，你可以删除 <span class=\"math inline\">\\(A_{i-1}\\)</span> 或 <span class=\"math inline\">\\(A_i\\)</span>，但要求删除后，该前缀必须单调递增。</li>\n</ul>\n<p>问最少可以删除多少个数。<span class=\"math inline\">\\(n\\le 10^5\\)</span>。</p>\n</blockquote>\n<p>你会发现<mark>删最少 = 留最多</mark>。</p>\n<p>考虑 <span class=\"math inline\">\\(i\\)</span> 能够转移到的 <span class=\"math inline\">\\(j(j&gt;i)\\)</span> 需满足的条件。若令 <span class=\"math inline\">\\(nex_p\\)</span> 表示 <span class=\"math inline\">\\(p\\)</span> 之后第一个值比 <span class=\"math inline\">\\(a_p\\)</span> 大的元素，则 <span class=\"math inline\">\\(j\\in [nex_i, nex_{nex_i})\\)</span> 且 <span class=\"math inline\">\\(a_j&gt;a_i\\)</span>。</p>\n<p><mark>赛时误认为右端点为 <span class=\"math inline\">\\(i\\)</span> 之后第二个值比 <span class=\"math inline\">\\(a_i\\)</span> 大的元素，导致完全寄掉。</mark></p>\n<p>时间复杂度 <span class=\"math inline\">\\(O(n^2)\\)</span>，考虑优化。<mark>注意到如果只有 <span class=\"math inline\">\\(j\\in [nex_i, nex_{nex_i})\\)</span> 这个条件很容易用线段树维护，考虑消去 <span class=\"math inline\">\\(a_j&gt;a_i\\)</span> 的影响。故考虑按 <span class=\"math inline\">\\(a\\)</span> <strong>从小到大</strong> 的顺序选取 <span class=\"math inline\">\\(i\\)</span>，因为当前最小的 <span class=\"math inline\">\\(i\\)</span> 一定已经被刷完表了</mark>。</p>\n<p>时间复杂度 <span class=\"math inline\">\\(O(n\\log n)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 5e5 + 5;\nconst int inf = 0x3f3f3f3f;\nstruct _ &#123; int u, d; &#125; t1[maxn &lt;&lt; 2];\nint n, t[maxn &lt;&lt; 2];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid upd(int p, int l, int r, int x, int v) &#123;\n    t[p] = std::min(t[p], v);\n    if (l == r)\n        return;\n    int mid = (l + r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        upd(lt, l, mid, x, v);\n    else\n        upd(rt, mid + 1, r, x, v);\n    return;\n&#125;\nint ask(int p, int l, int r, int ql, int qr) &#123;\n    if (ql &lt;= l &amp;&amp; r &lt;= qr)\n        return t[p];\n    int mid = (l + r) &gt;&gt; 1, res = n + 1;\n    if (ql &lt;= mid)\n        res = ask(lt, l, mid, ql, qr);\n    if (qr &gt; mid)\n        res = std::min(res, ask(rt, mid + 1, r, ql, qr));\n    return res;\n&#125;\nvoid pushdown(int p) &#123;\n    if (t1[p].d) &#123;\n        t1[lt].u = std::max(t1[lt].u, t1[p].d);\n        t1[lt].d = std::max(t1[lt].d, t1[p].d);       \n        t1[rt].u = std::max(t1[rt].u, t1[p].d);\n        t1[rt].d = std::max(t1[rt].d, t1[p].d);       \n        t1[p].d = 0;\n    &#125;\n    return;\n&#125;\nvoid upd(int p, int l, int r, int ql, int qr, int v) &#123;\n    t1[p].u = std::max(t1[p].u, v);\n    if (ql &lt;= l &amp;&amp; r &lt;= qr) &#123;\n        t1[p].d = std::max(t1[p].d, v);\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (l + r) &gt;&gt; 1;\n    if (ql &lt;= mid)\n        upd(lt, l, mid, ql, qr, v);\n    if (qr &gt; mid)\n        upd(rt, mid + 1, r, ql, qr, v);\n    return;\n&#125;\nint ask(int p, int l, int r, int x) &#123;\n    if (l == r)\n        return t1[p].u;\n    pushdown(p);\n    int mid = (l + r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        return ask(lt, l, mid, x);\n    return ask(rt, mid + 1, r, x);\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n#else\n    freopen(&quot;sort3.in&quot;, &quot;r&quot;, stdin);\n    // freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int res = 0;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1), ne(n + 1), f(n + 1);\n    std::fill(t + 1, t + 4 * n + 1, n + 1);\n    std::fill(t1 + 1, t1 + 4 * n + 1, (_)&#123; -inf, 0 &#125;);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    for (int i = n; ~i; --i) &#123;\n        ne[i] = ask(1, 0, n, a[i] + 1, n);\n        upd(1, 0, n, a[i], i);   \n    &#125;\n    std::vector&lt;int&gt; id(n + 1);\n    std::iota(id.begin(), id.end(), 0);\n    std::sort(id.begin(), id.end(), [&amp;](int x, int y) &#123; return a[x] &lt; a[y]; &#125;);\n    f[0] = 0;\n    for (int i = 0; i &lt;= n; ++i) &#123;\n        if (i) &#123;\n            f[id[i]] = ask(1, 0, n, id[i]);\n            res = std::max(res, f[id[i]]);\n        &#125;\n        if (ne[id[i]] &lt;= n)\n            upd(1, 0, n, ne[id[i]], ne[ne[id[i]]] - 1, f[id[i]] + 1);\n    &#125;\n    std::cout &lt;&lt; n - res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"merge-triplets\">4. Merge Triplets</h2>\n<p><a href=\"https://atcoder.jp/contests/agc043/tasks/agc043_d\" class=\"uri\">https://atcoder.jp/contests/agc043/tasks/agc043_d</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(A_{1\\sim 3N}=\\{1, 2, \\dots, 3N\\}\\)</span>，从 <span class=\"math inline\">\\(1\\)</span> 开始每 <span class=\"math inline\">\\(3\\)</span> 个数分为一组，每一组初始有一个指针指向第一个元素。执行若干次以下操作：</p>\n<ul>\n<li>在所有指针指向的数中选择一个最小的，把它放到序列末（不会加入末端的组）；将原本指向它的指针后移一位，如果移出原本的组就删除这个指针。</li>\n</ul>\n<p>问任意次操作后，可能得到多少种序列。<span class=\"math inline\">\\(n\\le 2\\times 10^3\\)</span>。</p>\n</blockquote>\n<p>由于要对合法的最终序列进行计数，考虑最终序列的性质。</p>\n<p>若序列中 <span class=\"math inline\">\\(a_{i+1}&lt;a_i\\)</span>，则说明在某一组中，值为 <span class=\"math inline\">\\(a_i\\)</span> 的元素下一个就是 <span class=\"math inline\">\\(a_{i+1}\\)</span>。否则，因 <span class=\"math inline\">\\(a_{i+1}\\)</span> 可选且比 <span class=\"math inline\">\\(a_i\\)</span> 小，<span class=\"math inline\">\\(a_{i+1}\\)</span> 应排在 <span class=\"math inline\">\\(a_i\\)</span> 前面。</p>\n<p>否则，<span class=\"math inline\">\\(a_{i+1}\\)</span> 既可以与 <span class=\"math inline\">\\(a_i\\)</span> 不在同一组，也可以是 <span class=\"math inline\">\\(a_i\\)</span> 的下一个元素。</p>\n<p>一组最多三个元素，也就是说，不能出现 <span class=\"math inline\">\\(a_i&gt;a_{i+1},a_{i+2},a_{i+3}\\)</span> 的情况。而 <span class=\"math inline\">\\(N=1\\)</span> 时序列长度只有 <span class=\"math inline\">\\(3\\)</span>，这就是为什么样例一的答案为 <span class=\"math inline\">\\(3!\\)</span>。</p>\n<p>但这个限制并不能排除所有非法情况。<span class=\"math inline\">\\(N=2\\)</span> 时暴搜我们目前限制下的解，共有 276 个，比答案中的 261 个要多，说明包含了其他非法解。</p>\n<p>暴搜输出并观察，易得这 15 个非法序列即为满足目前限制且存在 <span class=\"math inline\">\\(3\\)</span> 个 <span class=\"math inline\">\\(i\\)</span>，满足 <span class=\"math inline\">\\(a_i&gt;a_{i+1}\\)</span> 且 <span class=\"math inline\">\\(a_i&lt;a_{i+2}\\)</span> 的所有序列，<mark>由前面的推导，必须分为三个长度为 2 的组，而我们要求的是长度为 3 的组。显然无法用前者组合得到后者</mark>。</p>\n<p>在我们第一个条件的限制下，必须被分到同一组的数的连续长度，只有 <span class=\"math inline\">\\(1,2,3\\)</span> 三种。而：</p>\n<ul>\n<li>长度为 3 的对答案合法性无影响；</li>\n<li>而长度为 1 的既可以和 2 组为一组，也可以和其他两个 1 组为一组；</li>\n<li>长度为 2 的只能和 1 组成一组。</li>\n</ul>\n<p><mark>这时，我们发现所有限制都指向长度为 2 的段，其总个数不能比长度为 1 的段多。</mark></p>\n<p>于是乎，上述限制可总结为两点：</p>\n<ol type=\"1\">\n<li>若令所有满足 <span class=\"math inline\">\\(a_l&gt;\\max\\{a_{l\\sim r}\\}\\)</span> 的极大区间为一段（易证每段互不重合且覆盖全序列），那么其长度不能超过 3。</li>\n<li>其中，长度为 2 的个数不能比长度为 1 的个数多。</li>\n</ol>\n<p><mark>令 <span class=\"math inline\">\\(f_{i, j}\\)</span> 表示若当前枚举的最后一段右端点为 <span class=\"math inline\">\\(i\\)</span>，长度为 1 的段比长度为 2 的段多 <span class=\"math inline\">\\(j\\)</span> 的方案数。</mark></p>\n<p>最后答案即为 <span class=\"math inline\">\\(\\sum\\limits_{j=0}^n f_{i, j}\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n#else\n    freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, mod;\n    std::cin &gt;&gt; n &gt;&gt; mod;\n    n *= 3;\n    std::vector&lt;std::unordered_map&lt;int, long long&gt; &gt; f(n + 1);\n    f[0][0] = 1;\n    for (int i = 0; i &lt; n; ++i)\n        for (auto [j, k] : f[i]) &#123;\n            (f[i + 1][j + 1] += k) %= mod;\n            if (i + 2 &lt;= n)\n                (f[i + 2][j - 1] += k * (i + 1) % mod) %= mod;\n            if (i + 3 &lt;= n)\n                (f[i + 3][j] += k * (i + 1) % mod * (i + 2) % mod) %= mod;\n        &#125;\n    long long res = 0;\n    for (int i = 0; i &lt;= n; ++i)\n        (res += f[n][i]) %= mod;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"runaway-quail\">5. Runaway Quail</h2>\n<p><a href=\"https://qoj.ac/problem/5978\" class=\"uri\">https://qoj.ac/problem/5978</a></p>\n<blockquote>\n<p>数轴上有 <span class=\"math inline\">\\(n\\)</span> 只鸡，初始位置为非 <span class=\"math inline\">\\(0\\)</span> 整数 <span class=\"math inline\">\\(p_i\\)</span>，奔跑速度为 <span class=\"math inline\">\\(s_i\\)</span>。你初始在 <span class=\"math inline\">\\(0\\)</span> 位置，奔跑速度为 <span class=\"math inline\">\\(Y(Y&gt;s_i)\\)</span>。你要抓到所有鸡。</p>\n<p>你可以在任意时刻调转方向；鸡总会朝着远离你的方向奔跑；当你的坐标和鸡重合时，你抓到鸡。</p>\n<p>问抓到所有鸡的最短时间（显然是个实数）。<span class=\"math inline\">\\(n\\le 500\\)</span>。</p>\n</blockquote>\n<p>容易发现鸡的奔跑方向从始至终不会变，如果我们要从往左追变成往右追，显而易见地我们会<mark>在追上右边第一只鸡前经过原点</mark>，反之同理。</p>\n<p>那么有一个很神奇的状态设计，设 <span class=\"math inline\">\\(f_{i,j}\\)</span> 为追上了左边速度第 <span class=\"math inline\">\\(1\\sim i - 1\\)</span> 大的所有鸡和右边速度第 <span class=\"math inline\">\\(1\\sim j - 1\\)</span> 大的所有鸡，然后跑回原点的最小时间，这样我们就不用记录这个非常难记录的当前位置信息，对于速度排名 <span class=\"math inline\">\\(\\ge i,j\\)</span> 的所有鸡，当前是否追上我们并不关心——<mark>如果其位置比较远，那么我们会在后续转移中再考虑；如果其位置比较近，在解决速度排名 <span class=\"math inline\">\\(&lt;i,j\\)</span> 的鸡时就已经抓住</mark>。</p>\n<p><mark>我们 <span class=\"math inline\">\\(\\mathcal O(n)\\)</span> 枚举上一次反向是在抓住哪一只鸡时，然后让中间全部同向跑即可</mark>。</p>\n<p>也就是说，假设我们要用 <span class=\"math inline\">\\(f_{i,j}\\)</span> 更新 <span class=\"math inline\">\\(f_{k,j}\\)</span>（<span class=\"math inline\">\\(k&lt;i\\)</span>），那么只需要更新抓住速度排名 <span class=\"math inline\">\\(i\\sim k+1\\)</span> 中跑得最远的一只鸡所需额外时间。按速度排序后可以线性算代价。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst long double eps = 1e-12;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int v, n;\n        std::cin &gt;&gt; v &gt;&gt; n;\n        std::vector&lt;std::pair&lt;int, int&gt; &gt; a(n + 1);\n        for (int i = 1; i &lt;= n; ++i)\n            std::cin &gt;&gt; a[i].first;\n        for (int i = 1; i &lt;= n; ++i)\n            std::cin &gt;&gt; a[i].second;\n        a.emplace_back(0, 0), ++n;\n        std::sort(a.begin() + 1, a.end());\n        int p = std::lower_bound(a.begin() + 1, a.end(), std::make_pair(0, 0)) - a.begin();\n        std::sort(a.begin() + 1, a.begin() + p, [](std::pair&lt;int, int&gt; x, std::pair&lt;int, int&gt; y) &#123; return x.second == y.second ? x.first &lt; y.first : x.second &gt; y.second; &#125;);\n        std::sort(a.begin() + p + 1, a.end(), [](std::pair&lt;int, int&gt; x, std::pair&lt;int, int&gt; y) &#123; return x.second == y.second ? x.first &lt; y.first : x.second &lt; y.second; &#125;);\n        std::vector&lt;std::vector&lt;long double&gt; &gt; f(n + 1, std::vector&lt;long double&gt; (n + 1, 1e18));\n        f[1][n] = 0.;\n        auto at = [&amp;](int i, long double t) &#123;\n            return std::fabs(a[i].first + t * a[i].second * (i &lt; p ? -1 : 1));\n        &#125;;\n        auto calc = [&amp;](int i, long double t) &#123;\n            return at(i, t) / (v - a[i].second);\n        &#125;;\n        // for (int i = 1; i &lt;= n; ++i)\n        //     printf(&quot;%d: (%d, %d)\\n&quot;, i, a[i].first, a[i].second);\n        for (int i = 1; i &lt;= p; ++i)\n            for (int j = n; j &gt;= p; --j) &#123;\n                if (i == p &amp;&amp; j == p)\n                    break;\n                long double d = 0.;\n                // printf(&quot;[%d, %d]: %lf\\n&quot;, i, j, f[i][j]);\n                for (int k = i; k &lt; p; ++k) &#123;\n                    if (at(k, f[i][j]) &gt;= at(i, f[i][j]) - eps)\n                        d = std::max(d, calc(k, f[i][j]));\n                    // printf(&quot;  k1 = %d, d = %lf\\n&quot;, k, d);\n                    f[k + 1][j] = std::min(f[k + 1][j], f[i][j] + d + (k != j - 1) * d);\n                &#125;\n                d = 0.;\n                for (int k = j; k &gt; p; --k) &#123;\n                    if (at(k, f[i][j]) &gt;= at(j, f[i][j]) - eps)\n                        d = std::max(d, calc(k, f[i][j]));\n                    // printf(&quot;  k2 = %d, d = %lf\\n&quot;, k, d);\n                    f[i][k - 1] = std::min(f[i][k - 1], f[i][j] + d + (k != i + 1) * d);\n                &#125;\n            &#125;\n        &#123;\n            static int casetot = 0;\n            std::cout &lt;&lt; &quot;Case #&quot; &lt;&lt; ++casetot &lt;&lt; &quot;: &quot;;\n        &#125;\n        std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(9) &lt;&lt; f[p][p] &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"the-great-marathon\">6. The Great Marathon</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/38/H\" class=\"uri\">https://codeforces.com/problemset/problem/38/H</a></p>\n<blockquote>\n<p>给定一个 <span class=\"math inline\">\\(n\\)</span> 个点 <span class=\"math inline\">\\(m\\)</span> 条边的无向连通图，点 <span class=\"math inline\">\\(i\\)</span> 上初始有选手 <span class=\"math inline\">\\(i\\)</span>。为每个选手任意指定终点（可重复），那么最后的排名按照最短路为第一关键字、编号为第二关键字排序。</p>\n<p>现按照排名序列分成前中后三段，记为金银铜牌；满足金牌数在 <span class=\"math inline\">\\([g_1,g_2]\\)</span> 之间，银牌数在 <span class=\"math inline\">\\([s_1,s_2]\\)</span> 之间。任意指定发牌数量和每个人的终点，问最后有多少种方案数；两个方案不同当且仅当有至少一个人拿的牌不一样。</p>\n<p><span class=\"math inline\">\\(n\\le 50,m\\le 1000\\)</span>。</p>\n</blockquote>\n<p><mark><span class=\"math inline\">\\(n=50\\)</span>：可能需要考虑 <span class=\"math inline\">\\(n^5\\)</span> 做法。</mark></p>\n<p>发现是 <mark>需要确定顺序的 DP</mark>。关键位置自然在于『金银、银铜界处』。考虑钦定金牌最后一名、铜牌第一名的人选（不考虑中间的银牌是因为会出现这样那样的问题），还需要枚举他们的路程吗？并不。甚而至于，这样做会算重。</p>\n<p>考虑<mark>『最小化』左右两侧的金牌、铜牌可选集合</mark>。强行让金牌最后一名 <span class=\"math inline\">\\(u\\)</span> 的路程为 <span class=\"math inline\">\\(\\min\\{dis_{u,i}\\}\\)</span>，最小路程小于这个值的所有元素都可以成为金牌；同时让铜牌第一名 <span class=\"math inline\">\\(v\\)</span> 的路程为 <span class=\"math inline\">\\(\\max\\{dis_{v,i}\\}\\)</span>，最大路程大于这个值的所有数都可以成为铜牌。</p>\n<p>Q1: 如果存在一个 <span class=\"math inline\">\\(i\\)</span>，它最小的距离也比 <span class=\"math inline\">\\(u\\)</span> 的最小距离大，但实际上当 <span class=\"math inline\">\\(u\\)</span> 更大一点儿的时候，<span class=\"math inline\">\\(i\\)</span> 可以成为金牌呢？</p>\n<p>A1：这种情况在钦定 <span class=\"math inline\">\\(i\\)</span> 为最后一名的时候讨论过了。</p>\n<p>Q2：是否会算重？</p>\n<p>A2：如上所述，假如在钦定 <span class=\"math inline\">\\(i\\)</span> 的时候统计了 <span class=\"math inline\">\\(u\\)</span>，那么在钦定 <span class=\"math inline\">\\(u\\)</span> 的时候就不会统计 <span class=\"math inline\">\\(i\\)</span>。</p>\n<p>考虑转移。令 <span class=\"math inline\">\\(f_{i,u,v,j,k}\\)</span> 为考虑到 <span class=\"math inline\">\\(i\\)</span>，金牌倒一为 <span class=\"math inline\">\\(u\\)</span>，铜牌第一为 <span class=\"math inline\">\\(v\\)</span>，选了 <span class=\"math inline\">\\(j\\)</span> 个金、<span class=\"math inline\">\\(k\\)</span> 个铜的方案数。转移是 <span class=\"math inline\">\\(O(1)\\)</span> 的。</p>\n<details>\n<p>注意 <code>vector</code> 要开在循环外面，不然申请空间很耗时间 /ll</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int inf = 0x3f3f3f3f;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1, std::vector&lt;int&gt; (n + 1, inf));\n    for (int x, y; m--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        std::cin &gt;&gt; g[x][y], g[y][x] = g[x][y];\n    &#125;\n    for (int i = 1; i &lt;= n; ++i)\n        g[i][i] = 0;\n    for (int k = 1; k &lt;= n; ++k)\n        for (int i = 1; i &lt;= n; ++i)\n            if (k != i)\n                for (int j = 1; j &lt;= n; ++j)\n                    if (i != k &amp;&amp; j != k)\n                        g[i][j] = std::min(g[i][j], g[i][k] + g[k][j]);\n    int g1, g2, s1, s2;\n    std::cin &gt;&gt; g1 &gt;&gt; g2 &gt;&gt; s1 &gt;&gt; s2;\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = 1; j &lt;= n; ++j)\n            if (g[i][j] != inf)\n                g[i][j] = g[i][j] * n + i;\n    std::vector&lt;int&gt; mx(n + 1), mn(n + 1, inf);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = 1; j &lt;= n; ++j)\n            if (j != i)\n                mn[i] = std::min(mn[i], g[i][j]);\n        mx[i] = *std::max_element(g[i].begin() + 1, g[i].end());\n    &#125;\n    auto res(0ll);\n    std::vector&lt;std::vector&lt;std::vector&lt;long long&gt; &gt; &gt; f(n + 1, std::vector&lt;std::vector&lt;long long&gt; &gt; (n + 1, std::vector&lt;long long&gt; (n + 1)));\n    for (int u = 1; u &lt;= n; ++u)\n        for (int v = 1; v &lt;= n; ++v)\n            if (v != u) &#123;\n                f[0][1][1] = 1ll;\n                for (int i = 1; i &lt;= n; ++i)\n                    if (i == u || i == v)\n                        f[i] = f[i - 1];\n                    else &#123;\n                        bool flag = 0;\n                        for (int j = 1; j &lt;= n; ++j)\n                            if (mn[u] &lt; g[i][j] &amp;&amp; g[i][j] &lt; mx[v]) &#123;\n                                flag = 1;\n                                break;\n                            &#125;\n                        for (int j = 1; j &lt;= g2; ++j)\n                            for (int k = 1; k &lt;= n - g1 - s1; ++k) &#123;\n                                f[i][j][k] = 0ll;\n                                if (mx[i] &lt; mn[u])\n                                    f[i][j][k] = f[i - 1][j - 1][k];\n                                else if (mn[i] &gt; mx[v])\n                                    f[i][j][k] = f[i - 1][j][k - 1];\n                                else &#123;\n                                    if (flag)\n                                        f[i][j][k] = f[i - 1][j][k];\n                                    if (mn[i] &lt; mn[u])\n                                        f[i][j][k] += f[i - 1][j - 1][k];\n                                    if (mx[i] &gt; mx[v])\n                                        f[i][j][k] += f[i - 1][j][k - 1];\n                                &#125;\n                            &#125;\n                    &#125;\n                for (int g = g1; g &lt;= g2; ++g)\n                    for (int s = s1; s &lt;= s2; ++s)\n                        res += f[n][g][n - g - s];\n            &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"sorting-pancakes\">7. Sorting Pancakes</h2>\n<p><a href=\"https://codeforces.com/contest/1675/problem/G\" class=\"uri\">https://codeforces.com/contest/1675/problem/G</a></p>\n<blockquote>\n<p>给定盒子 <span class=\"math inline\">\\(1\\sim n\\)</span> 和每个盒子 <span class=\"math inline\">\\(i\\)</span> 里的初始球数 <span class=\"math inline\">\\(a_i\\)</span>，每次可以选择一个球移动到相邻盒子，最后欲使盒子内球数单调不升,求最小移球次数。</p>\n<p><span class=\"math inline\">\\(n,\\sum a_i\\le 250\\)</span>。</p>\n</blockquote>\n<p>简单题！这种『移动元素的题』，会考虑<mark>钦定每个元素最终的值，把前面的元素富余的 / 欠下来的存储起来</mark>。<em>当然也有例外，比如添加了『时间』这一维的限制，goto <a href=\"http://localhost:4000/20250510/#a---pass-to-next\">solu to Pass to Next</a></em></p>\n<p>在如果在 <span class=\"math inline\">\\(i\\)</span> 处富余了 <span class=\"math inline\">\\(x\\)</span>，那么在移动到 <span class=\"math inline\">\\(i+1\\)</span> 的过程中就会产生 <span class=\"math inline\">\\(|x|\\)</span> 的代价。</p>\n<p>令 <span class=\"math inline\">\\(f_{i,k,j}\\)</span> 表示第 <span class=\"math inline\">\\(i\\)</span> 个元素处，钦定它最终为 <span class=\"math inline\">\\(j\\)</span>，富余 <span class=\"math inline\">\\(k\\)</span>，则 <span class=\"math inline\">\\(f_{i,k,j}\\gets \\min\\limits_{j&#39;\\ge j}\\{f_{i-1, k-(j-a_i),j&#39;}\\}\\)</span>。显而易见后缀 min 优化就能 <span class=\"math inline\">\\(O(n\\cdot m^2)\\)</span> 地做了。</p>\n<details>\n<p>DP 数组和后缀 min 数组要合起来，不然会 MLE /ll</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int inf = 0x3f3f3f3f;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    using arr = std::vector&lt;int&gt;;\n    using brr = std::vector&lt;arr&gt;;\n    using crr = std::vector&lt;brr&gt;;\n    crr f(n + 1, brr(2 * m + 1, arr(m + 1, inf)));\n    std::fill(f[0][m].begin(), f[0][m].begin() + m + 1, 0);\n    for (int i = 1; i &lt;= n; ++i)\n        for (int k = 0; k &lt;= 2 * m; ++k)\n            for (int j = std::min(m, k + a[i]); j &gt;= std::max(0, k + a[i] - 2 * m); --j) &#123;\n                f[i][k][j] = f[i - 1][k - (j - a[i])][j] + std::abs(k - m);\n                if (j != m)\n                    f[i][k][j] = std::min(f[i][k][j], f[i][k][j + 1]);\n            &#125;\n    std::cout &lt;&lt; f[n][m][0] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"complexity\">8. Complexity</h2>\n<p><a href=\"https://atcoder.jp/contests/agc033/tasks/agc033_d\" class=\"uri\">https://atcoder.jp/contests/agc033/tasks/agc033_d</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(n\\times m\\)</span> 的 <span class=\"math inline\">\\(01\\)</span> 矩阵。定义其子矩阵的凌乱度：</p>\n<ul>\n<li>若该矩阵中只有一种值，凌乱度为 <span class=\"math inline\">\\(0\\)</span>。</li>\n<li>否则，任意竖直 / 水平切一刀，得到两个小矩阵；若它们的凌乱度分别为 <span class=\"math inline\">\\(a,b\\)</span>，则大矩阵的凌乱度为 <span class=\"math inline\">\\(\\max(a,b)+1\\)</span> 的最小值。</li>\n</ul>\n<p>求给定矩阵的凌乱度。<span class=\"math inline\">\\(n,m\\le 185\\)</span>。</p>\n</blockquote>\n<p>如果暴力枚举 DP，很不幸是 <span class=\"math inline\">\\(n^5\\)</span> 的。考虑优化。发现矩阵的凌乱度大致在 <span class=\"math inline\">\\(O(\\log n)\\)</span> 级别，考虑用<mark>状态交换答案</mark>减小复杂度。具体地，设 <span class=\"math inline\">\\(f_{k,u,d,l}\\)</span> 表示凌乱度 <span class=\"math inline\">\\(\\le k\\)</span> 时，<span class=\"math inline\">\\(r\\)</span> 可取到的最大值，那么有转移：</p>\n<ul>\n<li>竖着切一刀，枚举切点 <span class=\"math inline\">\\(i\\le f_{k-1,u,d,l}\\)</span>，有 <span class=\"math inline\">\\(f_{k,u,d,l}\\gets f_{k-1,u,d,i+1}\\)</span>。发现显然 <span class=\"math inline\">\\(i\\)</span> 取 <span class=\"math inline\">\\(f_{k-1,u,d,l}\\)</span> 的时候最优，这个是 <span class=\"math inline\">\\(O(1)\\)</span> 的。</li>\n<li>横着切一刀，枚举切点 <span class=\"math inline\">\\(i\\in[u,d)\\)</span>，有 <span class=\"math inline\">\\(f_{k,u,d,l}\\gets \\min(f_{k-1,u,i,l},f_{k-1,i+1,d,l})\\)</span>。发现随 <span class=\"math inline\">\\(i\\)</span> 增大左边单调不增，右边单调不降。随着 <span class=\"math inline\">\\(d\\)</span> 的增大，左边不变，右边下移，交出来的交点一直右移。然后就可以优化到均摊 <span class=\"math inline\">\\(O(1)\\)</span>。</li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int inf = 0x3f3f3f3f;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;std::vector&lt;char&gt; &gt; a(n + 1, std::vector&lt;char&gt; (m + 1));\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = 1; j &lt;= m; ++j)\n            std::cin &gt;&gt; a[i][j];\n    using arr = std::vector&lt;int&gt;;\n    using brr = std::vector&lt;arr&gt;;\n    using crr = std::vector&lt;brr&gt;;\n    std::vector&lt;std::string&gt; res;\n    std::vector&lt;crr&gt; _f(2, crr(n + 1, brr(m + 1, arr(n + 1))));\n    for (int k = 0; ; ++k) &#123;\n        auto &amp;f = _f[k &amp; 1], &amp;f1 = _f[(k &amp; 1) ^ 1];\n        if (k == 0) &#123;\n            crr tag(m + 1, brr(n + 1, arr(n + 1, -1)));\n            for (int l = 1; l &lt;= m; ++l)\n                for (int u = 1; u &lt;= n; ++u)\n                    for (int d = u; d &lt;= n &amp;&amp; a[d][l] == a[u][l]; ++d)\n                        tag[l][u][d] = a[u][l];\n            for (int u = 1; u &lt;= n; ++u)\n                for (int d = u; d &lt;= n; ++d)\n                    for (int l = m; l; --l) &#123;\n                        f[u][l][d] = l - 1;\n                        if (~tag[l][u][d]) &#123;\n                            if (l != m &amp;&amp; tag[l][u][d] == tag[l + 1][u][d])\n                                f[u][l][d] = f[u][l + 1][d];\n                            else\n                                f[u][l][d] = l;\n                        &#125;\n                    &#125;\n        &#125;\n        else\n            for (int u = 1; u &lt;= n; ++u)\n                for (int l = 1; l &lt;= m; ++l)\n                    for (int d = u, pos = 1; d &lt;= n; ++d) &#123;\n                        f[u][l][d] = f1[u][l][d];\n                        if (f[u][l][d] != m) &#123;\n                            f[u][l][d] = std::max(f[u][l][d], f1[u][f1[u][l][d] + 1][d]);\n                            int mx = 0;\n                            for (int i = pos; i &lt; d; ++i) &#123;\n                                if (std::min(f1[u][l][i], f1[i + 1][l][d]) &gt;= mx)\n                                    mx = std::min(f1[u][l][i], f1[i + 1][l][d]), pos = i;\n                                else\n                                    break;\n                            &#125;\n                            f[u][l][d] = std::max(f[u][l][d], mx);\n                        &#125;\n                    &#125;\n        if (f[1][1][n] == m) &#123;\n            std::cout &lt;&lt; k &lt;&lt; &#39;\\n&#39;;\n            return 0;\n        &#125;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"boxes-and-balls\">9. Boxes and Balls</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1845E\" class=\"uri\">https://www.luogu.com.cn/problem/CF1845E</a></p>\n<blockquote>\n<p>给定一个长度为 <span class=\"math inline\">\\(n\\)</span> 的 <span class=\"math inline\">\\(01\\)</span> 序列 <span class=\"math inline\">\\(a_{1\\sim n}\\)</span>。你可以进行恰好 <span class=\"math inline\">\\(k\\)</span> 次如下操作：</p>\n<ul>\n<li>选择序列中一对相邻且值不同的元素，将它们交换。</li>\n</ul>\n<p>问有多少种最终序列。<span class=\"math inline\">\\(n,k\\le 1500\\)</span>。</p>\n</blockquote>\n<p>沿用 <a href=\"#sorting-pancakes\">7. Sorting Pancakes</a> 的思路，考虑令 <span class=\"math inline\">\\(f_{i,j,l}\\)</span> 表示最终序列的前 <span class=\"math inline\">\\(i\\)</span> 个里有 <span class=\"math inline\">\\(j\\)</span> 个 <span class=\"math inline\">\\(1\\)</span>，代价已经有 <span class=\"math inline\">\\(l\\)</span> 的方案数；那么令 <span class=\"math inline\">\\(s_i\\)</span> 为 <span class=\"math inline\">\\(a\\)</span> 的前缀和，显然有：</p>\n<p><span class=\"math display\">\\[\nf_{i+1,j+1,k+|j-s_i|}\\gets f_{i,j,k}\\\\\nf_{i+1,j,k+|j-s_i|}\\gets f_{i,j,k}\n\\]</span></p>\n<p>最后在比 <span class=\"math inline\">\\(k\\)</span> 小且奇偶性和 <span class=\"math inline\">\\(k\\)</span> 相同的 <span class=\"math inline\">\\(l\\)</span> 里找答案。然后想怎么优化。</p>\n<p>答案是不用优化。考虑<mark>有效状态数</mark>，<del>打个表发现每个 <span class=\"math inline\">\\(i\\)</span> 在 <span class=\"math inline\">\\(O(n\\sqrt n)\\)</span> 左右</del>，但有另一种方法是发现有效的 <span class=\"math inline\">\\(|j-s_i|\\)</span> 不会超过 <span class=\"math inline\">\\(O(\\sqrt n)\\)</span>（原因：为了消除 <span class=\"math inline\">\\(|j-s_i|\\)</span> 的欠账，需要 <span class=\"math inline\">\\(|j-s_i|\\)</span> 个位置；每个位置都会有差不多 <span class=\"math inline\">\\(|j-s_i|\\)</span> 的代价），所以枚举时只用枚举 <span class=\"math inline\">\\(O(\\sqrt n)\\)</span> 个 <span class=\"math inline\">\\(j\\)</span>。</p>\n<p>总之只用存有效状态会发现跑不满 <img src=\"/em/bb.gif\" /></p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    std::vector&lt;int&gt; a(n + 1), s(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::partial_sum(a.begin() + 1, a.end(), s.begin() + 1);\n    using arr = std::vector&lt;long long&gt;;\n    using brr = std::vector&lt;arr&gt;;\n    using crr = std::vector&lt;brr&gt;;\n    brr tag(n + 1, arr(n + 1));\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; stt(2);\n    stt[0].emplace_back(0, 0);\n    crr _f(2, brr(n + 1, arr(k + 1)));\n    _f[0][0][0] = 1;\n    for (int i = 0; i &lt; n; ++i) &#123;\n        auto &amp;f = _f[i &amp; 1], &amp;f1 = _f[(i &amp; 1) ^ 1];\n        std::vector&lt;std::pair&lt;int, int&gt; &gt;().swap(stt[(i &amp; 1) ^ 1]);\n        for (auto [j, l] : stt[i &amp; 1]) &#123;\n                if (j + 1 &lt;= s[n] &amp;&amp; l + std::abs(j - s[i]) &lt;= k) &#123;\n                    if (tag[j + 1][l + std::abs(j - s[i])] != i + 1)\n                        tag[j + 1][l + std::abs(j - s[i])] = i + 1, stt[(i &amp; 1) ^ 1].emplace_back(j + 1, l + std::abs(j - s[i])), f1[j + 1][l + std::abs(j - s[i])] = 0ll;\n                    (f1[j + 1][l + std::abs(j - s[i])] += f[j][l]) %= mod;\n                &#125;\n                if (l + std::abs(j - s[i]) &lt;= k) &#123;\n                    if (tag[j][l + std::abs(j - s[i])] != i + 1)\n                        tag[j][l + std::abs(j - s[i])] = i + 1, stt[(i &amp; 1) ^ 1].emplace_back(j, l + std::abs(j - s[i])), f1[j][l + std::abs(j - s[i])] = 0ll;\n                    (f1[j][l + std::abs(j - s[i])] += f[j][l]) %= mod;\n                &#125;\n            &#125;\n        std::cout &lt;&lt; (int)stt[i &amp; 1].size() &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    auto res(0ll);\n    for (int i = k &amp; 1; i &lt;= k; i += 2)\n        if (tag[s[n]][i] == n)\n            (res += _f[n &amp; 1][s[n]][i]) %= mod;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"legondary-grandmaster\">10. LEGOndary Grandmaster</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1615/F\" class=\"uri\">https://codeforces.com/problemset/problem/1615/F</a></p>\n<blockquote>\n<p>给定两个长度为 <span class=\"math inline\">\\(n\\)</span> 的 <span class=\"math inline\">\\(0/1/?\\)</span> 串 <span class=\"math inline\">\\(s,t\\)</span>，你可以对 <span class=\"math inline\">\\(s\\)</span> 进行若干次如下操作：</p>\n<ul>\n<li>选择序列中一对相邻且值相同的元素，将它们取反。</li>\n</ul>\n<p>现任意将 <span class=\"math inline\">\\(s\\)</span> 和 <span class=\"math inline\">\\(t\\)</span> 中的 <code>?</code> 填为 <span class=\"math inline\">\\(0/1\\)</span>，问所有情况中 <span class=\"math inline\">\\(s\\)</span> 转化为 <span class=\"math inline\">\\(t\\)</span> 所需最小操作次数和（规定无解的操作次数为 <span class=\"math inline\">\\(0\\)</span>）。<span class=\"math inline\">\\(n\\le 2000\\)</span>。</p>\n</blockquote>\n<p>如果我们之前做过某些令人心（咬）旷（牙）神（切）怡（齿）的题目，会发现这个操作等价于交换任意两个相邻数，再让他们取反。</p>\n<p>进一步地，可以交换运算顺序，先取反某个位置，再交换，再取反这个位置——把这个操作平均分配到 <span class=\"math inline\">\\(s\\)</span> 和 <span class=\"math inline\">\\(t\\)</span> 上，<mark>结合『相邻两数位置必一奇一偶』这个美妙的性质，想到把 <span class=\"math inline\">\\(s\\)</span> 和 <span class=\"math inline\">\\(t\\)</span> 的奇数位都提前取反，这样就可以转化成直接交换了</mark>，</p>\n<p>接下来就和上一题有点不一样了。这里我们直接算一个位置的贡献——这意味着不需要统计一个序列的代价（此时失去了 <span class=\"math inline\">\\(k\\)</span> 的限制，代价来到 <span class=\"math inline\">\\(n^2\\)</span> 级别）。令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示从前往后到了第 <span class=\"math inline\">\\(i\\)</span> 个位置，欠债为 <span class=\"math inline\">\\(j\\)</span> 的方案数；同样地，令 <span class=\"math inline\">\\(g_{i,j}\\)</span> 表示从后到前到了第 <span class=\"math inline\">\\(i\\)</span> 个位置，欠债为 <span class=\"math inline\">\\(j\\)</span> 的方案数。则贡献为 <span class=\"math inline\">\\(\\sum_i \\sum_j f_{i, j}\\times g_{i + 1, -j}\\times j\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n;\n        std::string s, t;\n        std::cin &gt;&gt; n &gt;&gt; s &gt;&gt; t, s = &#39;#&#39; + s, t = &#39;#&#39; + t;\n        for (int i = 1; i &lt;= n; ++i)\n            if (i &amp; 1) &#123;\n                if (s[i] != &#39;?&#39;)\n                    s[i] = &#39;0&#39; + &#39;1&#39; - s[i];\n                if (t[i] != &#39;?&#39;)\n                    t[i] = &#39;0&#39; + &#39;1&#39; - t[i];\n            &#125;\n        using arr = std::vector&lt;long long&gt;;\n        using brr = std::vector&lt;arr&gt;;\n        brr f(n + 1, arr(2 * n + 1)), g(n + 2, arr(2 * n + 1));\n        f[0][n] = 1ll;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            for (int S = 0; S &lt;= 1; ++S)\n                if ((S == 0 &amp;&amp; s[i] == &#39;1&#39;) || (S == 1 &amp;&amp; s[i] == &#39;0&#39;));\n                else\n                    for (int T = 0; T &lt;= 1; ++T) &#123;\n                        if ((T == 0 &amp;&amp; t[i] == &#39;1&#39;) || (T == 1 &amp;&amp; t[i] == &#39;0&#39;));\n                        else\n                            for (int j = 0; j &lt;= 2 * n; ++j)\n                                if (j - (T - S) &gt;= 0 &amp;&amp; j - (T - S) &lt;= 2 * n)\n                                    (f[i][j] += f[i - 1][j - (T - S)]) %= mod;\n                    &#125;\n        &#125;\n        g[n + 1][n] = 1ll;\n        for (int i = n; i; --i) &#123;\n            for (int S = 0; S &lt;= 1; ++S)\n                if ((S == 0 &amp;&amp; s[i] == &#39;1&#39;) || (S == 1 &amp;&amp; s[i] == &#39;0&#39;));\n                else\n                    for (int T = 0; T &lt;= 1; ++T) &#123;\n                        if ((T == 0 &amp;&amp; t[i] == &#39;1&#39;) || (T == 1 &amp;&amp; t[i] == &#39;0&#39;));\n                        else\n                            for (int j = 0; j &lt;= 2 * n; ++j)\n                                if (j - (T - S) &gt;= 0 &amp;&amp; j - (T - S) &lt;= 2 * n)\n                                    (g[i][j] += g[i + 1][j - (T - S)]) %= mod;\n                    &#125;\n        &#125;\n        auto res(0ll);\n        for (int i = 1; i &lt; n; ++i)\n            for (int j = 1; j &lt;= n; ++j) &#123;\n                (res += j * f[i][n + j] % mod * g[i + 1][n - j] % mod) %= mod;\n                (res += j * f[i][n - j] % mod * g[i + 1][n + j] % mod) %= mod;\n            &#125;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "DP"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20240625/",
            "url": "https://xsc062.netlify.app/20240625/",
            "title": "媒介素养",
            "date_published": "2024-06-25T02:37:25.000Z",
            "content_html": "<p>Adapted from 之前的一片发电文。现在更癫了。</p>\n<span id=\"more\"></span>\n<hr />\n<p><img src=\"pre.jpeg\" /></p>\n<hr />\n<p>媒介素养一般是指人们正确地、建设性地使用媒介资源的能力。它包括人们面对各种信息时的选择、理解、质疑、评估等能力。</p>\n<ul>\n<li>关于选择：太遗憾了！你没有任何其他的项目是可选择的，因为<em>歌愛ユキ</em>很可爱！</li>\n<li>关于理解：接下来，你将会度过一定量的时间理解<em>歌愛ユキ</em>的可爱性。</li>\n<li>关于质疑：是的，正在质疑！通常情况下这代表着一种好的状态，但在这里您可能会遇到障碍——你不会想要质疑<em>歌愛ユキ</em>。事实上，<em>歌愛ユキ</em>又有什么是可质疑的呢？</li>\n<li><p>关于评估：当然，在这里，评估有着不可忽视的重要性——海内存知己，天涯若比邻。对我们的<em>歌愛ユキ</em>进行打分！</p>\n<p>可选的评估项：</p>\n<ul>\n<li>100 分</li>\n<li><p>其他，请补锟斤拷锟斤拷锟斤拷烫烫烫烫烫烫烫烫烫</p>\n<pre><code>程序 Assessing.exe 引用了名为 0x00000000ff 的内存，该地址不能为 &#39;read&#39;。</code></pre>\n<p>很遗憾！看起来你的 Windows 出现了问题。请勿关闭电脑，我们将会收集你电脑上的错误信息，我们将会将它上传到 Microsoft 官网并尝试在脱机状态下解决它。</p>\n<p>错误代码：0x00009E2EAF60</p>\n<p>我们正在为你解析。</p></li>\n</ul></li>\n</ul>\n<hr />\n<p>嘿，抬起头！这篇帖子可能并没有您正在考虑的那样陌生！</p>\n<p>Hey, heads up! The post may not so strange as you are considering!</p>\n<p>让我们分析这些笑话！</p>\n<p>Let’s analyse the jokes!</p>\n<ul>\n<li><p>努力理解「花」意味着什么。</p>\nTry to understand what “spend” means.</li>\n<li><p>正在错误地翻译「查询」。</p>\nWrong translating “querying”.</li>\n<li><p>海内存知己，天涯若比邻。</p>\nSea inside exist know self, sky Ya like than neighbor.</li>\n<li><p>主语并未变化，但主语却在相邻的两个短句中出现了。相同的相邻主语没有得到省略，而这将导致这些相同的主语看起来很累赘！</p>\nThe subject didn’t changed, but it appears in two adjacent short sentences. The same adjacent subjects havn’t been omitted, which will make these identical subjects appear cumbersome!</li>\n<li><p>正在错过时间状语！这使「上传」和「脱机处理」两个动作看上去像是同时发生的。</p>\nMissing time adverb! This makes the actions of “uploading” and “offline processing” appear to occur simultaneously.</li>\n<li><p>你您你您你您你您你您</p>\n<p>You you you you you you you you you you</p></li>\n</ul>\n",
            "tags": [
                "闲话"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20240517/",
            "url": "https://xsc062.netlify.app/20240517/",
            "title": "状压枚举子集 + 高维前缀和",
            "date_published": "2024-05-17T13:19:38.000Z",
            "content_html": "<p>出现了，但发现没写过，故记之。</p>\n<span id=\"more\"></span>\n<hr />\n<h3 id=\"状压枚举子集\">状压枚举子集</h3>\n<p>需求：对于 <strong>每一个</strong> 长度为 <span class=\"math inline\">\\(n\\)</span> 的二进制状态 <span class=\"math inline\">\\(s\\)</span>，枚举其子状态 <span class=\"math inline\">\\(\\{ t \\mid t \\operatorname{bitand} s = t \\}\\)</span>。</p>\n<p>直接枚举所有长度为 <span class=\"math inline\">\\(n\\)</span> 的状态 <span class=\"math inline\">\\(t&#39;\\)</span>，然后判定是否满足 <span class=\"math inline\">\\(t&#39; \\operatorname{bitand} s = t\\)</span>，总时间复杂度是 <span class=\"math inline\">\\(O(2^{2n})\\)</span> 的。考虑优化。</p>\n<p>考虑对于所有 <span class=\"math inline\">\\(2^n\\)</span> 种状态 <span class=\"math inline\">\\(s\\)</span>，假如有一种方式能够不重不漏地枚举出它们中每一个的所有子状态，那么总时间复杂度是多少呢？</p>\n<p>把所有数对 <span class=\"math inline\">\\((s, t)\\)</span> 排列在一起。那么对于 <span class=\"math inline\">\\(n\\)</span> 位中的每一位 <span class=\"math inline\">\\(i\\)</span>，枚举每一个 <span class=\"math inline\">\\((s&#39;, t&#39;)\\)</span>。</p>\n<p>那么存在以下几种可能性：</p>\n<ol type=\"1\">\n<li><span class=\"math inline\">\\({s&#39;}_i=1,{t&#39;}_i=1\\)</span>；</li>\n<li><span class=\"math inline\">\\({s&#39;}_i=1, {t&#39;}_i=0\\)</span>；</li>\n<li><span class=\"math inline\">\\({s&#39;}_i=0, {t&#39;}_i = 0\\)</span>。</li>\n</ol>\n<p>假如我们用 <span class=\"math inline\">\\(o_i=0,1,2\\)</span> 分别代表第一、二、三种情况，完全可以用长度为 <span class=\"math inline\">\\(n\\)</span> 的三进制状态 <span class=\"math inline\">\\(o\\)</span> 还原数对 <span class=\"math inline\">\\((s, t)\\)</span>。</p>\n<p>由于这个 <span class=\"math inline\">\\((s, t)\\)</span> 序列中肯定没有完全相同的元素，也就是说，对于每一个 <span class=\"math inline\">\\((s, t)\\)</span>，其 <span class=\"math inline\">\\(o\\)</span> 都各不相同。</p>\n<p>因此，<span class=\"math inline\">\\((s, t)\\)</span> 的数目不超过 <span class=\"math inline\">\\(3^n\\)</span>（更准确地，二者值相等）。</p>\n<p>又因为对于 <span class=\"math inline\">\\(3^n\\)</span> 个 <span class=\"math inline\">\\(o\\)</span>，每个都可以还原出合法状态，所以总的 <span class=\"math inline\">\\((s, t)\\)</span> 数目应恰好为 <span class=\"math inline\">\\(3^n\\)</span>。</p>\n<p>也就是说，假如有一种方式能够不重不漏地枚举出每一个 <span class=\"math inline\">\\(s\\)</span> 的所有子状态 <span class=\"math inline\">\\(t\\)</span>，可以做到均摊 <span class=\"math inline\">\\(O(3^n)\\)</span>。</p>\n<p>接下来探讨这种枚举方式。直接给出结论：</p>\n<pre class=\"cpp\"><code>for (int t = s; t; t = (t - 1) &amp; s);</code></pre>\n<p>其实不难理解。从 <span class=\"math inline\">\\(t\\)</span> 的定义出发即 <span class=\"math inline\">\\(t \\operatorname{bitand} s = t\\)</span>，重点理解 <span class=\"math inline\">\\(t\\gets (t - 1)\\operatorname{bitand} s\\)</span> 这一步。</p>\n<p>分两种情况讨论：</p>\n<ol type=\"1\">\n<li><p><span class=\"math inline\">\\(t-1\\)</span> 较 <span class=\"math inline\">\\(t\\)</span> 发生退位：</p>\n<p>因为只减 <span class=\"math inline\">\\(1\\)</span>，所以末位一定发生退位。</p>\n<p>如果发生连续退位，一定是因为末端有连续的 <span class=\"math inline\">\\(0\\)</span>。对于第一个 <span class=\"math inline\">\\(1\\)</span>（记为第 <span class=\"math inline\">\\(j\\)</span> 位），已经枚举完了在 <span class=\"math inline\">\\(j\\)</span> 及更高位固定在当前状态下的所有状态。</p>\n<p>则应有：</p>\n<ul>\n<li>比 <span class=\"math inline\">\\(j\\)</span> 更高的数位，未受到退位带来的连续影响的位不变；</li>\n<li>第 <span class=\"math inline\">\\(j\\)</span> 位 <span class=\"math inline\">\\(1\\to 0\\)</span>；</li>\n<li>从第 <span class=\"math inline\">\\(j\\)</span> 位一直到末位都有 <span class=\"math inline\">\\(0\\to 1\\)</span>。</li>\n</ul>\n<p>此时与 <span class=\"math inline\">\\(s\\)</span> 进行 <span class=\"math inline\">\\(\\operatorname{bitand}\\)</span>，得到比 <span class=\"math inline\">\\(j\\)</span> 更高的数位不变、<span class=\"math inline\">\\(j\\)</span> 位 <span class=\"math inline\">\\(1\\to 0\\)</span>、比 <span class=\"math inline\">\\(j\\)</span> 更低的数位变为抵着 <span class=\"math inline\">\\(s\\)</span> 对应数位的最大状态。</p>\n综上，这是比 <span class=\"math inline\">\\(t\\)</span> 小的第一个合法状态。</li>\n<li><p><span class=\"math inline\">\\(t-1\\)</span> 较 <span class=\"math inline\">\\(t\\)</span> 不发生退位：</p>\n<p>根据上面的讨论，其实就是末位不退位，即末位 <span class=\"math inline\">\\(1\\to 0\\)</span>。显然是比 <span class=\"math inline\">\\(t\\)</span> 更小的第一个合法状态。</p></li>\n</ol>\n<p>综上，实现了从大到小依次枚举合法状态，因此不重不漏。</p>\n<hr />\n<h3 id=\"枚举补集\">枚举补集</h3>\n<p>看了几个比较抽象的博客，但是我觉得不如直接把 <span class=\"math inline\">\\(s\\)</span> 异或一下 <span class=\"math inline\">\\(2^n-1\\)</span> 然后枚举子集。</p>\n<hr />\n<h3 id=\"子集和-高维前缀和\">子集和 / 高维前缀和</h3>\n<p>首先理解一下什么是高维前缀和。实际上全称应为边长为 <span class=\"math inline\">\\(2\\)</span> 的高维空间前缀和。其实就是求所有状态的子集和，运用了前缀和的思想故唤高位前缀和 / 逐维前缀和。</p>\n<p>即在 <span class=\"math inline\">\\(n=2\\)</span> 的情况下，我们发现我们可以将 <span class=\"math inline\">\\(k\\)</span> 维前缀和看作在 <span class=\"math inline\">\\(k\\)</span> 位二进制数上做子集元素求和。显然根据枚举子集有 <span class=\"math inline\">\\(3^k\\)</span> 的做法，但还能更快。</p>\n<pre class=\"cpp\"><code>std::copy(a.begin(), a.end(), s.begin());\nfor (int i = 0; i &lt; k; ++i)\n    for (int j = 0; j &lt; l; ++j)\n        if ((j &gt;&gt; i) &amp; 1)\n            s[j] += s[j ^ (1 &lt;&lt; i)];</code></pre>\n<p>先枚举 <span class=\"math inline\">\\(i\\)</span> 是因为使用高维前缀和的题目一般时限卡得比较死，需要使用内存连续访问尽量减小常数。</p>\n<p>对于状态 <span class=\"math inline\">\\(j\\)</span>，考虑枚举其每一维上的值，则 <span class=\"math inline\">\\(s_j=a_j+\\sum s_{j\\bigoplus 2^i}\\)</span>。易发现这可以不重不漏地覆盖所有子集。</p>\n<p>这种思想在一些状态压缩的题目中也有应用，具体见 <a href=\"/20231117#1\">此</a>。</p>\n<h3 id=\"高维后缀和\">高维后缀和</h3>\n<p>从大往小枚举 <span class=\"math inline\">\\(j\\)</span>，对于 <span class=\"math inline\">\\(j\\)</span> 中值为 <code>false</code> 的维 <span class=\"math inline\">\\(i\\)</span>，令 <span class=\"math inline\">\\(s_j=a_j+\\sum s_{j+2^i}\\)</span> 即可。</p>\n<pre class=\"cpp\"><code>std::copy(a.begin(), a.end(), s.begin());\nfor (int i = 0; i &lt; k; ++i)\n    for (int j = l - 1; ~j; --j)\n        if (!((j &gt;&gt; i) &amp; 1))\n            s[j] += s[j ^ (1 &lt;&lt; i)];</code></pre>\n",
            "tags": [
                "状压",
                "高维前缀和"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20240501/",
            "url": "https://xsc062.netlify.app/20240501/",
            "title": "五一杂题",
            "date_published": "2024-05-01T07:44:48.000Z",
            "content_html": "<p><a href=\"http://222.180.160.110:61235/contest/5169\">SAM 杂题</a> + <a href=\"http://222.180.160.110:61235/contest/5170\">NOIPS8</a> + <a href=\"http://222.180.160.110:61235/contest/5175\">周考</a> 选讲。</p>\n<p>看看这个标签列表长度就知道这三天做的题有多杂。</p>\n<span id=\"more\"></span>\n<hr />\n<h3 id=\"d.-字符串\">D. 字符串</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/5169/problem/4\" class=\"uri\">http://222.180.160.110:61235/contest/5169/problem/4</a></p>\n<p>和 SA 的做法一样，先二分 <span class=\"math inline\">\\(s_{c\\sim d}\\)</span> 的前缀长度 <span class=\"math inline\">\\(mid\\)</span>，只需 check <span class=\"math inline\">\\(s_{c \\sim c + mid - 1}\\)</span> 是否在 <span class=\"math inline\">\\(s_{a\\sim b}\\)</span> 中出现过。</p>\n<p>考虑怎么快速 check。从 <span class=\"math inline\">\\(c\\)</span> 一步一步跳到 <span class=\"math inline\">\\(c+mid-1\\)</span> 显然会起飞，考虑到查询是静态的，我们事先预处理一下然后倍增地跳即可。</p>\n<p>此时只需看当前状态的 <span class=\"math inline\">\\(\\text {endpos}\\)</span> 是否在 <span class=\"math inline\">\\([a + mid - 1, b]\\)</span> 出现过。</p>\n<p>因为这个不能用最大最小简单代替，所以就到了我们喜闻乐见的线段树合并环节。将插入后的每个单点 <span class=\"math inline\">\\(\\text {endpos}\\)</span> 在权值线段树上更新，在 parent tree 上暴力线段树合并即可。</p>\n<p>之前一直有一个误区，就是觉得线段树合并是一次性的，比如用 A 树和 B 树并出来了 C 树之后，A 树和 B 树的数据就无效了。</p>\n<p>但这显然是很荒谬的，同样因为我们的查询是静态的，所以完全可以用一种类似于可持久化的方式，建立一些新的点表示合并后的信息状态点，一些可以保留的点就保留作儿子。</p>\n<p>在对应的状态上查询即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxm = 35;\nconst int maxn = 6e5 + 5;\nconst int maxk = 8e7 + 5;\nstruct _ &#123;\n    int l, f;\n    int ne[maxm]; \n    _() &#123;&#125;\n    _(int l1, int f1): l(l1), f(f1) &#123;&#125;\n&#125;;\n_ t[maxn &lt;&lt; 1];\nint vis[maxn &lt;&lt; 1];\nint fa[maxn][maxm];\nint n, la, tot, siz;\nstruct &#123; int l, r, u; &#125; t1[maxk];\nint tab[maxn &lt;&lt; 1], cnt[maxn &lt;&lt; 1];\nvoid Init(void) &#123;\n    la = tot = 1;\n    t[1] = _(0, 0);\n    return;\n&#125;\nvoid ext(int c) &#123;\n    int p = la, np = ++tot;\n    la = tot;\n    t[np] = _(t[p].l + 1, 0);\n    while (p &amp;&amp; !t[p].ne[c])\n        t[p].ne[c] = np, p = t[p].f;\n    if (!p)\n        t[np].f = 1;\n    else &#123;\n        int q = t[p].ne[c];\n        if (t[q].l == t[p].l + 1)\n            t[np].f = q;\n        else &#123;\n            int nq = ++tot;\n            t[nq] = _(t[p].l + 1, t[q].f);\n            std::copy(t[q].ne, t[q].ne + 26, t[nq].ne);\n            while (p &amp;&amp; t[p].ne[c] == q)\n                t[p].ne[c] = nq, p = t[p].f;\n            t[q].f = nq;\n            t[np].f = nq;\n        &#125;\n    &#125;\n    return;\n&#125;\nint now = 0;\nvoid ins(int &amp;p, int l, int r, int v) &#123;\n    if (!p)\n        p = ++now;\n    ++t1[p].u;\n    if (l == r)\n        return;\n    int mid = (l + r) &gt;&gt; 1;\n    if (v &lt;= mid)\n        ins(t1[p].l, l, mid, v);\n    else\n        ins(t1[p].r, mid + 1, r, v);\n    return;\n&#125;\nint ask(int p, int l, int r, int ql, int qr) &#123;\n    if (ql &lt;= l &amp;&amp; r &lt;= qr)\n        return t1[p].u;\n    int mid = (l + r) &gt;&gt; 1, res = 0;\n    if (ql &lt;= mid)\n        res = ask(t1[p].l, l, mid, ql, qr);\n    if (qr &gt; mid)\n        res += ask(t1[p].r, mid + 1, r, ql, qr);\n    return res;\n&#125;\nint merge(int p, int q, int l, int r) &#123;\n    if (!p || !q)\n        return p + q;\n    int np = ++now, mid = (l + r) &gt;&gt; 1;\n    t1[np].u = t1[p].u + t1[q].u;\n    if (l == r) return np;\n    t1[np].l = merge(t1[p].l, t1[q].l, l, mid);\n    t1[np].r = merge(t1[p].r, t1[q].r, mid + 1, r);\n    return np;\n&#125;\nint pos[maxn], rt[maxn &lt;&lt; 1];\nbool check(int x, int a, int b, int c, int d) &#123;\n    assert(c + x - 1 &gt;= 0);\n    int p = pos[c + x - 1];\n    for (int i = siz; ~i; --i)\n        if (fa[p][i] &amp;&amp; t[fa[p][i]].l &gt;= x)\n            p = fa[p][i];\n    return ask(rt[p], 0, n - 1, a + x - 1, b) &gt; 0;\n&#125;\nint solve(int a, int b, int c, int d) &#123;\n    int l = 1, r = std::min(d - c + 1, b - a + 1), res = 0;\n    while (l &lt;= r) &#123;\n        int mid = (l + r) &gt;&gt; 1;\n        if (check(mid, a, b, c, d))\n            l = mid + 1, res = mid;\n        else\n            r = mid - 1;\n    &#125;\n    return res;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n#endif\n    int m;\n    std::string s;\n    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;\n    Init();\n    for (int i = 0; i &lt; n; ++i) &#123;\n        ext(s[i] - &#39;a&#39;);\n        pos[i] = la;\n        ins(rt[la], 0, n - 1, i);\n    &#125;\n    siz = log(tot) / log(2.0);\n    for (int i = 1; i &lt;= tot; ++i)\n        ++cnt[t[i].l];\n    std::partial_sum(cnt + 1, cnt + tot + 1, cnt + 1);\n    for (int i = 1; i &lt;= tot; ++i)\n        tab[cnt[t[i].l]--] = i;\n    for (int i = 1; i &lt;= tot; ++i) &#123;\n        int u = tab[i];\n        fa[u][0] = t[u].f;\n        for (int j = 1; j &lt;= siz; ++j)\n            fa[u][j] = fa[fa[u][j - 1]][j - 1];\n    &#125;\n    for (int i = tot; i; --i) &#123;\n        int u = tab[i];\n        if (t[u].f)\n            rt[t[u].f] = merge(rt[t[u].f], rt[u], 0, n - 1);\n    &#125;\n    while (m--) &#123;\n        int a, b, c, d;\n        std::cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;\n        std::cout &lt;&lt; solve(a - 1, b - 1, c - 1, d - 1) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"f.-security\">F. Security</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/5169/problem/6\" class=\"uri\">http://222.180.160.110:61235/contest/5169/problem/6</a></p>\n<p>对我们来说应该是会 D 就会 F 的。所以只打了 10min。</p>\n<p>首先考虑一个大家喜闻乐见的 DFS 求最小字典序。显然地，如果存在和当前位相等的字符，那么优先跳相等字符，进入下一层深搜；否则找到最小的更大字符，然后直接 out。</p>\n<p>此时 SAM 就是我们用来判断 <span class=\"math inline\">\\(S_{l, r}\\)</span> 中是否存在某状态的工具了。甚至比上一题简单，因为不用写二分和倍增。</p>\n<p>值得注意的是如果 <span class=\"math inline\">\\(S_{l, r}\\)</span> 包含 <span class=\"math inline\">\\(T\\)</span> 那么还要在后面随便加一个字符以字典序保证严格大于 <span class=\"math inline\">\\(T\\)</span>。</p>\n<details>\n<p>值得注意的是因为我写的太丑了以至于在 CF 上会光荣 MLE #46。然后分屏左半边看我代码右半边写的 zwb 却没有。啧。为什么呢。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxm = 35;\nconst int maxn = 6e5 + 5;\nconst int maxk = 8e7 + 5;\nstruct _ &#123;\n    int l, f;\n    int ne[maxm]; \n    _() &#123;&#125;\n    _(int l1, int f1): l(l1), f(f1) &#123;&#125;\n&#125;;\n_ t[maxn &lt;&lt; 1];\nint vis[maxn &lt;&lt; 1];\nint fa[maxn][maxm];\nint n, la, tot, siz;\nstruct &#123; int l, r, u; &#125; t1[maxk];\nint tab[maxn &lt;&lt; 1], cnt[maxn &lt;&lt; 1];\nvoid Init(void) &#123;\n    la = tot = 1;\n    t[1] = _(0, 0);\n    return;\n&#125;\nvoid ext(int c) &#123;\n    int p = la, np = ++tot;\n    la = tot;\n    t[np] = _(t[p].l + 1, 0);\n    while (p &amp;&amp; !t[p].ne[c])\n        t[p].ne[c] = np, p = t[p].f;\n    if (!p)\n        t[np].f = 1;\n    else &#123;\n        int q = t[p].ne[c];\n        if (t[q].l == t[p].l + 1)\n            t[np].f = q;\n        else &#123;\n            int nq = ++tot;\n            t[nq] = _(t[p].l + 1, t[q].f);\n            std::copy(t[q].ne, t[q].ne + 26, t[nq].ne);\n            while (p &amp;&amp; t[p].ne[c] == q)\n                t[p].ne[c] = nq, p = t[p].f;\n            t[q].f = nq;\n            t[np].f = nq;\n        &#125;\n    &#125;\n    return;\n&#125;\nint now = 0;\nvoid ins(int &amp;p, int l, int r, int v) &#123;\n    if (!p)\n        p = ++now;\n    ++t1[p].u;\n    if (l == r)\n        return;\n    int mid = (l + r) &gt;&gt; 1;\n    if (v &lt;= mid)\n        ins(t1[p].l, l, mid, v);\n    else\n        ins(t1[p].r, mid + 1, r, v);\n    return;\n&#125;\nint ask(int p, int l, int r, int ql, int qr) &#123;\n    if (ql &lt;= l &amp;&amp; r &lt;= qr)\n        return t1[p].u;\n    int mid = (l + r) &gt;&gt; 1, res = 0;\n    if (ql &lt;= mid)\n        res = ask(t1[p].l, l, mid, ql, qr);\n    if (qr &gt; mid)\n        res += ask(t1[p].r, mid + 1, r, ql, qr);\n    return res;\n&#125;\nint merge(int p, int q, int l, int r) &#123;\n    if (!p || !q)\n        return p + q;\n    int np = ++now, mid = (l + r) &gt;&gt; 1;\n    t1[np].u = t1[p].u + t1[q].u;\n    if (l == r) return np;\n    t1[np].l = merge(t1[p].l, t1[q].l, l, mid);\n    t1[np].r = merge(t1[p].r, t1[q].r, mid + 1, r);\n    return np;\n&#125;\nint pos[maxn], rt[maxn &lt;&lt; 1];\nbool check(int p, int ch, int l, int r) &#123;\n    return ask(rt[t[p].ne[ch]], 0, n - 1, l, r) &gt; 0;\n&#125;\nbool fun(std::string &amp;res, std::string now, std::string &amp;t, int x, int p, int l, int r) &#123;\n    // std::cout &lt;&lt; &quot;x = &quot; &lt;&lt; x &lt;&lt; &quot;, now = \\&quot;&quot; &lt;&lt; now &lt;&lt; &quot;\\&quot;;\\n&quot;;\n    if (x != (int)t.length() &amp;&amp; check(p, t[x] - &#39;a&#39;, l + x, r) &amp;&amp; fun(res, now + t[x], t, x + 1, ::t[p].ne[t[x] - &#39;a&#39;], l, r))\n        return 1;\n    for (int i = (x == (int)t.length()) ? 0 : t[x] - &#39;a&#39; + 1; i &lt; 26; ++i) &#123;\n        if (check(p, i, l + x, r)) &#123;\n            now += i + &#39;a&#39;;\n            res = now;\n            return 1;\n        &#125;\n    &#125;\n    return 0;\n&#125;\nstd::string solve(std::string &amp;t, int l, int r) &#123;\n    std::string res;\n    return fun(res, &quot;&quot;, t, 0, 1, l, r) ? res : &quot;-1&quot;;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n#endif\n    int q;\n    std::string s;\n    std::cin &gt;&gt; s &gt;&gt; q;\n    n = (int)s.length();\n    Init();\n    for (int i = 0; i &lt; n; ++i) &#123;\n        ext(s[i] - &#39;a&#39;);\n        pos[i] = la;\n        ins(rt[la], 0, n - 1, i);\n    &#125;\n    siz = log(tot) / log(2.0);\n    for (int i = 1; i &lt;= tot; ++i)\n        ++cnt[t[i].l];\n    std::partial_sum(cnt + 1, cnt + tot + 1, cnt + 1);\n    for (int i = 1; i &lt;= tot; ++i)\n        tab[cnt[t[i].l]--] = i;\n    for (int i = 1; i &lt;= tot; ++i) &#123;\n        int u = tab[i];\n        fa[u][0] = t[u].f;\n        for (int j = 1; j &lt;= siz; ++j)\n            fa[u][j] = fa[fa[u][j - 1]][j - 1];\n    &#125;\n    for (int i = tot; i; --i) &#123;\n        int u = tab[i];\n        if (t[u].f)\n            rt[t[u].f] = merge(rt[t[u].f], rt[u], 0, n - 1);\n    &#125;\n    while (q--) &#123;\n        int l, r;\n        std::string t;\n        std::cin &gt;&gt; l &gt;&gt; r &gt;&gt; t;\n        std::cout &lt;&lt; solve(t, l - 1, r - 1) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"a.-六出祁山\">A. 六出祁山</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/5170/problem/1\" class=\"uri\">http://222.180.160.110:61235/contest/5170/problem/1</a></p>\n<p>是能用贪心拿 60pts 的 DP 题 /tuu</p>\n<p>需要先把暴力的式子写出来。设 <span class=\"math inline\">\\(f_{i, j}\\)</span> 为将 <span class=\"math inline\">\\(i\\)</span> 山修改高度为 <span class=\"math inline\">\\(j\\)</span> 的代价，则：</p>\n<p><span class=\"math display\">\\[\nf_{i, j} = \\min\\limits_{k\\in [j-d, j+d]}\\left\\{f_{i-1, k}\\right\\} + |h_i - j|\n\\]</span></p>\n<p>注意到可以单调队列优化。但是这样做复杂度还是 <span class=\"math inline\">\\(O(nV)\\)</span> 的，根本原因在于第二维这个 <span class=\"math inline\">\\(V\\)</span> 的状态数太多了。</p>\n<p>根据直觉，最后 <span class=\"math inline\">\\(j\\)</span> 的值应为 <span class=\"math inline\">\\(k+d\\)</span> 或 <span class=\"math inline\">\\(k-d\\)</span> 或 <span class=\"math inline\">\\(a_i\\)</span>。也就是说，我们可以认为，合法的状态数为所有的 <span class=\"math inline\">\\(a_i+x\\times d, x\\in[-n, n]\\)</span>。</p>\n<details>\n<p><summary>正确性证明……</summary></p>\n<p>考虑全部更改完后的结束状态，即最后的最优状态。</p>\n<p>考虑所有山中最矮的山 <span class=\"math inline\">\\(i\\)</span>，此山的高度要么为 <span class=\"math inline\">\\(h_i\\)</span>，要么为前一座山的高度 <span class=\"math inline\">\\(-d\\)</span>，要么为后一座山的高度 <span class=\"math inline\">\\(-d\\)</span>。</p>\n<p>考虑第二矮的山，以此类推即可。</p>\n</details>\n<p>将第二维的状态集大小减少为 <span class=\"math inline\">\\(O(n^2)\\)</span>，总时间复杂度为 <span class=\"math inline\">\\(O(n^3)\\)</span>。</p>\n<details>\n<p>需注意到因为 <span class=\"math inline\">\\(a_i+x\\times d\\)</span> 中的 <span class=\"math inline\">\\(x\\)</span> 范围为 <span class=\"math inline\">\\([-n, n]\\)</span> 共 <span class=\"math inline\">\\(2\\times n\\)</span>，所以 DP 数组第二维大小一定要开 <span class=\"math inline\">\\(2\\times n^2\\)</span> 呀！！！</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nusing ll = long long;\nconst int maxn = 305;\nconst int maxm = 18e4 + 5;\nconst ll inf = 0x3f3f3f3f3f3f3f3f;\nll d;\nint n;\nll h[maxn];\nll f[maxn][maxm];\nint main() &#123;\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    memset(f, 0x3f, sizeof (f));\n    std::cin &gt;&gt; n &gt;&gt; d;\n    std::vector&lt;ll&gt; st;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; h[i];\n        for (ll j = -n; j &lt;= n; ++j)\n            st.push_back(h[i] + j * d);\n    &#125;\n    std::sort(st.begin(), st.end());\n    st.erase(std::unique(st.begin(), st.end()), st.end());\n    auto abs = [&amp;](ll x) -&gt; ll &#123; return x &gt;= 0 ? x : -x; &#125;;\n    f[1][lower_bound(st.begin(), st.end(), h[1]) - st.begin()] = 0;\n    for (int i = 2; i &lt;= n; ++i) &#123;\n        int h(1), t(0), p(-1);\n        static int q[maxm];\n        for (int j = 0; j &lt; (int)st.size(); ++j) &#123;\n            while (p &lt; (int)st.size() &amp;&amp; st[p + 1] &lt;= st[j] + d) &#123;\n                ++p;\n                while (h &lt;= t &amp;&amp; f[i - 1][p] &lt;= f[i - 1][q[t]])\n                    --t;\n                q[++t] = p;\n            &#125;\n            while (h &lt;= t &amp;&amp; st[q[h]] &lt; st[j] - d)\n                ++h;\n            if (h &lt;= t)\n                f[i][j] = std::min(inf, f[i - 1][q[h]] + abs(st[j] - ::h[i]));\n        &#125;\n    &#125;\n    ll res = f[n][std::lower_bound(st.begin(), st.end(), h[n]) - st.begin()];\n    std::cout &lt;&lt; (res == inf ? -1 : res) &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"b.-水淹七军\">B. 水淹七军</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/5170/problem/2\" class=\"uri\">http://222.180.160.110:61235/contest/5170/problem/2</a></p>\n<p>容易发现最后连出来一定是没有环的。所以一定是一个 DAG。</p>\n<p>我们知道状态压缩是会遍历到每一种情况的，所以我们可以假设当前的 DAG 就是该状态下的最优。</p>\n<p>至于这个「最优」如何定义就要交给我们了。我们不妨强制认为这个 DAG 是按层序遍历得到的，也就是说连续遍历到的点属于同一层（这里的层是指某点到任意源点的最长路长度）。</p>\n<p>显然只有一组相互之间没有任何连边的点才能组成同一层。不妨枚举点集然后暴力转移，转移时记录路径即可。</p>\n<details>\n<p>注意到在写这玩意儿的时候我还不会 <a href=\"/2024/05/17/20240517/\">状压枚举子集</a>，所以枚举子集的部分可能打得比较抽象。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 25;\nconst int inf = 0x3f3f3f3f;\nconst int maxm = (1 &lt;&lt; 16) + 5;\nint n, res;\nint tag[maxn][maxn];\nint f[maxn], g[maxn];\nint solve(std::vector&lt;int&gt;&amp; a) &#123;\n    static int g[maxn];\n    static int f[maxm], p[maxm];\n    int n(a.size()), siz(1 &lt;&lt; n);\n    std::fill(g, g + n, 0);\n    std::fill(p, p + siz + 1, 0);\n    std::fill(f, f + siz + 1, inf);\n    std::vector&lt;int&gt; st;\n    for (int i = 0; i &lt; n; ++i) &#123;\n        for (int j = 0; j &lt; n; ++j) &#123;\n            if (::g[a[i]] &amp; (1 &lt;&lt; a[j]))\n                g[i] |= 1 &lt;&lt; j;\n        &#125;\n    &#125;\n    for (int i = 1; i &lt; siz; ++i) &#123;\n        int now = 0;\n        for (int j = 0; j &lt; n; ++j) &#123;\n            if (i &amp; (1 &lt;&lt; j))\n                now |= g[j];\n        &#125;\n        if (!(now &amp; i))\n            st.push_back(i), f[i] = 0, p[i] = i;\n        for (auto j : st) &#123;\n            if (!(i &amp; j)) &#123;\n                if (f[i | j] &gt; f[i] + 1)\n                    f[i | j] = f[i] + 1, p[i | j] = j;\n            &#125;\n        &#125;\n    &#125;\n    int now = siz - 1;\n    while (now) &#123;\n        int fa = now ^ p[now];\n        for (int i = 0; i &lt; n; ++i)\n            if (p[now] &amp; (1 &lt;&lt; i))\n                for (int j = 0; j &lt; n; ++j)\n                    if ((fa &amp; (1 &lt;&lt; j)) &amp;&amp; tag[a[j]][a[i]] == 2)\n                        tag[a[j]][a[i]] = 1, tag[a[i]][a[j]] = -1;\n        now = fa;\n    &#125;\n    return f[siz - 1];\n&#125;\nint find(int x) &#123;\n    return x == f[x] ? x : f[x] = find(f[x]);\n&#125;\nint main() &#123;\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    int m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; edge;\n    for (int i = 0; i &lt; n; ++i)\n        f[i] = i;\n    while (m--) &#123;\n        int x, y;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        edge.emplace_back(--x, --y);\n        f[find(x)] = find(y);\n        g[x] |= 1 &lt;&lt; y;\n        g[y] |= 1 &lt;&lt; x;\n        tag[x][y] = tag[y][x] = 2;\n    &#125;\n    std::vector&lt;int&gt; ver[maxn];\n    for (int i = 0; i &lt; n; ++i) &#123;\n        ver[find(i)].push_back(i);\n    &#125;\n    for (int i = 0; i &lt; n; ++i) &#123;\n        if (f[i] == i)\n            res = std::max(res, solve(ver[i]));\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    for (auto i : edge) &#123;\n        if (tag[i.first][i.second] == 1)\n            std::cout &lt;&lt; i.first + 1 &lt;&lt; &#39; &#39; &lt;&lt; i.second + 1 &lt;&lt; &#39;\\n&#39;;\n        else std::cout &lt;&lt; i.second + 1 &lt;&lt; &#39; &#39; &lt;&lt; i.first + 1 &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"c.-煮酒论英雄\">C. 煮酒论英雄</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/5170/problem/3\" class=\"uri\">http://222.180.160.110:61235/contest/5170/problem/3</a></p>\n<p>注意到如果存在串被其他串包含那么直接将其毙掉就可以了。</p>\n<p>对于相互不完全包含的串，我们令 <span class=\"math inline\">\\(mx_{i, j, 0/1, 0/1}\\)</span> 表示将正序 / 逆序的 <span class=\"math inline\">\\(i\\)</span> 串拼到正序 / 逆序的 <span class=\"math inline\">\\(j\\)</span> 串之前，两者共用相接公共部分的串长。这个可以用字符串哈希暴力求。</p>\n<p>用状压枚举拼接顺序，求得最小总串长即可。</p>\n<p>注意如果去掉被包含串后 <span class=\"math inline\">\\(n=1\\)</span> 时需直接输出串的 border；以及答案需和 <span class=\"math inline\">\\(2\\)</span> 取 <span class=\"math inline\">\\(\\max\\)</span>。</p>\n<p>实现起来又臭又长，但实际上思路确实非常简单。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nusing ll = long long;\nconst int p = 131;\nconst int maxn = 25;\nconst int lim = 2e4;\nconst int maxl = 2e4 + 5;\nconst int mod = 998244353;\nconst int inf = 0x3f3f3f3f;\nconst int maxm = (1 &lt;&lt; 16) + 5;\nint n;\nstd::vector&lt;std::string&gt; s;\nstd::vector&lt;std::vector&lt;ll&gt; &gt; h[2];\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n#endif\n    std::cin &gt;&gt; n;\n    s.resize(n);\n    h[0].resize(n);\n    h[1].resize(n);\n    static ll base[maxl];\n    static bool del[maxn];\n    base[0] = 1;\n    for (int i = 1; i &lt;= lim; ++i)\n        base[i] = base[i - 1] * p % mod;\n\n    for (int i = 0; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; s[i];\n        h[0][i].resize((int)s[i].length());\n        h[1][i].resize((int)s[i].length());\n        ll x = 0;\n        for (int j = 0; j &lt; (int)s[i].length(); ++j, (x *= p) %= mod)\n            h[0][i][j] = ((x += s[i][j]) %= mod);\n        std::reverse(s[i].begin(), s[i].end());\n        x = 0;\n        for (int j = 0; j &lt; (int)s[i].length(); ++j, (x *= p) %= mod)\n            h[1][i][j] = ((x += s[i][j]) %= mod);\n        std::reverse(s[i].begin(), s[i].end());\n    &#125;\n\n    std::vector&lt;int&gt; tab;\n    auto gethash = [&amp;](int i, int l, int r, bool t) -&gt; ll &#123;\n        if (l &gt; r) return 0;\n        ll res = (h[t][i][r] - (l ? h[t][i][l - 1] : 0) * base[r - l + 1] % mod);\n        return (res % mod + mod) % mod;\n    &#125;;\n    // ll now = 0;\n    // for (int i = 0; i &lt;= 4; ++i)\n    //     now = (now * p + s[1][i]) % mod;\n    // printf(&quot;now = %lld\\n&quot;, now);\n    // now = 0;\n    // for (int i = 3; i &lt;= 7; ++i)\n    //     now = (now * p + s[0][i]) % mod;\n    // printf(&quot;now = %lld\\n&quot;, now);\n    // printf(&quot;# %lld\\n&quot;, h[0][0].back());\n    for (int i = 0; i &lt; n; ++i) &#123;\n        tab.push_back(i);\n        for (int j = 0; j &lt; n; ++j)\n            if (!del[j] &amp;&amp; i != j)\n                for (int k = 0; k &lt;= ((int)s[j].length()) - ((int)s[i].length()); ++k) &#123;\n                    // printf(&quot;i = %d, j = %d, k = %d, %lld / %lld\\n&quot;, i, j, k,\n                    //         gethash(i, 0, ((int)s[i].length()) - 1, 0), gethash(j, k, k + ((int)s[i].length()) - 1, 0));\n                    if (h[0][i].back() == gethash(j, k, k + ((int)s[i].length()) - 1, 0)) &#123;\n                        tab.pop_back();\n                        del[i] = 1;\n                        goto outo;\n                    &#125;\n                &#125;\n        outo: ;\n    &#125;\n    n = (int)tab.size();\n    if (n == 1) &#123;\n        int border;\n        for (border = ((int)s[tab[0]].length()) - 1; ~border; --border) &#123;\n            if (gethash(tab[0], 0, border - 1, 0) == gethash(tab[0], ((int)s[tab[0]].length()) - border, ((int)s[tab[0]].length()) - 1, 0))\n                break;\n        &#125;\n        std::cout &lt;&lt; std::max(2, ((int)s[tab[0]].length()) - border) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    else &#123;\n        static int mx[maxn][maxn][2][2];\n        for (int i = 0; i &lt; n; ++i)\n            for (int j = 0; j &lt; n; ++j)\n                for (int a = 0; a &lt; 2; ++a)\n                    for (int b = 0; b &lt; 2; ++b)\n                        for (int k = std::min((int)s[tab[i]].length(), (int)s[tab[j]].length()); ~k; --k) &#123;\n                            if (gethash(tab[i], ((int)s[tab[i]].length()) - k, ((int)s[tab[i]].length()) - 1, a) ==\n                                                                                            gethash(tab[j], 0, k - 1, b)) &#123;\n                                mx[i][j][a][b] = (int)s[tab[j]].length() - k;\n                                // printf(&quot;%d(%d) + %d(%d) = %d, k = %d\\n&quot;, i, a, j, b, mx[i][j][a][b], k);\n                                break;\n                            &#125;\n                        &#125;\n        static int f[maxm][maxn][2];\n        memset(f, 0x3f, sizeof (f));\n\n        int siz = 1 &lt;&lt; n, res = inf;\n        f[1][0][0] = (int)s[tab[0]].length();\n        for (int i = 1; i &lt; siz; ++i)\n            for (int j = 0; j &lt; n; ++j)\n                if (i &amp; (1 &lt;&lt; j))\n                    for (int a = 0; a &lt; 2; ++a) &#123;\n                        // printf(&quot;f[%d][%d][%d] = %d\\n&quot;, i, j, a, f[i][j][a]);\n                        for (int k = 0; k &lt; n; ++k)\n                            if (!(i &amp; (1 &lt;&lt; k)))\n                                for (int b = 0; b &lt; 2; ++b)\n                                    f[i | (1 &lt;&lt; k)][k][b] = std::min(f[i | (1 &lt;&lt; k)][k][b], f[i][j][a] + mx[j][k][a][b]);\n                        if (i == siz - 1)\n                            res = std::min(res, f[i][j][a] - (int)s[tab[0]].length() + mx[j][0][a][0]);\n                    &#125;\n        \n        std::cout &lt;&lt; std::max(2, res) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"a.-捏斑马\">A. 捏斑马</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/5175/problem/1\" class=\"uri\">http://222.180.160.110:61235/contest/5175/problem/1</a></p>\n<p>我甚至不会（）</p>\n<p>翻转 + 拼接本质上就是首尾相接。我们把字符串整个拼到自己后边儿，然后任取一段长度为 <span class=\"math inline\">\\(n\\)</span> 的串就可以得到一个倒过来的操作后的字符串。</p>\n<p>注意到可以操作很多次。但是既然我们操作后的串也可以在这个拼接后的串中找到了，那么其实多次操作后的也行。</p>\n<p>所以呢我们在拼接后的串种枚举每一个长度为 <span class=\"math inline\">\\(n\\)</span> 的串计算答案即可。</p>\n<p>具体怎么算呢？注意到只看开头，也就是在新串中只看离我们当前枚举的右端点最近的那一段，所以我们打一个双指针，看这一段是否在右移后仍然合法，如果非法就把答案区间左端点更新为右端点自己。以及注意到左右端点的距离不能超过 <span class=\"math inline\">\\(n\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint res;\nstd::string s;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n#endif\n    std::cin &gt;&gt; s;\n    int l = 0, r = -1, n = (int)s.length();\n    char la = 0;\n    s += s;\n    while (++r &lt; (int)s.length()) &#123;\n        if (s[r] == la)\n            l = r;\n        while (r - l + 1 &gt; n) ++l;\n        la = s[r];\n        res = std::max(res, r - l + 1);\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"d.-链状闪电\">D. 链状闪电</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/5175/problem/4\" class=\"uri\">http://222.180.160.110:61235/contest/5175/problem/4</a></p>\n<p>莫名其妙且又臭又长的根号做法。</p>\n<p>容易发现一个怪被杀掉了序列就会裂开成两段连续子序列，以及最先被杀掉的怪物一定血量最少。在裂开来的两段连续子序列中也满足此规律，以此类推。</p>\n<p>考虑对序列建立笛卡尔树。令树根为 <span class=\"math inline\">\\(rt\\)</span>，当前攻击力为 <span class=\"math inline\">\\(k\\)</span>，记 <span class=\"math inline\">\\(t_{x, k}=\\left\\lceil \\dfrac {h_x}k \\right\\rceil\\)</span>，即不考虑其他条件时击倒 <span class=\"math inline\">\\(x\\)</span> 所需次数。</p>\n<p>那么对于 <span class=\"math inline\">\\(rt\\)</span> 的左、右儿子 <span class=\"math inline\">\\(l,r\\)</span>，单考虑这三个怪物所需的总击倒次数，容易发现为 <span class=\"math inline\">\\(t_{rt,k}+(t_{l,k}-t_{rt,k})+(t_{r,k}-t_{rt,k})\\)</span>。</p>\n<p>对于 <span class=\"math inline\">\\(l\\)</span> 引导的子树，此时的实际已攻击次数为 <span class=\"math inline\">\\(t_{l,k}\\)</span>；所以对于 <span class=\"math inline\">\\(l\\)</span> 的左右儿子 <span class=\"math inline\">\\(l&#39;,r&#39;\\)</span>，击倒这两个怪物的所需次数为 <span class=\"math inline\">\\((t_{l&#39;,k} - t_{l,k})+(t_{r&#39;,k}-t_{l,k})\\)</span>。<span class=\"math inline\">\\(r\\)</span> 引导的子树同理。</p>\n<p>所以我们就可以知道，如果存在树边 <span class=\"math inline\">\\(u\\to v\\)</span>，那么击倒 <span class=\"math inline\">\\(v\\)</span> 的所需次数为 <span class=\"math inline\">\\(t_{v,k}-t_{u,k}\\)</span>；特别地，击倒 <span class=\"math inline\">\\(rt\\)</span> 的所需次数为 <span class=\"math inline\">\\(t_{rt,k}\\)</span>。</p>\n<p>那么我们就可以通过一次 <span class=\"math inline\">\\(O(n)\\)</span> 的树上 DFS 对于一个 <span class=\"math inline\">\\(k\\)</span> 找到答案了。</p>\n<p>那么对于 <span class=\"math inline\">\\(2\\times 10^4\\)</span> 范围内的所有 <span class=\"math inline\">\\(k\\)</span>，应该怎么办呢？这个时候就要利用 <span class=\"math inline\">\\(t\\)</span> 的性质进行根号分治了。</p>\n<ul>\n<li><p>对于 <span class=\"math inline\">\\(k\\le \\sqrt {2\\times 10^4}\\)</span>，我们大可以直接做这么多次 DFS 得到答案；</p></li>\n<li><p>对于 <span class=\"math inline\">\\(k&gt;\\sqrt {2\\times 10^4}\\)</span>：</p>\n<p>我们容易发现最终的结果是若干个 <span class=\"math inline\">\\(t\\)</span> 的值相加减得到的，而每个 <span class=\"math inline\">\\(t\\)</span> 的权值 <span class=\"math inline\">\\(cnt\\)</span> 取决于其在笛卡尔树上的儿子个数，有多少就在 <span class=\"math inline\">\\(1\\)</span> 的基础上减去多少。</p>\n<p>由于 <span class=\"math inline\">\\(t\\)</span> 实在过于特殊，考虑整除分块 / 数论分块。对于每个 <span class=\"math inline\">\\(x\\)</span>，对于任意 <span class=\"math inline\">\\(k&#39;\\in (\\sqrt {2\\times 10^4}, 2\\times 10^4]\\)</span>，可能的 <span class=\"math inline\">\\(t\\)</span> 值只有 <span class=\"math inline\">\\(\\sqrt {2\\times 10^4 }\\)</span> 种。计算出对于每个 <span class=\"math inline\">\\(t&#39;\\)</span>，满足 <span class=\"math inline\">\\(\\left\\lceil \\dfrac {h_x}{k&#39;} \\right\\rceil=t&#39;\\)</span> 的 <span class=\"math inline\">\\(k&#39;\\)</span> 范围，对该范围 <span class=\"math inline\">\\(k&#39;\\)</span> 的答案区间加上 <span class=\"math inline\">\\(t&#39;\\times cnt\\)</span> 即可，可以使用差分。</p>\n<p>至此，就可以在一次 DFS 内解决这种情况下的问题。</p></li>\n</ul>\n<p>总时间复杂度为 <span class=\"math inline\">\\(O(n\\sqrt {2\\times 10^4})\\)</span>。</p>\n<details>\n<p>值得注意的是，我在做这道题的时候并没有意识到自己用到了笛卡尔树，</p>\n<p>所以代码中笛卡尔树的建树部分可能长得特别抽象（</p>\n<p>这里是使用了下标上的 ST 表带 log 地求解了左右儿子。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxm = 35;\nconst int maxn = 1e5 + 5;\nusing ll = long long;\nll res;\nint n, k, l;\nint g[maxn][2];\nint f[maxn][maxm];\nint a[maxn], t[maxn];\nll dif[maxn], cnt[maxn];\nint ask(int l, int r) &#123;\n    if (l &gt; r) return 0;\n    int k = log(r - l + 1) / log(2.0);\n    return (a[f[l][k]] &lt; a[f[r - (1 &lt;&lt; k) + 1][k]]) ? f[l][k] : f[r - (1 &lt;&lt; k) + 1][k];\n&#125;\nvoid bld(int rt, int l, int r) &#123;\n    if (rt != l) &#123;\n        g[rt][0] = ask(l, rt - 1);\n        bld(g[rt][0], l, rt - 1);\n    &#125;\n    if (rt != r) &#123;\n        g[rt][1] = ask(rt + 1, r);\n        bld(g[rt][1], rt + 1, r);\n    &#125;\n    return;\n&#125;\n// k &lt;= sqrt(lim)\nvoid DFS(int x, int k, int fa) &#123;\n    t[x] = (a[x] + k - 1) / k;\n    res += t[x] - t[fa];\n    for (int i = 0; i &lt; 2; ++i) &#123;\n        if (g[x][i])\n            DFS(g[x][i], k, x);\n    &#125;\n    return;\n&#125;\n// k &gt; sqrt(lim)\nvoid DFS(int x, int fa) &#123;\n    ++cnt[x];\n    --cnt[fa];\n    for (int i = 0; i &lt; 2; ++i) &#123;\n        if (g[x][i])\n            DFS(g[x][i], x);\n    &#125;\n    int l = k + 1, r;\n    // 注意这里 i 的范围判定，如果直接写成 i * i &lt;= k 会少计算一些情况\n    for (int i = 1; (i - 1) * (i - 1) &lt; k; ++i) &#123;\n        r = l - 1;\n        l = (a[x] + i - 1) / i;\n        // fprintf(stderr, &quot;%d: [%d, %d] += %d * %d\\n&quot;, a[x], l, r, cnt[x], i);\n        dif[l] += i * cnt[x], dif[r + 1] -= i * cnt[x];\n    &#125;\n    return;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n#endif\n    std::cin &gt;&gt; n;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        f[i][0] = i;\n        k = std::max(k, a[i]);\n    &#125;\n    for (int j = 1; (1 &lt;&lt; j) &lt;= n; ++j)\n        for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i)\n            f[i][j] = (a[f[i][j - 1]] &lt; a[f[i + (1 &lt;&lt; (j - 1))][j - 1]]) ? f[i][j - 1] : f[i + (1 &lt;&lt; (j - 1))][j - 1];\n    int rt = ask(1, n);\n    bld(rt, 1, n);\n    for (int i = 1; i * i &lt;= k; ++i) &#123;\n        res = 0;\n        DFS(rt, i, 0);\n        std::cout &lt;&lt; res &lt;&lt; &#39; &#39;;\n        l = i + 1;\n    &#125;\n    // fputs(&quot;\\n&quot;, stderr);\n    DFS(rt, 0);\n    std::partial_sum(dif + 1, dif + k + 1, dif + 1);\n    for (int i = l; i &lt;= k; ++i)\n        std::cout &lt;&lt; dif[i] &lt;&lt; &#39; &#39;;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"f.-弹飞绵羊\">F. 弹飞绵羊</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/5175/problem/6\" class=\"uri\">http://222.180.160.110:61235/contest/5175/problem/6</a></p>\n<p>很棒可持久化分块，使我 lxl 旋转。</p>\n<p>笑话：赛后 5s 才交上去。然后 A 了。</p>\n<p>我们猜大家都会普通的弹飞绵羊这道题。就是块间暴力跳嘛。</p>\n<p>这里给一个我自己整的简单实现方法。</p>\n<p>我们把分出来的块视作若干个无关联的散块并纳入块集合；对于每一个版本，用一个大小为 <span class=\"math inline\">\\(\\sqrt n\\)</span> 的 <span class=\"math inline\">\\(id\\)</span> 数组记录每一位置的块在块集合中对应的位置。</p>\n<p>然后该怎么搞怎么搞即可。</p>\n<p>P.S. zwb 坚定不移信仰 lxl 神教于是决定用可持久化平衡树实现可持久化分块，结果当然是因为多了个 <span class=\"math inline\">\\(\\log\\)</span> 被卡飞了，最后气急败坏慌不择路恼羞成怒抄起了我的代码。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxk = 320;\nconst int maxn = 2e5 + 5;\nclass devicer &#123;\npublic:\n    int l, r;\n    std::vector&lt;int&gt; ne, u, a;\n    int &amp;nex(int x);\n    int &amp;val(int x);\n&#125;;\nint id[maxn][maxk];\nstd::vector&lt;devicer&gt; b;\nint n, q, ty, siz, k, la;\nint a[maxn], tab[maxn], blk[maxn];\nvoid upd(int x, int a, devicer &amp;p) &#123;\n    if (x + a &gt; n)\n        p.nex(x) = -1, p.val(x) = 1;\n    else if (x + a &gt; p.r)\n        p.nex(x) = x + a, p.val(x) = 1;\n    else\n        p.nex(x) = p.nex(x + a), p.val(x) = p.val(x + a) + 1;\n    // printf(&quot;x = %d, a = %d, r = %d, upd ne[%d] to %d\\n&quot;, x, a, p.r, x, p.nex(x));\n    return;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n#endif\n    std::cin &gt;&gt; n &gt;&gt; q &gt;&gt; ty;\n    siz = sqrt(n);\n    k = (n + siz - 1) / siz;\n    b.resize(k);\n    int la = 0, now = k - 1;\n    for (auto &amp;i : b)\n        i.l = la + 1, la = i.r = i.l + siz - 1;\n    b.back().r = n;\n    for (int i = 0; i &lt; k; ++i) &#123;\n        id[0][i] = i;\n        b[i].a.resize(b[i].r - b[i].l + 1);\n        b[i].u.resize(b[i].r - b[i].l + 1);\n        b[i].ne.resize(b[i].r - b[i].l + 1);\n        for (int j = b[i].l; j &lt;= b[i].r; ++j)\n            tab[j] = j - b[i].l, blk[j] = i;\n    &#125;\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; b[blk[i]].a[tab[i]];\n    for (int i = n; i; --i)\n        upd(i, b[blk[i]].a[tab[i]], b[blk[i]]);\n    int ver = 0;\n    while (q--) &#123;\n        int op, pr, x;\n        static int res = 0;\n        std::cin &gt;&gt; op &gt;&gt; pr &gt;&gt; x;\n        if (!ty)\n            res = 0;\n        x ^= res;\n        if (op == 1) &#123;\n            std::copy(id[pr], id[pr] + k, id[++ver]);\n            b.push_back(b[id[ver][blk[x]]]);\n            id[ver][blk[x]] = ++now;\n            std::cin &gt;&gt; b.back().a[tab[x]];\n            b.back().a[tab[x]] ^= res;\n            for (int i = x; i &gt;= b.back().l; --i)\n                upd(i, b.back().a[tab[i]], b.back());\n        &#125;\n        else &#123;\n            int p = x;\n            res = 0;\n            while (~p) &#123;\n                // printf(&quot;p = %d\\n&quot;, p);\n                res += b[id[pr][blk[p]]].u[tab[p]];\n                p = b[id[pr][blk[p]]].ne[tab[p]];\n            &#125;\n            std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n        &#125;\n    &#125;\n    return 0;\n&#125;\nint&amp; devicer::nex(int x) &#123;\n    return ne[tab[x]];\n&#125;\nint&amp; devicer::val(int x) &#123;\n    return u[tab[x]];\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "DP",
                "SAM",
                "状压",
                "分块",
                "可持久化",
                "笛卡尔树"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20240206/",
            "url": "https://xsc062.netlify.app/20240206/",
            "title": "曼哈顿最小距离生成树",
            "date_published": "2024-02-06T01:57:49.000Z",
            "content_html": "<p>如题。</p>\n<span id=\"more\"></span>\n<hr />\n<h3 id=\"e.-another-minimum-spanning-tree\">E. Another Minimum Spanning Tree</h3>\n<p>http://222.180.160.110:61235/contest/4940/problem/5</p>\n<p>曼哈顿最小距离生成树。给定 <span class=\"math inline\">\\(n\\)</span> 个已知坐标的点，两两之间可连权值为曼哈顿距离的边，需求最小生成树。</p>\n<p>有一引理：以任意一点为顶点的大小为 <span class=\"math inline\">\\(\\dfrac \\pi8\\)</span> 、且一条边与坐标轴重合的角覆盖的范围中，与该点曼哈顿距离最小的点才有可能与此点连边。</p>\n<p>概括说来便是以该点为原点建系，沿坐标轴米字划分。</p>\n<details>\n<p><summary>浅证</summary></p>\n<p>首先需认识到，若 <span class=\"math inline\">\\(w(x,y)&lt;w(x,z)\\)</span> 且 <span class=\"math inline\">\\(w(y,z)&lt;w(x,z)\\)</span>，则边 <span class=\"math inline\">\\(E(x,z)\\)</span> 不在最小生成树中。</p>\n<figure>\n<img src=\"1.png\" alt=\"示意图\" /><figcaption>示意图</figcaption>\n</figure>\n<p>考虑有如上 <span class=\"math inline\">\\(A,B,C\\)</span> 三点。不妨设 <span class=\"math inline\">\\(d(A,B)\\le d(A,C)\\)</span>。其中 <span class=\"math inline\">\\(d\\)</span> 为曼哈顿距离。</p>\n<p>由图易知 <span class=\"math inline\">\\(x_B,y_B,x_C,y_C&gt;0\\)</span> 且 <span class=\"math inline\">\\(y_B-x_B,y_C-x_C&gt;0\\)</span>。讨论 <span class=\"math inline\">\\(B\\)</span> 与 <span class=\"math inline\">\\(C\\)</span> 位置关系。下文的 <span class=\"math inline\">\\(x,y\\)</span> 均相对 <span class=\"math inline\">\\(A\\)</span> 而言。</p>\n<ul>\n<li><p><span class=\"math inline\">\\(x_B&gt;x_C\\)</span> 且 <span class=\"math inline\">\\(y_B&gt;y_c\\)</span>：</p>\n此时 <span class=\"math inline\">\\(d(A,B)&gt;d(B,C)\\)</span>，与题设不符，舍去。</li>\n<li><p><span class=\"math inline\">\\(x_B&gt;x_C\\)</span> 且 <span class=\"math inline\">\\(y_B&lt;y_C\\)</span>：</p>\n<p>此时 <span class=\"math inline\">\\(d(A,B)=x_B+y_B,d(B,C)=x_B-x_C+y_C-y_B,d(A,C)=x_C+y_C\\)</span>。由作差法得 <span class=\"math inline\">\\(d(B,C)-d(A,C)=x_B-y_B-2\\times x_C\\)</span>，由 <span class=\"math inline\">\\(x_B-y_B&lt;0,x_C&gt;0\\)</span>，<span class=\"math inline\">\\(d(B,C)&lt;d(A,C)\\)</span>。</p>\n由于 <span class=\"math inline\">\\(d(A,B),d(B,C)&lt;d(A,C)\\)</span>，故 <span class=\"math inline\">\\(A\\)</span> 一定不与 <span class=\"math inline\">\\(C\\)</span> 连边。</li>\n<li><p><span class=\"math inline\">\\(x_B&lt;x_C\\)</span> 且 <span class=\"math inline\">\\(y_B&gt;y_C\\)</span>：</p>\n与上一种情况同理。</li>\n<li><p><span class=\"math inline\">\\(x_B&lt;x_C\\)</span> 且 <span class=\"math inline\">\\(y_B&lt;y_C\\)</span>：</p>\n此时有 <span class=\"math inline\">\\(d(A,C)=d(A,B)+d(B,C)\\)</span>，则 <span class=\"math inline\">\\(A\\)</span> 一定不与 <span class=\"math inline\">\\(C\\)</span> 连边。</li>\n</ul>\n</details>\n<p>如此一来，边数便降低到了 <span class=\"math inline\">\\(O(n)\\)</span> 水平。</p>\n<p>此外，如何识别每个点周围每 <span class=\"math inline\">\\(\\dfrac \\pi8\\)</span> 的最近点便是问题所在。</p>\n<p>由于坐标可以变换，此处仅考虑顶点为 <span class=\"math inline\">\\(A\\)</span>，始边沿 <span class=\"math inline\">\\(y\\)</span> 轴正方向，终边沿 <span class=\"math inline\">\\(k=1\\)</span> 的区域。则对于区域内的点 <span class=\"math inline\">\\(B\\)</span>，易知 <span class=\"math inline\">\\(x_B\\geqslant x_A,y_B-y_A\\geqslant x_B-x_A\\)</span>。</p>\n<p>后一条规则分离变量则有 <span class=\"math inline\">\\(y_B-x_B\\geqslant y_A-x_A\\)</span>，那么问题转化为二维偏序，其中待求为最小 <span class=\"math inline\">\\(x_B+y_B\\)</span>，可以用树状数组离散解决。</p>\n<p><del>由于边是双向的，将问题在平面任意连续 <span class=\"math inline\">\\(\\dfrac \\pi 2\\)</span> 范围内进行四次坐标转化即可。</del></p>\n<p><del>其实并不一定要连续，只要该区域与其旋转一百八十度后的图形的并可以覆盖整个平面即可。这么看来是不是只能连续。</del></p>\n<p>我们会发现旋转 <span class=\"math inline\">\\(\\dfrac \\pi 8\\)</span> 这个我们在整数域上做不到啊。所以我们考虑旋转 + 翻折，最后整出来差不多这个图形：</p>\n<figure>\n<img src=\"2.png\" alt=\"示意图\" /><figcaption>示意图</figcaption>\n</figure>\n<p>然后由于我们发现这些点关于 <span class=\"math inline\">\\(A\\)</span> 的关系（是通过 <span class=\"math inline\">\\(A\\)</span> 翻折还是旋转得来的）并不中心对称啊，所以呢就要委屈一下写满八个方向了。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 1e5 + 5;\nstruct _ &#123;\n    int x, y, id;\n    bool operator&lt; (const _ &amp;q) const &#123;\n        return y - x &gt; q.y - q.x;\n    &#125;\n&#125;;\nstruct __ &#123;\n    int x, y, w;\n    __() &#123;&#125;\n    __(int x1, int y1, int w1) &#123;\n        if (y1 &lt; x1) x1 ^= y1 ^= x1 ^= y1;\n        x = x1, y = y1, w = w1;\n    &#125;\n    bool operator&lt; (const __ &amp;q) const &#123;\n        return w == q.w ? x &lt; q.x : w &lt; q.w;\n    &#125;\n&#125;;\nint n;\nint Bit[maxn]; \nstd::vector&lt;__&gt; e;\n_ a[maxn], b[maxn];\nint ls[maxn], f[maxn];\nint lowbit(int x) &#123; return x &amp; -x; &#125;\nvoid upd(int &amp;i, int j) &#123;\n    if (!i || (j &amp;&amp; b[j].x + b[j].y &lt;= b[i].x + b[i].y)) i = j;\n    return;\n&#125;\nvoid add(int x, int i) &#123;\n    for (; x &lt;= n; x += lowbit(x)) upd(Bit[x], i);\n    return;\n&#125;\nint ask(int x) &#123;\n    int res = 0;\n    for (; x; x -= lowbit(x)) upd(res, Bit[x]);\n    return res;\n&#125; \nint find(int x) &#123; return x == f[x] ? x : f[x] = find(f[x]); &#125;\nvoid merge(int x, int y) &#123; f[find(x)] = find(y); return; &#125;\nint abs(int x) &#123; return x &gt;= 0 ? x : -x; &#125;\nvoid adde(int x, int y) &#123;\n    if (!x || !y) return;\n    e.emplace_back(x, y, abs(a[x].x - a[y].x) + abs(a[x].y - a[y].y));\n    return;\n&#125;\nint main() &#123;\n    read(n);\n    while (n) &#123;\n        e.clear();\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            read(a[i].x), read(a[i].y), a[i].id = i;\n            ls[i] = a[i].x, b[i] = a[i], f[i] = i;\n        &#125;\n        memset(Bit, 0, sizeof (Bit));\n        std::sort(b + 1, b + n + 1);\n        std::sort(ls + 1, ls + n + 1);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            int x = std::lower_bound(ls + 1, ls + n + 1, b[i].x) - ls;\n            x = n + 1 - x, adde(b[i].id, b[ask(x)].id), add(x, i);\n        &#125;\n        memset(Bit, 0, sizeof (Bit));\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            b[i].x = a[i].y, b[i].y = a[i].x;\n            ls[i] = b[i].x, b[i].id = i;\n        &#125;\n        std::sort(b + 1, b + n + 1);\n        std::sort(ls + 1, ls + n + 1);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            int x = std::lower_bound(ls + 1, ls + n + 1, b[i].x) - ls;\n            assert(x &gt;= 1 &amp;&amp; x &lt;= n);\n            x = n + 1 - x, adde(b[i].id, b[ask(x)].id), add(x, i);\n        &#125;\n        memset(Bit, 0, sizeof (Bit));\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            b[i].x = -a[i].x, b[i].y = a[i].y;\n            ls[i] = b[i].x, b[i].id = i;\n        &#125;\n        std::sort(b + 1, b + n + 1);\n        std::sort(ls + 1, ls + n + 1);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            int x = std::lower_bound(ls + 1, ls + n + 1, b[i].x) - ls;\n            assert(x &gt;= 1 &amp;&amp; x &lt;= n);\n            x = n + 1 - x, adde(b[i].id, b[ask(x)].id), add(x, i);\n        &#125;\n        memset(Bit, 0, sizeof (Bit));\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            b[i].x = -a[i].y, b[i].y = a[i].x;\n            ls[i] = b[i].x, b[i].id = i;\n        &#125;\n        std::sort(b + 1, b + n + 1);\n        std::sort(ls + 1, ls + n + 1);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            int x = std::lower_bound(ls + 1, ls + n + 1, b[i].x) - ls;\n            assert(x &gt;= 1 &amp;&amp; x &lt;= n);\n            x = n + 1 - x, adde(b[i].id, b[ask(x)].id), add(x, i);\n        &#125;\n        memset(Bit, 0, sizeof (Bit));\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            b[i].x = -a[i].y, b[i].y = -a[i].x;\n            ls[i] = b[i].x, b[i].id = i;\n        &#125;\n        std::sort(b + 1, b + n + 1);\n        std::sort(ls + 1, ls + n + 1);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            int x = std::lower_bound(ls + 1, ls + n + 1, b[i].x) - ls;\n            assert(x &gt;= 1 &amp;&amp; x &lt;= n);\n            x = n + 1 - x, adde(b[i].id, b[ask(x)].id), add(x, i);\n        &#125;\n        memset(Bit, 0, sizeof (Bit));\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            b[i].x = -a[i].x, b[i].y = -a[i].y;\n            ls[i] = b[i].x, b[i].id = i;\n        &#125;\n        std::sort(b + 1, b + n + 1);\n        std::sort(ls + 1, ls + n + 1);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            int x = std::lower_bound(ls + 1, ls + n + 1, b[i].x) - ls;\n            assert(x &gt;= 1 &amp;&amp; x &lt;= n);\n            x = n + 1 - x, adde(b[i].id, b[ask(x)].id), add(x, i);\n        &#125;\n        memset(Bit, 0, sizeof (Bit));\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            b[i].x = a[i].x, b[i].y = -a[i].y;\n            ls[i] = b[i].x, b[i].id = i;\n        &#125;\n        std::sort(b + 1, b + n + 1);\n        std::sort(ls + 1, ls + n + 1);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            int x = std::lower_bound(ls + 1, ls + n + 1, b[i].x) - ls;\n            assert(x &gt;= 1 &amp;&amp; x &lt;= n);\n            x = n + 1 - x, adde(b[i].id, b[ask(x)].id), add(x, i);\n        &#125;\n        memset(Bit, 0, sizeof (Bit));\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            b[i].x = a[i].y, b[i].y = -a[i].x;\n            ls[i] = b[i].x, b[i].id = i;\n        &#125;\n        std::sort(b + 1, b + n + 1);\n        std::sort(ls + 1, ls + n + 1);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            int x = std::lower_bound(ls + 1, ls + n + 1, b[i].x) - ls;\n            assert(x &gt;= 1 &amp;&amp; x &lt;= n);\n            x = n + 1 - x, adde(b[i].id, b[ask(x)].id), add(x, i);\n        &#125;\n        std::sort(e.begin(), e.end());\n        int res = 0;\n        for (auto i : e) &#123;\n            if (find(i.x) != find(i.y))\n                res += i.w, merge(i.x, i.y);\n        &#125;\n        static int TimeKeeper = 0;\n        printf(&quot;Case %d: Total Weight = %d\\n&quot;, ++TimeKeeper, res);\n        read(n);\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n",
            "tags": [
                "最小生成树"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20240131/",
            "url": "https://xsc062.netlify.app/20240131/",
            "title": "USACO2024JAN 三组连打",
            "date_published": "2024-01-31T02:30:29.000Z",
            "content_html": "<p>假的，只连打了两组。Ag 没时间了。日后再补吧。</p>\n<span id=\"more\"></span>\n<p><img src=\"https://pic.imgdb.cn/item/65b7b152871b83018ac5e7b7.gif\" /></p>\n<p>无意中存了题面，但代码大部分因为系统还原消失了，只有文字题解，将就着看吧。</p>\n<hr />\n<h3 id=\"cu-a.-majority-opinion\">Cu A. Majority Opinion</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P10131\" class=\"uri\">https://www.luogu.com.cn/problem/P10131</a></p>\n<p><em>省流：任意区间内，若某元素出现个数严格大于区间长度一半，则可将整个区间推平为该值。问最终可以使整个序列被推平为哪些值。</em></p>\n<p>注意到当任意长度 <span class=\"math inline\">\\(\\ge 2\\)</span> 的区间可以被推平为某种元素时，整个数列都可以被推平为该元素。故目标转化为对于某种元素判定是否存在一个可被其推平的区间。</p>\n<p>统计元素个数采用前缀和。令 <span class=\"math inline\">\\(s_i\\)</span> 表示 <span class=\"math inline\">\\(h_i\\)</span> 在前 <span class=\"math inline\">\\(i\\)</span> 项中出现的次数，假设有 <span class=\"math inline\">\\([j,i]\\)</span> 满足条件，贪心可知 <span class=\"math inline\">\\(h_i=h_j\\)</span>。</p>\n<p>那么由定义有 <span class=\"math inline\">\\(i-j+1&lt;2\\times (s_i-s_j+1)\\)</span>。典中典，直接移项分离变量。则有 <span class=\"math inline\">\\(i-2\\times s_i-1&lt;j-2\\times s_j\\)</span>。令 <span class=\"math inline\">\\(t_p\\gets p-2\\times s_p\\)</span>，对于每个 <span class=\"math inline\">\\(h\\)</span> 记录 <span class=\"math inline\">\\(t_j\\)</span> 最大值查看是否有 <span class=\"math inline\">\\(i,j\\)</span> 满足条件即可。</p>\n<h3 id=\"cu-b.-cannonball\">Cu B. Cannonball</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P10132\" class=\"uri\">https://www.luogu.com.cn/problem/P10132</a></p>\n<p><em>省流：有 <span class=\"math inline\">\\(N\\)</span> 个格子，从 <span class=\"math inline\">\\(s\\)</span> 格子开始以 <span class=\"math inline\">\\(1\\)</span> 为初始能量向右跳，跳一步的距离为能量大小。格子分两种，一种经过加一定能量并反向，另一种若当前能量大于一定值则可永久摧毁，问跳出范围或无限长时间后可摧毁格子个数。</em></p>\n<p>不难发现若忽略增加能量为 <span class=\"math inline\">\\(0\\)</span> 的跳板则每经过一个跳板可跳距离增加 <span class=\"math inline\">\\(1\\)</span>，最多增加到 <span class=\"math inline\">\\(n\\)</span>，否则会跳出去。</p>\n<p>注意到调和级数，故直接模拟跳的过程。唯一导致时间无限的情况是存在相邻的增加能量为 <span class=\"math inline\">\\(0\\)</span> 的跳板，但其实它具体是什么并不重要，反正我们跳的次数严格大于调和级数后就可以认为进入死循环，直接结束模拟即可。我这里嫌麻烦直接拿了 <span class=\"math inline\">\\(2\\times 10^8\\)</span> 作阈值。</p>\n<h3 id=\"cu-c.-balancing-bacteria\">Cu C. Balancing Bacteria</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P10133\" class=\"uri\">https://www.luogu.com.cn/problem/P10133</a></p>\n<p><em>省流：定义一次操作为选取一个整数 <span class=\"math inline\">\\(\\Delta\\le N\\)</span>，并从 <span class=\"math inline\">\\(N\\)</span> 到 <span class=\"math inline\">\\(1\\)</span>，令 <span class=\"math inline\">\\(a_i\\gets a_i+\\Delta\\)</span> 并令 <span class=\"math inline\">\\(\\Delta\\)</span> 向 <span class=\"math inline\">\\(0\\)</span> 靠近 <span class=\"math inline\">\\(1\\)</span>，<span class=\"math inline\">\\(\\Delta=0\\)</span> 时停止。问令所有 <span class=\"math inline\">\\(a_i=0\\)</span> 所需最少操作次数。</em></p>\n<p>挺有意思的思维题，首先需要进行一个思维转化。<span class=\"math inline\">\\(\\Delta\\le N\\)</span> 是一个利于解题的限制，这意味着我们想让任何一个 <span class=\"math inline\">\\(a_i\\)</span> 改变 <span class=\"math inline\">\\(1\\)</span> 而不影响到之前的值，从让 <span class=\"math inline\">\\(a_1\\gets 0\\)</span> 入手，进行一次操作后每个 <span class=\"math inline\">\\(a_i\\)</span> 分到的 <span class=\"math inline\">\\(\\Delta\\)</span> 应依次加 1 或依次减 1。则差分数组为 <span class=\"math inline\">\\(0\\)</span> 后跟着一截 <span class=\"math inline\">\\(1\\)</span> 是理想状态。中间每有一项不满足规律都会带来额外的操作次数。</p>\n<p>归纳为差分数组的差分数组绝对值之和即为答案。</p>\n<hr />\n<h3 id=\"ag-a.-cowmpetency\">Ag A. Cowmpetency</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P10134\" class=\"uri\">https://www.luogu.com.cn/problem/P10134</a></p>\n<p><em>省流：有若干条限制，每条形如 <span class=\"math inline\">\\(\\max\\limits_{i=1}^{a_h-1}\\{A_i\\}=\\max\\limits_{i=1}^{a_j}\\{A_i\\}\\)</span> 且 <span class=\"math inline\">\\(A_{a_h}&gt;\\max\\limits_{i=1}^{a_h-1}\\{A_i\\}\\)</span>，部分数已知，构造出符合条件且字典序最小的序列。</em></p>\n<p>是本场最难题吧，但也没啥卡的。画个线段图容易发现，若将 <span class=\"math inline\">\\([a,h)\\)</span> 视作一条线段，那么除非 <span class=\"math inline\">\\(h\\)</span> 相同，否则两条线段不能有交集。不然的话就无解。以及如果存在不满足条件的定值也显然无解。</p>\n<p>从前往后看每个 <span class=\"math inline\">\\(h\\)</span> 并尝试赋值，对于每个 <span class=\"math inline\">\\(1\\sim a\\)</span> 记录一个需要满足的最大值数值，按照此数值从后往前填空格。</p>\n<p>填完过后扫一遍看看是不是全部合法，可以证明若此时不合法则无解。</p>\n<h3 id=\"ag-b.-potion-farming\">Ag B. Potion Farming</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P10135\" class=\"uri\">https://www.luogu.com.cn/problem/P10135</a></p>\n<p><em>省流：一棵树，每个点上有若干个物品，对于每条从根到叶子的简单路径，可以选择路径上的一个物品，每个物品只能被选一次，问最多可选物品数。</em></p>\n<p>如果一个点引导的子树下所有叶子有没有分配到的，就可以把这个点的物品分配给该叶子。</p>\n<p>跑一个树形 DP 即可。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 1e5 + 5;\nint n, x, y;\nint cnt[maxn];\nstd::vector&lt;int&gt; g[maxn];\nint a[maxn], f[maxn], p[maxn];\nint min(int x, int y) &#123;\n    return x &lt; y ? x : y;\n&#125;\nvoid DFS(int x, int fa) &#123;\n    if ((int)g[x].size() == 1)\n        cnt[x] = 1;\n    for (auto i : g[x]) &#123;\n        if (i == fa) continue;\n        DFS(i, x);\n        f[x] += f[i];\n        cnt[x] += cnt[i];\n    &#125;\n    if (f[x] &lt; cnt[x])\n        f[x] = min(f[x] + a[x], cnt[x]);\n    return;\n&#125;\nvoid add(int x, int y) &#123;\n    g[x].push_back(y);\n    return;\n&#125;\nint main() &#123;\n    read(n);\n    for (int i = 1; i &lt;= n; ++i) read(p[i]);\n    for (int i = 1; i &lt; n; ++i) &#123;\n        read(x), read(y);\n        add(x, y), add(y, x);\n    &#125;\n    int tot = 0;\n    for (int i = 2; i &lt;= n; ++i)\n        tot += ((int)g[i].size() == 1);\n    for (int i = 1; i &lt;= tot; ++i) ++a[p[i]];\n    DFS(1, -1);\n    print(f[1], &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<h3 id=\"ag-c.-cowlendar\">Ag C. Cowlendar</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P10136\" class=\"uri\">https://www.luogu.com.cn/problem/P10136</a></p>\n<p><em>省流：对于给定的序列 <span class=\"math inline\">\\(a\\)</span>，找出所有满足 <span class=\"math inline\">\\(a_i\\bmod L\\)</span> 的值的种类最多为 3 的 <span class=\"math inline\">\\(L\\)</span>。</em></p>\n<p>也是挺有意思的数学题了。若将 <span class=\"math inline\">\\(a_i\\)</span> 按照模 <span class=\"math inline\">\\(L\\)</span> 的情况分组，则对于任意一个 <span class=\"math inline\">\\(a_i\\)</span>，在 <span class=\"math inline\">\\((a_i,a_i+L)\\)</span> 中最多包含两个分别来自其余两组的数。</p>\n<p>对于去重后 <span class=\"math inline\">\\(n&gt;3\\)</span> 的情况，由鸽巢得必定有两个数可分为一组。故我们枚举可能的组间间隔，而可能的 <span class=\"math inline\">\\(L\\)</span> 就是这些间隔的因数。</p>\n<p>由上面我们推出一个合法组间间隔中最多间隔三个数，我们将所有 <span class=\"math inline\">\\(a_{i+3}-a_i\\)</span>、<span class=\"math inline\">\\(a_{i+2}-a_i\\)</span> 和 <span class=\"math inline\">\\(a_{i+1}-a_i\\)</span> 纳入考虑范围即可。对于所有可能的 <span class=\"math inline\">\\(L\\)</span>，直接 <span class=\"math inline\">\\(O(n)\\)</span> 跑一个 <code>check</code> 检查是否合法。</p>\n<p>因子个数照理来说是 <span class=\"math inline\">\\(\\sqrt{V}\\times n\\)</span> 级别的，但是实测 <span class=\"math inline\">\\(n\\)</span> 最多只有一百多。估计是因为 <span class=\"math inline\">\\(n\\)</span> 太大就很难构造出更多的合法解吧。</p>\n<details>\n<pre class=\"cpp\"><code>#define int long long\nnamespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 1e4 + 5;\nconst int maxm = 3e4 + 5;\nstd::set&lt;int&gt; u;\nint n, res, mn, tot;\nint a[maxn], b[maxm];\nbool check(int x) &#123;\n    int l1 = 0, l2 = 0, l3 = 0;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        if (l1 == 0) l1 = a[i];\n        else if (x &amp;&amp; (a[i] - l1) % x == 0) l1 = a[i];\n        else if (l2 == 0) l2 = a[i];\n        else if (x &amp;&amp; (a[i] - l2) % x == 0) l2 = a[i];\n        else if (l3 == 0) l3 = a[i];\n        else if (x &amp;&amp; (a[i] - l3) % x == 0) l3 = a[i];\n        else return 0;\n    &#125;\n    return 1;\n&#125;\nint main() &#123;\n    read(n);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        read(a[i]);\n        if (!mn || a[i] / 4 &lt; mn) mn = a[i] / 4;\n    &#125;\n    std::sort(a + 1, a + n + 1);\n    n = std::unique(a + 1, a + n + 1) - a - 1;\n    if (check(0)) &#123;\n        print(mn * (mn + 1) / 2, &#39;\\n&#39;);\n        return 0;\n    &#125;\n    for (int i = 2; i &lt;= n; ++i) &#123;\n        b[++tot] = a[i] - a[i - 1];\n        if (i &gt;= 3) b[++tot] = a[i] - a[i - 2];\n        if (i &gt;= 4) b[++tot] = a[i] - a[i - 3];\n    &#125;\n    std::sort(b + 1, b + tot + 1);\n    tot = std::unique(b + 1, b + tot + 1) - b - 1;\n    for (int i = 1; i &lt;= tot; ++i) &#123;\n        if (check(b[i])) &#123;\n            for (int j = 1; j * j &lt;= b[i]; ++j) &#123;\n                if (b[i] % j == 0)\n                    u.insert(j), u.insert(b[i] / j);\n            &#125;\n        &#125;\n    &#125;\n    for (auto i : u) &#123;\n        if (i &gt; mn) break;\n        res += i;\n    &#125;\n    print(res, &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n<p></deteails></p>\n",
            "tags": [
                "鸽巢原理",
                "调和级数",
                "差分",
                "思维",
                "树形 DP"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20240125/",
            "url": "https://xsc062.netlify.app/20240125/",
            "title": "我超！雀！",
            "date_published": "2024-01-25T03:20:57.000Z",
            "content_html": "<p>Solution to <a href=\"http://222.180.160.110:61235/contest/4813/problem/1\">PKUSC2022 Mahjong</a>。</p>\n<span id=\"more\"></span>\n<hr />\n<p><a href=\"https://www.bilibili.com/video/BV1JB4y1R7AP/\" class=\"uri\">https://www.bilibili.com/video/BV1JB4y1R7AP/</a></p>\n<p>这里是 PKUSC 当时的讲解视频。听说可以证明本题一定有 <span class=\"math inline\">\\(\\le 5\\)</span> 的解。好神奇。</p>\n<hr />\n<p>就比如说我们爆搜，<span class=\"math inline\">\\(9^4\\times 13^4\\)</span> 这个显然干不动对吧，所以我们考虑反过来 DP。</p>\n<p>我们先把字符串转化成计数数组，就是每种牌有多少片。不妨将 <code>1m ~ 9s</code> 编号为 <span class=\"math inline\">\\(1\\sim 27\\)</span>，记 <span class=\"math inline\">\\(g_i\\)</span> 为编号为 <span class=\"math inline\">\\(i\\)</span> 的牌的数量。</p>\n<p>为什么我们觉得 DP 不好打呢？因为换牌操作可以将两个毫不相干的牌的数量更改，不好记录状态。我们不妨直接将换牌拆成 <em>丢弃一张牌</em> 和 <em>借取令一张牌</em> 两个操作。很显然这两个操作数量是一样的，因为我们的牌数量自始至终不变。</p>\n<p>对于比较简单的对子作为终局的情况，我们只关心对数是否为 <span class=\"math inline\">\\(7\\)</span>，所以设计状态：<span class=\"math inline\">\\(dp_{i,j}\\)</span> 表示前 <span class=\"math inline\">\\(i\\)</span> 张牌中凑出 <span class=\"math inline\">\\(j\\)</span> 个对子的最小代价。</p>\n<p>那么就分 <em>把当前牌丢一些 / 借一些拿去组对子</em> 和 <em>直接丢弃当前牌</em> 两种方案。因为丢 / 借的数量是不确定的，直接 <code>abs</code> 一下就好。刷表，有：</p>\n<p><span class=\"math display\">\\[\ndp_{i+1,j}=dp_{i,j}+g_{i+1}\\\\\ndp_{i+1,j+1}=dp_{i,j}+|g_{i+1}-2|\n\\]</span></p>\n<p>最后我们的答案就来自 <span class=\"math inline\">\\(dp_{27,7}\\)</span>。然后注意这里我们的终局是 14 张牌 <del>你能秒我</del>，但起手只有 13 张牌，所以其实会有一个额外的借牌操作，假设答案为 <span class=\"math inline\">\\(x\\)</span>，那么其实 <span class=\"math inline\">\\(dp_{27,7}=2\\times x+1\\)</span>。</p>\n<hr />\n<p>有了对子的铺垫，面子手其实也还好。我们需要考虑的是对子和面子的个数。</p>\n<p>但是有个问题，对子只用借 / 丢当前花色，但面子可能是会借 / 丢下一个 / 下下一个花色的。</p>\n<p>所以干脆全部记录到状态里，令 <span class=\"math inline\">\\(f_{i,j,k,a,b}\\)</span> 表示当前在第 <span class=\"math inline\">\\(i\\)</span> 个花色，凑成了 <span class=\"math inline\">\\(j\\)</span> 个面子，<span class=\"math inline\">\\(k\\)</span> 个对子，需要 <span class=\"math inline\">\\(a\\)</span> 个 <span class=\"math inline\">\\(i+1\\)</span>，<span class=\"math inline\">\\(b\\)</span> 个 <span class=\"math inline\">\\(i+2\\)</span>。注意因为表示丢借有负数不太容易，不如就直接设成需要的数量了。</p>\n<p>因为这个需要数量只是前面的花色对当前花色的需要 <span class=\"math inline\">\\(a\\)</span>，我们还要满足当前花色 <strong>自身</strong> 的需要 <span class=\"math inline\">\\(now\\)</span>（也就是说当前花色一共需要 <span class=\"math inline\">\\(a+now\\)</span> 张）。注意这里 <span class=\"math inline\">\\(a\\)</span> 张全部都是拿去借给前面的花色用的，自己不能用。</p>\n<ul>\n<li><p>对于 <span class=\"math inline\">\\(k=0\\)</span> 且 <span class=\"math inline\">\\(now\\ge 2\\)</span>，此时可以从 <span class=\"math inline\">\\(now\\)</span> 里拿两张出来凑对子，剩下的 <span class=\"math inline\">\\(now - 2\\)</span> 因为肯定 <span class=\"math inline\">\\(\\le 2\\)</span>，所以只能全部拿去凑顺子。所以有：</p>\n<span class=\"math display\">\\[\nf_{i+1,j+now-2,1,b+now-2, now-2}=f_{i,j,0,a,b}+|g_{i+1}-(a+now)|\n\\]</span></li>\n<li><p>对于 <span class=\"math inline\">\\(now\\ge 3\\)</span>，拿三张凑一面。有：</p>\n<span class=\"math display\">\\[\nf_{i+1,j+now-2,k,b+now-3,now-3}=f_{i,j,0,a,b}+|g_{i+1}-(a+now)|\n\\]</span></li>\n<li><p>对于 <span class=\"math inline\">\\(now\\ne 0\\)</span>，可以凑顺子，有：</p>\n<p><span class=\"math display\">\\[\nf_{i+1,j+now,k,b+now,now}=f_{i,j,0,a,b}+|g_{i+1}-(a+now)|\n\\]</span></p>\n<p>注意不能跨花色借牌，也就是不能让 <span class=\"math inline\">\\(i=8/9/17/18/26/27\\)</span>。</p></li>\n</ul>\n<p>答案就是 <span class=\"math inline\">\\(f_{27,4,1,0,0}\\)</span>。</p>\n<hr />\n<p>然后这两个情况取一个 <span class=\"math inline\">\\(\\min\\)</span> 就是答案。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nusing std::cin;\nusing std::getline;\nusing str = std::string;\nint g[30];\nint dp[30][15];\nstr sm, sp, ss;\nint f[30][7][2][7][7];\nint abs(int x) &#123; return x &gt;= 0 ? x : -x; &#125;\nint min(int x, int y) &#123; return x &lt; y ? x : y; &#125;\nvoid upd(int &amp;x, int y) &#123; x = min(x, y); return; &#125;\nint main() &#123;\n    getline(cin, sm, &#39;m&#39;);\n    getline(cin, sp, &#39;p&#39;);\n    getline(cin, ss, &#39;s&#39;);\n    for (auto i : sm) ++g[i - &#39;0&#39;];\n    for (auto i : sp) ++g[i - &#39;0&#39; + 9];\n    for (auto i : ss) ++g[i - &#39;0&#39; + 18];\n    // 打对子\n    memset(dp, 0x3f, sizeof (dp));\n    dp[0][0] = 0;\n    for (int i = 0; i &lt; 27; ++i) &#123;\n        for (int j = 0; j &lt;= 7; ++j) &#123;\n            if (dp[i][j] == 0x3f3f3f3f) continue;\n            upd(dp[i + 1][j], dp[i][j] + g[i + 1]);\n            upd(dp[i + 1][j + 1], dp[i][j] + abs(g[i + 1] - 2));\n        &#125;\n    &#125;\n    // 打飞机\n    memset(f, 0x3f, sizeof (f));\n    f[0][0][0][0][0] = 0;\n    for (int i = 0; i &lt; 27; ++i)\n    for (int j = 0; j &lt;= 4; ++j)\n    for (int k = 0; k &lt;= 1; ++k)\n    for (int a = 0; a &lt;= 4; ++a)\n    for (int b = 0; b &lt;= 4; ++b) &#123;\n        if (i % 9 == 8 &amp;&amp; b) continue;\n        if (i % 9 == 0 &amp;&amp; a + b) continue;\n        for (int now = 0; now &lt;= 4; ++now) &#123; // 对当前的额外需求 \n            if (a + now &gt; 4) continue;\n            int v = f[i][j][k][a][b] + abs(g[i + 1] - (a + now));\n            if (j + now &lt;= 4 &amp;&amp; b + now &lt;= 4) // 直接硬配顺子 \n                upd(f[i + 1][j + now][k][b + now][now], v);\n            if (now &gt;= 2 &amp;&amp; !k &amp;&amp; j + now - 2 &lt;= 4 &amp;&amp; b + now - 2 &lt;= 4) // 借两个去凑对子 \n                upd(f[i + 1][j + now - 2][1][b + now - 2][now - 2], v);\n            if (now &gt;= 3 &amp;&amp; j + now - 2 &lt;= 4 &amp;&amp; b + now - 3 &lt;= 4) // 借两个去凑三不带 \n                upd(f[i + 1][j + now - 2][k][b + now - 3][now - 3], v);\n        &#125;\n    &#125;\n    // 拿来借走会算两次 \n    print(min(dp[27][7], f[27][4][1][0][0]) / 2, &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n",
            "tags": [
                "DP"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20240111/",
            "url": "https://xsc062.netlify.app/20240111/",
            "title": "杂题别选谈了",
            "date_published": "2024-01-11T03:25:19.000Z",
            "content_html": "<p>Solution to <a href=\"http://222.180.160.110:61235/contest/4665/problem/2\">SP4060 Game with Probability Problem</a>。</p>\n<span id=\"more\"></span>\n<hr />\n<p>设 <span class=\"math inline\">\\(f_i,g_i\\)</span> 分别表示还剩 <span class=\"math inline\">\\(i\\)</span> 个的时候轮到 Alice 和 Bob 时 <strong>Alice</strong> 分别的胜率。</p>\n<p>概率经典倒推。那么显然有 <span class=\"math inline\">\\(f_0=0,g_0=1\\)</span>。</p>\n<p>然后就是一个分讨，讨论这个人想要正面还是反面。很显然，对于同样的剩余棋子数，两个人先手的情况对于这颗棋子的喜爱程度是一样的。也就是说，要么都想要，要么都不想要。</p>\n<p>什么时候想要呢？拿掉过后自己胜率更大，也就是 <span class=\"math inline\">\\(g_{i-1}&gt;f_{i-1}\\)</span>。此时有：</p>\n<p><span class=\"math display\">\\[\nf_i=(1-p)\\times g_i+p\\times g_{i-1}\\\\\ng_i=(1-q)\\times f_i+q\\times f_{i-1}\n\\]</span></p>\n<p>发现是互相影响的，这个时候先不要着急怀疑自己推错了，因为我们这里有两个未知数，又刚好有两个方程，暴解一下就有：</p>\n<p><span class=\"math display\">\\[\nf_i=\\dfrac {(1-p)\\times q\\times f_{i-1}+p\\times g_{i-1}}{1-(1-p)(1-q)}\\\\\ng_i=\\dfrac {(1-q)\\times p\\times g_{i-1}+q\\times f_{i-1}}{1-(1-p)(1-q)}\n\\]</span></p>\n<p>然后 <span class=\"math inline\">\\(g_{i-1}&lt;f_{i-1}\\)</span> 的情况也差不多，把拿的概率和不拿的概率换一下：</p>\n<p><span class=\"math display\">\\[\nf_i=p\\times g_i+(1-p)\\times g_{i-1}\\\\\ng_i=q\\times f_i+(1-q)\\times f_{i-1}\n\\]</span></p>\n<p>解方程组有：</p>\n<p><span class=\"math display\">\\[\nf_i=\\dfrac {(1-q)\\times p\\times f_{i-1}+(1-p)\\times g_{i-1}}{1-p\\times q}\\\\\ng_i=\\dfrac {(1-p)\\times q\\times g_{i-1}+(1-q)\\times f_{i-1}}{1-p\\times q}\n\\]</span></p>\n<p>然后就可以开始 DP 了。最后的答案就是 <span class=\"math inline\">\\(f_{\\min(n,1000)}\\)</span>。</p>\n<p>还有个问题就是 <span class=\"math inline\">\\(n\\)</span> 特别大然后这个看起来也不太能矩乘，但是这个 DP 式有个好处是它的增长趋势是指数级的，所以我们 DP 到 <span class=\"math inline\">\\(1000\\)</span> 就可以了。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nnamespace XSC062 &#123;\nconst int maxn = 1e3 + 5;\nusing db = double;\ndb p, q;\nint T, n;\ndb f[maxn], g[maxn];\nint min(int x, int y) &#123;\n    return x &lt; y ? x : y;\n&#125;\nint main() &#123;\n    scanf(&quot;%d&quot;, &amp;T);\n    while (T--) &#123;\n        scanf(&quot;%d %lf %lf&quot;, &amp;n, &amp;p, &amp;q);\n        f[0] = .0, g[0] = 1.0;\n        for (int i = 1; i &lt;= n &amp;&amp; i &lt;= 1000; ++i) &#123;\n            if (g[i - 1] &gt; f[i - 1]) &#123;\n                f[i] = ((1 - p) * q * f[i - 1] + p * g[i - 1]) / (1 - (1 - p) * (1 - q));\n                g[i] = ((1 - q) * p * g[i - 1] + q * f[i - 1]) / (1 - (1 - p) * (1 - q));\n            &#125;\n            else &#123;\n                f[i] = ((1 - q) * p * f[i - 1] + (1 - p) * g[i - 1]) / (1 - p * q);\n                g[i] = ((1 - p) * q * g[i - 1] + (1 - q) * f[i - 1]) / (1 - p * q);\n            &#125;\n        &#125;\n        printf(&quot;%.6lf\\n&quot;, f[min(n, 1000)]);\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062\nint main() &#123;\n    XSC062::main();\n    return 0;\n&#125;\n</code></pre>\n</details>\n",
            "tags": [
                "DP",
                "概率期望"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20240106/",
            "url": "https://xsc062.netlify.app/20240106/",
            "title": "杂题全谈",
            "date_published": "2024-01-06T03:27:39.000Z",
            "content_html": "<p>想不到好标题了。</p>\n<span id=\"more\"></span>\n<p>有句话怎么说来着，罗马不是一天建成的，是一天天建成的。</p>\n<p>还有什么，Do in Rome as the Romans’ do，还有一句，All roads leads to Rome。</p>\n<hr />\n<h3 id=\"a.-连续的零-zero\">A. 连续的零 zero</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4647/problem/1\" class=\"uri\">http://222.180.160.110:61235/contest/4647/problem/1</a></p>\n<p>做个前缀和，看看任意一个长度为 <span class=\"math inline\">\\(k\\)</span> 的区间中有几个 <span class=\"math inline\">\\(1\\)</span>。复杂度 <span class=\"math inline\">\\(O(n)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 5e5 + 5;\nconst int inf = 0x3f3f3f3f;\nint n, m, res = inf;\nint a[maxn], s[maxn];\nint min(int x, int y) &#123;\n    return x &lt; y ? x : y;\n&#125;\nint main() &#123;\n    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        scanf(&quot;%1d&quot;, &amp;a[i]);\n        s[i] = s[i - 1] + a[i];\n        if (i &gt;= m)\n            res = min(res, s[i] - s[i - m]);\n    &#125;\n    print(res, &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"b.-反回文串-anti\">B. 反回文串 anti</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4647/problem/2\" class=\"uri\">http://222.180.160.110:61235/contest/4647/problem/2</a></p>\n<p>当 <span class=\"math inline\">\\(n\\)</span> 为奇时，中间的元素一定和自己相等，故无解。</p>\n<p>当数量最多的一个字符个数超过 <span class=\"math inline\">\\(\\dfrac n2\\)</span> 时，由鸽巢得无解。</p>\n<p>剩下的情况一定有解。</p>\n<details>\n<p><summary>证明</summary></p>\n<p>可以找到一种合法的构造方式。我们列出一个列数为 <span class=\"math inline\">\\(2\\)</span>，行数为 <span class=\"math inline\">\\(\\dfrac n2\\)</span> 的表格，将所有相同字母排列在一起，按照从左到右，从上到下的方式将字母填入表格，最后将第 <span class=\"math inline\">\\(i\\)</span> 行第一列的字母填入 <span class=\"math inline\">\\(a_i\\)</span>，第 <span class=\"math inline\">\\(i\\)</span> 行第二列的字母填入 <span class=\"math inline\">\\(a_{n-i+1}\\)</span>，即可完成构造。</p>\n<p>一种字母只在第一列或第二列出现当然合法，如果从第一列持续到第二列，因为任意字母出现次数不超过 <span class=\"math inline\">\\(\\dfrac n2\\)</span> 次，所以同一行的两列不会出现同一种字母。</p>\n<p>这叫什么，有字证明。</p>\n<p><del>感觉可以拿去出一道类似于「找到字符串字典序最小的反回文串」之类的小水题</del></p>\n</details>\n<p>然后现在我们知道有解了，怎么找到最优解呢。</p>\n<p>比如有一组 <span class=\"math inline\">\\((a_i,a_{n-i+1})=(\\texttt a, \\texttt a)\\)</span>，还有一组 <span class=\"math inline\">\\((a_j, a_{n-j+1})=(\\texttt b, \\texttt b)\\)</span>，那我们直接把 <span class=\"math inline\">\\(a_i\\)</span> 和 <span class=\"math inline\">\\(a_j\\)</span> 交换，皆大欢喜。</p>\n<p>这就说明我们需要把值不相等的非法 <span class=\"math inline\">\\(a_i\\)</span> 与 <span class=\"math inline\">\\(a_j\\)</span> 配对。</p>\n<p>然后我们就可以沿用证明中的构造方式，分组配对，一定最优，每组代价为 <span class=\"math inline\">\\(1\\)</span>。</p>\n<p>同一行两个值 <span class=\"math inline\">\\(v\\)</span> 相等，因为已经最优了，所以不能再在非法串中寻找答案。应该找合法对中某个值交换，每组代价为 <span class=\"math inline\">\\(2\\)</span>。具体和谁交换我们不用担心，只要找到一组 <span class=\"math inline\">\\((a_i,a_{n-i+1})\\)</span> 满足 <span class=\"math inline\">\\(a_i\\ne v\\)</span> 且 <span class=\"math inline\">\\(a_{n-i+1}\\ne v\\)</span> 就可以了，然后我们又知道 <span class=\"math inline\">\\(v\\)</span> 的个数 <span class=\"math inline\">\\(\\ne \\dfrac n2\\)</span>，假设 <span class=\"math inline\">\\(\\dfrac n2\\)</span> 对中每队都有至少一个 <span class=\"math inline\">\\(v\\)</span>，由于当前这一对有两个相同的 <span class=\"math inline\">\\(v\\)</span>，那么 <span class=\"math inline\">\\(v\\)</span> 的个数就会大于 <span class=\"math inline\">\\(\\dfrac n2\\)</span>，矛盾了，所以一定能找到。</p>\n<p>对于非法总对数是奇数的情况，我们要钦定一个非法对强制让其和合法对交换，贪心一下取非法对数量最多的 <span class=\"math inline\">\\(v\\)</span> 的某一对最优。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxm = 35;\nconst int maxn = 2e5 + 5;\nchar s[maxn];\nint cnt[maxm], p[maxn];\nint T, n, tot, res, now;\nint main() &#123;\n    scanf(&quot;%d&quot;, &amp;T);\n    while (T--) &#123;\n        tot = 0;\n        scanf(&quot;%d %s&quot;, &amp;n, s + 1);\n        if (n &amp; 1) &#123;\n            puts(&quot;-1&quot;);\n            continue;\n        &#125;\n        memset(cnt, 0, sizeof (cnt));\n        for (int i = 1; i &lt;= n; ++i)\n            ++cnt[s[i] - &#39;a&#39; + 1];\n        for (int i = 1; i &lt;= 26; ++i) &#123;\n            if (cnt[i] * 2 &gt; n) &#123;\n                puts(&quot;-1&quot;);\n                goto noSol;\n            &#125;\n        &#125;\n        memset(cnt, 0, sizeof (cnt));\n        for (int i = 1; i * 2 &lt;= n; ++i) &#123;\n            if (s[i] == s[n - i + 1])\n                ++cnt[s[i] - &#39;a&#39; + 1], ++tot;\n        &#125;\n        std::sort(cnt + 1, cnt + 27,\n                    std::greater&lt;int&gt;());\n        res = now = 0;\n        if (tot &amp; 1) &#123;\n            res = 1, --cnt[1];\n            std::sort(cnt + 1, cnt + 27,\n                        std::greater&lt;int&gt;());\n        &#125;\n        for (int i = 1; i &lt;= 26; ++i) &#123;\n            while (cnt[i]--) &#123;\n                if (++now &gt; tot / 2) &#123;\n                    if (i == p[now - tot / 2])\n                        res += 2;\n                    else ++res;\n                &#125;\n                else p[now] = i;\n            &#125;\n        &#125;\n        print(res, &#39;\\n&#39;);\n        noSol: ;\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"c.-除与减-divsub\">C. 除与减 divsub</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4647/problem/3\" class=\"uri\">http://222.180.160.110:61235/contest/4647/problem/3</a></p>\n<p>小数学，还好。</p>\n<p>假设 <span class=\"math inline\">\\(n=d\\times k^p\\)</span>，其中 <span class=\"math inline\">\\(k\\nmid d\\)</span>，那么我们分两种情况讨论。</p>\n<ol type=\"1\">\n<li><p><span class=\"math inline\">\\(p=0\\)</span>，即 <span class=\"math inline\">\\(k\\nmid n\\)</span>，那么 <span class=\"math inline\">\\(n\\bmod k=1\\)</span>，即 <span class=\"math inline\">\\(k\\mid (n-1)\\)</span>。</p>\n这个时候问 <span class=\"math inline\">\\(k\\)</span> 的个数就相当于是在问 <span class=\"math inline\">\\(n-1\\)</span> 除 <span class=\"math inline\">\\(1\\)</span> 以外的因子个数。假设 <span class=\"math inline\">\\(n-1={x_1}^{p_1}{x_2}^{p_2}\\cdots {x_m}^{p_m}\\)</span>，那么答案为 <span class=\"math inline\">\\((\\prod p_i+1)-1\\)</span>，减去的是 <span class=\"math inline\">\\(1\\)</span>。</li>\n<li><p><span class=\"math inline\">\\(p\\ne 0\\)</span>，<span class=\"math inline\">\\(k\\mid n\\)</span>。</p>\n<p>这个时候好像并没有什么好的转化。好消息是 <span class=\"math inline\">\\(n\\)</span> 的范围是 <span class=\"math inline\">\\(10^{12}\\)</span>，根号枚举因数复杂度跑得过。所以我们就可以暴力判定 <span class=\"math inline\">\\(n\\)</span> 的所有因数是否满足条件。</p></li>\n</ol>\n<p>时间复杂度，<span class=\"math inline\">\\(O(\\sqrt n\\times \\log n)\\)</span>，枚举因数是根号，算次数（也就是算 <span class=\"math inline\">\\(d\\)</span>）是 <span class=\"math inline\">\\(\\log\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#define int long long\nnamespace XSC062 &#123;\nusing namespace fastIO;\nint n, m, res, cnt;\nint main() &#123;\n    read(n), m = n;\n    for (int i = 2; i * i &lt;= n; ++i) &#123;\n        if (n % i == 0) &#123;\n            m = n;\n            while (m % i == 0) m /= i;\n            if (m % i == 1) ++res;\n            if (i * i != n) &#123;\n                m = n;\n                while (m % (n / i) == 0)\n                    m /= (n / i);\n                if (m % (n / i) == 1) ++res;\n            &#125;\n        &#125;\n    &#125;\n    m = n - 1, cnt = 1;\n    for (int i = 2; i * i &lt;= m; ++i) &#123;\n        if (m % i == 0) &#123;\n            int now = 0;\n            while (m % i == 0)\n                ++now, m /= i;\n            cnt *= now + 1;\n        &#125;\n    &#125;\n    if (m != 1) cnt *= 2;\n    print(res + cnt, &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n</details>\n<hr />\n<h3 id=\"d.-图书管理员-librarian\">D. 图书管理员 librarian</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4647/problem/4\" class=\"uri\">http://222.180.160.110:61235/contest/4647/problem/4</a></p>\n<p>[SDOI2008] 郁闷的小 J。</p>\n<p>关于这个，我们发现自己不会考场现冲主席树。哎，打 CDQ 又怕写挂。</p>\n<p>我们发现这道题的修改都是单点的，询问也只关于某一种颜色，不同的颜色之间没有影响。</p>\n<p>于是我们可以把操作离线下来，初始视作将某颜色在某位置增加，修改视作将某颜色在某位置删除，将另一颜色在该位置增加，将所有操作按颜色离散化分类然后 <code>vector</code> 下来，对于所有颜色从前到后树状数组做一遍操作就能 <span class=\"math inline\">\\(O(n\\log n+q\\log n)\\)</span> 解决。</p>\n<p>树状数组清空是肯定不能 <code>memset</code> 的，复杂度不对。那么怎么办呢？把所有操作撤回去就可以了。</p>\n<p>顺带一提我是洛谷上最优解。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 2e5 + 5;\nstruct __ &#123;\n    int ty, l, r, v;\n    __() &#123;&#125;\n    __(int t1, int l1, int r1, int v1 = 0) &#123;\n        if (t1 == 0)\n            ty = 0, l = l1, v = r1;\n        else ty = 1, l = l1, r = r1, v = v1;\n    &#125;\n&#125;;\nchar ty;\nstd::map&lt;int, int&gt; tab;\nstd::vector&lt;__&gt; q[maxn];\nint n, m, tot, x, y, v, id;\nint Bit[maxn], a[maxn], res[maxn];\nint lowbit(int x) &#123; return x &amp; -x; &#125;\nvoid add(int x, int v) &#123;\n    for (; x &lt;= n; x += lowbit(x))\n        Bit[x] += v;\n    return;\n&#125;\nint ask(int x) &#123;\n    int res = 0;\n    for (; x; x -= lowbit(x)) res += Bit[x];\n    return res;\n&#125;\nint main() &#123;\n    read(n), read(m);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        read(a[i]);\n        if (!tab.count(a[i]))\n            tab[a[i]] = ++tot;\n        a[i] = tab[a[i]];\n        q[a[i]].emplace_back(0, i, 1);\n    &#125;\n    while (m--) &#123;\n        scanf(&quot;%1s&quot;, &amp;ty);\n        if (ty == &#39;C&#39;) &#123;\n            read(x), read(y);\n            if (!tab.count(y))\n                tab[y] = ++tot;\n            y = tab[y];\n            q[a[x]].emplace_back(0, x, -1);\n            q[a[x] = y].emplace_back(0, x, 1);\n        &#125;\n        else &#123;\n            ++id;\n            read(x), read(y), read(v);\n            if (!tab.count(v)) continue;\n            v = tab[v];\n            q[v].emplace_back(1, x, y, id);\n        &#125;\n    &#125;\n    for (int i = 1; i &lt;= tot; ++i) &#123;\n        for (auto &amp;j : q[i]) &#123;\n            if (j.ty == 0) add(j.l, j.v);\n            else &#123;\n                res[j.v] =\n                    ask(j.r) - ask(j.l - 1);\n            &#125;\n        &#125;\n        for (auto &amp;j : q[i])\n            if (j.ty == 0) add(j.l, -j.v);\n    &#125;\n    for (int i = 1; i &lt;= id; ++i)\n        print(res[i], &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<p>E 会单独开一篇。</p>\n<hr />\n<h3 id=\"f.-树-tree\">F. 树 tree</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4647/problem/6\" class=\"uri\">http://222.180.160.110:61235/contest/4647/problem/6</a></p>\n<p>CF916E。</p>\n<p>大分讨给我整不会了，更给我整不会的是下来过后发现这只是个小分讨。</p>\n<p>更新子树和子树查询我们都会。换根 DP 我们也都写过，都知道换根并不会对子树结构产生大的影响。所以应当是能根据已知信息推测出子树在原树上对应的点集的。</p>\n<p>记 <span class=\"math inline\">\\(r\\)</span> 为当前树根，<span class=\"math inline\">\\(\\text {LCA}(x,y)\\)</span> 为 <span class=\"math inline\">\\(x,y\\)</span> 在 <span class=\"math inline\">\\(1\\)</span> 为根时的 LCA，<span class=\"math inline\">\\(\\text {LCA}&#39;(x,y)\\)</span> 表示 <span class=\"math inline\">\\(x,y\\)</span> 在 <span class=\"math inline\">\\(r\\)</span> 为根时的 LCA。</p>\n<p>那么对于 <span class=\"math inline\">\\(\\text {LCA}&#39;(x,y)\\)</span>，肯定是要讨论 <span class=\"math inline\">\\(x,y\\)</span> 和 <span class=\"math inline\">\\(r\\)</span> 的位置关系的。</p>\n<ol type=\"1\">\n<li><span class=\"math inline\">\\(\\text {LCA}(x,y)\\)</span> 是 <span class=\"math inline\">\\(r\\)</span> 的子孙。此时 <span class=\"math inline\">\\(\\text {LCA}&#39;(x,y) = \\text {LCA}(x,y)\\)</span>。</li>\n<li><span class=\"math inline\">\\(\\text {LCA}(x,y)\\)</span> 是 <span class=\"math inline\">\\(r\\)</span> 的祖先。那么说明至少有一个点不是 <span class=\"math inline\">\\(r\\)</span> 的子孙。此时 <span class=\"math inline\">\\(\\text {LCA}(x,y)&#39;\\)</span> 的值为 <span class=\"math inline\">\\(r\\)</span> 为另一个点的 LCA。</li>\n</ol>\n<p>整理可得 <span class=\"math inline\">\\(\\text {LCA}&#39;(x,y)\\)</span> 是 <span class=\"math inline\">\\(\\text {LCA}(x,y)\\)</span>、<span class=\"math inline\">\\(\\text {LCA}(x,r)\\)</span> 和 <span class=\"math inline\">\\(\\text {LCA}(y,r)\\)</span> 中的深度最大者。</p>\n<p>对于以 <span class=\"math inline\">\\(r\\)</span> 为根时的子树 <span class=\"math inline\">\\(x\\)</span>：</p>\n<ol type=\"1\">\n<li><span class=\"math inline\">\\(x=r\\)</span>，此时子树为整棵树。</li>\n<li><span class=\"math inline\">\\(\\text {LCA}(x,r)\\ne x\\)</span>，即 <span class=\"math inline\">\\(r\\)</span> 不为 <span class=\"math inline\">\\(x\\)</span> 的子孙，此时子树就是以 <span class=\"math inline\">\\(1\\)</span> 为根是的子树 <span class=\"math inline\">\\(x\\)</span>。</li>\n<li><span class=\"math inline\">\\(\\text {LCA}(x,y)=x\\)</span>，即 <span class=\"math inline\">\\(r\\)</span> 为 <span class=\"math inline\">\\(x\\)</span> 的子孙，此时子树是整棵树除开 <span class=\"math inline\">\\(x\\)</span> 包含 <span class=\"math inline\">\\(r\\)</span> 的儿子及其子孙。修改和查询的时候容斥一下就好。这个时候的子树倍增跳一下就能找到。</li>\n</ol>\n<p>然后就是常规线段树维护了。时间复杂度 <span class=\"math inline\">\\(O(n\\log n)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxm = 35;\nconst int maxn = 1e5 + 5;\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nstruct _ &#123; int l, r, u, d; &#125;;\n_ t[maxn &lt;&lt; 2];\nint f[maxn][maxm];\nstd::vector&lt;int&gt; g[maxn];\nint a[maxn], dfn[maxn], rfn[maxn];\nint n, q, r, ty, x, y, v, si, now;\nint top[maxn], dep[maxn], tab[maxn];\nvoid swap(int &amp;x, int &amp;y) &#123;\n    x ^= y ^= x ^= y;\n    return;\n&#125;\nvoid DFS(int x) &#123;\n    dep[x] = dep[f[x][0]] + 1;\n    dfn[x] = ++now, tab[now] = x;\n    for (auto i : g[x]) &#123;\n        if (i == f[x][0]) continue;\n        f[i][0] = x;\n        for (int j = 1; j &lt;= si; ++j)\n            f[i][j] = f[f[i][j - 1]][j - 1];\n        DFS(i);\n    &#125;\n    rfn[x] = now;\n    return;\n&#125;\nvoid pushup(int p) &#123;\n    t[p].u = t[lt].u + t[rt].u;\n    return;\n&#125;\nvoid pushdown(int p) &#123;\n    if (t[p].d) &#123;\n        t[lt].d += t[p].d;\n        t[rt].d += t[p].d;\n        t[lt].u += t[p].d *\n                (t[lt].r - t[lt].l + 1);\n        t[rt].u += t[p].d *\n                (t[rt].r - t[rt].l + 1);\n        t[p].d = 0;\n    &#125;\n    return;\n&#125;\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        t[p].u = a[tab[l]];\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    pushup(p);\n    return;\n&#125;\nvoid add(int p, int x, int v) &#123;\n    t[p].u += v;\n    if (t[p].l == t[p].r) return;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid) add(lt, x, v);\n    else add(rt, x, v);\n    return;\n&#125;\nvoid add(int p, int l, int r, int v) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        t[p].d += v;\n        t[p].u += (t[p].r - t[p].l + 1) * v;\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid) add(lt, l, r, v);\n    if (r &gt; mid) add(rt, l, r, v);\n    pushup(p);\n    return;\n&#125;\nint ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].u;\n    pushdown(p);\n    int res = 0,\n        mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid) res = ask(lt, l, r);\n    if (r &gt; mid) res += ask(rt, l, r);\n    return res;\n&#125;\nint LCA(int x, int y) &#123;\n    if (dep[x] &lt; dep[y]) swap(x, y);\n    for (int i = si; ~i; --i) &#123;\n        if (dep[f[x][i]] &gt;= dep[y])\n            x = f[x][i];\n    &#125;\n    if (x == y) return x;\n    for (int i = si; ~i; --i) &#123;\n        if (f[x][i] != f[y][i])\n            x = f[x][i], y = f[y][i];\n    &#125;\n    return f[x][0];\n&#125;\nvoid Add(int x, int v) &#123;\n    int rlca = LCA(r, x);\n    if (x == r) add(1, 1, n, v);\n    else if (rlca != x)\n        add(1, dfn[x], rfn[x], v);\n    else &#123;\n        add(1, 1, n, v);\n        int p = r;\n        for (int i = si; ~i; --i) &#123;\n            if (dep[f[p][i]] &gt;= dep[x] + 1)\n                p = f[p][i];\n        &#125;\n        add(1, dfn[p], rfn[p], -v);\n    &#125;\n    return;\n&#125;\nvoid tAdd(int x, int y, int v) &#123;\n    int llca = LCA(r, x), rlca = LCA(r, y),\n        ulca = LCA(x, y);\n    if (dep[llca] &gt;= dep[rlca] &amp;&amp;\n        dep[llca] &gt;= dep[ulca]) Add(llca, v);\n    else if (dep[rlca] &gt;= dep[llca] &amp;&amp;\n        dep[rlca] &gt;= dep[ulca]) Add(rlca, v);\n    else Add(ulca, v);\n    return;\n&#125;\nint tAsk(int x) &#123;\n    int rlca = LCA(r, x);\n    if (x == r) return t[1].u;\n    if (rlca != x)\n        return ask(1, dfn[x], rfn[x]);\n    int p = r;\n    for (int i = si; ~i; --i) &#123;\n        if (dep[f[p][i]] &gt;= dep[x] + 1)\n            p = f[p][i];\n    &#125;\n    return t[1].u - ask(1, dfn[p], rfn[p]);\n&#125;\nvoid add(int x, int y) &#123;\n    g[x].push_back(y);\n    return;\n&#125;\nint main() &#123;\n    read(n), read(q), r = 1;\n    si = log(n) / log(2.0);\n    for (int i = 1; i &lt;= n; ++i) read(a[i]);\n    for (int i = 1; i &lt; n; ++i) &#123;\n        read(x), read(y);\n        add(x, y), add(y, x);\n    &#125;\n    dep[0] = 1, DFS(1), dep[0] = 0;\n    bld(1, 1, n);\n    while (q--) &#123;\n        read(ty);\n        if (ty == 1) read(r);\n        else if (ty == 2) &#123;\n            read(x), read(y), read(v);\n            tAdd(x, y, v);\n        &#125;\n        else &#123;\n            read(x);\n            print(tAsk(x), &#39;\\n&#39;);\n        &#125;\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n</details>\n",
            "tags": [
                "线段树",
                "树状数组",
                "LCA",
                "倍增",
                "鸽巢原理"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/231230/",
            "url": "https://xsc062.netlify.app/231230/",
            "title": "解题报告 [SDOI2016] 游戏",
            "date_published": "2023-12-30T04:12:30.000Z",
            "content_html": "<p>可以看出来出题人很想出一道把李超和别的什么东西凑起来的题目，于是给了这么一个缝合怪。</p>\n<span id=\"more\"></span>\n<hr />\n<p><a href=\"https://www.luogu.com.cn/problem/P4069\" class=\"uri\">https://www.luogu.com.cn/problem/P4069</a></p>\n<p>符号有点混乱。比如箭头又可以表示路径又可以表示赋值，代入语境应该还是好理解的。</p>\n<hr />\n<p>看到 <span class=\"math inline\">\\(a\\times dis + b\\)</span> 就应激反应出来是李超了，看到 <span class=\"math inline\">\\(s\\to t\\)</span> 又瞬间反应过来是树剖，但是树剖的 DFN 和 <span class=\"math inline\">\\(dis\\)</span> 没有直接关联，赛时想不到怎么做就跑路了。</p>\n<p>实际上这个转化很板。因为这是条路径，我们还在树链上跳，每次跳过的一个链上的 DFN 是连续的，对应的 <span class=\"math inline\">\\(dis\\)</span> 也是连续的。</p>\n<p>估计是打 T4 的子树问题打傻了，没想到这个。</p>\n<p>所以我们就相当于是给一条重链上的某个连续区间加了一个斜率为 <span class=\"math inline\">\\(a\\)</span>，截距为 <span class=\"math inline\">\\(b\\)</span> 加上 <em>一坨东西</em> 的线段。用李超维护即可。</p>\n<hr />\n<p>感觉讲的不清不楚的，那就再讲讲。</p>\n<p>我们要让李超上任意一个点 <span class=\"math inline\">\\(u\\)</span> 代表的 <span class=\"math inline\">\\(x\\)</span> 是个定值。<em>一坨东西</em> 维护了这条线段相对于 <span class=\"math inline\">\\(s\\)</span> 的偏移量。令 <span class=\"math inline\">\\(r\\gets \\text{LCA of } s \\text { and } t\\)</span>，<span class=\"math inline\">\\(R\\)</span> 表示整棵树的根，<span class=\"math inline\">\\(d(u,v)\\gets \\text {distance between } u \\text { and } v\\)</span>。</p>\n<ol type=\"1\">\n<li><p>对于 <span class=\"math inline\">\\(s\\to r\\)</span> 上的每个点 <span class=\"math inline\">\\(u\\)</span>：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nval_u&amp;=a\\times d(s, u)+b\\\\\n&amp;=a\\times[d(s,R)-d(u,R)]+b\\\\\n&amp;=-a\\times d(u,R)+[a\\times d(s,R)+b]\n\\end{aligned}\n\\]</span> <span class=\"math inline\">\\(a\\times d(s,R)+b\\)</span> 是和 <span class=\"math inline\">\\(u\\)</span> 无关的定值（这意味着可以在同一个询问的树剖时直接线段树），<span class=\"math inline\">\\(d(u,R)\\)</span> 是只和 <span class=\"math inline\">\\(u\\)</span> 相关的值（这意味着对于任意询问都成立）。令斜率为 <span class=\"math inline\">\\(-a\\)</span>，截距为 <span class=\"math inline\">\\(a\\times d(s,R)+b\\)</span>，李超上任意点 <span class=\"math inline\">\\(u\\)</span> 代表 <span class=\"math inline\">\\(x\\)</span> 为 <span class=\"math inline\">\\(d(x,R)\\)</span>，维护如此一条线段即可。</p></li>\n<li><p>对于 <span class=\"math inline\">\\(r\\to t\\)</span> 上的每个点 <span class=\"math inline\">\\(v\\)</span>： <span class=\"math display\">\\[\n\\begin{aligned}\nval_v&amp;=a\\times d(s,v)+b\\\\\n&amp;= a\\times [d(r,v)+d(s,r)]+b\\\\\n&amp;=a\\times [d(v,R)-d(r,R)+d(s,r)]+b\\\\\n&amp;=a\\times d(v,R)+[-a\\times d(r,R)+a\\times d(s,r)+b]\n\\end{aligned}\n\\]</span> <span class=\"math inline\">\\(-a\\times d(r,R)+a\\times d(s,r)+b\\)</span> 是和 <span class=\"math inline\">\\(v\\)</span> 无关，只和询问中固定的 <span class=\"math inline\">\\(s,r,a,b\\)</span> 有关的定值；<span class=\"math inline\">\\(d(v,R)\\)</span> 是只和 <span class=\"math inline\">\\(v\\)</span> 相关的值且和上一个 case 里的 <span class=\"math inline\">\\(d(u,R)\\)</span> 同构，也用李超这么维护即可。</p></li>\n</ol>\n<p>用李超维护把原问题转化为每次向若干重链上连续区间插入线段，求最低交点的问题。</p>\n<p>注意到区间查询，李超需要加一个 pushup。具体怎么去操作呢？在加线段的时候除编号外新增一个变量维护当前区间内最低交点；我们就 pushup 这个东西。然后查询的时候就是在散区间的时候和原来一样查，整区间就在散区间答案的基础上再和当前区间的整体最低交点比一个 min。</p>\n<details>\n<pre class=\"cpp\"><code>#define int long long\nnamespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxk = 25;\nconst int maxn = 1e6 + 5;\nconst int maxm = 1e6 + 5;\nconst int inf = 123456789123456789;\n//#define DEBUG\n\n#ifdef DEBUG\n#define Z(x) x\n#else\n#define Z(x)\n#endif\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nstruct __ &#123; int k, b; &#125;;\nstruct _ &#123; int l, r, u, d; &#125;;\nstruct ____ &#123;\n    int v, w;\n    ____() &#123;&#125;\n    ____(int v1, int w1) &#123;\n        v = v1, w = w1; \n    &#125;\n&#125;;\n__ a[maxm];\n_ t[maxn &lt;&lt; 2];\nint tot, si, now;\nint f[maxn][maxk];\nint dis[maxn], dep[maxn];\nint dfn[maxn], tab[maxn];\nstd::vector&lt;____&gt; g[maxn];\nint n, m, ty, x, y, w, k, b;\nint siz[maxn], top[maxn], son[maxn];\nint max(int x, int y) &#123;\n    return x &gt; y ? x : y;\n&#125;\nint min(int x, int y) &#123;\n    return x &lt; y ? x : y;\n&#125;\nvoid swap(int &amp;x, int &amp;y) &#123;\n    x ^= y ^= x ^= y;\n    return;\n&#125;\nvoid DFS1(int x) &#123;\n    siz[x] = 1;\n    for (auto i : g[x]) &#123;\n        if (i.v == f[x][0]) continue;\n        f[i.v][0] = x;\n        for (int j = 1; j &lt;= si; ++j)\n            f[i.v][j] = f[f[i.v][j - 1]][j - 1];\n        dep[i.v] = dep[x] + 1;\n        dis[i.v] = dis[x] + i.w;\n        DFS1(i.v);\n        if (siz[i.v] &gt; siz[son[x]])\n            son[x] = i.v;\n        siz[x] += siz[i.v];\n    &#125;\n    return;\n&#125;\nvoid DFS2(int x, int t) &#123;\n    top[x] = t;\n    dfn[x] = ++now, tab[now] = x;\n    if (son[x]) DFS2(son[x], t);\n    for (auto i : g[x]) &#123;\n        if (i.v == f[x][0] || i.v == son[x])\n            continue;\n        DFS2(i.v, i.v);\n    &#125;\n    return;\n&#125;\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r, t[p].d = inf;\n    if (l == r) return;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    return;\n&#125;\nint getv(int id, int x) &#123;\n    if (!id) return inf;\n    Z(printf(&quot;get (%lld, %lld) = %lld\\n&quot;,\n        id, x, dis[tab[x]] * a[id].k + a[id].b));\n    return dis[tab[x]] * a[id].k + a[id].b;\n&#125;\nvoid pushup(int p) &#123;\n    if (t[p].l == t[p].r) return;\n    t[p].d = min(t[p].d, min(t[lt].d, t[rt].d));\n    Z(printf(&quot;[%lld, %lld]: pushup to %lld\\n&quot;,\n        t[p].l, t[p].r, t[p].d));\n    return;\n&#125;\nvoid chg(int p, int id) &#123;\n    t[p].u = id;\n    Z(int tmp = t[p].d);\n    t[p].d = min(getv(id, t[p].l),\n                 getv(id, t[p].r));\n    Z(printf(&quot;[%lld, %lld]: %lld -&gt; %lld\\n&quot;,\n                t[p].l, t[p].r, tmp, t[p].d)); \n    return;\n&#125;\nvoid upd(int p, int id) &#123;\n    if (!t[p].u) &#123;\n        chg(p, id), pushup(p);\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    int v1 = getv(t[p].u, mid),\n        v2 = getv(id, mid);\n    if (v2 &lt; v1) swap(t[p].u, id);\n    v1 = getv(t[p].u, t[p].l);\n    v2 = getv(id, t[p].l);\n    if (v2 &lt; v1) upd(lt, id);\n    v1 = getv(t[p].u, t[p].r);\n    v2 = getv(id, t[p].r);\n    if (v2 &lt; v1) upd(rt, id);\n    chg(p, t[p].u);\n    pushup(p);\n    return;\n&#125;\nvoid add(int p, int l, int r, int id) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        upd(p, id);\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid) add(lt, l, r, id);\n    if (r &gt; mid) add(rt, l, r, id);\n    pushup(p);\n    return;\n&#125;\nint ask(int p, int l, int r) &#123;\n    l = max(l, t[p].l);\n    r = min(r, t[p].r);\n    int res = min(getv(t[p].u, l),\n                  getv(t[p].u, r));\n    Z(printf(&quot;[%lld, %lld]: res = %lld\\n&quot;,\n        t[p].l, t[p].r, res));\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return min(res, t[p].d);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid) res = min(res, ask(lt, l, r));\n    if (r &gt; mid) res = min(res, ask(rt, l, r));\n    Z(printf(&quot;[%lld, %lld]: res = %lld\\n&quot;,\n        t[p].l, t[p].r, res));\n    return res;\n&#125;\nvoid add(int x, int y, int w) &#123;\n    g[x].push_back(____(y, w));\n    return;\n&#125;\nvoid ins(int l, int r, int k, int b) &#123;\n    a[++tot].k = k, a[tot].b = b;\n    add(1, l, r, tot);\n    return;\n&#125;\nint getLCA(int x, int y) &#123;\n    if (dep[x] &lt; dep[y]) swap(x, y);\n    for (int i = si; ~i; --i) &#123;\n        if (dep[f[x][i]] &gt;= dep[y])\n            x = f[x][i];\n    &#125;\n    if (x == y) return x;\n    for (int i = si; ~i; --i) &#123;\n        if (f[x][i] != f[y][i])\n            x = f[x][i], y = f[y][i];\n    &#125;\n    return f[x][0];\n&#125;\nvoid inst(int s, int t, int k, int b) &#123;\n    int r = getLCA(s, t), u = s;\n    while (top[u] != top[r]) &#123;\n        ins(dfn[top[u]], dfn[u],\n                    -k, k * dis[s] + b);\n        u = f[top[u]][0];\n    &#125;\n    ins(dfn[r], dfn[u], -k, k * dis[s] + b);\n    u = t;\n    int d = dis[s] - dis[r];\n    while (top[u] != top[r]) &#123;\n        ins(dfn[top[u]], dfn[u],\n                k, -k * dis[r] + k * d + b);\n        u = f[top[u]][0];\n    &#125;\n    ins(dfn[r], dfn[u],\n            k, -k * dis[r] + k * d + b);\n    return;\n&#125;\nint qry(int x, int y) &#123;\n    int res = inf;\n    while (top[x] != top[y]) &#123;\n        if (dep[top[x]] &lt; dep[top[y]])\n            swap(x, y);\n        Z(printf(&quot;ask %lld -&gt; %lld: %lld\\n&quot;,\n            x, top[x],\n            ask(1, dfn[top[x]], dfn[x])));\n        res = min(res,\n            ask(1, dfn[top[x]], dfn[x]));\n        x = f[top[x]][0];\n    &#125;\n    if (dep[x] &lt; dep[y]) swap(x, y);\n    Z(printf(&quot;ask %lld -&gt; %lld: %lld\\n&quot;,\n        x, y, ask(1, dfn[y], dfn[x])));\n    res = min(res, ask(1, dfn[y], dfn[x]));\n    return res;\n&#125;\nint main() &#123;\n//  freopen(&quot;game1.in&quot;, &quot;r&quot;, stdin);\n    read(n), read(m);\n    si = log(n) / log(2.0);\n    for (int i = 1; i &lt; n; ++i) &#123;\n        read(x), read(y), read(w);\n        add(x, y, w), add(y, x, w);\n    &#125;\n    bld(1, 1, n);\n    dep[1] = 1, DFS1(1), DFS2(1, -1);\n    Z(for (int i = 1; i &lt;= n; ++i)\n        printf(&quot;dfn[%lld] = %lld\\n&quot;, i, dfn[i]));\n    while (m--) &#123;\n        read(ty), read(x), read(y);\n        if (ty == 1) &#123;\n            read(k), read(b);\n            inst(x, y, k, b);\n        &#125;\n        else print(qry(x, y), &#39;\\n&#39;);\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n</details>\n",
            "tags": [
                "树链剖分",
                "李超线段树"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20231117/",
            "url": "https://xsc062.netlify.app/20231117/",
            "title": "TRICKS",
            "date_published": "2023-11-17T06:31:23.000Z",
            "content_html": "<p>想着写点什么东西，就是说，不会被归入知识点（upd：并非不会），却又感觉很常用（upd：并非常用）的东西。</p>\n<p>哦我懂了，通常来说我们管这个叫 trick。</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"ds\">DS</h2>\n<details>\n<p><summary><strong>容易记错的操作复杂度：</strong></summary></p>\n<ul>\n<li><strong>线段树合并、线段树建树</strong>：<span class=\"math inline\">\\(O(n)\\)</span>。</li>\n<li>FHQ Treap 建树：视作笛卡尔树，<span class=\"math inline\">\\(O(n)\\)</span>。</li>\n<li>动态开店线段树单次访问至多增加 <span class=\"math inline\">\\(4\\log\\)</span> 个点，e.g. <span class=\"math inline\">\\([2,n-1]\\)</span>。</li>\n</ul>\n</details>\n<details>\n<p><summary><strong>随机序列的笛卡尔树：</strong></summary></p>\n<p>是 Treap。</p>\n</details>\n<details>\n<p><summary><strong>有『合并』功能的 DS：</strong></summary></p>\n<p>并查集，线段树，<strong>字典树</strong>，笛卡尔树，BST。</p>\n</details>\n<details>\n<p><summary><strong>复杂度依赖『均摊』的 DS：</strong></summary></p>\n<p>并查集，线段树 / 字典树合并。</p>\n<p><strong>不强制在线</strong> <strong>复杂度不依赖均摊</strong> 的可持久化数据结构 <span class=\"math inline\">\\(\\to\\)</span> DAG 上直接模拟。</p>\n</details>\n<details>\n<p><summary><strong>部分可持久化：</strong></summary></p>\n<p>只要求『在最新版本上修改』和『查询所有版本』的可持久化数组可以在 <code>vector</code> 上二分，又唤部分可持久化。</p>\n</details>\n<details>\n<p><summary><strong>字典树维护二进制操作：</strong></summary></p>\n<p>字典树的节点 id 可视作对信息的引用，也即，如果在初次插入时记录了某个元素对应的 id，相当于获取了元素的引用。</p>\n<ul>\n<li>单点修改：拿出来，修改，塞进去，单次修改 <span class=\"math inline\">\\(O(\\log V)\\)</span>。</li>\n<li>全局 <code>xor</code>：打懒标记，单次修改 <span class=\"math inline\">\\(O(1)\\)</span>。</li>\n<li>全局 +1 / -1：字典树上信息必须从低位到高位存储。现场处理，（发现只会递归一条链），单次修改 <span class=\"math inline\">\\(O(\\log V)\\)</span>。</li>\n</ul>\n</details>\n<details>\n<p><summary><strong>线段树可维护的经典信息：</strong></summary></p>\n<ul>\n<li><p>操作：插入 / 删除区间，询问：值域内未被覆盖的点的信息：</p>\n<p>线段树维护节点内被覆盖次数最小值和最小值信息；当最小值为 <span class=\"math inline\">\\(0\\)</span> 时，将信息纳入统计。</p>\n扩：维护值域内恰好被区间覆盖 <span class=\"math inline\">\\(k\\)</span> 次的点的信息：线段树维护节点内前 <span class=\"math inline\">\\(k+1\\)</span> 小值的信息，则 <span class=\"math inline\">\\(k\\)</span> 一定出现在前 <span class=\"math inline\">\\(k+1\\)</span> 小值中。</li>\n<li><p>线段树维护函数：如果对于任意区间，都能定义一个定义域为该区间的函数，可以线段树维护该函数。维护的总点数是 <span class=\"math inline\">\\(n\\log n\\)</span> 的。</p></li>\n</ul>\n</details>\n<hr />\n<h2 id=\"数学\">数学</h2>\n<!-- <details><summary> -->\n<details>\n<p><summary><strong>常见数据对应的数列：</strong></summary></p>\n<ul>\n<li><span class=\"math inline\">\\(\\{1,1,2,3,5,8,\\cdots\\}\\)</span> 是斐波那契；矩阵可以优化；生成函数可以找通项；<span class=\"math inline\">\\(f_i=\\sum\\limits_{i=0}^nC_n-i^i\\)</span>。</li>\n<li><span class=\"math inline\">\\(\\{1, 1, 2, 5, 14\\cdots\\}\\)</span> 是 Catalan，走网格不能穿过对角线 / 构造二叉树方案数 / 一群人买电影票。<a href=\"/20250419/#不经过-yxc-的方案数\">有组合求法 <span class=\"math inline\">\\({2n\\choose n} - {2n \\choose n - 1}\\)</span></a>；生成函数还是可以找通项；</li>\n<li><span class=\"math inline\">\\(\\{3, 7, 6, 15, 25, 10, 31, 90, 65, 15, 63, 301, 350, 140, 21, 127, 966,\\cdots\\}\\)</span>，中间插着一堆 <span class=\"math inline\">\\(1\\)</span>，是展开了的第二类斯特林数三角形，把 <span class=\"math inline\">\\(n\\)</span> 个不同球，不空放，放到 <span class=\"math inline\">\\(k\\)</span> 个相同盒子的方案数，有递推式 <span class=\"math inline\">\\(S(n,k)=S(n-1,k-1)+k\\cdot S(n-1,k)\\)</span> 和二项式反演出来的通项 <span class=\"math inline\">\\(S(n,m)=\\sum\\limits_{i=0}^m\\dfrac {(-1)^{m-i}\\cdot i^n}{i!\\cdot (m-i)!}\\)</span>。多项式可以 <span class=\"math inline\">\\(n\\log\\)</span> 算同一行 / 列，方法不太一样。</li>\n</ul>\n</details>\n<details>\n<p><summary><strong><span class=\"math inline\">\\(n\\)</span> 被取模后的组合数：</strong></summary></p>\n<p>将原式展开，<span class=\"math inline\">\\(\\binom nm=\\frac 1{m!} \\prod\\limits_{i=0}^{m-1} (n-i)\\)</span>，容易发现 <span class=\"math inline\">\\(n\\)</span> 取模是没有影响的，如果模数很小则可以预处理模数范围内的阶乘，如果 <span class=\"math inline\">\\(m\\)</span> 很小则可以每次 <span class=\"math inline\">\\(O(m)\\)</span> 现算。</p>\n<p>同理可以发现 <span class=\"math inline\">\\(m\\)</span> 是不能直接取模的，如果需要给 <span class=\"math inline\">\\(m\\)</span> 取模就只能用 Lucas。</p>\n</details>\n<details>\n<p><summary><strong><span class=\"math inline\">\\(O(V\\log V)\\)</span> 求数的因数：</strong></summary></p>\n<p>假设 <span class=\"math inline\">\\(n=V=5\\times 10^6\\)</span>，那么对于每个数暴力分解就是 <span class=\"math inline\">\\(O(n\\sqrt V)\\)</span> 的，无法通过。</p>\n<p>埃筛预处理，存储每个数的所有因数就可以 <span class=\"math inline\">\\(O(V\\log V)\\)</span> 求了。</p>\n</details>\n<details>\n<p><summary><strong>求线段穿过直线系的次数：</strong></summary></p>\n<p>求线段 <span class=\"math inline\">\\((x_1,y_1,x_2,y_2)\\)</span> 穿过直线系 <span class=\"math inline\">\\(x+y=k\\cdots m(k\\in \\mathbb{N}^*)\\)</span> 的次数算出线段中 <span class=\"math inline\">\\(x+y\\)</span> 的取值范围也即 <span class=\"math inline\">\\([x_1+y_1,x_2+y_2]\\)</span>（斜率为负就不同了，但可以证明都是单调的），求出 <span class=\"math inline\">\\(k\\cdot m\\)</span> 在里面的出现次数就可以了。<del>有的人高中数学欠的债要到竞赛来还</del></p>\n<p>goto <a href=\"https://codeforces.com/contest/2098/problem/E\">CF2098E</a>。</p>\n</details>\n<hr />\n<h2 id=\"图论\">图论</h2>\n<details>\n<p><summary><span class=\"math inline\">\\(m-n\\)</span> 很小带来的隐含条件</summary></p>\n<p>DFS 树的反祖边很少，可以基于这一点想一些比较暴力的做法。</p>\n<p>goto <a href=\"http://localhost:4000/20250816/#g---count-simple-paths-2\">solu to <em>Count Simple Paths 2</em></a>。</p>\n</details>\n<h3 id=\"经典建模\">经典建模</h3>\n<details>\n<p><summary><strong>左部点度数为 <span class=\"math inline\">\\(2\\)</span> 的二分图匹配：</strong></summary></p>\n<p>一系列元素，每个元素有不超过两种可选值，要求最终每个元素值不同，求方案数。</p>\n<p>对所有可选值建图。如果只有一个可选值，看作两种可选值相同，连自环；否则把两个可选值连边。此时一个元素对应一条边，即对于每条边选一个端点，满足每个端点被选最多一次。</p>\n<p>对于所有连通块：</p>\n<ul>\n<li>若 <span class=\"math inline\">\\(n&gt;m+1\\)</span>： 没有这种可能性（不连通）。</li>\n<li>若 <span class=\"math inline\">\\(n=m+1\\)</span>，即该连通块为树，任选一个点不选都能唯一构成一组解，方案数为 <span class=\"math inline\">\\(n\\)</span>。</li>\n<li><p>若 <span class=\"math inline\">\\(n=m\\)</span>，即形成基环树：</p>\n<p>由于环上点只能且必须被环上边选，树上边的选法唯一。主要讨论环边选法。</p>\n<ul>\n<li>若环为自环，答案为 <span class=\"math inline\">\\(1\\)</span>；</li>\n<li>否则枚举环上所有边是统一选顺 / 逆时针方向的端点，答案为 <span class=\"math inline\">\\(2\\)</span>。</li>\n</ul></li>\n<li><p>若 <span class=\"math inline\">\\(n&lt;m\\)</span>：</p>\n<p>点不够用，答案为 <span class=\"math inline\">\\(0\\)</span>。</p></li>\n</ul>\n<p>最后把所有连通块的答案相乘就可以得到总答案。</p>\n<p>goto <a href=\"https://vjudge.net/problem/OpenJ_POJ-C19A\">Ball</a>, <a href=\"https://codeforces.com/contest/2097/problem/B\">Baggage Claim</a>, <a href=\"https://atcoder.jp/contests/tkppc6-2/tasks/tkppc6_2_g\">Must be Distinct!</a>。</p>\n</details>\n<details>\n<p><summary><strong>凸多边形三角剖分转化为树上问题</strong>：</summary></p>\n<p>结论：若把三角形视作 <span class=\"math inline\">\\(n-2\\)</span> 个点，在有公共边的三角形之间连边可以得到树。</p>\n<p>证明：有 <span class=\"math inline\">\\(n-3\\)</span> 条边，显然每条边都被两个三角形共用；至于为什么是 <span class=\"math inline\">\\(n-2\\)</span> 个三角形请移步计几。</p>\n<p>生成方法：易发现肯定存在 <span class=\"math inline\">\\(\\ge 2\\)</span> 个顶点不被任何对角线经过（其属于一个叶子三角形），其度数为 <span class=\"math inline\">\\(2\\)</span>；用类似拓扑排序的方式，不断切下叶子三角形并寻找新的叶子三角形，就可以找到所有点。注意到对角线就是树边，记录每条对角线两侧的三角形，连边即可。</p>\n<p>goto <a href=\"/20250612/#b---distance-on-triangulation\">solu to <em>Distance on Triangulation</em></a>。</p>\n</details>\n<h3 id=\"优化建图\">优化建图</h3>\n<details>\n<p><summary><strong>前缀和优化建图：</strong></summary></p>\n<p>要求每条边都指向某个前缀区间；与线段树优化建图相比的优势是虚点、边数均为 <span class=\"math inline\">\\(O(n)\\)</span>。</p>\n<p>Goto <a href=\"/20250505/\">solu to <em>喝醉的兔子</em></a>。</p>\n</details>\n<h3 id=\"图上-dp\">图上 DP</h3>\n<details>\n<p><summary><strong>有环图的 DP 顺序：</strong></summary></p>\n<p>有环图上的 DP，通常来说可以根据状态转移方程的形式找到环上的「根源」，即不由任何环上节点转移得到。</p>\n<p>无视根源在环上的前驱边就可以用类拓扑的方式转移。</p>\n<p>Goto <a href=\"/20231113/#b.-商人\">solu to 商人</a>。</p>\n</details>\n<h3 id=\"树的直径图的直径\">树的直径，图的直径</h3>\n<details>\n<p><summary><strong>半径与中点的定义：</strong></summary></p>\n<ul>\n<li><strong>半径</strong>：图 / 树的半径（<strong>数值上为 <span class=\"math inline\">\\(\\min\\limits_x\\{\\max\\limits_y dis(x, y)\\}\\)</span></strong>）的一端一定在直径上，且在直径中间。如果不带权的话就是直径长度的一半 <del>不然为啥叫半径</del>。</li>\n<li><strong>中点</strong>：半径在直径上的端点，有一个（直径为奇）或两个（直径为偶），均满足到所有点的距离不超过半径。</li>\n</ul>\n</details>\n<details>\n<p><summary><strong>直径的性质：</strong></summary></p>\n<ul>\n<li><p><strong>图的直径的性质</strong>：</p>\n<ol type=\"1\">\n<li>不能用两次 BFS 求，原因：图不满足『距离任意点最远的点都是直径的一个端点』这条贪心性质。</li>\n<li><p>设图的直径为 <span class=\"math inline\">\\(d\\)</span>，对于任意点 <span class=\"math inline\">\\(x\\)</span>，其和其他点最短路的最大值 <span class=\"math inline\">\\(s\\)</span> 满足：</p>\n<p><span class=\"math display\">\\[\n\\left\\lceil \\dfrac d2\\right\\rceil \\le s\\le d\n\\]</span></p>\n<p>等价形式：<span class=\"math inline\">\\(d\\in[s, 2s]\\)</span>。</p>\n证明：上界显然；对于下界，取图中心 <span class=\"math inline\">\\(m\\)</span>，对任意 <span class=\"math inline\">\\(x\\)</span> 找到距其最远的点 <span class=\"math inline\">\\(y\\)</span>。由松弛，显然有 <span class=\"math inline\">\\(d(x,y)\\le d(x,m)+d(y,m)\\)</span>。又 <span class=\"math inline\">\\(d(x,m),d(y,m)\\le r\\)</span>，故 <span class=\"math inline\">\\(d(x,y)\\le 2r\\)</span>，也即 <span class=\"math inline\">\\(d\\ge d(x,y)\\)</span>。</li>\n</ol></li>\n<li><p><strong>树的直径的性质</strong>：</p>\n<ol type=\"1\">\n<li>树的所有直径交于树的所有中点（参考半径，如果长度为偶数就是两个点）；</li>\n<li>向树中加一个叶子，最多改变直径的一个端点。</li>\n<li>距离任意点最远的点都是直径的一个端点。</li>\n</ol></li>\n</ul>\n</details>\n<details>\n<p><summary><strong>半径的性质 / 离树上某点最远的点：</strong></summary></p>\n<p>将中心边（若有两条任选一条）提出来，让两侧的点作为根；</p>\n<p><img src=\"image.png\" /></p>\n<p>对于一个点 <span class=\"math inline\">\\(u\\)</span>，离它最远的点一定在另一棵树中最深的位置。</p>\n</details>\n<details>\n<p><summary><strong>动态维护树的直径：</strong></summary></p>\n<p>如果知道一个连通块内的直径是 <span class=\"math inline\">\\(x\\to y\\)</span>，另一个是 <span class=\"math inline\">\\(a\\to b\\)</span>，那么两个合并起来的直径一定是 <span class=\"math inline\">\\(\\{x,y,a,b\\}\\)</span> 里的 <span class=\"math inline\">\\(C_4^2\\)</span>。</p>\n<p>线段树维护一段连续<strong>欧拉序</strong>内（不用 DFS 序是为了保证联通）的直径和两个端点，就能解决动态加点一类问题。</p>\n</details>\n<h3 id=\"树上问题\">树上问题</h3>\n<details>\n<p><summary><strong>树上路径问题的解决思路：</strong></summary></p>\n<ol type=\"1\">\n<li><p>静态问题：</p>\n<ul>\n<li><p>不要求方向且能预处理：树上差分。</p></li>\n<li><p>要求方向且能预处理：倍增、树剖（多一个 log 但跑不满；综合来看慢一些）。</p></li>\n<li><p>离线、要求方向且不能预处理：</p>\n<p>把询问挂在 <span class=\"math inline\">\\(u\\)</span> 和 LCA 上，第一遍 DFS 把 <span class=\"math inline\">\\(u\\to\\)</span> LCA 的答案计算出来（需要可合并信息），第二遍 DFS 利用回溯把 LCA <span class=\"math inline\">\\(\\to v\\)</span> 的答案计算出来。</p>\ngoto <a href=\"/20250809/#a---记忆\">solu to <em>记忆</em></a>。</li>\n</ul></li>\n<li><p>动态问题：树剖。</p></li>\n</ol>\n</details>\n<hr />\n<h2 id=\"dp\">DP</h2>\n<details>\n<p><summary><strong>轮廓线 DP / 逐格状压 DP：</strong></summary></p>\n<p>对于棋盘上的状压 DP，如果某格内容的限制只来自相邻的格子（这是大部分棋盘问题能够满足的），可以考虑轮廓线 DP。</p>\n<p>具体来说，按照通常的从上到下、从左到右 DP 的思路，对于某一格，发现影响到它的只有左侧和上方的状态；这时我们通常会保存上一行所有状态，但发现左上侧格子及以前的状态是无用的，反而左边的状态是有用的。故记录每一列最靠下的已确定状态，就可以完成 DP。</p>\n<p>goto <a href=\"/20250805/#d---count-grid-3-coloring\">solu to <em>Count Grid 3-coloring</em></a>，<a href=\"/20250805/#f---123-set\">solu to <em>123 Set</em></a>。</p>\n<p>对于 <span class=\"math inline\">\\(2\\times 1\\)</span> 骨牌放置问题，可以设『上半片』为 <code>1</code>，其余为 <code>0</code>，对于横向骨牌逐二格确定。这样就能发现，轮廓线 DP 并不一定只有在左侧有限制的时候才能用，因为<strong>记录左侧状态也是在完成状态的转移</strong>。</p>\n</details>\n<details>\n<p><summary><strong>『贡献』的思想：</strong></summary></p>\n<p>用乘法分配率将式子拆开，即『分类』，这时可能会发现『分步』这一步比原来更好做。</p>\n<p>更具象地，对于『分步』中的某一步，将『类别』的全集划分为若干个子集，发现除此之外的部分可能可以更方便地计算。如果能找到这样一种简单的均裂或异裂的方式，使得每一『类』的『单步』价值能够确定，就能考虑用『贡献』计算。</p>\n<p>特别地，对于一个子集，如果其他步骤对它的价值没有影响，其贡献往往会表现为幂次形式。</p>\n<p>Goto <a href=\"/20250803/#b---one-to-one\">solu to <em>One to One</em></a>，<a href=\"/20250407/#e---kdoi-11彩灯晚会\">solu to <em>彩灯晚会</em></a></p>\n</details>\n<details>\n<p><summary><strong>想要筛选出特定一『类』的状态 / 不同『分类』对应不同『分步』时的处理方法：</strong></summary></p>\n<p>如果类别比较少，将类别放到维度里（例：如果存在二进制运算则可以拆位，则类别为 0/1 两类），分别处理。</p>\n<p>看起来很显然，但确实是很多状态设计的难点。</p>\n</details>\n<details>\n<p><summary><strong>多重集的组合数</strong></summary></p>\n<p>主要要求能够认识到正在应用该模型。</p>\n<p>当 <span class=\"math inline\">\\(n,m\\)</span> 很小而 <span class=\"math inline\">\\(c_i\\)</span> 很大时：</p>\n<ul>\n<li><p>朴素地，设 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示在 <span class=\"math inline\">\\(i\\)</span> 处填了 <span class=\"math inline\">\\(\\le j\\)</span> 的数（可以意识到需要前缀和），如果只关注当前位是不能做的，考虑枚举填了多少个 <span class=\"math inline\">\\(j\\)</span>，可以得到 <span class=\"math inline\">\\(f_{i,j}=\\sum_k f_{i-k,j-1}\\)</span>。注意 <span class=\"math inline\">\\(k\\)</span> 可以取到 <span class=\"math inline\">\\(0\\)</span>，从数值上来看恰好是对的。</p>\n如果认为一个多重集中的元素是有差异的，还可以乘上 <span class=\"math inline\">\\(\\binom {c_j}k\\)</span>。</li>\n<li>如果保证 <span class=\"math inline\">\\(n\\le c_i\\)</span>，且题目没有其他限制时，发现原问题等价于 <span class=\"math inline\">\\(x_1+x_2+\\cdots +x_m=n\\)</span> 的非负整数解数目，插板法解决。</li>\n<li><p>在上一种方式的基础上，如果没有了 <span class=\"math inline\">\\(n\\le c_i\\)</span> 的限制，易发现容斥也是可行的。</p></li>\n</ul>\n</details>\n<details>\n<p><summary><strong>与字典序有关的状态设计：</strong></summary></p>\n<p>要求字典序大于 / 小于给定值的方案数，考虑使用 <span class=\"math inline\">\\(f_i\\)</span> 表示 <span class=\"math inline\">\\(1\\sim i\\)</span> 全部和给定值相同，<span class=\"math inline\">\\(i+1\\)</span> 大于 / 小于给定值，后面无限制的情况总数。</p>\n<p>Goto <a href=\"http://222.180.160.110:61235/contest/5423/problem/2\">冒泡排序</a>。</p>\n</details>\n<ul>\n<li>计数 DP 和容斥的选择。</li>\n<li><p>（容斥）碰到了「起点状态到终点状态，中间不能经过一些非法状态的方案数」，可以用 <span class=\"math inline\">\\(f_i\\)</span> 表示从起点，不经过 <span class=\"math inline\">\\(1\\sim i-1\\)</span> 的非法状态，到达非法状态 <span class=\"math inline\">\\(i\\)</span> 的方案数，最后将终点状态也视为一个非法状态并 DP 即可。</p>\nGoto <a href=\"/20231113/#a---gerald-and-giant-chess\">solu to <em>Gerald and Giant Chess</em></a>，<a href=\"https://www.cnblogs.com/XSC062/p/17330225.html\">solu to <em>两双手</em></a>。</li>\n<li><p>求方案数，如果用通常的「考虑满足条件的情况并转移」，就必须能够简单地对条件进行判定。</p>\n<p>如果这一点做不到，可以考虑从最简单或最极限情况出发充要且不重地 <strong>构造</strong> 出一般情况，并计算相应的方案数。</p>\ngoto <a href=\"/20230716/\">solu to <em>染色</em></a>。</li>\n<li><p>如果有转移会有后效性不妨考虑是否有前效性然后逆序 DP。</p>\n<p>例如求字典序最小的答案：只知道最后一个字符不能推断出谁的字典序最小。但如果知道最开头一个字符，并保证从后往前填表的每一步都走的最小就能够确定。</p>\ngoto <a href=\"/20230716-1/\">solu to <em>匹配数</em></a></li>\n<li><p id=\"1\">\n状态拆分技巧。比如状态 ABC 不一定要从状态 A、状态 B、状态 C 分别 <span class=\"math inline\">\\(O(m)\\)</span> 的转移，而可以从 A 和 BC 以 <span class=\"math inline\">\\(O(1)\\)</span> 完成转移。\n</p>\n<p>Goto <a href=\"/20231003/#f.-单词\">solu to <em>单词</em></a>。</p></li>\n</ul>\n<h3 id=\"关于背包\">关于背包</h3>\n<details>\n<p><summary><strong>子序列问题转化为背包问题：</strong></summary></p>\n<p>子序列问题（不仅是 + &amp; min，也可以是 xor、加 &amp; 模等）可以转化为背包问题；对一个区间做背包，可以把区间划分成若干段，每段做背包，再依次 <span class=\"math inline\">\\(O(v^2)\\)</span> 地合并。</p>\n<p>『划分』的一个典型场景是找『分割线』，然后向左向右分别做背包——这么做的优点是，对于任意穿这条分割线的区间，你都能 <span class=\"math inline\">\\(O(v^2)\\)</span> 得到所有的背包信息。甚至，如果你只需要求某个特定体积下的答案，只需要 <span class=\"math inline\">\\(O(v)\\)</span> 枚举。</p>\n<p>upd：可以猫树</p>\n<p>goto <a href=\"https://loj.ac/p/6515\">贪玩蓝月</a>。</p>\n</details>\n<details>\n<p><summary><strong>离线背包结合分治：</strong></summary></p>\n<p>背包可以看作一种 +/min 卷积：在体积维上做加法、在代价维上做 min。当然其他操作如体积维上的 xor、加模；代价维上的方案数都差不多。</p>\n<p>因此，多次区间询问（离线）的背包可以结合分治——原因是从每个 <span class=\"math inline\">\\(l\\)</span> 开始做一次背包是不现实的，而我们发现分割线是可以共用的——分割线代表的背包信息也是可以共用的。</p>\n<p>所以需要找到一种『找分割线』和『一条分割线求解的范围』的方法，使得规定复杂度内能够最大化利用『公共信息』。分治的（类线段树的）结构就是一种极好的方式，在一层分治内解决所有在 <span class=\"math inline\">\\([l,r]\\)</span> 范围内，且跨越 <span class=\"math inline\">\\(mid\\)</span> 的询问，这样就能从 <span class=\"math inline\">\\(mid\\)</span> 出发，向左到 <span class=\"math inline\">\\(l\\)</span>，向右到 <span class=\"math inline\">\\(r\\)</span> 求解背包。</p>\n<p>goto <a href=\"/20250520/#cf2043f-nim\">solu to CF2043F</a>。</p>\n</details>\n<details>\n<p><summary><strong>树上背包序列化：</strong></summary></p>\n<p>注意到对于任何类型的背包，树结构复杂度不优于序列结构。仅有物品体积为 <span class=\"math inline\">\\(1\\)</span> 的 01 背包可以用技巧优化到相同复杂度。</p>\n<p>利用 DFS 序进行填表，若不选某个点，相当于不选其引导的一整个子树 DFS 序区间。其余和序列背包一致。</p>\n<p>Goto <a href=\"/20250612/#c---shopping\">solu to <em>Shopping</em></a>。</p>\n</details>\n<details>\n<p><summary><strong>随机序列的背包：</strong></summary></p>\n<p>有结论：一个长度为 <span class=\"math inline\">\\(n\\)</span> 的 <span class=\"math inline\">\\(1/-1\\)</span> 随机序列的前缀和离 <span class=\"math inline\">\\(0\\)</span> 的距离期望不超过 <span class=\"math inline\">\\(\\sqrt n\\)</span>。</p>\n<p>拓展一下，在保证值域内分布均匀的整数域内背包，在 <code>random_shuffle</code> 后实际最大状态不太会超过 <span class=\"math inline\">\\(\\sqrt V\\)</span>。</p>\n<p>因为结论很松，所以运气比较好的时候甚至不会超过 <span class=\"math inline\">\\(\\log V\\)</span>。</p>\n</details>\n<hr />\n<h2 id=\"哈希\">哈希</h2>\n<details>\n<p><summary><strong>哈希中全等条件的应用 / 哈希与前缀信息的关联：</strong></summary></p>\n<p>有的区间问题的判定条件可以转化为部分前缀信息的全等。</p>\n<p>例：要求区间内每个数出现次数为 <span class=\"math inline\">\\(3\\)</span> 的倍数，转化为：令 <span class=\"math inline\">\\(cnt_{i,j}\\)</span> 表示前 <span class=\"math inline\">\\(i\\)</span> 个数中 <span class=\"math inline\">\\(j\\)</span> 出现次数 <span class=\"math inline\">\\(\\bmod3\\)</span> 的值，则要求左右端点该值全等。</p>\n<p>Goto <a href=\"https://www.luogu.com.cn/article/5reynyzi\">Three Occurrences</a>。</p>\n</details>\n<details>\n<p><summary><strong>xor hash：</strong></summary></p>\n<p>使用于异或判断次数奇偶性 / 元素存在性的哈希。</p>\n<p>区间里每个值出现次数都是偶数的必要条件是区间异或起来为 <span class=\"math inline\">\\(0\\)</span>。该结论不充分：<span class=\"math inline\">\\(1\\oplus 2\\oplus 3=0\\)</span>。</p>\n<p>把每个数都哈希成一个随机大数（比如 ull），冲突的概率就会变成 <span class=\"math inline\">\\(2^{-64}\\)</span>。</p>\n<p>Goto <a href=\"https://www.luogu.com.cn/article/ugg047a7\">NOI2024 D1T1</a>，<a href=\"/20221010/\">solu to <em>博弈</em></a>。</p>\n</details>\n<hr />\n<h2 id=\"二分\">二分</h2>\n<hr />\n<h2 id=\"关于最值\">关于最值</h2>\n<h3 id=\"关于冒泡排序\">关于冒泡排序</h3>\n<p><em>『冒泡排序有一种被出烂但是每次碰到我都不会的美感。』——wosile</em></p>\n<p><em>这个人我不认识，但是我觉得这句话说得太好了！</em></p>\n<ul>\n<li><p>一轮冒泡排序做的事情：将序列按前缀最大值为段首划分为若干段，并把其移到段末。</p>\ngoto <a href=\"/20250510/#c---1-loop-bubble-sort\">1 Loop Bubble Sort</a>。</li>\n<li><p>前缀最大值在一轮冒泡排序后仍是前缀最大值。</p></li>\n</ul>\n<details>\n<p><summary>求某下标在序列所有的 LIS 中出现次数：</summary></p>\n<p>分别统计以其结尾和开头的 LIS 长度与次数，如果加起来是序列 LIS 的长度，那么次数相乘就是答案。</p>\n</details>\n<h2 id=\"杂项\">杂项</h2>\n<details>\n<p><summary><strong>常用低复杂度库函数 / 比手写复杂度更低的库函数：</strong></summary></p>\n<ul>\n<li><code>__builtin_clz</code> / <code>__builtin_ctz</code>：统计二进制开头 / 末尾 <span class=\"math inline\">\\(0\\)</span> 的个数，通常是硬件指令，硬件不支持则会采用掩码 <span class=\"math inline\">\\(O(1)\\)</span> 得到结果。</li>\n<li><code>__builtin_popcount</code>：同上。</li>\n<li><p><code>sqrt</code>：争议很大，但事实是对于所有数据最多迭代 <span class=\"math inline\">\\(6\\)</span> 次，实际表现接近单次浮点乘法操作，故为 <span class=\"math inline\">\\(O(1)\\)</span>。</p>\n<p>此处值得说明的是，<code>&lt;cmath&gt;</code> 中的对数函数同样为常数复杂度，但被观测到实际表现时常数较大，跑 1e6 次就已经很危险了。</p>\n如果需要对 <span class=\"math inline\">\\(2\\)</span> 取对数，使用 <code>std::__lg</code> 代替（其实现为 <code>31 - __builtin_clz(x)</code>）。</li>\n<li><p><code>std::nth_element</code>：可以 <span class=\"math inline\">\\(O(n)\\)</span> 找到第 <span class=\"math inline\">\\(k\\)</span> 大元素（放在第 <span class=\"math inline\">\\(k\\)</span> 位），并将原数组部分重排，使得前 <span class=\"math inline\">\\(k-1\\)</span> 为均比第 <span class=\"math inline\">\\(k\\)</span> 位小，后 <span class=\"math inline\">\\(n-k\\)</span> 位均比第 <span class=\"math inline\">\\(k\\)</span> 位大。</p>\n<p>所以实际功能其实是 <span class=\"math inline\">\\(O(n)\\)</span> 找到前 <span class=\"math inline\">\\(k\\)</span> 大元素。因为平常提到 rank 都喜欢用 <span class=\"math inline\">\\(k\\)</span> 来叙述，所以函数名经常被误记为 <code>kth</code>。</p></li>\n</ul>\n</details>\n<details>\n<p><summary><strong>随机序列跳悬线 / 悬线结合分块：</strong></summary></p>\n<p>随机序列的笛卡尔树深度为 <span class=\"math inline\">\\(\\log\\)</span>；令块长为 <span class=\"math inline\">\\(B=\\sqrt {\\log n}\\)</span>，维护每个点跳 <span class=\"math inline\">\\(B\\)</span> 步的答案；那么就能 <span class=\"math inline\">\\(O(\\sqrt {\\log n})\\)</span> 跳悬线。</p>\n</details>\n<details>\n<p><summary><strong>多组元素两两配对，要求同一组间不成对：</strong></summary></p>\n<p>设元素总数为 <span class=\"math inline\">\\(2n\\)</span>，则有解当且仅当最大的一组元素数不超过 <span class=\"math inline\">\\(n\\)</span>。</p>\n<p>若需要输出一种方案，可以看作有两个长为 <span class=\"math inline\">\\(n\\)</span>、上下并行放置的盒子，现欲用若干元素充满盒子，使得上下对应位置元素不同组。一种简单的构造方式是，把上下两个盒子拼在一起，按任意顺序把所有组连续放入，然后从拼接处断开，上下对应即为一对，容易发现上下元素一定不同组。</p>\n</details>\n<details>\n<p><summary><strong>撤销思想：</strong></summary></p>\n<p>当题目给出『按一定的操作序列，将整块逐步分解为小段，问至晚哪一步后满足条件（需要单调性）』，可以考虑从最后的局面开始考虑，逐步『合并』，并 check 最早合并到哪一步时满足条件。</p>\n<p>Goto <a href=\"/20220808/\">solu to <em>CF567D</em></a></p>\n</details>\n<details>\n<p><summary><strong>双栈模拟双端队列：</strong></summary></p>\n<blockquote>\n<p>用两个栈模拟队列或双端队列。支持两头删除、插入。</p>\n</blockquote>\n<p>一个维护前面的插入、删除；一个维护后面的插入、删除。插入是简单的；删除在大部分情况下是简单的；如果某个栈删空了，将另一个栈的一半挪过来暴力重构即可。均摊复杂度线性。</p>\n<p>复杂度证明：设两栈长度分别为 <span class=\"math inline\">\\(L_1,L_2\\)</span>，定义势能 <span class=\"math inline\">\\(E=|L_1-L_2|\\)</span>。每次插入 / 简单删除带来 <span class=\"math inline\">\\(\\pm 1\\)</span> 的势能变化；一次重构消耗 <span class=\"math inline\">\\(E\\)</span> 的势能，将势能重置为 <span class=\"math inline\">\\(E\\le 1\\)</span>。显然就有均摊线性复杂度了。</p>\n<p>适用场景：类队列 / 双端队列场景，但若固定一个端点就可以向左向右分别简单维护的；如背包等。</p>\n<p>goto <a href=\"/20250520/#贪玩蓝月\">solu to <em>贪玩蓝月</em></a>。</p>\n</details>\n<details>\n<p><summary><strong>线段树维护括号序列：</strong></summary></p>\n<p>每个节点维护左边</p>\n</details>\n<details>\n<p><summary><strong>贪心选取括号序列：</strong></summary></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(a_1\\sim a_{2N}\\)</span>，选取一个合法的长度为 <span class=\"math inline\">\\(2N\\)</span> 的括号序列，记权值为所有 <span class=\"math inline\">\\((\\)</span> 所在位置的 <span class=\"math inline\">\\(a\\)</span> 值之和，最大化权值。</p>\n</blockquote>\n<p><span class=\"math inline\">\\(a_1\\)</span> 显然为 <code>(</code>，<span class=\"math inline\">\\(a_{2N}\\)</span> 显然为 <code>)</code>；</p>\n<p>对于 <span class=\"math inline\">\\(a_2\\sim a_{2N-1}\\)</span>，从前往后扫，每次把两个连续元素放在一起考虑，进行如下操作：</p>\n<ul>\n<li>把这两个连续元素放到『可用来作 <code>(</code>』的队列里。</li>\n<li>贪心地从队列里挑选 <span class=\"math inline\">\\(a\\)</span> 最大的元素，令其为 <code>(</code>。</li>\n</ul>\n<blockquote>\n<p><strong>正确性证明</strong></p>\n<p>即证：可构造出来的序列 <span class=\"math inline\">\\(\\iff\\)</span> 合法的序列；构造出来的序列最优。</p>\n<ul>\n<li><p>必要性：</p>\n<p>我们知道，括号序列合法 <span class=\"math inline\">\\(\\iff\\)</span> 对于任意 <span class=\"math inline\">\\(i\\)</span>，<span class=\"math inline\">\\(1\\sim i\\)</span> 中的 <code>)</code> 的数量不超过 <code>(</code>。</p>\n对于任意 <span class=\"math inline\">\\(i=2k+1\\)</span>，前 <span class=\"math inline\">\\(i\\)</span> 个元素中存在至少 <span class=\"math inline\">\\(k+1\\)</span> 个 <code>(</code>。<strong>且如果任意一步少选，序列不合法</strong>。</li>\n<li><p>充分性：</p>\n<p>也即在我们可以任意选择从队列中挑选哪个元素的情况下，证明任意目标序列都可以被这么构造。</p>\n每次选择目标序列最靠前的未被选的 <code>(</code> 并将其选中。如果有一步不存在这样的位置怎么办？由『必要性』中粗体字得不合法。</li>\n<li><p>最优性：</p>\n<p>首先需要知道每个元素是否被选择是相对独立的。如果两个数都可被选，那么它们的选中状态是互不影响的（除非这是最后一个位置了，但显然这不是我们关注的重点）。</p>\n<p>假设一个 <span class=\"math inline\">\\(a_i\\)</span> 位于最优解序列，但我们没有选择它：说明选中了一个比 <span class=\"math inline\">\\(a_i\\)</span> 更大的元素，可以构造出更优的序列。由此反证。</p></li>\n</ul>\n</blockquote>\n<p>goto <a href=\"/20250520/#abc407e-most-valuable-parentheses\">solu to <em>abc407E</em></a>。</p>\n</details>\n<ul>\n<li><span class=\"math inline\">\\(k\\)</span> 个「二者至少选其一」形式的限制，要求选的尽可能少，使用 <span class=\"math inline\">\\(2^k\\)</span> 枚举后取并集代替 <span class=\"math inline\">\\(3^k\\)</span> 枚举。</li>\n</ul>\n",
            "tags": [
                "下饭"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20231113/",
            "url": "https://xsc062.netlify.app/20231113/",
            "title": "杂题",
            "date_published": "2023-11-13T07:54:34.000Z",
            "content_html": "<p><a href=\"http://222.180.160.110:61235/contest/4434\">NOIP S</a> &amp; <a href=\"https://vjudge.net/contest/594162\">计数杂题</a>。</p>\n<span id=\"more\"></span>\n<hr />\n<h3 id=\"a.-卡门\">A. 卡门</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P6370\" class=\"uri\">https://www.luogu.com.cn/problem/P6370</a></p>\n<p><a href=\"http://222.180.160.110:61235/contest/4434/problem/1\" class=\"uri\">http://222.180.160.110:61235/contest/4434/problem/1</a></p>\n<p>我们惊讶地发现全场没多少人会做绿题。</p>\n<hr />\n<p>就是说呢，我们把它「滚动到相邻行然后落下」的过程直接变成「往左下 / 右下滚」。那么球掉下去的过程呢，就可以理解为它是一直一次往下掉一格的，然后每一次掉落呢，会根据实际情况往左 / 往右 / 直着掉。</p>\n<p>所以我们可以直接用 <span class=\"math inline\">\\(m\\)</span> 个长度为 <span class=\"math inline\">\\(n\\)</span> 的序列，记录从每 <span class=\"math inline\">\\(1\\sim m\\)</span> 列扔下去的情况。然后我们很容易可以知道，如果任意两个序列发生了交汇，那么从交汇点开始至序列结束呢，这两个序列的内容都是完全一样的。因为之前序列长什么样子，完全不会对之后产生影响。所以一旦有任意一个状态是一样的，后面都会是一样的。</p>\n<p>所以呢，一旦我们跟着计划好的路线走，却发现走不动了，那就说明从走不动的位置开始，到原定路线结束，这些位置都会被封掉。所以这个时候我们直接重新计算路线就好了。</p>\n<p>对于这 <span class=\"math inline\">\\(m\\)</span> 列，就算每一列预定路线上的每个位置都被占了一次，也只会被更改 <span class=\"math inline\">\\(n\\times m\\)</span> 次；总体时间复杂度只有 <span class=\"math inline\">\\(O(nm^2)\\)</span>。然后又由于不可能跑满，其实是完全没有问题，甚至跑得出溜快的。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxm = 35;\nconst int maxn = 3e4 + 5;\nchar a[maxn][maxm];\nint n, m, q, u, x, y;\nstd::vector&lt;int&gt; p[maxm]; \nint main() &#123;\n#ifdef ONLINE_JUDGE\n    freopen(&quot;kamen.in&quot;, &quot;r&quot;, stdin);\n    freopen(&quot;kamen.out&quot;, &quot;w&quot;, stdout);\n#endif\n    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);\n    for (int i = 1; i &lt;= n; ++i)\n        scanf(&quot;%s&quot;, a[i] + 1);\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        x = 1, y = i;\n        for (;;) &#123;\n            p[i].push_back(y); \n            if (a[x + 1][y] == &#39;.&#39;) ++x;\n            else &#123;\n                if (a[x + 1][y] == &#39;X&#39;) break;\n                if (a[x][y - 1] == &#39;.&#39; &amp;&amp; a[x + 1][y - 1] == &#39;.&#39;)\n                    ++x, --y;\n                else if (a[x][y + 1] == &#39;.&#39; &amp;&amp; a[x + 1][y + 1] == &#39;.&#39;)\n                    ++x, ++y;\n                else break;\n            &#125;\n        &#125;\n    &#125;\n    scanf(&quot;%d&quot;, &amp;q);\n    while (q--) &#123;\n        scanf(&quot;%d&quot;, &amp;u);\n        while (a[p[u].size()][p[u].back()] != &#39;.&#39;)\n            p[u].pop_back();\n        x = p[u].size(), y = p[u].back();\n        for (;;) &#123;\n            p[u].push_back(y); \n            if (a[x + 1][y] == &#39;.&#39;) ++x;\n            else &#123;\n                if (a[x + 1][y] == &#39;X&#39;) break;\n                if (a[x][y - 1] == &#39;.&#39; &amp;&amp; a[x + 1][y - 1] == &#39;.&#39;)\n                    ++x, --y;\n                else if (a[x][y + 1] == &#39;.&#39; &amp;&amp; a[x + 1][y + 1] == &#39;.&#39;)\n                    ++x, ++y;\n                else break;\n            &#125;\n        &#125;\n        a[x][y] = &#39;O&#39;;\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) puts(a[i] + 1);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"b.-商人\">B. 商人</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4434/problem/2\" class=\"uri\">http://222.180.160.110:61235/contest/4434/problem/2</a></p>\n<p>首先忽略图中的环带来的问题，假设 <span class=\"math inline\">\\(f_u\\)</span> 表示从 <span class=\"math inline\">\\(u\\)</span> 点出发的答案，不难想到 DP 式 <span class=\"math inline\">\\(f_u = \\min\\{\\max(f_v-p_{(u,v)}, r_{(u,v)})\\}\\)</span>。</p>\n<p>那么问题来了，图中是会有环的，不能简单地去更新 DP 值。我们首先考虑「根源」，每一个 <span class=\"math inline\">\\(f_u\\)</span> 一定都是由另一个 <span class=\"math inline\">\\(f_v\\)</span> 转移得到的，那么一定会存在一个已知的 <span class=\"math inline\">\\(f_u\\)</span>，不由其他任何 <span class=\"math inline\">\\(f_v\\)</span> 得到。</p>\n<p>考虑一个环中 <span class=\"math inline\">\\(r\\)</span> 最大的一条边 <span class=\"math inline\">\\((u,v)\\)</span>。假设图中只有这一个环，那么 <span class=\"math inline\">\\(f_u\\)</span> 的值一定为 <span class=\"math inline\">\\(r\\)</span>，因为 <span class=\"math inline\">\\(p\\)</span> 只能为非负。这样「根源」就被我们找到了。接下来进一步考虑转移方法。</p>\n<p>一个点 <span class=\"math inline\">\\(u\\)</span> 只能被其相连的点 <span class=\"math inline\">\\(v\\)</span> 更新，那么当且仅当所有 <span class=\"math inline\">\\(f_v\\)</span> 都是确定的，<span class=\"math inline\">\\(f_u\\)</span> 才能被确定，进而去更新 <span class=\"math inline\">\\(u\\)</span> 的前驱。这让我们想到了拓扑排序。如果我们将所有边反向，那么上面的过程几乎就是拓扑排序。</p>\n<p>为了保证任意一个环上的「根源」都能最先被确定，我们按照按 <span class=\"math inline\">\\(r\\)</span> 从大到小遍历每一条边的方式处理问题。对于每一条边 <span class=\"math inline\">\\((u,v)\\)</span>，我们都假设它是「根源」并用 <span class=\"math inline\">\\(r_{(u,v)}\\)</span> 更新 <span class=\"math inline\">\\(f_u\\)</span>。我们其实并不关心 <span class=\"math inline\">\\(u\\)</span> 是否是我们刚刚定义的形式上的「根源」，毕竟，只要 <span class=\"math inline\">\\(f_u\\)</span> 能被 <span class=\"math inline\">\\(r_{(u,v)}\\)</span> 更新，它就能算作广义上的，<strong>当前时刻的</strong>「根源」。</p>\n<p>我们在一开始将出度为 <span class=\"math inline\">\\(0\\)</span>（反图上就是入度为 <span class=\"math inline\">\\(0\\)</span>）的点全部加入队列，在每次加边的时候进行拓扑排序。每次一条边以任意形式被「使用」后，都要打标记删除并不能再访问，以保证转移的正确性和高效。如果一条边被「使用」，分两种情况：</p>\n<ol type=\"1\">\n<li><p>更新「根源」：</p>\n这个时候这条边已经发挥了它的所有作用了，作为 <strong>当前时刻的</strong>「根源」，这条边的源点在未来至少不会再经由这一条边被更新。故可以删除。</li>\n<li><p>拓扑排序中转移：</p>\n<p>一个点被加入队列，说明它的 DP 值是确定的，那么就不用拿一个已经确定的值多次更新另一个 DP 值。故可以删除。</p></li>\n</ol>\n<p>所以正确性是可以保证的。类拓扑排序的结构也保证了算法复杂度 <span class=\"math inline\">\\(O(n+m)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#define int long long\nnamespace XSC062 &#123;\nusing namespace fastIO;\nconst int inf = 1e18;\nconst int maxn = 2e5 + 5;\nconst int maxm = 2e5 + 5;\nstruct _ &#123;\n    int v, r, p, i;\n    _() &#123;&#125;\n    _(int v1, int r1, int p1, int i1) &#123;\n        v = v1, r = r1, p = p1, i = i1;\n    &#125;\n&#125;;\nstruct __ &#123;\n    int x, y, r, p;\n    bool operator&lt; (const __ &amp;q) const &#123;\n        return r &gt; q.r;\n    &#125;\n&#125;;\n__ a[maxm];\nbool del[maxn];\nstd::queue&lt;int&gt; q;\nint n, m, x, y, r, p;\nstd::vector&lt;_&gt; g[maxn];\nint f[maxn], deg[maxn];\nint max(int x, int y) &#123; return x &gt; y ? x : y; &#125;\nint min(int x, int y) &#123; return x &lt; y ? x : y; &#125;\nvoid add(int x, int y, int r, int p, int i) &#123;\n    g[x].emplace_back(y, r, p, i);\n    return;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    freopen(&quot;merchant.in&quot;, &quot;r&quot;, stdin);\n    freopen(&quot;merchant.out&quot;, &quot;w&quot;, stdout);\n#endif\n    read(n), read(m);\n    std::fill(f + 1, f + n + 1, inf);\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        read(a[i].x), read(a[i].y);\n        read(a[i].r), read(a[i].p);\n        ++deg[a[i].x];\n    &#125;\n    std::sort(a + 1, a + m + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        if (!deg[i]) q.push(i);\n    for (int i = 1; i &lt;= m; ++i)\n        add(a[i].y, a[i].x, a[i].r, a[i].p, i);\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        while (!q.empty()) &#123;\n            int t = q.front(); q.pop();\n            for (auto j : g[t]) &#123;\n                if (del[j.i]) continue;\n                del[j.i] = 1;\n                if (f[t] != inf)\n                    f[j.v] = min(f[j.v], max(f[t] - j.p, j.r));\n                if (!--deg[j.v]) q.push(j.v);\n            &#125;\n        &#125;\n        if (!del[i]) &#123;\n            del[i] = 1, f[a[i].x] = min(f[a[i].x], a[i].r);\n            if (!--deg[a[i].x]) q.push(a[i].x);\n        &#125;\n    &#125;\n    for (int i = 1; i &lt;= n; ++i)\n        print(f[i] == inf ? -1 : f[i], &#39; &#39;);\n    putchar(&#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n</details>\n<hr />\n<h3 id=\"a---gerald-and-giant-chess\">A - Gerald and Giant Chess</h3>\n<p><a href=\"https://vjudge.net/contest/594162#problem/A\" class=\"uri\">https://vjudge.net/contest/594162#problem/A</a></p>\n<p>这个呢，一道简单的数数题，但是因为我忘了 DP 容斥怎么打了所以自行思考了很久很久很久，还差最后一点点想出来的时候放弃了去抄题解 /cf</p>\n<p>就是，这种「限制通行」的 DP 容斥（名字是我现场起的）类型的数数题有一种通法，就是首先我们只计算非法方案然后减掉。</p>\n<p>那么非法方案怎么算呢？令 <span class=\"math inline\">\\(f_i\\)</span> 表示一个非法点都不经过，到达 <span class=\"math inline\">\\(i\\)</span> 这个非法点的方案数，那么有 <span class=\"math inline\">\\(f_i=calc(s,i)-\\sum f_j\\times calc(j,i)\\)</span>，其中 <span class=\"math inline\">\\(s\\)</span> 是起点，<span class=\"math inline\">\\(calc(j,i)\\)</span> 是从 <span class=\"math inline\">\\(j\\to i\\)</span> 的方案数。这样就能不重不漏地枚举完所有情况了。</p>\n<p>我们把 <span class=\"math inline\">\\((n,m)\\)</span> 也视作一个非法点然后代入 DP 即可得到答案。</p>\n<details>\n<pre class=\"cpp\"><code>#define int long long\nnamespace XSC062 &#123;\nusing namespace fastIO;\nconst int lim = 3e5;\nconst int mod = 1e9 + 7;\nconst int maxk = 2e3 + 5;\nconst int maxn = 3e5 + 5;\nstruct _ &#123;\n    int x, y;\n    bool operator&lt; (const _ &amp;q) const &#123;\n        return x == q.x ? y &lt; q.y : x &lt; q.x;\n    &#125;\n&#125;;\n_ a[maxk];\nint n, m, k, res; \nint f[maxk], fac[maxn];\nint qkp(int x, int y) &#123;\n    int res = 1;\n    while (y) &#123;\n        if (y &amp; 1) (res *= x) %= mod;\n        (x *= x) %= mod, y &gt;&gt;= 1;\n    &#125;\n    return res;\n&#125;\nint inv(int x) &#123; return qkp(x, mod - 2); &#125;\nint A(int n, int m) &#123;\n    return fac[n] * inv(fac[n - m]) % mod;\n&#125;\nint C(int n, int m) &#123;\n    return A(n, m) * inv(fac[m]) % mod;\n&#125;\nint calc(int i, int j) &#123;\n    int x = a[j].x - a[i].x + 1,\n        y = a[j].y - a[i].y + 1;\n    return C(x + y - 2, y - 1);\n&#125;\nint main() &#123;\n    fac[0] = 1;\n    for (int i = 1; i &lt;= lim; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    bool flag = 0;\n    read(n), read(m), read(k);\n    for (int i = 1; i &lt;= k; ++i) &#123;\n        read(a[i].x), read(a[i].y);\n        flag |= (a[i].x == 1 &amp;&amp; a[i].y == 1);\n        flag |= (a[i].x == n &amp;&amp; a[i].y == m);\n    &#125;\n    a[0].x = a[0].y = 1;\n    if (flag) &#123; print(0, &#39;\\n&#39;); return 0; &#125;\n    ++k, a[k].x = n, a[k].y = m;\n    std::sort(a + 1, a + k + 1);\n    for (int i = 1; i &lt;= k; ++i) &#123;\n        f[i] = calc(0, i);\n        for (int j = 1; j &lt; i; ++j) &#123;\n            if (a[j].x &gt; a[i].x || a[j].y &gt; a[i].y) continue;\n            (f[i] -= f[j] * calc(j, i) % mod) %= mod;\n        &#125;\n    &#125;\n    f[k] = (f[k] % mod + mod) % mod;\n    print(f[k], &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n</details>\n",
            "tags": [
                "Tarjan"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20231112/",
            "url": "https://xsc062.netlify.app/20231112/",
            "title": "杂题",
            "date_published": "2023-11-12T08:42:43.000Z",
            "content_html": "<p><a href=\"http://222.180.160.110:61235/contest/4424\">NOIP S</a> &amp; <a href=\"http://222.180.160.110:61235/contest/4423\">周考 16</a> &amp; 杂题。</p>\n<span id=\"more\"></span>\n<hr />\n<h3 id=\"a.-数字游戏\">A. 数字游戏</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4424/problem/1\" class=\"uri\">http://222.180.160.110:61235/contest/4424/problem/1</a></p>\n<details>\n<p><summary>闲话</summary></p>\n<p>一开始忘了怎么做的然后从 Cindy 的做法开始回忆，一边回忆一边写下文，结果发现写着写着变成 wjf 的做法了 /cf</p>\n<p>upd：变成菌的做法了 /cf /cf /cf</p>\n<p>upd：变成 zmq 的做法了，我已经懒得 /cf 了。</p>\n</details>\n<p>题意转化一下，大致就是一个每次往右拓展一位的询问区间，每次查询该询问区间内最大值并拿走之。</p>\n<p>我们先感性地想，对于一个 <strong>很大的值</strong>，它一进入询问范围就会被当场拿走。</p>\n<p>那如果没有被拿走是因为什么呢？因为在前面积存下来的元素中还有比它大的。</p>\n<p>那为什么前面的比它大的元素没有被当场拿走呢？因为在更前面积存下来的有比这个元素大的…… 那么最开始的积存是怎么来的呢？是最初询问区间为 <span class=\"math inline\">\\([1,p_i]\\)</span> 而非 <span class=\"math inline\">\\([1,1]\\)</span> 导致的。</p>\n<p>被积存下的数被拿出来用掉的时刻，就是往后碰到了一个比它小的值，然后顶替掉这个值被用掉。被顶替的就进入积存区。</p>\n<p>所以这个时候我们直接 <strong>模拟</strong> 积存数被用掉的过程。</p>\n<p>对于全序列中的最大值，当场用掉。次大值呢，若它比最大值先进入询问区间，皆大欢喜，当场用掉；又因为最大值不可能被积存，就算它在最大值之后，也可以当场用掉。</p>\n<p>第三大的，就可能进积存区。假设它要出来，首先要满足出来的时间（在进入积存区之后，有点废话），然后如果它一出来就碰到了比它更大的，很不幸，出不来了。但是因为除了最大和次大之外没有元素比它大了，它就可以在剩下的位置里面随便挑——当然是挑最靠前的。后面的和第三大道理就差不多了。</p>\n<p>所以这个时候我们就可以得到一个大致的做法了，我们把元素从大到小排序，顺便记录一下它进入询问范围的时间 <span class=\"math inline\">\\(t\\)</span>。然后我们优先让这个值在 <span class=\"math inline\">\\(t\\)</span> 时刻直接被拿走。那假如 <span class=\"math inline\">\\(t\\)</span> 这个位置已经被更大的元素占领了，就找这之后第一个空位。</p>\n<p>那么这个「第一个空位」怎么找呢？我们用一个初值为 <span class=\"math inline\">\\(1\\)</span> 的 <span class=\"math inline\">\\(pos\\)</span>，对于当场拿走的情况，肯定是不会有冲突的，所以冲突都发生在积存区。积存区又都是从 <span class=\"math inline\">\\(1\\)</span> 开始的，所以我们只需要对于不是当场拿走的情况，把 <span class=\"math inline\">\\(pos\\)</span> 移到距离 <strong>当前值</strong> 最近的空位然后放进去就可以了。因为 <span class=\"math inline\">\\(pos\\)</span> 全程只会右移，摊出来是 <span class=\"math inline\">\\(O(n)\\)</span> 的。</p>\n<p>因为我们只要在最开始排个序，总时间复杂度 <span class=\"math inline\">\\(O(n\\log n + nq)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#define int long long\nnamespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 1e5 + 5;\nstruct _ &#123;\n    int x, i;\n    bool operator&lt; (const _ &amp;q) const &#123;\n        return x &gt; q.x;\n    &#125;\n&#125;;\n_ a[maxn];\nint flag[maxn];\nint n, m, p, res, pos;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    freopen(&quot;game.in&quot;, &quot;r&quot;, stdin);\n    freopen(&quot;game.out&quot;, &quot;w&quot;, stdout);\n#endif\n    read(n), read(m);\n    for (int i = 1; i &lt;= n; ++i)\n        read(a[i].x), a[i].i = i;\n    std::sort(a + 1, a + n + 1);\n    while (m--) &#123;\n        read(p), res = 0, pos = 1;\n        for (int i = 1; i &lt;= n; ++i)\n            flag[i] = 0;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            int id =\n            (a[i].i &lt; p ? 1 : a[i].i - p + 1);\n            if (flag[id]) &#123;\n                while (flag[pos]) ++pos;\n                flag[pos] = i;\n            &#125;\n            else flag[id] = i;\n        &#125;\n        for (int i = 1, j = 1; i &lt;= n; ++i, j = -j) \n            res += j * a[flag[i]].x;\n        print(res, &#39;\\n&#39;);\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n</details>\n<hr />\n<h3 id=\"b.-过河卒ii\">B. 过河卒II</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4424/problem/2\" class=\"uri\">http://222.180.160.110:61235/contest/4424/problem/2</a></p>\n<p>以及 <a href=\"https://www.luogu.com.cn/problem/P6234\">这</a> 是原题。</p>\n<p>读错题了整整 3.5h /youl</p>\n<p>我们接下来把「特殊格子」记为 <code>-</code>，「特殊格子」四个方向相邻的点记作 <code>O</code>，除此之外的点因为没有可能被选到，我们不做讨论。</p>\n<pre class=\"plain\"><code>  -\n- O -\n  -</code></pre>\n<p>对于一个关键点，我们发现找 T 字本身不太方便，所以我们可以把这个转化成在十字里面抠掉一个最小值。</p>\n<p>接下来，我们假设有另一个关键点的十字和这一个的十字有重合并不相邻，那么大抵是形如这个样子的：</p>\n<pre class=\"plain\"><code>  -   -\n- O - O -\n  -   -</code></pre>\n<p>这个时候，我们发现一共有 7 个 <code>-</code>，一共需要 6 个 <code>-</code>，所以我们试着随便抠掉一个。</p>\n<pre class=\"plain\"><code>  X   | -\n- O - | O -\n  -   | -</code></pre>\n<p>我们发现这个时候一定是能找到一个 <strong>确定的</strong> 方案去划分 T 字的。</p>\n<p>所以对于两个 <code>O</code> 的情况，我们抠掉七个 <code>-</code> 当中的最小值即可。</p>\n<p>接下来假设有三个 <code>O</code>，那么会有 10 个 <code>-</code>，但我们需要 9 个，于是抠掉最小值，依然存在一种 <strong>确定的</strong> 方案去划分 T 字。</p>\n<p>不难发现，<span class=\"math inline\">\\(n\\)</span> 彼此影响还不相邻的 <code>O</code> 会带来 <span class=\"math inline\">\\(3\\times n-1\\)</span> 个 <code>-</code>（小学数学计算即可），我们将最小者删除即可得到最大答案。</p>\n<p>推广一下结论，其实是我们对于 <span class=\"math inline\">\\(x\\)</span> 个相互影响的 <code>O</code>（注意这里 <strong>没有强调</strong> 不相邻），删掉一些使得 <code>-</code> 的数量为 <span class=\"math inline\">\\(3x\\)</span>。</p>\n<p>那么我们又知道对于最理想的情况，也就是上面讲到的相互影响又不相邻，<code>-</code> 的个数是 <span class=\"math inline\">\\(3\\times x+1\\)</span>，我们又只能进行抠掉 <code>-</code> 这一个操作。</p>\n<p>所以对于一个 <code>O/-</code> 连通块，要求其 <code>-</code> 的个数要么是 <span class=\"math inline\">\\(3x\\)</span>（不然 <code>-</code> 就不够用了，以及 <code>-</code> 的缺失是相邻的 <code>O</code> 和边界导致的；边界外的 <code>-</code> 肯定是不能算的），要么为 <span class=\"math inline\">\\(3x+1\\)</span>（只用删一个也保证了正确性）。</p>\n<p>所以我们跑一个类 Flood-fill，一边搜一边找最小的 <code>-</code>，还要统计 <code>-</code> 和 <code>O</code> 的总个数，还要计算 <span class=\"math inline\">\\(sum\\)</span>。然后就完了。</p>\n<p>虽然说这个 Flood-fill 没什么技术含量，但是我们要注意只能从 <code>-</code> 出发只能通往 <code>O</code> 而非另一个 <code>-</code>，因为相邻的两个 <code>-</code> 其实是不会互相交叉的相互影响的。</p>\n<p>Flood-fill 带来的总时间复杂度为 <span class=\"math inline\">\\(O(nm)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxk = 1e6 + 5;\nconst int inf = 0x3f3f3f3f;\nconst int fx[] = &#123; 0, 0, 1, -1 &#125;;\nconst int fy[] = &#123; 1, -1, 0, 0 &#125;;\nint n, m, k, x, y, res;\nint mn, sum, cnt1, cnt2;\nstd::vector&lt;std::vector&lt;int&gt; &gt; a, b, c;\nint min(int x, int y) &#123; return x &lt; y ? x : y; &#125;\nint max(int x, int y) &#123; return x &gt; y ? x : y; &#125;\nvoid DFS(int x, int y) &#123;\n    sum += a[x][y];\n    if (b[x][y] == 1) ++cnt1;\n    else ++cnt2, mn = min(mn, a[x][y]);\n    c[x][y] = 1;\n    for (int i = 0; i &lt; 4; ++i) &#123;\n        int nx = x + fx[i],\n            ny = y + fy[i];\n        if (!nx || !ny || nx &gt; n || ny &gt; m)\n            continue;\n        if (c[nx][ny]) continue;\n        if ((b[x][y] == 1 &amp;&amp; b[nx][ny] == 1)\n         || (b[x][y] == 1 &amp;&amp; b[nx][ny] == 2)\n          || (b[x][y] == 2 &amp;&amp; b[nx][ny] == 1))\n            DFS(nx, ny);\n    &#125;\n    return;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    freopen(&quot;pawn.in&quot;, &quot;r&quot;, stdin);\n    freopen(&quot;pawn.out&quot;, &quot;w&quot;, stdout);\n#endif\n    read(n), read(m);\n    a.push_back(std::vector&lt;int&gt;(m + 1));\n    b.push_back(std::vector&lt;int&gt;(m + 1));\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        a.push_back(std::vector&lt;int&gt;(m + 1));\n        b.push_back(std::vector&lt;int&gt;(m + 1));\n        for (int j = 1; j &lt;= m; ++j)\n            read(a[i][j]);\n    &#125;\n    c = b, read(k);\n    for (int i = 1; i &lt;= k; ++i) &#123;\n        read(x), read(y), ++x, ++y;\n        b[x][y] = 1;\n        if (x + 1 &lt;= n &amp;&amp; !b[x + 1][y]) b[x + 1][y] = 2;\n        if (y + 1 &lt;= m &amp;&amp; !b[x][y + 1]) b[x][y + 1] = 2;\n        if (x - 1 &gt;= 1 &amp;&amp; !b[x - 1][y]) b[x - 1][y] = 2;\n        if (y - 1 &gt;= 1 &amp;&amp; !b[x][y - 1]) b[x][y - 1] = 2;\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = 1; j &lt;= m; ++j) &#123;\n            if (b[i][j] &amp;&amp; !c[i][j]) &#123;\n                mn = inf;\n                cnt1 = cnt2 = sum = 0;\n                DFS(i, j);\n                if (cnt2 == cnt1 * 3) res += sum;\n                else if (cnt2 == cnt1 * 3 + 1) res += sum - mn;\n                else &#123; puts(&quot;No&quot;); return 0; &#125;\n            &#125;\n        &#125;\n    &#125;\n    print(res, &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"c.-树图\">C. 树图</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4424/problem/3\" class=\"uri\">http://222.180.160.110:61235/contest/4424/problem/3</a></p>\n<blockquote>\n<p>DJ：你们去打一下动态树 DP 的板子就可以了。</p>\n</blockquote>\n<p>此时无声胜有声。</p>\n<p>这里仅仅介绍一下 40pts 的做法。我们理所当然地想到 DP 一个点染成某种颜色所需的最小代价。</p>\n<p>这里说的染成某种颜色其实不太准确，应该是「代表着」哪种颜色。像 0 可以代表 1 也可以代表 2，1 就只能代表 1，2 也只能代表 2。</p>\n<p>令 <span class=\"math inline\">\\(f_{u,1}\\)</span> 表示以 <span class=\"math inline\">\\(u\\)</span> 为根的子树中不保留颜色 2 的最小代价（代表 1），<span class=\"math inline\">\\(f_{u, 2}\\)</span> 表示以 <span class=\"math inline\">\\(u\\)</span> 为根的子树中不保留颜色 1 的最小代价（代表 2）。</p>\n<p>那么对于颜色已经确定为 <span class=\"math inline\">\\(1\\)</span> 的点 <span class=\"math inline\">\\(u_1\\)</span>，<span class=\"math inline\">\\(f_{u_1,2}=\\inf\\)</span>；对于颜色已经确定为 <span class=\"math inline\">\\(2\\)</span> 的点 <span class=\"math inline\">\\(u_2\\)</span>，<span class=\"math inline\">\\(f_{u_2,1}=\\inf\\)</span>；颜色为 0 的 <span class=\"math inline\">\\(u_0\\)</span> 就不用管。</p>\n<p>然后如果 <span class=\"math inline\">\\(u_1\\)</span> 有一个 2 颜色的儿子 <span class=\"math inline\">\\(v_2\\)</span>，就要切断这条边；反之，如果这个儿子的颜色为 1，就不用切断。</p>\n<p>所以有：</p>\n<p><span class=\"math display\">\\[\nf_{u,c}=\\sum_{v\\in son_u} \\min(f_{v,c},f_{v,3-c}+1)\n\\]</span></p>\n<p>那么就完了。每次询问的时候跑一个完整的树 DP，或者我们也可以发现只用更新 <span class=\"math inline\">\\(u\\)</span> 到目标点这一条链上的 DP 值，然后就可以根据这个做一个并不会实际改进复杂度的优化。</p>\n<p>总体时间复杂度 <span class=\"math inline\">\\(O(nq)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 1e5 + 5;\nconst int inf = 0x3f3f3f3f;\nint col[maxn];\nint f[maxn][3];\nint n, x, y, q;\nstd::vector&lt;int&gt; g[maxn];\nint min(int x, int y) &#123;\n    return x &lt; y ? x : y;\n&#125;\nvoid DFS(int x, int fa, int to) &#123;\n    f[x][1] = f[x][2] = 0;\n    if (col[x] == 1) f[x][2] = inf;\n    else if (col[x] == 2) f[x][1] = inf;\n    for (auto i : g[x]) &#123;\n        if (i == fa) continue;\n        if (x != to) DFS(i, x, to);\n        f[x][1] += min(f[i][1], f[i][2] + 1);\n        f[x][2] += min(f[i][2], f[i][1] + 1);\n    &#125;\n    return;\n&#125;\nvoid add(int x, int y) &#123;\n    g[x].push_back(y);\n    return;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE \n    freopen(&quot;diagrams.in&quot;, &quot;r&quot;, stdin);\n    freopen(&quot;diagrams.out&quot;, &quot;w&quot;, stdout);\n#endif\n    read(n);\n    for (int i = 1; i &lt; n; ++i) &#123;\n        read(x), read(y);\n        add(x, y), add(y, x);\n    &#125;\n    read(q);\n    while (q--) &#123;\n        read(x), read(y);\n        col[y] = (x &lt;= 2) ? x : 0;\n        DFS(1, -1, y);\n        print(min(f[1][1], f[1][2]), &#39;\\n&#39;);\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"e.-字符串-string\">E. 字符串 string</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4423/problem/5\" class=\"uri\">http://222.180.160.110:61235/contest/4423/problem/5</a></p>\n<p>原题：<a href=\"https://codeforces.com/problemset/problem/756/D\">CF756D - Bacterial Melee</a>。</p>\n<details>\n<p><summary>怪话</summary></p>\n<p>兔子：我谴责你。</p>\n<p>我：？</p>\n<p>兔子：为什么你的 last 要缩写成 <code>la</code>。我没看你题解直接看的代码看了半天没看懂。</p>\n<p>我：不缩写成 <code>la</code> 难道要写成 <code>lst</code> 吗？</p>\n<p>兔子：不然呢？</p>\n<p>好吧，大家都是异教徒。</p>\n</details>\n<p>可以很简单的想到，最终字符串一定由原串中的部分字符，按照其在原串中的顺序，经过若干次重复得到。那么我们把一段连续的相同字符视为一个字符，得到的这个串就是原串的一个子序列。</p>\n<p>所以我们只需要求出原串的不同子序列个数，再经过一定的排列组合就可以求出方案数。</p>\n<p>比如，我们知道一个长度为 <span class=\"math inline\">\\(n\\)</span> 的串中有 <span class=\"math inline\">\\(k\\)</span> 个长度为 <span class=\"math inline\">\\(m\\)</span> 的子序列，那么由插板法可得这 <span class=\"math inline\">\\(k\\)</span> 个子序列会贡献 <span class=\"math inline\">\\(C_{n-1}^{m-1}\\times k\\)</span> 的方案数。</p>\n<p>那么不同子序列个数怎么求呢？显而易见需要 DP，规定 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示一个长度为 <span class=\"math inline\">\\(i\\)</span> 的子序列最后一位为 <span class=\"math inline\">\\(s_j\\)</span> 的方案数，就可以直接 <span class=\"math inline\">\\(f_{i,j}=\\sum f_{i-1,k}\\)</span>。</p>\n<p>但这样做有一个问题，就是会重复计算。假如原串中在 <span class=\"math inline\">\\(i\\)</span> 位置有一个 <code>'o'</code>，<span class=\"math inline\">\\(i+1\\)</span> 位置又有一个 <code>'o'</code>，两个都可以从前面某个位置（假设为 <span class=\"math inline\">\\(j\\)</span>；假设 <span class=\"math inline\">\\(j\\)</span> 上其中一个被计入方案数的合法子序列为 <code>\"hyac\"</code>），那么转移到 <span class=\"math inline\">\\(i\\)</span> 时，计算了 <code>\"hyaco\"</code>，到了 <span class=\"math inline\">\\(i+1\\)</span>，依然可以从 <span class=\"math inline\">\\(j\\)</span> 处得到 <code>\"hyaco\"</code>，就会重复计算。</p>\n<p>那么怎么避免这一点呢？对于一个位置 <span class=\"math inline\">\\(i\\)</span>，假设其上一个相同字母的位置为 <span class=\"math inline\">\\(last_i\\)</span>，我们规定其仅可从 <span class=\"math inline\">\\((last_i,i)\\)</span> 进行转移即可（注意两边都是开区间）。</p>\n<p>初始化是对于每一个没有前驱的 <span class=\"math inline\">\\(i\\)</span>，<span class=\"math inline\">\\(f_{1,i}=1\\)</span>。</p>\n<p>实现上，因为 <span class=\"math inline\">\\(n\\)</span> 的大小是 <span class=\"math inline\">\\(5\\times 10^3\\)</span>，转移区间又是连续的，我们用一个前缀和进行优化即可。</p>\n<p>时间复杂度 <span class=\"math inline\">\\(O(n^2)\\)</span>，应该比官方题解讲的方法具象一些。</p>\n<details>\n<pre class=\"cpp\"><code>#define int long long\nnamespace XSC062 &#123;\nusing namespace fastIO;\nconst int mod = 1e9 + 7;\nconst int maxn = 5e3 + 5;\nint n, res;\nchar s[maxn];\nint fac[maxn];\nint la[maxn], p[maxn];\nint f[maxn][maxn], u[maxn][maxn];\nint max(int x, int y) &#123; return x &gt; y ? x : y; &#125;\nint qkp(int x, int y) &#123;\n    int res = 1;\n    while (y) &#123;\n        if (y &amp; 1) (res *= x) %= mod;\n        (x *= x) %= mod, y &gt;&gt;= 1;\n    &#125;\n    return res;\n&#125;\nint inv(int x) &#123; return qkp(x, mod - 2); &#125;\nint A(int n, int m) &#123;\n    return fac[n] * inv(fac[n - m]) % mod;\n&#125;\nint C(int n, int m) &#123;\n    return A(n, m) * inv(fac[m]) % mod;\n&#125;\nint main() &#123;\n    scanf(&quot;%lld %s&quot;, &amp;n, s + 1);\n    fac[0] = 1;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        la[i] = p[s[i] - &#39;a&#39; + 1];\n        if (!la[i]) f[1][i] = 1, ++res;\n        u[1][i] = u[1][i - 1] + f[1][i];\n        p[s[i] - &#39;a&#39; + 1] = i;\n        fac[i] = (fac[i - 1] * i) % mod;\n    &#125;\n    for (int i = 2; i &lt;= n; ++i) &#123;\n        int sum = 0;\n        for (int j = i; j &lt;= n; ++j) &#123;\n            int k = max(i - 1, la[j] + 1);\n            if (k &lt;= j - 1)\n                f[i][j] = (u[i - 1][j - 1] - u[i - 1][k - 1]) % mod;\n            u[i][j] = (u[i][j - 1] + f[i][j]) % mod;\n            (sum += f[i][j]) %= mod;\n        &#125;\n        res += C(n - 1, i - 1) * sum % mod;\n        res %= mod;\n    &#125;\n    res = (res + mod) % mod;\n    print(res, &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n</details>\n<hr />\n<h3 id=\"abc328f---good-set-query\">ABC328F - Good Set Query</h3>\n<p><a href=\"https://atcoder.jp/contests/abc328/tasks/abc328_f\" class=\"uri\">https://atcoder.jp/contests/abc328/tasks/abc328_f</a></p>\n<p>一个加权并查集。</p>\n<p>我们用并查集维护关系，在合并两个集合的时候给被合并者的原本根打一个懒标记，意为该并查集需要整体更新的 delta。</p>\n<p>在每次 <code>find</code> 时，路径上的点均从 <strong>直系父亲</strong> 处继承懒标记。然后因为有了路径压缩，所以每个点在查询时均能得到不重复的懒标记（因为自己的祖先已经被直系父亲继承过了）。</p>\n<p>同样也是因为弱势一方才被打标记，保证了根节点上不会有标记，路径压缩后就将父亲更新为根，保证不会因为多次 <code>find</code> 导致标记重复计算。</p>\n<p>每次尝试合并的时候，因为首先需要进行 <code>find</code>，保证 <span class=\"math inline\">\\(x\\)</span> 和 <span class=\"math inline\">\\(y\\)</span> 均是最新状态。若 <span class=\"math inline\">\\(x\\)</span> 和 <span class=\"math inline\">\\(y\\)</span> 已经在同一个集合了，直接判断两个差值是否为 <span class=\"math inline\">\\(d\\)</span>；否则，合并两个集合并给弱势方打上标记。</p>\n<details>\n<pre class=\"cpp\"><code>#define int long long\nnamespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 2e5 + 5;\nint n, q, x, y, d;\nint f[maxn], u[maxn];\nint find(int x) &#123;\n    if (f[x] == x) return x;\n    int fa = find(f[x]);\n    u[x] += u[f[x]];\n    return f[x] = fa;\n&#125;\nbool merge(int x, int y, int d) &#123;\n    int fx = find(x), fy = find(y);\n    if (fx == fy) return u[x] - u[y] == d;\n    f[fx] = fy, u[fx] = d - (u[x] - u[y]);\n    return 1;\n&#125;\nint main() &#123;\n    read(n), read(q);\n    for (int i = 1; i &lt;= n; ++i)\n        f[i] = i;\n    for (int i = 1; i &lt;= q; ++i) &#123;\n        read(x), read(y), read(d);\n        if (merge(x, y, d)) print(i, &#39; &#39;);\n    &#125;\n    putchar(&#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n</details>\n<hr />\n<h3 id=\"cf1701f---points\">CF1701F - Points</h3>\n<p><a href=\"http://codeforces.com/problemset/problem/1701/F\" class=\"uri\">http://codeforces.com/problemset/problem/1701/F</a></p>\n<p>我们先考虑对于一个单点 <span class=\"math inline\">\\(p\\)</span>，假设 <span class=\"math inline\">\\([p-d, p)\\)</span> 中共有 <span class=\"math inline\">\\(k\\)</span> 个点，那么答案就是 <span class=\"math inline\">\\(C_k^2=\\dfrac {k(k-1)}2\\)</span>。</p>\n<p>假如范围内新加入了一个点，<span class=\"math inline\">\\(k\\gets k+1\\)</span>，那么答案就是 <span class=\"math inline\">\\(C_{k+1}^2=\\dfrac {k(k+1)}{2}\\)</span>，较原来增加了 <span class=\"math inline\">\\(k\\)</span>。相应地，若范围内减少了一个点，<span class=\"math inline\">\\(k\\gets k-1\\)</span>，答案较原来就会减少 <span class=\"math inline\">\\(k-1\\)</span>。</p>\n<p>当我们加入一个点 <span class=\"math inline\">\\(p\\)</span>，区间 <span class=\"math inline\">\\((p,p+d]\\)</span> 都会收到影响。假设该区间内原本的每个点之 <span class=\"math inline\">\\(k\\)</span> 的和是 <span class=\"math inline\">\\(s_k\\)</span>，那么总体的答案就会减少 <span class=\"math inline\">\\(s_k\\)</span>。</p>\n<p>那么 <span class=\"math inline\">\\(s_k\\)</span> 怎么去维护呢？插入点 <span class=\"math inline\">\\(p\\)</span> 时，答案先加上当前 <span class=\"math inline\">\\(s_k\\)</span> 和新点的 <span class=\"math inline\">\\(k\\)</span>，再将 <span class=\"math inline\">\\((p, p+d]\\)</span> 内的 <span class=\"math inline\">\\(s_k\\)</span> 全部 +1；删除点 <span class=\"math inline\">\\(p\\)</span> 时，答案减去 <span class=\"math inline\">\\(s_k-c\\)</span> 和待删点的答案（其中 <span class=\"math inline\">\\(c\\)</span> 是 <span class=\"math inline\">\\((p,p+d]\\)</span> 中的点数），再将 <span class=\"math inline\">\\((p, p+d]\\)</span> 内的 <span class=\"math inline\">\\(s_k\\)</span> 全部 -1。</p>\n<details>\n<pre class=\"cpp\"><code>#define int long long\nnamespace XSC062 &#123;\nusing namespace fastIO;\nconst int lim = 2e5;\nconst int maxn = 2e5 + 5;\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nstruct _ &#123; int u, p, d, l, r; &#125;;\n_ t[maxn &lt;&lt; 2];\nint q, d, x, res;\nint min(int x, int y) &#123; return x &lt; y ? x : y; &#125;\nint max(int x, int y) &#123; return x &gt; y ? x : y; &#125;\nvoid pushdown(int p) &#123;\n    if (t[p].d) &#123;\n        t[lt].u += t[lt].p * t[p].d;\n        t[rt].u += t[rt].p * t[p].d;\n        t[lt].d += t[p].d;\n        t[rt].d += t[p].d;\n        t[p].d = 0;\n    &#125;\n    return;\n&#125;\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    if (l == r) return;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    return;\n&#125;\nint ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].p;\n    int res = 0, mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid) res = ask(lt, l, r);\n    if (r &gt; mid) res += ask(rt, l, r);\n    return res;\n&#125;\nint qry(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].u;\n    int res = 0, mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    pushdown(p);\n    if (l &lt;= mid) res = qry(lt, l, r);\n    if (r &gt; mid) res += qry(rt, l, r);\n    return res;\n&#125;\nvoid upd(int p, int l, int r, int x) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        t[p].d += x;\n        t[p].u += t[p].p * x;\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    pushdown(p);\n    if (l &lt;= mid) upd(lt, l, r, x);\n    if (r &gt; mid) upd(rt, l, r, x);\n    t[p].u = t[lt].u + t[rt].u;\n    return;\n&#125;\nvoid clr(int p, int x) &#123;\n    --t[p].p;\n    if (t[p].l == t[p].r) &#123;\n        res -= t[p].u * (t[p].u - 1) / 2;\n        t[p].u = t[p].d = t[p].p = 0;\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    pushdown(p);\n    if (x &lt;= mid) clr(lt, x);\n    else clr(rt, x);\n    t[p].u = t[lt].u + t[rt].u;\n    return;\n&#125;\nvoid add(int p, int x, int v) &#123;\n    ++t[p].p;\n    if (t[p].l == t[p].r) &#123;\n        res += v * (v - 1) / 2;\n        t[p].u = v, t[p].p = 1;\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    pushdown(p);\n    if (x &lt;= mid) add(lt, x, v);\n    else add(rt, x, v);\n    t[p].u = t[lt].u + t[rt].u;\n    return;\n&#125;\nvoid upd(int l, int r, int x) &#123;\n    upd(1, min(l, lim), min(r, lim), x);\n    return;\n&#125;\nint qry(int l, int r) &#123;\n    return qry(1, min(l, lim), min(r, lim));\n&#125;\nint ask(int l, int r) &#123;\n    return ask(1, max(1, min(l, lim)), max(1, min(r, lim)));\n&#125;\nint main() &#123;\n    read(q), read(d);\n    bld(1, 1, lim);\n    while (q--) &#123;\n        read(x);\n        if (ask(x, x)) &#123;\n            int u = qry(x + 1, x + d) - ask(x + 1, x + d);\n            res -= u, upd(x + 1, x + d, -1), clr(1, x);\n        &#125;\n        else &#123;\n            int u = qry(x + 1, x + d);\n            res += u, upd(x + 1, x + d, 1);\n            add(1, x, ask(x - d, x - 1));\n        &#125;\n        print(res, &#39;\\n&#39;);\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n</details>\n",
            "tags": [
                "数据结构"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20231005/",
            "url": "https://xsc062.netlify.app/20231005/",
            "title": "构造",
            "date_published": "2023-10-05T08:42:43.000Z",
            "content_html": "<p><a href=\"https://vjudge.net/contest/585791\">构造杂题</a>。</p>\n<span id=\"more\"></span>\n<hr />\n<h3 id=\"a---errich-tac-toe-hard-version\">A - Errich-Tac-Toe (Hard Version)</h3>\n<p><a href=\"https://vjudge.net/contest/585791#problem/A\" class=\"uri\">https://vjudge.net/contest/585791#problem/A</a></p>\n<p>如果我们将地图按国际象棋式斜向黑白染色分组，规定黑组要么黑色要么无色，白组要么白色要么无色，那么这样是一定不会三连击的。</p>\n<p><img src=\"https://pic.imgdb.cn/item/651e6652c458853aef280846.jpg\" /></p>\n<p>容易发现无色格子永远不会被更改，而在方式 A 中被更改的格子在方式 B 中一定不会被更改；相应地，在方式 A 中不被更改的格子在方式 B 中一定会被更改，故两种染色方式更改的格子数总和就是一开始非无色的格子数。所以根据抽屉原理，一定能找到一种染色方式，代价 <span class=\"math inline\">\\(\\le \\dfrac k2\\)</span>。</p>\n<p>但是我们要找到的，是代价 <span class=\"math inline\">\\(\\le \\dfrac k3\\)</span> 的方案呀？我们观察到我们上面的分组方式，直接让相邻两个不一样了，连二连击都做不到；所以我们要使我们的染色方式更廉价。</p>\n<p>我们仍然斜向染色，但是分为三组：</p>\n<p><img src=\"https://pic.imgdb.cn/item/651e691fc458853aef28c528.jpg\" /></p>\n<p>这样，因为刚才叙述过的原因，一定能找到一种染色方法，代价 <span class=\"math inline\">\\(\\le \\dfrac k3\\)</span>。</p>\n<p>枚举三种方式，取代价最小的一种即可。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 305;\nchar a[maxn][maxn];\nint col[maxn][maxn];\nint T, n, res, id, typ;\nint min(int x, int y) &#123; return x &lt; y ? x : y; &#125;\nint func(int x, int y) &#123;\n    int res = 0;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = 1; j &lt;= n; ++j) &#123;\n            if (col[i][j] == y)\n                res += (a[i][j] == &#39;X&#39;);\n            else if (col[i][j] != x)\n                res += (a[i][j] == &#39;O&#39;);\n        &#125;\n    &#125;\n    return res;\n&#125;\nint main() &#123;\n    scanf(&quot;%d&quot;, &amp;T);\n    while (T--) &#123;\n        scanf(&quot;%d&quot;, &amp;n);\n        int cnt = 0;\n        for (int i = 1; i &lt;= n; ++i)\n            scanf(&quot;%s&quot;, a[i] + 1);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            for (int j = 1; j &lt;= n; ++j)\n                cnt += (a[i][j] != &#39;.&#39;);\n            for (int j = 1; j &lt;= i; ++j)\n                col[j][i - j + 1] = (i - 1) % 3 + 1;\n        &#125;\n        for (int i = 2; i &lt;= n; ++i) &#123;\n            for (int j = 1; j &lt;= n - i + 1; ++j)\n                col[j + i - 1][n - j + 1] = (n + i - 2) % 3 + 1;\n        &#125;\n        res = func(1, 2), id = 1, typ = 2;\n        if (func(1, 3) &lt; res)\n            res = func(1, 3), id = 1, typ = 3;\n        if (func(2, 1) &lt; res)\n            res = func(2, 1), id = 2, typ = 1;\n        if (func(2, 3) &lt; res)\n            res = func(2, 3), id = 2, typ = 3;\n        if (func(3, 1) &lt; res)\n            res = func(3, 1), id = 3, typ = 1;\n        if (func(3, 2) &lt; res)\n            res = func(3, 2), id = 3, typ = 2;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            for (int j = 1; j &lt;= n; ++j) &#123;\n                if (col[i][j] == typ) &#123;\n                    if (a[i][j] == &#39;X&#39;)\n                        a[i][j] = &#39;O&#39;;\n                &#125;\n                else if (col[i][j] != id) &#123;\n                    if (a[i][j] == &#39;O&#39;)\n                        a[i][j] = &#39;X&#39;;\n                &#125;\n            &#125;\n        &#125;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            for (int j = 1; j &lt;= n; ++j)\n                putchar(a[i][j]);\n            putchar(&#39;\\n&#39;);\n        &#125;\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<p>抽屉原理是构造中经常用到的手段，后面我们也会遇到运用了抽屉原理的更多题目。</p>\n<hr />\n<h3 id=\"b---mine-sweeper-ii\">B - Mine Sweeper II</h3>\n<p><a href=\"https://vjudge.net/contest/585791#problem/B\" class=\"uri\">https://vjudge.net/contest/585791#problem/B</a></p>\n<p>观察到答案必须 <span class=\"math inline\">\\(\\le \\dfrac {n\\times m}2\\)</span>，根据在上一道题目得到的经验，考虑找到两种地位相等、并完全相反的方案。</p>\n<p>我们知道，把 B 变成 A 一定可以满足条件；从「完全相反」出发，考虑把所有雷变成空地、所有空地变成雷。</p>\n<p>将空地上的数字视为由空地向周围八格的雷连边，可以连到的边的数量。将地图完全翻转后，边除了起点和终点翻转之外，<strong>没有任何变化</strong>。所以，数字之和不变。</p>\n<p>由此我们就得到了分两组的方案，由抽屉原理，必有一组方案的代价 <span class=\"math inline\">\\(\\le \\dfrac {n\\times m}2\\)</span>，取较小者即可。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 1e3 + 5;\nint n, m, res1, res2;\nchar a[maxn][maxn], b[maxn][maxn];\nint main() &#123;\n    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);\n    for (int i = 1; i &lt;= n; ++i)\n        scanf(&quot;%s&quot;, a[i] + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        scanf(&quot;%s&quot;, b[i] + 1);\n        for (int j = 1; j &lt;= m; ++j) &#123;\n            res1 += (a[i][j] != b[i][j]);\n            res2 += (a[i][j] == b[i][j]);\n        &#125;\n    &#125;\n    if (res1 &lt; res2) &#123;\n        for (int i = 1; i &lt;= n; ++i)\n            puts(a[i] + 1);\n    &#125;\n    else &#123;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            for (int j = 1; j &lt;= m; ++j) &#123;\n                if (a[i][j] == &#39;.&#39;)\n                    putchar(&#39;X&#39;);\n                else putchar(&#39;.&#39;);\n            &#125;\n            putchar(&#39;\\n&#39;);\n        &#125;\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"c---ehabs-last-corollary\">C - Ehab’s Last Corollary</h3>\n<p><a href=\"https://vjudge.net/contest/585791#problem/C\" class=\"uri\">https://vjudge.net/contest/585791#problem/C</a></p>\n<p>我们尝试证明出题人的猜想……</p>\n<ul>\n<li><p>如果整个图上没有环，就整个一棵树</p>\n树呢，是一个二分图对不对，然后抽屉原理，我们看两部节点中比较大的那一坨，它的大小一定是 <span class=\"math inline\">\\(\\ge \\dfrac n2\\)</span> 又 <span class=\"math inline\">\\(\\ge \\dfrac k2\\)</span> 的，直接输出就好了。</li>\n<li>否则，对于一个环，如果它的点数小于等于 <span class=\"math inline\">\\(k\\)</span>，那我们直接将它作为第二个问题的答案输出。</li>\n<li><p>否则，我们在图的最小环上隔一个点选一个点，一定能选出 <span class=\"math inline\">\\(\\left\\lfloor\\dfrac k2\\right\\rfloor\\)</span> 个相互独立的点。你说为什么它们之间没有直接连边呢？因为我们是在一个比 <span class=\"math inline\">\\(k\\)</span> 大的最小环上选的，要是它们之间有直接连边，那就会又构成一个更小的环了。</p>\n<p>所以我们只需要找到一个最小的环然后按上述操作得到答案…… 然而找最小环这一点本身不太现实……</p>\n<p>这个时候我们怎么办呢？</p>\n<p>我们用一点神奇科技。考虑图的 DFS 树。</p>\n<ul>\n<li>如果有返祖边 <span class=\"math inline\">\\((v, u)\\)</span>，且深度 <span class=\"math inline\">\\(d_v-d_u&lt; k\\)</span>，那么 <span class=\"math inline\">\\(u\\to v\\)</span> 在树上的简单路径和返祖边 <span class=\"math inline\">\\((v, u)\\)</span> 共同构成一个长度不超过 <span class=\"math inline\">\\(k\\)</span> 的环，直接输出。</li>\n<li><p>否则，因为 <span class=\"math inline\">\\(d_v-d_u\\ge k\\)</span>，有 <span class=\"math inline\">\\(d_v\\ge k\\)</span>，且对于任意 <span class=\"math inline\">\\(d_y-d_x&lt;k\\)</span>，返祖边 <span class=\"math inline\">\\((y,x)\\)</span> 不存在。</p>\n<p>我们仍然考虑上面提到的隔一个取一个的方法。从任意 <span class=\"math inline\">\\(d_v\\ge k\\)</span> 开始取点，分别取 <span class=\"math inline\">\\(v\\)</span> 的 <span class=\"math inline\">\\(0\\)</span> 代父辈（即自身），<span class=\"math inline\">\\(2\\)</span> 代父辈（即爷爷），<span class=\"math inline\">\\(4\\)</span> 代父辈……</p>\n<p>为什么这么取就不会出 bug 呢？因为我们上面提到的「对于任意 <span class=\"math inline\">\\(d_y-d_x&lt;k\\)</span>，返祖边 <span class=\"math inline\">\\((y,x)\\)</span> 不存在」，所以不会有杂边干扰。</p></li>\n</ul></li>\n</ul>\n<p>时间复杂度 <span class=\"math inline\">\\(O(n + m)\\)</span>。只能说真是妙啊。jly 赛高！</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 1e5 + 5;\nbool vis[maxn];\nint n, m, k, x, y;\nint f[maxn], dep[maxn];\nstd::vector&lt;int&gt; g[maxn];\nint col[maxn], cnt[5];\nvoid color(int x, int fa, int now) &#123;\n    col[x] = now, ++cnt[now];\n    for (auto i : g[x]) &#123;\n        if (i == fa) continue;\n        color(i, x, 3 - now);\n    &#125;\n    return;\n&#125;\nvoid DFS(int x, int fa) &#123;\n    vis[x] = 1;\n    for (auto i : g[x]) &#123;\n        if (i == fa) continue;\n        if (vis[i]) &#123;\n            if (dep[i] &lt; dep[x] &amp;&amp;\n                dep[x] - dep[i] &lt; k) &#123;\n                print(2, &#39;\\n&#39;);\n                int p = x, cnt = 1;\n                while (p != i) ++cnt, p = f[p];\n                print(cnt, &#39;\\n&#39;), p = x;\n                while (p != i) print(p, &#39; &#39;), p = f[p];\n                print(i, &#39;\\n&#39;), exit(0);\n            &#125;\n            continue;\n        &#125;\n        f[i] = x;\n        dep[i] = dep[x] + 1;\n        DFS(i, x);\n    &#125;\n    return;\n&#125;\nvoid add(int x, int y) &#123;\n    g[x].push_back(y);\n    return;\n&#125;\nint main() &#123;\n    read(n), read(m), read(k);\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        read(x), read(y);\n        add(x, y), add(y, x);\n    &#125;\n    if (m == n - 1) &#123;\n        print(1, &#39;\\n&#39;);\n        color(1, -1, 1);\n        k = (k + 1) / 2;\n        x = cnt[1] &gt; cnt[2] ? 1 : 2;\n        for (int i = 1; i &lt;= n &amp;&amp; k; ++i) &#123;\n            if (col[i] == x)\n                print(i, &#39; &#39;), --k;\n        &#125;\n        putchar(&#39;\\n&#39;);\n        return 0;\n    &#125;\n    dep[1] = 1, DFS(1, -1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        if (dep[i] &gt;= k) &#123;\n            print(1, &#39;\\n&#39;);\n            x = i, k = (k + 1) / 2;\n            while (k--)\n                print(x, &#39; &#39;), x = f[f[x]];\n            putchar(&#39;\\n&#39;);\n            break;\n        &#125;\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"d---景点划分\">D - 景点划分</h3>\n<p><a href=\"https://vjudge.net/contest/585791#problem/D\" class=\"uri\">https://vjudge.net/contest/585791#problem/D</a></p>\n<details>\n<p><summary>🤡 前言</summary></p>\n<p>你打开了题目。你想，不就是从图里抠两个连通块出来吗，这也能进 IOI？</p>\n<p>你开始打代码。你突然发现不对劲。你抠掉了一个大小为 <span class=\"math inline\">\\(a\\)</span> 的连通块，然后发现剩下的部分裂成了很多个块，其中根本找不到一个大小 <span class=\"math inline\">\\(\\ge b\\)</span> 的块。</p>\n<p>你发现，事情没有这么简单。</p>\n<p>这是你吗？不，这不是你，这是我，小丑 lym 🤡</p>\n</details>\n<p>不妨设 <span class=\"math inline\">\\(a\\le b\\le c\\)</span>，则由抽屉原理，<span class=\"math inline\">\\(a\\le \\dfrac n3\\)</span>。</p>\n<p>我们从最特殊的情况开始思考。假如图是树，那么答案怎么求呢？</p>\n<p>对于任意一条边，在其左右两边的连通块中，根据抽屉原理，较大者的大小必定 <span class=\"math inline\">\\(\\ge \\dfrac{n}{2}\\)</span>，根据重心的定义，重心必然属于较大连通块。</p>\n<p>后面鸽了。总之先放个代码在这里。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 1e5 + 5;\nint org[5];\nbool book[maxn];\nint solFlag, sumFa, faP;\nint siz[maxn], col[maxn];\nint n, m, a, b, c, x, y, P;\nbool vis[maxn], legSon[maxn];\nstd::vector&lt;int&gt; w[maxn], g[maxn];\nvoid DFS(int x, int fa) &#123;\n    bool flag = 1;\n    vis[x] = 1, siz[x] = 1;\n    for (auto i : w[x]) &#123;\n        if (vis[i]) continue;\n        DFS(i, x);\n        if (siz[i] &gt; n / 2) flag = 0;\n        siz[x] += siz[i];\n        g[x].push_back(i);\n    &#125;\n    if (n - siz[x] &gt; n / 2) flag = 0;\n    if (flag &amp;&amp; !P) &#123;\n        P = x, faP = fa;\n        if (n - siz[x] &gt;= a)\n            solFlag = fa;\n        else &#123;\n            for (auto i : g[x]) &#123;\n                if (siz[i] &gt;= a) &#123;\n                    solFlag = i;\n                    break;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    return;\n&#125;\nvoid fillA(int x) &#123;\n    if (a == 0) return;\n    col[x] = 1, --a;\n    for (auto i : g[x]) fillA(i);\n    return;\n&#125;\nvoid fillB(int x) &#123;\n    if (b == 0) return;\n    col[x] = 2, --b;\n    for (auto i : g[x]) &#123;\n        if (x == P &amp;&amp; i == solFlag)\n            continue;\n        fillB(i);\n    &#125;\n    return;\n&#125;\nvoid fillC(void) &#123;\n    for (int i = 1; i &lt;= n; ++i)\n        if (!col[i]) col[i] = 3;\n    return;\n&#125;\nvoid DFS1(int x) &#123;\n    if (!a || x == P) return;\n    col[x] = 1, --a;\n    for (auto i : g[x]) DFS1(i);\n    return;\n&#125;\nvoid DFS2(int x) &#123;\n    if (b == 0) return;\n    if (!col[x]) col[x] = 2, --b;\n    for (auto i : g[x]) DFS2(i);\n    return;\n&#125;\nvoid func(void) &#123;\n    int pos[5] = &#123;&#125;;\n    if (a &gt;= b &amp;&amp; b &gt;= c) // cba\n        org[1] = 3, org[2] = 2, org[3] = 1;\n    else if (a &gt;= b &amp;&amp; a &gt;= c) // bca\n        org[1] = 2, org[2] = 3, org[3] = 1;\n    else if (a &gt;= b) // bac\n        org[1] = 2, org[2] = 1, org[3] = 3;\n    else if (c &gt;= b) // abc\n        org[1] = 1, org[2] = 2, org[3] = 3;\n    else if (c &gt;= a) // acb\n        org[1] = 1, org[2] = 3, org[3] = 2;\n    else // cab\n        org[1] = 3, org[2] = 1, org[3] = 2;\n    pos[1] = a, pos[2] = b, pos[3] = c;\n    std::sort(pos + 1, pos + 4);\n    a = pos[1], b = pos[2], c = pos[3];\n    return;\n&#125;\nvoid ADD(int x) &#123; // 判断儿子是否合法 \n    if (x == P)\n        return;\n    book[x] = 1;\n    for (auto i : w[x]) &#123;\n        if (i == P &amp;&amp; x != faP) legSon[x] = 1;\n        if (!book[i]) ADD(i);\n    &#125;\n    return;\n&#125;\nvoid DFS3(int x) &#123; // Sub2 染头上 \n    if (!a || x == P) return;\n    col[x] = 1, --a;\n    for (auto i : g[x]) DFS3(i);\n    return;\n&#125;\nvoid DFS4(int x) &#123; // Sub2 染儿子\n    if (a == 0) return;\n    col[x] = 1, --a;\n    for (auto i : g[x]) DFS4(i);\n    return;\n&#125;\nvoid DFS5(int x) &#123; // Sub2 染 B 色\n    if (b == 0) return;\n    col[x] = 2, --b;\n    for (auto i : g[x]) &#123;\n        // 如果子树加入了 A\n        // 那么起码子树的根是会被染的。 \n        if (col[i]) continue;\n        DFS5(i);\n    &#125;\n    return;\n&#125;\nint main() &#123;\n    read(n), read(m);\n    read(a), read(b), read(c), func();\n    while (m--) &#123;\n        read(x), read(y), ++x, ++y;\n        w[x].push_back(y), w[y].push_back(x);\n    &#125;\n    DFS(1, -1);\n    if (solFlag) &#123;\n        if (solFlag == faP) DFS1(1), DFS2(P);\n        else fillA(solFlag), fillB(1);\n        fillC();\n    &#125;\n    else &#123;\n        ADD(1), sumFa = n - siz[P];\n        auto now = g[P].begin(), ex = now;\n        while (sumFa &lt; a) &#123;\n            while (now != g[P].end() &amp;&amp; !legSon[*now]) ++now;\n            if (now == g[P].end()) goto noSol;\n            sumFa += siz[*(ex = now++)];\n        &#125;\n        auto pos = g[P].begin();\n        DFS3(1);\n        for (;; ++pos) &#123;\n            if (!legSon[*pos]) continue;\n            DFS4(*pos);\n            if (pos == ex) break;\n        &#125;\n        DFS5(P), fillC();\n    &#125;\n    noSol: ;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n    #ifdef ONLINE_JUDGE\n        print(org[col[i]], &#39; &#39;);\n    #else\n        print(col[i], &#39; &#39;);\n    #endif\n    &#125;\n    putchar(&#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062\nint main() &#123;\n    XSC062::main();\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"f---strange-housing\">F - Strange Housing</h3>\n<p><a href=\"https://vjudge.net/contest/585791#problem/F\" class=\"uri\">https://vjudge.net/contest/585791#problem/F</a></p>\n<p>是难得一见的小清新题目（经历过前两题的洗礼之后）。</p>\n<p>我们从原图中抽一个生成树出来，比如 DFS 树。</p>\n<p>然后我们又知道树是连通二分图，所以我们按照二分图来染色就可以了。</p>\n<p>但这么做有个 bug，就是树里有返祖边，这就可能会导致二分图的一个部分里出现在原图中相连的点。</p>\n<p>所以我们可以换一种思考方式，把二分图的染色方法带到原图里。</p>\n<p>一个点当且仅当周围有染色点或自身为染色点时是可达的。</p>\n<p>对于一个点，我们先检查其周围一圈有没有染色点；如果有就不能染色。在 DFS 遍历的时候直接染色即可。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 3e5 + 5;\nint col[maxn];\nbool vis[maxn];\nint T, n, m, x, y, cnt;\nstd::vector&lt;int&gt; g[maxn];\nvoid DFS(int x) &#123;\n    vis[x] = 1;\n    for (auto i : g[x]) &#123;\n        if (col[i] == 1) &#123;\n            col[x] = 0;\n            break;\n        &#125;\n    &#125;\n    if (col[x] == -1)\n        ++cnt, col[x] = 1;\n    for (auto i : g[x]) &#123;\n        if (vis[i]) continue;\n        if (col[x] == 1) col[i] = 0;\n        DFS(i);\n    &#125;\n    return;\n&#125;\nvoid add(int x, int y) &#123;\n    g[x].push_back(y);\n    return;\n&#125;\nint main() &#123;\n    read(T);\n    while (T--) &#123;\n        read(n), read(m);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            g[i].clear();\n            g[i].shrink_to_fit();\n            vis[i] = 0, col[i] = -1;\n        &#125;\n        while (m--) &#123;\n            read(x), read(y);\n            add(x, y), add(y, x);\n        &#125;\n        cnt = 0, DFS(1);\n        for (int i = 2; i &lt;= n; ++i) &#123;\n            if (!vis[i]) &#123;\n                puts(&quot;NO&quot;);\n                goto noSol;\n            &#125;\n        &#125;\n        puts(&quot;YES&quot;), print(cnt, &#39;\\n&#39;);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            if (col[i] == 1)\n                print(i, &#39; &#39;);\n        &#125;\n        putchar(&#39;\\n&#39;);\n        noSol: ;\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n",
            "tags": [
                "构造"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20231004/",
            "url": "https://xsc062.netlify.app/20231004/",
            "title": "情景剧",
            "date_published": "2023-10-04T08:42:00.000Z",
            "content_html": "<p>Solution to <a href=\"http://222.180.160.110:61235/contest/4273/problem/1\">情景剧</a>。</p>\n<span id=\"more\"></span>\n<hr />\n<h3 id=\"a.-情景剧\">A. 情景剧</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4273/problem/1\" class=\"uri\">http://222.180.160.110:61235/contest/4273/problem/1</a></p>\n<blockquote>\n<p>给定序列，求任取一段区间，区间最大值、区间最小值、区间长度之积的最大值。</p>\n<p><span class=\"math inline\">\\(N\\le 2\\times 10^6\\)</span>，值域为 <span class=\"math inline\">\\(10^9\\)</span>。</p>\n</blockquote>\n<p>对于 <span class=\"math inline\">\\(a_i\\)</span>，假设它是 <span class=\"math inline\">\\([X_i, Y_i]\\)</span> 内的最大值，且 <span class=\"math inline\">\\([X_i, Y_i]\\)</span> 是该条件下的极大区间；</p>\n<p>相似地，对于 <span class=\"math inline\">\\(a_j\\)</span>，假设它是 <span class=\"math inline\">\\([P_j, Q_j]\\)</span> 内的最小值，且 <span class=\"math inline\">\\([P_j, Q_j]\\)</span> 是该条件下的极大区间；</p>\n<p>则对于 <span class=\"math inline\">\\(a_i\\)</span> 作为区间内最大值，<span class=\"math inline\">\\(a_j\\)</span> 作为区间内最小值的情况，满足该条件的区间为 <span class=\"math inline\">\\([\\max(X_i, P_j), \\min(Y_i, Q_j)]\\)</span>，答案为 <span class=\"math inline\">\\(k=a_i \\times a_j \\times [\\min(Y_i, Q_j) - \\max(X_i, P_j) + 1]\\)</span>。我们的目标就是最大化 <span class=\"math inline\">\\(k\\)</span>。</p>\n<p>两个不固定的值，并且不能拆给斜优做，所以考虑将其中一个变得「固定」。</p>\n<p>观察数组，我们发现，对于数组中的最大值 <span class=\"math inline\">\\(a_m\\)</span>，有 <span class=\"math inline\">\\(X_m = 1,Y_m=n\\)</span>。那么此时选取 <span class=\"math inline\">\\(a_m\\)</span> 作为区间最大值，选取任意数 <span class=\"math inline\">\\(a_j\\)</span> 作为最小值。这样做可以保证由 <span class=\"math inline\">\\(i\\)</span> 带来的影响都是最优的，只用枚举 <span class=\"math inline\">\\(j\\)</span> 并求解即可。此时的答案就是 <span class=\"math inline\">\\(a_m\\times a_j\\times (Q_j-P_j + 1)\\)</span>。</p>\n<p>我们上述条件成立的前提是 <span class=\"math inline\">\\(i\\)</span> 在 <span class=\"math inline\">\\([P_j, Q_j]\\)</span> 内且 <span class=\"math inline\">\\(j\\)</span> 在 <span class=\"math inline\">\\([X_i, Y_i]\\)</span> 内。当 <span class=\"math inline\">\\(i\\)</span> 取 <span class=\"math inline\">\\(m\\)</span> 时后者显然成立，但很容易构造出来情况让前者不成立。比如说 <code>15 1 5</code>，当 <span class=\"math inline\">\\(j=3\\)</span> 时就会得到错误的答案。</p>\n<p>受刚才的思考启发，取 <span class=\"math inline\">\\([P_j, Q_j]\\)</span> 内的最大值作为 <span class=\"math inline\">\\(i\\)</span>。此时有 <span class=\"math inline\">\\(X_i\\le P_j\\le Q_j \\le Y_j\\)</span>，答案为区间内最优。</p>\n<p>接下来需要求解 <span class=\"math inline\">\\(P_j\\)</span> 和 <span class=\"math inline\">\\(Q_j\\)</span>。观察数据范围，应该是 <span class=\"math inline\">\\(O(n)\\)</span> 做法。不难想到单调栈，可惜我不会，所以采用同样是 <span class=\"math inline\">\\(O(n)\\)</span> 的悬线法（<a href=\"/20220927\">我的博客：有关悬线法的介绍</a>）。</p>\n<p>那么怎么求 <span class=\"math inline\">\\([P_j,Q_j]\\)</span> 内的最大值呢？当遇到这种求解区间与左右端点一致，并且待求满足可加性的情况时，我们可以在悬线的时候一起求解。当悬线跨越一个区间时，我们直接用这个已求解区间的最大值更新当前求的最大值。</p>\n<p>左右分别求最大值（注意要用两个数组分别记录，防止错误更新），最后取两者较大作为最终区间内最大值即可。</p>\n<p>最终时间复杂度 <span class=\"math inline\">\\(O(n)\\)</span>。</p>\n<details>\n<p><summary>🌼 鲜花</summary></p>\n<p>不知道为什么听别人说很卡，不卡啊，我一个点 250ms。</p>\n<p>啊什么你们打的 <span class=\"math inline\">\\(O(n\\log n)\\)</span>？因为单调栈信息断层不能维护区间内最大值？菜。那我必须把这篇发出来嘲讽你们了。兔子说要是不打 <code>fread</code> Lemon 上就会起飞，我说我打了，我还疑惑 <span class=\"math inline\">\\(O(n)\\)</span> 跑 <code>2e6</code> 普通快读怎么会寄呢。一问，啊，带 <span class=\"math inline\">\\(\\log\\)</span>，菜。</p>\n<p>啊什么谭委员带 <span class=\"math inline\">\\(\\log\\)</span> 一个点只要 500ms？那也比我慢，菜。</p>\n</details>\n<p>说起来这是我头一次用悬线解决不在矩阵上，还要维护信息的题，之前并没有细想过单调栈和悬线可维护的信息差异，这次算是误打误撞做对了。</p>\n<p>注意到数据范围，应该要开 <code>__int128</code> 吧。</p>\n<details>\n<pre class=\"cpp\"><code>#define int __int128\nnamespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 2e6 + 5;\nint a[maxn];\nint n, mx, res;\nint l[maxn], r[maxn];\nint mxl[maxn], mxr[maxn];\nint max(int x, int y) &#123; return x &gt; y ? x : y; &#125;\nint main() &#123;\n    read(n), l[0] = 1;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        read(a[i]), l[i] = i;\n        mxl[i] = mxr[i] = a[i];\n        while (l[i] &gt; 1 &amp;&amp; a[l[i] - 1] &gt;= a[i]) &#123;\n            mxl[i] = max(mxl[i], mxl[l[i] - 1]);\n            l[i] = l[l[i] - 1];\n        &#125;\n    &#125;\n    r[n + 1] = n;\n    for (int i = n; i; --i) &#123;\n        r[i] = i;\n        while (r[i] &lt; n &amp;&amp; a[r[i] + 1] &gt;= a[i]) &#123;\n            mxr[i] = max(mxr[i], mxr[r[i] + 1]);\n            r[i] = r[r[i] + 1];\n        &#125;\n        res = max(res, max(mxl[i], mxr[i]) * a[i] * (r[i] - l[i] + 1));\n    &#125;\n    print(res, &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n</details>\n<hr />\n<p><em>upd on 240704</em></p>\n<p>我们在 <a href=\"/20220927\">这篇博客</a> 中提到了悬线的本质是笛卡尔树，而本题就是其链上爬山维护数据的一个优秀体现，也是因为这一点，应该更加深切地认识到悬线包含式的访问顺序使之维护的数据类型应和倍增 / 树状数组等类似。</p>\n<p>所以说到可维护数据的复杂程度，笛卡尔树严格大于悬线严格大于单调栈好吧 <img src=\"/em/dy.gif\" /></p>\n<p>虽然现在全世界都知道我是悬线魔怔人了 <img src=\"/em/dy.gif\" /></p>\n",
            "tags": [
                "悬线法"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20231004-1/",
            "url": "https://xsc062.netlify.app/20231004-1/",
            "title": "杂题",
            "date_published": "2023-10-04T08:41:40.000Z",
            "content_html": "<p><a href=\"http://222.180.160.110:61235/contest/4272\">牛客普及</a>。</p>\n<span id=\"more\"></span>\n<hr />\n<h3 id=\"a.-学习求余\">A. 学习求余</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4272/problem/1\" class=\"uri\">http://222.180.160.110:61235/contest/4272/problem/1</a></p>\n<p>今天我们来学习求余！这种题放普及 T1 不合适吧！</p>\n<p>令 <span class=\"math inline\">\\(k=\\left\\lfloor \\dfrac n2 \\right\\rfloor + 1\\)</span>，直接输出 <span class=\"math inline\">\\(k\\times (n - k)\\)</span> 即可。</p>\n<details>\n<p><summary>我是不是证复杂了…</summary></p>\n<p>我们可以简单地发现一个道理，对于任意 <span class=\"math inline\">\\(\\dfrac n2&lt;x\\le n\\)</span>，<span class=\"math inline\">\\(n\\bmod x\\)</span> 的值是 <span class=\"math inline\">\\(n - x\\)</span>；</p>\n<p>根据基本不等式（<del>wjs 直接感动得哭出声来</del>）或小学知识「和不变，差小积大」，我们可以知道当 <span class=\"math inline\">\\(x=\\left\\lfloor \\dfrac n2 \\right\\rfloor + 1\\)</span> 时，<span class=\"math inline\">\\(x\\times (n-x)\\)</span> 取最大值。</p>\n<p>故有：当 <span class=\"math inline\">\\(x=\\left\\lfloor \\dfrac n2 \\right\\rfloor + 1\\)</span> 时，<span class=\"math inline\">\\(x\\times (n\\bmod x)\\)</span> 取最大值。</p>\n<p>而对于 <span class=\"math inline\">\\(y\\le \\dfrac n2\\)</span>，由余数小于除数得，<span class=\"math inline\">\\(n\\bmod y&lt;y\\le \\dfrac n2\\)</span>。由于 <span class=\"math inline\">\\(0&lt;y&lt;x=\\left\\lfloor \\dfrac n2 \\right\\rfloor + 1\\)</span> 且 <span class=\"math inline\">\\(0\\le n\\bmod y\\le \\left\\lfloor \\dfrac n2 \\right\\rfloor - 1\\le n - \\left\\lfloor \\dfrac n2 \\right\\rfloor - 1=n\\bmod x\\)</span>，由不等式的基本性质得 <span class=\"math inline\">\\(x\\times(n\\bmod x)&gt;y\\times (n\\bmod y)\\)</span>。</p>\n<p>综上，对于 <span class=\"math inline\">\\(1\\le x\\le n\\)</span>，当 <span class=\"math inline\">\\(x=\\left\\lfloor \\dfrac n2 \\right\\rfloor + 1\\)</span> 时，<span class=\"math inline\">\\(x\\times (n\\bmod x)\\)</span> 有最大值。</p>\n</details>\n<p>然后如果你要问我怎么发现这一点的呢，我当时没有思路，然后随手输出了 <span class=\"math inline\">\\(n=100\\)</span> 时 <span class=\"math inline\">\\(n\\bmod i\\)</span> 的所有值。然后发现 <span class=\"math inline\">\\(k=51\\)</span> 时余数是 <span class=\"math inline\">\\(49\\)</span>…… 然后就会了。</p>\n<details>\n<pre class=\"cpp\"><code>#define int long long\nnamespace XSC062 &#123;\nusing namespace fastIO;\nint n, k;\nint main() &#123;\n    read(n), k = n / 2 + 1;\n    print(k * (n % k));\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n<p><del>头一次在题解里贴这么短的代码</del></p>\n</details>\n<hr />\n<h3 id=\"b.-提取数字\">B. 提取数字</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4272/problem/2\" class=\"uri\">http://222.180.160.110:61235/contest/4272/problem/2</a></p>\n<p>我被这道题（疑似 T1）坑到了！交了三遍才过！这合理吗？</p>\n<p>首先要开 <code>long long</code>！然后注意，你的判定条件应为「当前是否已存储数」而非「当前存数变量是否为 0」！因为数据中会有单个 0 的情况出现！</p>\n<p>然后就没有了。</p>\n<details>\n<pre class=\"cpp\"><code>#define int long long\nnamespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 1e5 + 5;\nbool flag;\nchar s[maxn]; \nint n, ans, cnt;\nint main() &#123;\n    scanf(&quot;%*s %s&quot;, s + 1);\n    n = strlen(s + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        if (s[i] &gt;= &#39;0&#39; &amp;&amp; s[i] &lt;= &#39;9&#39;)\n            cnt = cnt * 10 + s[i] - &#39;0&#39;, flag = 1;\n        else if (flag)\n            ans += (cnt + 5), cnt = 0, flag = 0;\n    &#125;\n    if (flag) ans += (cnt + 5);\n    print(ans, &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n</details>\n<hr />\n<h3 id=\"c.-武器选择\">C. 武器选择</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4272/problem/3\" class=\"uri\">http://222.180.160.110:61235/contest/4272/problem/3</a></p>\n<details>\n<p><summary>首先是我想了半个小时的狂拽酷炫吊炸天的法一：离线</summary></p>\n<p>我当时一边打一边怀疑现在的普及组是什么神仙，T3 考这么神奇的离线，难道是我落后于时代了？</p>\n<p>（之所以认为这是 T3 是因为括号那道题确实是正常 T4 风格）</p>\n<p>我们预处理出对于每一个可能获得武器 <span class=\"math inline\">\\(i\\)</span> 的位置，应该从哪个位置第一次捡到武器 <span class=\"math inline\">\\(i\\)</span>，由于这一段内的所有武器 <span class=\"math inline\">\\(i\\)</span> 都需要被拾取，我们将其作为区间 <span class=\"math inline\">\\([L_i, R_i]\\)</span> 来记录。</p>\n<p>那么询问可以转化为，在 <span class=\"math inline\">\\([l, r]\\)</span> 内 <strong>不同颜色</strong> <span class=\"math inline\">\\([L_i, R_i]\\)</span> 的数量。</p>\n<p>考虑将询问离线。将询问按左端点从大到小排序，信息区间 <span class=\"math inline\">\\([L_i, R_i]\\)</span> 也按左端点从大到小排序。</p>\n<p>对于每次询问 <span class=\"math inline\">\\(l, r\\)</span>，在树状数组中将被 <span class=\"math inline\">\\([l, n]\\)</span> 完全包含的所有 <span class=\"math inline\">\\([L_i, R_i]\\)</span>（其实就是 <span class=\"math inline\">\\(l\\le L_i\\)</span> 的所有 <span class=\"math inline\">\\(L_i\\)</span>）在右端点 <span class=\"math inline\">\\(R_i\\)</span> 处加一，我们就统计到了可以捡到武器的所有位置。</p>\n<p>怎么区分颜色呢？很简单，我们让每个颜色只被算一次。算哪一次呢？就算当前已加入的 <span class=\"math inline\">\\([L_i, R_i]\\)</span> 内，比选中概率最大的一次。</p>\n<p>我们树状数组统计的是 <span class=\"math inline\">\\([1, r]\\)</span> 内的值，所以我们要让概率最大的话，就要让 <span class=\"math inline\">\\(R_i\\)</span> 尽量的小。</p>\n<p>我们记录每个颜色当前合法 <span class=\"math inline\">\\([L_i, R_i]\\)</span> 的最小右端点 <span class=\"math inline\">\\(\\min_R\\)</span>。加入一个新的 <span class=\"math inline\">\\([L_i, R_i]\\)</span> 时，如果 <span class=\"math inline\">\\(R_i\\ge \\min_R\\)</span>，那么不会产生影响，跳过；否则，当 <span class=\"math inline\">\\(R_i&lt;\\min_R\\)</span> 时，我们就要先消除当前 <span class=\"math inline\">\\(\\min_R\\)</span> 的影响（即在树状数组中将该位置加上的 1 减去），再加上 <span class=\"math inline\">\\(R_i\\)</span> 的影响（即在树状数组中加上该位置的 1）。</p>\n<p>此时我们对 <span class=\"math inline\">\\([1, r]\\)</span> 的询问就是答案。</p>\n<p>复杂度 <span class=\"math inline\">\\(O(n\\log n + m\\log m + m\\log n)\\)</span>，其中 <span class=\"math inline\">\\(n\\log n\\)</span> 来自于对 <span class=\"math inline\">\\([L_i, R_i]\\)</span> 的排序，<span class=\"math inline\">\\(m\\log m\\)</span> 来自于对询问的排序，<span class=\"math inline\">\\(m\\log n\\)</span> 来自于离线树状数组。</p>\n</details>\n<p>接下来讲题解给的正解…… 这个是真的妙。</p>\n<p>考虑所有种类数，在 <span class=\"math inline\">\\(n\\)</span> 个数内满足条件的种类 <span class=\"math inline\">\\(x\\)</span> 最优条件下也不过 <span class=\"math inline\">\\(\\dfrac {x\\times (x+1)}2=n\\)</span>，所以满足条件武器的数量最多只有 <span class=\"math inline\">\\(\\sqrt n\\)</span> 级别。</p>\n<p>所以我们对所有合法种类做前缀和，每次询问检查所有合法种类是否在该区间内出现对应次数，然后统计答案。复杂度 <span class=\"math inline\">\\(O(m\\sqrt n + n\\sqrt n)\\)</span>。<span class=\"math inline\">\\(n\\sqrt n\\)</span> 是前面前缀和来的，<span class=\"math inline\">\\(m\\sqrt n\\)</span> 是暴力统计来的。</p>\n<p>但是根号可耻，所以我的法一更 NB！！！🤡🤡🤡</p>\n<details>\n<p><summary>狂拽酷炫吊炸天的法一代码</summary></p>\n<pre class=\"cpp\"><code>#define int long long\nnamespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 1e5 + 5;\nstruct _ &#123;\n    int l, r, k, i;\n    bool operator&lt; (const _ &amp;q) const &#123;\n        return l &lt; q.l;\n    &#125;\n&#125;;\nstruct __ &#123;\n    int l, r, nxt, x;\n    bool operator&lt; (const __ &amp;q) const &#123;\n        return l &lt; q.l;\n    &#125;\n&#125;;\n_ q[maxn];\n__ a[maxn];\nstd::map&lt;int, int&gt; t;\nstd::vector&lt;int&gt; u[maxn];\nint ans[maxn], now[maxn];\nint mnr[maxn], Bit[maxn];\nint n, m, tot, x, cnt, pos;\nint lowbit(int x) &#123; return x &amp; -x; &#125;\nvoid add(int x, int v) &#123;\n    for (int i = x; i &lt;= n; i += lowbit(i))\n        Bit[i] += v;\n    return;\n&#125;\nint ask(int x) &#123;\n    int res = 0;\n    for (int i = x; i; i -= lowbit(i))\n        res += Bit[i];\n    return res;\n&#125;\nint calc(int x, int k) &#123;\n    int res = 1;\n    for (int i = 1; i &lt;= k; ++i)\n        res *= x--;\n    for (int i = 1; i &lt;= k; ++i)\n        res /= i;\n    return res;\n&#125;\nint main() &#123;\n    read(n);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        read(x);\n        if (!t.count(x)) t[x] = ++tot;\n        int id = t[x];\n        u[id].push_back(i);\n        if ((int)u[id].size() &gt;= x) &#123;\n            a[++cnt].l = u[id][(int)u[id].size() - x];\n            a[cnt].r = i, a[now[id]].nxt = cnt;\n            a[cnt].x = x, mnr[x] = n + 1;\n            now[id] = cnt;\n        &#125;\n    &#125;\n    read(m);\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        read(q[i].l), read(q[i].r);\n        read(q[i].k), q[i].i = i;\n    &#125;\n    std::sort(q + 1, q + m + 1);\n    std::sort(a + 1, a + cnt + 1);\n    pos = cnt;\n    for (int i = m; i; --i) &#123;\n        while (a[pos].l &gt;= q[i].l) &#123;\n            if (a[pos].r &lt; mnr[a[pos].x]) &#123;\n                if (mnr[a[pos].x] &lt;= n)\n                    add(mnr[a[pos].x], -1);\n                add(a[pos].r, 1);\n                mnr[a[pos].x] = a[pos].r;\n            &#125;\n            --pos;\n        &#125;\n        ans[q[i].i] = calc(ask(q[i].r), q[i].k);\n    &#125;\n    for (int i = 1; i &lt;= m; ++i)\n        print(ans[i], &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n<p>我甚至打完了就过了样例然后直接就 A 了，好久没有这么爽地过过这种大码量 <del>正确性还未知</del> 的题了。</p>\n</details>\n<p>而且我相信全场只有我一个 <del>小丑</del> 帅哥打离线，所以我是最强的！！！🤡🤡🤡</p>\n<details>\n<p><summary>绝对不如法一的法二代码</summary></p>\n<pre class=\"cpp\"><code>#define int long long\nnamespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxm = 505;\nconst int maxn = 1e5 + 5;\nint a[maxn];\nint cnt[maxn];\nint sum[maxm][maxn];\nint n, tot, m, l, r, k, res;\nint calc(int x, int k) &#123;\n    int res = 1;\n    for (int i = 1; i &lt;= k; ++i)\n        res *= x--;\n    for (int i = 1; i &lt;= k; ++i)\n        res /= i;\n    return res;\n&#125;\nint main() &#123;\n    read(n);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        read(a[i]);\n        if (a[i] &lt;= n) ++cnt[a[i]];\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        if (cnt[i] &gt;= i) &#123;\n            sum[++tot][n + 1] = i;\n            for (int j = 1; j &lt;= n; ++j)\n                sum[tot][j] = sum[tot][j - 1] + (a[j] == i);\n        &#125;\n    &#125;\n    read(m);\n    while (m--) &#123;\n        read(l), read(r), read(k);\n        res = 0;\n        for (int i = 1; i &lt;= tot; ++i)\n            res += (sum[i][r] - sum[i][l - 1] &gt;= sum[i][n + 1]);\n        print(calc(res, k), &#39;\\n&#39;);\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n</details>\n<hr />\n<h3 id=\"d.-括号序列\">D. 括号序列</h3>\n<p>http://222.180.160.110:61235/contest/4272/problem/4</p>\n<p>呃呃呃，这，有什么好讲的吗？做过原题的应该都会吧……</p>\n<p>反正就是个比较裸的区间 DP，转移的时候注意一下究竟哪些是同一对括号，哪些是相邻括号就好。</p>\n<p>复杂度 <span class=\"math inline\">\\(O(n^2)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 1e3 + 5;\nint n, res;\nchar s[maxn];\nstd::stack&lt;int&gt; t;\nint mat[maxn], c[5];\nint f[maxn][maxn][3][3];\nint max(int x, int y) &#123; return x &gt; y ? x : y; &#125;\nvoid upd(int &amp;x, int y) &#123; x = max(x, y); return; &#125;\nint main() &#123;\n    memset(f, -0x3f, sizeof (f));\n    scanf(&quot;%d %d %d&quot;, &amp;n, &amp;c[1], &amp;c[2]);\n    scanf(&quot;%s&quot;, s + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        if (s[i] == &#39;(&#39;) t.push(i);\n        else mat[t.top()] = i, t.pop();\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        if (mat[i] == i + 1) &#123;\n            for (int k = 0; k &lt;= 2; ++k)\n                f[i][i + 1][k][k] = c[k];\n        &#125;\n    &#125;\n    for (int l = 4; l &lt;= n; l += 2) &#123;\n        for (int i = 1; i &lt;= n - l + 1; ++i) &#123;\n            int j = i + l - 1;\n            if (mat[i] == j) &#123;\n                // ((...))\n                // xy...zx\n                for (int x = 0; x &lt;= 2; ++x) &#123;\n                    for (int y = 0; y &lt;= 2; ++y) &#123;\n                        if (y == x) continue;\n                        for (int z = 0; z &lt;= 2; ++z) &#123;\n                            if (z == x) continue;\n                            upd(f[i][j][x][x], f[i + 1][j - 1][y][z] + c[x]);\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n            else &#123;\n                // ()(...)\n                // xxy...z\n                for (int x = 0; x &lt;= 2; ++x) &#123;\n                    for (int y = 0; y &lt;= 2; ++y) &#123;\n                        if (y == x) continue;\n                        for (int z = 0; z &lt;= 2; ++z)\n                            upd(f[i][j][x][z], f[i][mat[i]][x][x] + f[mat[i] + 1][j][y][z]);\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    for (int i = 0; i &lt;= 2; ++i) &#123;\n        for (int j = 0; j &lt;= 2; ++j)\n            res = max(res, f[1][n][i][j]);\n    &#125;\n    print(res, &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n",
            "tags": [
                "树状数组",
                "区间 DP"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20231003/",
            "url": "https://xsc062.netlify.app/20231003/",
            "title": "杂题",
            "date_published": "2023-10-03T08:42:43.000Z",
            "content_html": "<p><a href=\"http://222.180.160.110:61235/contest/4268\">周考 14</a>。</p>\n<span id=\"more\"></span>\n<hr />\n<p>医生问我对药有什么要求吗，我说我宁死不喝冲剂。</p>\n<p>然后医生给我开了五盒胶囊，告诉我说一天三次，一次六个。</p>\n<p>哈哈哈，我自找的。以此为证，A 一道题磕一片！！！</p>\n<hr />\n<h3 id=\"a.-修改序列\">A. 修改序列</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4268/problem/1\" class=\"uri\">http://222.180.160.110:61235/contest/4268/problem/1</a></p>\n<p>注意到一增一减，全数列的和 <span class=\"math inline\">\\(s\\)</span> 不变，考虑这一点带来的提示。</p>\n<p>假设最后要求一部分数为 <span class=\"math inline\">\\(p\\)</span>，另一部分为 <span class=\"math inline\">\\(p+1\\)</span>，那么有 <span class=\"math inline\">\\(p = \\lfloor \\dfrac sn \\rfloor\\)</span>，<span class=\"math inline\">\\(p+1\\)</span> 的数量 <span class=\"math inline\">\\(c_r=s\\bmod n\\)</span>，<span class=\"math inline\">\\(p\\)</span> 的数量 <span class=\"math inline\">\\(c_l=n-c_r\\)</span>。</p>\n<p>那么我们让 <span class=\"math inline\">\\(\\le p\\)</span> 的变成 <span class=\"math inline\">\\(p\\)</span>，<span class=\"math inline\">\\(\\ge p + 1\\)</span> 的变成 <span class=\"math inline\">\\(p + 1\\)</span>。直接求两数距离，最后将总和除以二即为答案、</p>\n<details>\n<p><summary>正确性证明…</summary></p>\n<p>这样做的最优性毫无疑问，问题无非就在于这么做的正确性，换言之，为什么一定能找到合法的操作序列还原我们的求解过程。</p>\n<p>将原数列分为两部分，数值 <span class=\"math inline\">\\(\\le p\\)</span> 的（记为 <span class=\"math inline\">\\(X\\)</span>）和数值 <span class=\"math inline\">\\(\\ge p + 1\\)</span> 的（记为 <span class=\"math inline\">\\(Y\\)</span>）。</p>\n<p>再把我们的目标状态分为两部分，数值 <span class=\"math inline\">\\(= p\\)</span> 的（记为 <span class=\"math inline\">\\(A\\)</span>）和 数值 <span class=\"math inline\">\\(=p + 1\\)</span> 的（记为 <span class=\"math inline\">\\(B\\)</span>）。</p>\n<p>那么有 <span class=\"math inline\">\\(\\begin{cases}X+Y=s\\\\A+B=s\\end{cases}\\)</span>，由等式的基本性质得 <span class=\"math inline\">\\(X-A+Y-B = 0\\)</span>，移项得 <span class=\"math inline\">\\(Y-B=A-X\\)</span>。也就是说，<span class=\"math inline\">\\(Y\\)</span> 部分与 <span class=\"math inline\">\\(p+1\\)</span> 的差的总和正好等于 <span class=\"math inline\">\\(X\\)</span> 部分与 <span class=\"math inline\">\\(p\\)</span> 的差的总和。</p>\n<p>这个时候我们的正确性就有了保证。</p>\n<p>这个时候你可能就有疑问了，<span class=\"math inline\">\\(X,Y\\)</span> 中的元素个数和 <span class=\"math inline\">\\(A,B\\)</span> 中的元素个数并不对应，怎么办呢？</p>\n<p>我们发现上面的原理式并不会随元素个数的变化而变化，所以依然可以用它来解答这个问题。没有人规定 <span class=\"math inline\">\\(Y-B\\)</span> 和 <span class=\"math inline\">\\(A-X\\)</span> 不能为负，为负时我们把 <span class=\"math inline\">\\(A\\)</span> 中塞不下的 <span class=\"math inline\">\\(X\\)</span> 拿到 <span class=\"math inline\">\\(B\\)</span> 里面去即可，反之同理。</p>\n</details>\n<p>那么代码还是很好写的。时间复杂度 <span class=\"math inline\">\\(O(n)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 2e5 + 5;\nint a[maxn];\nint n, s, p, cl, cg, res;\nint main() &#123;\n    read(n);\n    for (int i = 1; i &lt;= n; ++i)\n        read(a[i]), s += a[i];\n    p = s / n, cg = s - p * n, cl = n - cg;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        if (a[i] &lt;= p) &#123;\n            if (cl) res += p - a[i], --cl;\n            else res += p - a[i] + 1, --cg;\n        &#125;\n        else &#123;\n            if (cg) res += a[i] - p - 1, --cg;\n            else res += a[i] - p, --cl;\n        &#125;\n    &#125;\n    print(res / 2, &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"b.-knuth-表示法\">B. Knuth 表示法</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4268/problem/2\" class=\"uri\">http://222.180.160.110:61235/contest/4268/problem/2</a></p>\n<p>模拟。输入的数用 <code>map</code> 转化为 <span class=\"math inline\">\\(10\\)</span> 的次幂形式，然后幂次直接相加即表示指数相乘。</p>\n<p>最后按位数从大到小将次幂形式转化为字符串、再按位数从小到大输出。</p>\n<p>注意到开头的字符串不是 <code>one</code> 就是 <code>ten</code>，需要在没有抽出来 <code>ten</code> 的时候补 <code>one</code>。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nusing str = std::string;\nconst str u[] = &#123; &quot;one&quot;, &quot;ten&quot;, &quot;hundred&quot;, &quot;myriad&quot;, &quot;myllion&quot;, &quot;byllion&quot;, &quot;tryllion&quot;,\n                  &quot;quadryllion&quot;, &quot;quintyllion&quot;, &quot;sextyllion&quot;, &quot;septyllion&quot;, &quot;octyllion&quot;,\n                  &quot;nonyllion&quot;, &quot;decyllion&quot; &#125;;\nstr x;\nint res = 0;\nstd::stack&lt;str&gt; s;\nstd::map&lt;str, int&gt; t;\nvoid get(str &amp;x) &#123;\n    str y;\n    std::stringstream p(x);\n    while (p &gt;&gt; y) &#123;\n        if (y == &quot;one&quot;) continue;\n        res += 1 &lt;&lt; (t[y] - 1);\n    &#125;\n    return;\n&#125;\nint main() &#123;\n    for (int i = 0; i &lt;= 13; ++i) t[u[i]] = i;\n    std::getline(std::cin, x), get(x);\n    std::getline(std::cin, x), get(x);\n    for (int i = 13; i; --i) &#123;\n        if (res &amp; (1 &lt;&lt; (i - 1)))\n            s.push(u[i]), res ^= (1 &lt;&lt; (i - 1));\n    &#125;\n    if (s.top() != &quot;ten&quot;) s.push(&quot;one&quot;);\n    while (!s.empty())\n        std::cout &lt;&lt; s.top() &lt;&lt; &#39; &#39;, s.pop();\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"c.-魔力塔\">C. 魔力塔</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4268/problem/3\" class=\"uri\">http://222.180.160.110:61235/contest/4268/problem/3</a></p>\n<p>神奇的线段树优化建图。这拿来放 T3？不合适吧。</p>\n<p>很好想到对于 <span class=\"math inline\">\\(a_i\\ne -1\\)</span>，连边 <span class=\"math inline\">\\(i\\to a_i\\)</span>；否则，连边 <span class=\"math inline\">\\(i\\to x(x\\in [i+1,\\min(i + k,n+1)])\\)</span>。BFS 遍历，复杂度 <span class=\"math inline\">\\(O(n\\times k)\\)</span>。</p>\n<p>问题在于无用边太多，例如 <span class=\"math inline\">\\(i\\)</span> 和 <span class=\"math inline\">\\(i+1\\)</span> 共同可达的点有整整 <span class=\"math inline\">\\(k-1\\)</span> 个，造成大量浪费。</p>\n<p>考虑到实际进入 BFS 的点只有 <span class=\"math inline\">\\(n\\)</span> 个，及由传送门构成的连通块均呈棒棒糖状（即链套环），我们直接优化掉 <span class=\"math inline\">\\(a_i=-1\\)</span> 时的连边。使用线段树查询 <span class=\"math inline\">\\([i+1,\\min(i + k,n+1)]\\)</span> 内的所有剩余点，连边入队并从线段树中删除。</p>\n<p>这样，每个点只会入队一次（忽视无用环），时间复杂度控制在 <span class=\"math inline\">\\(O(n\\log n)\\)</span>，<span class=\"math inline\">\\(\\log\\)</span> 来源于线段树，写得不好就是 <span class=\"math inline\">\\(\\log^2\\)</span>，写得好一点就只有一个。</p>\n<details>\n<p><summary>然而…</summary></p>\n<p>会 T，因为常数太大了。</p>\n<p>所以我们需要另一种 <span class=\"math inline\">\\(\\log\\)</span> 的做法，并且短小精悍。</p>\n<p>用 <code>set</code> 存储所有未入队的点，每次 <code>lower_bound</code> 并依次弹出、入队。</p>\n</details>\n<p>用迭代器的话代码很短，美汁汁。</p>\n<p>时间复杂度 <span class=\"math inline\">\\(O(n\\log n)\\)</span>，但等我先磕片药先。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 5e5 + 5;\nint a[maxn];\nint n, k, res;\nbool vis[maxn];\nstd::set&lt;int&gt; t;\nstd::vector&lt;int&gt; g[maxn]; \nint max(int x, int y) &#123; return x &gt; y ? x : y; &#125;\nvoid DFS(int x) &#123;\n    res = max(res, x);\n    if (a[x] == -1) &#123;\n        auto p = t.lower_bound(x + 1);\n        while (p != t.end() &amp;&amp; *p &lt;= x + k) &#123;\n            g[x].push_back(*p);\n            t.erase(*p++);\n        &#125;\n    &#125;\n    for (auto i : g[x]) &#123;\n        if (vis[i]) continue;\n        vis[i] = 1, DFS(i);\n    &#125;\n    return;\n&#125;\nint main() &#123;\n    read(n), read(k);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        read(a[i]), t.insert(i + 1);\n        if (~a[i]) g[i].push_back(a[i]);\n    &#125;\n    DFS(1), print(res, &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"d.-卡牌游戏\">D. 卡牌游戏</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4268/problem/4\" class=\"uri\">http://222.180.160.110:61235/contest/4268/problem/4</a></p>\n<p>怎么说呢，爆搜可以拿 80pts！！！然而正解是区间 DP，哭唧唧。他这个数据范围给得很神奇，让人只会往搜索上面想。</p>\n<p>摧毁操作是一换一，不会更改串长，而入栈操作会增加初始串的长度。</p>\n<p>所以我们考虑 <strong>逆序 DP</strong>，从最终状态入手，用 <span class=\"math inline\">\\(f_{x, i, j}\\)</span> 表示是否可以使用一个字符 <span class=\"math inline\">\\(x\\)</span> 经过一系列操作消掉 <span class=\"math inline\">\\(w_{i\\sim j}\\)</span>。</p>\n<p>那么明显若一条摧毁操作为可用字符 <span class=\"math inline\">\\(a\\)</span> 摧毁 <span class=\"math inline\">\\(w_i\\)</span>，有 <span class=\"math inline\">\\(f_{a, i, i} = 1\\)</span>。</p>\n<p>若一条入栈操作为用字符 <span class=\"math inline\">\\(a\\)</span> 换字符 <span class=\"math inline\">\\(b,c\\)</span>，枚举区间断点 <span class=\"math inline\">\\(k\\)</span>，有 <span class=\"math inline\">\\(f_{a, i, j} = f_{b, i, k} \\times f_{c, k + 1, j}\\)</span>。</p>\n<p>最后答案为 <span class=\"math inline\">\\(f_{\\texttt S,i,|w_i|}\\)</span>。</p>\n<p>注意循环顺序，区间的枚举应在字符的枚举之外。最终时间复杂度 <span class=\"math inline\">\\(O(T\\times |w_i|^3\\times N_2)\\)</span>，注意到字母的枚举属于常数。胶囊好吃滴捏。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 25;\nconst int maxm = 1e3 + 5;\nint n, m, l;\nchar w[maxn];\nbool r1[maxm][maxm];\nbool f[maxm][maxn][maxn];\nstruct &#123; int u, a, b; &#125; r2[maxn];\nint main() &#123;\n    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        scanf(&quot;%s&quot;, w + 1);\n        r1[(int)w[1]][(int)w[4]] = 1;\n    &#125;\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        scanf(&quot;%s&quot;, w + 1);\n        r2[i].u = w[1];\n        r2[i].a = w[4], r2[i].b = w[5];\n    &#125;\n    while (~scanf(&quot;%s&quot;, w + 1)) &#123;\n        memset(f, 0, sizeof (f));\n        l = strlen(w + 1);\n        for (int i = &#39;A&#39;; i &lt;= &#39;Z&#39;; ++i) &#123;\n            for (int j = 1; j &lt;= l; ++j) &#123;\n                if (r1[i][(int)w[j]])\n                    f[i][j][j] = 1;\n            &#125;\n        &#125;\n        for (int len = 1; len &lt;= l; ++len) &#123;\n            for (int i = 1; i &lt;= l - len + 1; ++i) &#123;\n                int j = i + len - 1;\n                for (int t = &#39;A&#39;; t &lt;= &#39;Z&#39;; ++t) &#123;\n                    for (int k = i; k &lt; j; ++k) &#123;\n                        for (int p = 1; p &lt;= m; ++p) &#123;\n                            if (r2[p].u != t) continue;\n                            f[t][i][j] |= f[r2[p].a][i][k] &amp;&amp; f[r2[p].b][k + 1][j];\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        puts(f[&#39;S&#39;][1][l] ? &quot;YES&quot; : &quot;NO&quot;);\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"e.-生长树\">E. 生长树</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4268/problem/5\" class=\"uri\">http://222.180.160.110:61235/contest/4268/problem/5</a></p>\n<p>一道很菜的题。我们发现有子树操作，第一时间想到树剖，那么接下来要考虑的内容就是线段树如何维护。</p>\n<p>题意换句话说就是往下数 0 代是加，数 1 代是减，数 2 代是加，以此类推。那么不难想到奇偶性。</p>\n<p>如果起点的深度是奇数，那么子树中所有奇数深度权值增加，偶数深度权值减少，反之同理。</p>\n<p>但是我们操作线段树的时候怎么知道点在树中的深度奇偶性呢？我们只能在线段树外才知道呀。</p>\n<p>所以观察询问，询问是单点的，所以我们知道了，可以只在线段树外对奇偶性进行处理。简单来说，假设更改起点深度为奇数，那么增加整个子树的「奇加偶减计数器」；反之，增加整个子树的「奇减偶加计数器」。</p>\n<p>最后查询的时候，如果该点深度为奇，那么答案为对应的「奇加偶减计数器」减去「奇减偶加计数器」的值，反之同理。</p>\n<p>做到最后发现根本不用树剖，就是一个 DFN 上线段树。时间复杂度 <span class=\"math inline\">\\(O(m\\log n)\\)</span>。</p>\n<p>胶囊真好吃！！！</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nconst int maxn = 2e5 + 5;\nstruct _ &#123;\n    int l, r;\n    int u1, u2, d1, d2;\n&#125;; \n_ t[maxn &lt;&lt; 2];\nint a[maxn], dep[maxn];\nstd::vector&lt;int&gt; g[maxn];\nint n, m, x, y, tot, typ;\nint end[maxn], dfn[maxn], tab[maxn];\n// u 只用维护最底层信息\n// 所以不用打 pushup \n// 但维护起来好看一些 所以还是打了\nvoid pushup(int p) &#123;\n    t[p].u1 = t[lt].u1 + t[rt].u1;\n    t[p].u2 = t[lt].u2 + t[rt].u2;\n    return;\n&#125;\nvoid pushdown(int p) &#123;\n    if (t[p].d1) &#123;\n        t[lt].d1 += t[p].d1;\n        t[rt].d1 += t[p].d1;\n        t[lt].u1 += t[p].d1 * (t[lt].r - t[lt].l + 1);\n        t[rt].u1 += t[p].d1 * (t[rt].r - t[rt].l + 1);\n        t[p].d1 = 0;\n    &#125;\n    if (t[p].d2) &#123;\n        t[lt].d2 += t[p].d2;\n        t[rt].d2 += t[p].d2;\n        t[lt].u2 += t[p].d2 * (t[lt].r - t[lt].l + 1);\n        t[rt].u2 += t[p].d2 * (t[rt].r - t[rt].l + 1);\n        t[p].d2 = 0;\n    &#125;\n    return;\n&#125;\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        if (dep[tab[l]] &amp; 1)\n            t[p].u1 = a[tab[l]];\n        else t[p].u2 = a[tab[l]];\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    pushup(p);\n    return;\n&#125;\nvoid add1(int p, int l, int r, int x) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        t[p].d1 += x;\n        t[p].u1 += (t[p].r - t[p].l + 1) * x;\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    pushdown(p);\n    if (l &lt;= mid) add1(lt, l, r, x);\n    if (r &gt; mid) add1(rt, l, r, x);\n    pushup(p);\n    return;\n&#125;\nvoid add2(int p, int l, int r, int x) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        t[p].d2 += x;\n        t[p].u2 += (t[p].r - t[p].l + 1) * x;\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    pushdown(p);\n    if (l &lt;= mid) add2(lt, l, r, x);\n    if (r &gt; mid) add2(rt, l, r, x);\n    pushup(p);\n    return;\n&#125;\nint ask(int p, int x) &#123;\n    if (t[p].l == t[p].r)\n        return t[p].u1 - t[p].u2;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    pushdown(p);\n    if (x &lt;= mid) return ask(lt, x);\n    return ask(rt, x);\n&#125;\nvoid DFS(int x, int fa) &#123;\n    dfn[x] = ++tot, tab[tot] = x;\n    for (auto i : g[x]) &#123;\n        if (i == fa) continue;\n        dep[i] = dep[x] + 1;\n        DFS(i, x);\n    &#125;\n    end[x] = tot;\n    return;\n&#125;\nvoid add(int x, int y) &#123;\n    g[x].push_back(y);\n    return;\n&#125;\nint main() &#123;\n    read(n), read(m);\n    for (int i = 1; i &lt;= n; ++i)\n        read(a[i]);\n    for (int i = 1; i &lt; n; ++i) &#123;\n        read(x), read(y);\n        add(x, y), add(y, x);\n    &#125;\n    dep[1] = 1, DFS(1, -1);\n    bld(1, 1, n);\n    while (m--) &#123;\n        read(typ), read(x);\n        if (typ == 1) &#123;\n            read(y);\n            if (dep[x] &amp; 1)\n                add1(1, dfn[x], end[x], y);\n            else add2(1, dfn[x], end[x], y);\n        &#125;\n        else &#123;\n            int res = ask(1, dfn[x]);\n            if (dep[x] &amp; 1)\n                print(res, &#39;\\n&#39;);\n            else print(-res, &#39;\\n&#39;);\n        &#125;\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"f.-单词\">F. 单词</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4268/problem/6\" class=\"uri\">http://222.180.160.110:61235/contest/4268/problem/6</a></p>\n<p><span class=\"math inline\">\\(n \\le 20\\)</span>，考虑状压。用 <span class=\"math inline\">\\(f_x\\)</span> 表示状态为 <span class=\"math inline\">\\(x\\)</span> 时的最小代价，其中 <span class=\"math inline\">\\(x\\)</span> 是字符串合法情况的状态压缩。</p>\n<p>对于每一个待满足的串，枚举去满足它的哪一位，那么满足方式分两种情况：</p>\n<ul>\n<li>把它变成一个新的值</li>\n<li><p>把和它重合的变成新的值</p>\n<p>我们注意到 <span class=\"math inline\">\\(n \\le 20 \\le 26\\)</span>，所以一定能找到一种方法让每个串的这一位都不一样。</p>\n<p>接着，反正我们都要改这一位了，那就贪心地把要改的全部改成完全不一样的。那么这些要改的串也在这一位上满足了条件。</p></li>\n</ul>\n<p>所以，假设对于状态 <span class=\"math inline\">\\(i\\)</span>，有串 <span class=\"math inline\">\\(j\\)</span> 未满足，枚举位置 <span class=\"math inline\">\\(k\\)</span>，有：</p>\n<pre class=\"cpp\"><code>f[i | (1 &lt;&lt; (j - 1))] = min(f[i | (1 &lt;&lt; (j - 1))], f[i] + a[j][k]); \nf[i | lac[j][k]] = min(f[i | lac[j][k]], f[i] + mx[j][k]);</code></pre>\n<p>其中 <code>lac[j][k]</code> 和 <code>mx[j][k]</code> 都是预处理出来的值。<code>lac[j][k]</code> 表示与第 <span class=\"math inline\">\\(j\\)</span> 个串的第 <span class=\"math inline\">\\(k\\)</span> 位相同串的状态压缩；<code>mx[j][k]</code> 表示通过第二种方式将 <span class=\"math inline\">\\(j\\)</span> 串的第 <span class=\"math inline\">\\(k\\)</span> 位变得合法的最小费用。</p>\n<p><code>lac[j][k]</code> 的求法没有任何疑问，主要是在 <code>mx[j][k]</code> 上。注意到假设这一位上有 <span class=\"math inline\">\\(x\\)</span> 个串与 <span class=\"math inline\">\\(j\\)</span> 串的第 <span class=\"math inline\">\\(k\\)</span> 位相同（包括其本身），而我们只需要将这当中的 <span class=\"math inline\">\\(x-1\\)</span> 个变成两两不同的全新字符就可以同时满足这 <span class=\"math inline\">\\(x\\)</span> 串的条件，那我们为什么不把不动的这一个串设置为 <span class=\"math inline\">\\(x\\)</span> 个串中改这一位代价最大的那个呢？</p>\n<p>那么问题来了。我们枚举状态、枚举状态中的每一个 <code>0</code>，枚举每一个串的每一位，实际上是 <span class=\"math inline\">\\(O(n\\times m\\times 2^n)\\)</span> 的。虽然跑不满，但这个时间复杂度仍然是有问题的。我们需要优化。</p>\n<p>我们枚举的是状态中的每一个 <code>0</code>，假设我们的状态是 <code>000</code>，我们的解决方案是将三个 <code>0</code> 位置的方案共同处理，表示为 <code>'0--'</code> + <code>'-0-'</code> + <code>'--0'</code>。但实际上，我们只用实际求解一个 <code>0</code> 位置的答案，表示为 <code>'0--'</code> + <code>'-00'</code> 。</p>\n<p>也就是说，我们原本需要枚举每一个状态为 <code>0</code> 的 <span class=\"math inline\">\\(j\\)</span> 并用 <span class=\"math inline\">\\(O(m)\\)</span> 的时间进行计算，现在我们碰到一个状态为 <code>0</code> 的 <span class=\"math inline\">\\(j\\)</span> 就开始计算，得到完全相同的答案。</p>\n<p>很 NB 并且很实用的优化，已加入 <a href=\"/20231117/\">下饭操作合集</a>。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 205;\nconst int maxm = (1 &lt;&lt; 25) + 5;\nint f[maxm];\nint n, m, siz;\nchar s[maxn][maxn];\nint lac[maxn][maxn];\nint a[maxn][maxn], mx[maxn][maxn];\nint min(int x, int y) &#123; return x &lt; y ? x : y; &#125;\nint max(int x, int y) &#123; return x &gt; y ? x : y; &#125;\nint main() &#123;\n    while(~scanf(&quot;%d %d&quot;, &amp;n, &amp;m)) &#123;\n        memset(f, 0x3f, sizeof (f));\n        f[0] = 0, siz = 1 &lt;&lt; n;\n        for (int i = 1; i &lt;= n; ++i)\n            scanf(&quot;%s&quot;, s[i] + 1);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            for (int j = 1; j &lt;= m; ++j)\n                scanf(&quot;%d&quot;, &amp;a[i][j]);\n        &#125;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            for (int j = 1; j &lt;= m; ++j) &#123;\n                int sum = 0;\n                lac[i][j] = mx[i][j] = 0;\n                for (int k = 1; k &lt;= n; ++k) &#123;\n                    if (s[k][j] == s[i][j]) &#123;\n                        lac[i][j] |= 1 &lt;&lt; (k - 1);\n                        sum += a[k][j];\n                        mx[i][j] = max(mx[i][j], a[k][j]);\n                    &#125;\n                &#125;\n                mx[i][j] = sum - mx[i][j];\n            &#125;\n        &#125;\n        for (int i = 0, j; i &lt; siz - 1; ++i) &#123;\n            for (j = 1; j &lt;= n; ++j) &#123;\n                if (!(i &amp; (1 &lt;&lt; (j - 1))))\n                    break;\n            &#125;\n            for (int k = 1; k &lt;= m; ++k) &#123;\n                f[i | (1 &lt;&lt; (j - 1))] =\n                    min(f[i | (1 &lt;&lt; (j - 1))], f[i] + a[j][k]); \n                f[i | lac[j][k]] =\n                    min(f[i | lac[j][k]], f[i] + mx[j][k]);\n            &#125;\n        &#125;\n        print(f[siz - 1], &#39;\\n&#39;);\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<p>这次暴露出的问题：</p>\n<ul>\n<li>深度乱求，打代码的时候考虑过要放在递归之前，但是由于精力不集中最后还是放在了递归后面。</li>\n</ul>\n<p>没了。这次主要问题出在 T5。T3 估计真的想不到，先不强求自己。</p>\n<p>这次学到的新知识：</p>\n<ul>\n<li>对于子集合并最优性的问题，可以用单点 + 集合代替集合 + 集合枚举。</li>\n</ul>\n",
            "tags": [
                "DP",
                "线段树"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20230928/",
            "url": "https://xsc062.netlify.app/20230928/",
            "title": "颜色",
            "date_published": "2023-09-28T08:44:30.000Z",
            "content_html": "<p>Solution to <a href=\"https://vjudge.net/contest/583230#problem/B\">颜色</a>。</p>\n<span id=\"more\"></span>\n<hr />\n<h3 id=\"b---颜色\">B - 颜色</h3>\n<p><a href=\"https://vjudge.net/contest/583230#problem/B\" class=\"uri\">https://vjudge.net/contest/583230#problem/B</a></p>\n<p>颜色删完过后剩下的肯定是一段区间。</p>\n<p>那么区间外的所有颜色都会被删掉，如果要满足题目条件的话，删掉的颜色不能出现在区间内。</p>\n<p>那么就可以有这么一个题意的转化：寻找区间的个数，满足区间内的颜色只出现在区间内。</p>\n<p>然后你可能就要问了，不是还要满足区间外的所有颜色都不出现在区间内吗。但是你想想，要是它出现在区间内了，它作为区间内的颜色，不就不满足我们上面说的那条规则了吗。</p>\n<p>这个转化是非常厉害的。那么这个时候有一个显而易见暴力做法，我们记录一个颜色在整个序列中出现的第一个位置（记为 <span class=\"math inline\">\\(L_x\\)</span>）和最后一个位置（记作 <span class=\"math inline\">\\(R_x\\)</span>），然后枚举每一个区间 <span class=\"math inline\">\\([i, j]\\)</span>，再枚举其中的每一个颜色，看看有没有超出去就好，复杂度 <span class=\"math inline\">\\(O(n^3)\\)</span>。</p>\n<details>\n<summary>对纯暴力的一点小优化</summary> 上述区间内枚举过程转化为判定区间是否满足 <span class=\"math inline\">\\({L_x}_{\\min} \\ge i\\)</span> 且 <span class=\"math inline\">\\({R_x}_{\\max} \\le j\\)</span>，采用数据结构维护，就可以优化到 <span class=\"math inline\">\\(O(n^2\\log)\\)</span>。为什么要专门提一嘴这个呢，因为这个模型我没想到。我真 NB。\n</details>\n<p>接下来又是一个我想不到的模型。我们发现复杂度瓶颈出在枚举区间上，所以考虑通过固定区间右端点，用较小的复杂度直接求解满足条件的左端点数量来解决问题。为什么不是固定左端点呢？</p>\n<p>「因为题解都是写的固定右端点。」 0# 如是说。</p>\n<p>对于正在枚举的右端点 <span class=\"math inline\">\\(j\\)</span> 右边的颜色 <span class=\"math inline\">\\(x\\)</span>，我们记录它们上一次出现的位置 <span class=\"math inline\">\\(p_x\\)</span>，并用线段树找到范围内最右值 <span class=\"math inline\">\\((p_x)_{\\max}\\)</span>，那么左端点 <span class=\"math inline\">\\(i&gt;(p_x)_{\\max}\\)</span>。取 <span class=\"math inline\">\\(i&#39;=(p_x)_{\\max}+1\\)</span>，这样我们就初步得到了一个 <span class=\"math inline\">\\([i&#39;, j]\\)</span>。相对于纯暴力的做法，<span class=\"math inline\">\\(R_x\\le j\\)</span> 的等价条件已经满足，但还有一个条件，就是 <span class=\"math inline\">\\(L_x\\)</span> 不能小于 <span class=\"math inline\">\\(i\\)</span>。</p>\n<p>为了方便数据结构维护 <span class=\"math inline\">\\(p_x\\)</span>，我们逆序枚举 <span class=\"math inline\">\\(j\\)</span>，这样又可以得到一个性质：<span class=\"math inline\">\\(i&#39;\\)</span> 单调不降。这个时候我们逆向思维，处理出对于每个 <span class=\"math inline\">\\(i\\ge i&#39;\\)</span>，其能够到的最远的 <span class=\"math inline\">\\(j\\)</span>，记为 <span class=\"math inline\">\\(f_i\\)</span>，那么我们对于 <span class=\"math inline\">\\(f_i\\)</span> 建一个权值线段树，然后在枚举过程中查询权值在 <span class=\"math inline\">\\([j, +\\infty)\\)</span> 的 <span class=\"math inline\">\\(i\\)</span> 的个数就是答案。由于求的是个数，所以可以对超出范围的 <span class=\"math inline\">\\(i\\)</span> 对应的 <span class=\"math inline\">\\(f_i\\)</span> 进行删除操作。</p>\n<p>那么 <span class=\"math inline\">\\(f_i\\)</span> 又该怎么求呢？暴力地再建一个权值线段树维护 <span class=\"math inline\">\\(L_x\\)</span>，在 <span class=\"math inline\">\\((-\\infty, i)\\)</span> 权值范围内查询下标 <span class=\"math inline\">\\(k\\)</span> 的最小值，此时的 <span class=\"math inline\">\\(k\\)</span> 就是 <span class=\"math inline\">\\(f_i\\)</span>。</p>\n<p>因为 0# 讲课的时候我在开飞机，所以我也不知道 0# 是不是这么讲的，总之我这么做应该能做出来，就是要维护的东西实在有亿点点多。</p>\n<p>但是注意到一个线段树和两个权值线段树维护的大区间其实是一样的，所以我们只用一个线段树同时维护三个信息就好。最后时间复杂度 <span class=\"math inline\">\\(O(n\\log n)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\n#define mid (t[p].l + t[p].r) / 2\nconst int maxn = 3e5 + 5;\n// shaber monotonicity\n// destroy my youth \nstruct _ &#123; int l, r, u, d; &#125;;\nstruct __ &#123;\n    int u, i;\n    __() &#123;&#125;\n    __(int u1, int i1) &#123;\n        u = u1, i = i1;\n    &#125;\n&#125;;\nint T, n, res;\n_ t[maxn &lt;&lt; 2];\nint a[maxn], L[maxn], R[maxn];\nint max(int x, int y) &#123; return x &gt; y ? x : y; &#125;\nint min(int x, int y) &#123; return x &lt; y ? x : y; &#125;\nvoid pushup(int p) &#123;\n    t[p].u = t[lt].u + t[rt].u;\n    return;\n&#125;\nvoid pushdown(int p) &#123;\n    if (t[p].d) &#123;\n        t[lt].d = t[rt].d = 1;\n        t[lt].u = t[lt].r - t[lt].l + 1;\n        t[rt].u = t[rt].r - t[rt].l + 1;\n        t[p].d = 0;\n    &#125;\n    return;\n&#125;\nvoid bld(int p, int l, int r) &#123;\n    t[p].u = t[p].d = 0;\n    t[p].l = l, t[p].r = r;\n    if (l == r) return;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    return;\n&#125;\nvoid add(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        t[p].u = t[p].r - t[p].l + 1;\n        t[p].d = 1;\n        return;\n    &#125;\n    pushdown(p);\n    if (l &lt;= mid) add(lt, l, r);\n    if (r &gt; mid) add(rt, l, r);\n    pushup(p);\n    return;\n&#125;\nint ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].u;\n    int res = 0; pushdown(p);\n    if (l &lt;= mid) res = ask(lt, l, r);\n    if (r &gt; mid) res += ask(rt, l, r);\n    return res;\n&#125;\nint main() &#123;\n    read(T);\n    while (T--) &#123;\n        read(n), res = 0;\n        std::stack&lt;__&gt; p;\n        std::fill(L + 1, L + n + 1, n + 5);\n        std::fill(R + 1, R + n + 1, 0);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            read(a[i]), R[a[i]] = i;\n            if (L[a[i]] == n + 5) L[a[i]] = i;\n        &#125;\n        bld(1, 1, n);\n        for (int i = 1, j; i &lt;= n; ++i) &#123;\n            if (i == R[a[i]] &amp;&amp; i != L[a[i]])\n                add(1, L[a[i]] + 1, R[a[i]]);\n            else p.push(__(a[i], i));\n            while (!p.empty() &amp;&amp; R[p.top().u] &lt;= i) p.pop();\n            j = p.size() ? p.top().i : 0;\n            if (i != j) res += i - j - ask(1, j + 1, i);\n        &#125;\n        print(res, &#39;\\n&#39;);\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n",
            "tags": [
                "线段树"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20230813/",
            "url": "https://xsc062.netlify.app/20230813/",
            "title": "pn、pm 和 plmm",
            "date_published": "2023-08-13T08:46:13.000Z",
            "content_html": "<p>Sotution to <a href=\"https://codeforces.com/problemset/problem/258/C\">CF258C Little Elephant and LCM</a>。</p>\n<span id=\"more\"></span>\n<hr />\n<p>0#：那么这个 pn 可以等于什么？它只能等于 pm。（露出看到 plmm 一般的猥琐坏笑）</p>\n<hr />\n<p>方便起见，下面 <span class=\"math inline\">\\(b_{\\text{lcm}}\\)</span> 的意思就是 <span class=\"math inline\">\\(\\text{lcm}\\{b_1,b_2,\\cdots,b_n\\}\\)</span>，<span class=\"math inline\">\\(\\max\\)</span> 什么的也同理。</p>\n<p>首先我们都能反应过来，如果 <span class=\"math inline\">\\(b_{\\text{lcm}}=b_{\\max}\\)</span>，那么 <span class=\"math inline\">\\(b\\)</span> 中的最大值就得是 <span class=\"math inline\">\\(b_{\\text {lcm}}\\)</span>，而其他元素都得是 <span class=\"math inline\">\\(b_{\\max}\\)</span> 的因数。</p>\n<p>既然涉及到求 <span class=\"math inline\">\\(b_{\\max}\\)</span> 的因数，那我们势必避免不了枚举 <span class=\"math inline\">\\(b_{\\max}\\)</span>。我一开始陷入了一个 trick：我并不知道 <span class=\"math inline\">\\(b_{\\max}\\)</span> 应该处于哪一个位置。但其实这不重要，它对我们最后的方案没有影响，有影响的是「有多少个位置可以取到当前枚举的 <span class=\"math inline\">\\(b_{\\max}\\)</span>」。</p>\n<p>对于当前枚举的 <span class=\"math inline\">\\(b_{\\max}\\)</span>（假设为 <span class=\"math inline\">\\(k\\)</span>），我们找到它的所有因数 <span class=\"math inline\">\\(p_1\\sim p_m\\)</span>，按从小到大的顺序排列。对于一个 <span class=\"math inline\">\\(a_i\\)</span>，当且仅当 <span class=\"math inline\">\\(a_i\\ge p_j\\)</span> 时，<span class=\"math inline\">\\(a_i\\)</span> 可以选择 <span class=\"math inline\">\\(p_j\\)</span>。那么我们找到 <span class=\"math inline\">\\(a_i\\)</span> 可以选到的最大的 <span class=\"math inline\">\\(p_j\\)</span>，此时 <span class=\"math inline\">\\(a_i\\)</span> 的选择就是 <span class=\"math inline\">\\(p_1\\sim p_j\\)</span>，共 <span class=\"math inline\">\\(j\\)</span> 种。</p>\n<p>那么我们在外面已经有一层枚举 <span class=\"math inline\">\\(k\\)</span> 的循环的前提下，再遍历 <span class=\"math inline\">\\(a\\)</span> 数组无疑是会起飞的，我们考虑倒过来，遍历 <span class=\"math inline\">\\(p\\)</span>，对于每个 <span class=\"math inline\">\\(p_j\\)</span>，找到它是多少个 <span class=\"math inline\">\\(a_i\\)</span> 的最大选择（假设为 <span class=\"math inline\">\\(x_j\\)</span>），那么对于 <span class=\"math inline\">\\(p_j\\)</span>，它贡献的答案就是 <span class=\"math inline\">\\(j^{x_j}\\)</span>。</p>\n<p><span class=\"math inline\">\\(x_j\\)</span> 的计算也不难，我们用两个二分找到满足 <span class=\"math inline\">\\(p_j\\le a_i &lt; p_j + 1\\)</span> 的 <span class=\"math inline\">\\(a_i\\)</span> 数量就可以了。那么总方案数就是 <span class=\"math inline\">\\(\\prod j^{x_j}\\)</span>。</p>\n<p>但是别忘了还有 <span class=\"math inline\">\\(k\\)</span> 为 <span class=\"math inline\">\\(b_{\\max}\\)</span> 的限制。找到 <span class=\"math inline\">\\(x_m\\)</span>，怎么去满足至少有一个 <span class=\"math inline\">\\(a_i=k\\)</span> 呢？一个微型容斥，用总方案数减去一个 <span class=\"math inline\">\\(k\\)</span> 都没有的方案数。那么就规定了每个可以取到 <span class=\"math inline\">\\(k\\)</span> 的数都必须不取 <span class=\"math inline\">\\(k\\)</span>，本来有 <span class=\"math inline\">\\(m\\)</span> 种选择，现在只剩下 <span class=\"math inline\">\\(m−1\\)</span> 种，所以答案就是 <span class=\"math inline\">\\((m−1)^{x_m}\\)</span>，容斥后为 <span class=\"math inline\">\\(m^{x_m}−(m−1)^{x_m}\\)</span>。</p>\n<p>对于 <span class=\"math inline\">\\(b_{\\max}=k\\)</span>，最终结果为 <span class=\"math inline\">\\((\\prod\\limits_{j=1}^{m−1}j^{x_j})\\times (m^{x_m}−(m−1)^{x_m})\\)</span>。加法原理把所有 <span class=\"math inline\">\\(k\\)</span> 的情况加起来即可。</p>\n<p>对于时间复杂度，枚举 <span class=\"math inline\">\\(k\\)</span> 是 <span class=\"math inline\">\\(O(V)\\)</span> 的，找因数是 <span class=\"math inline\">\\(O(\\sqrt V)\\)</span> 的，枚举 <span class=\"math inline\">\\(p_j\\)</span> 是 <span class=\"math inline\">\\(\\log V\\)</span> 的，二分是 <span class=\"math inline\">\\(\\log n\\)</span> 的。所以最终时间复杂度为 <span class=\"math inline\">\\(O(V\\times \\max\\{\\sqrt V,\\log V\\times \\log n\\})\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#define int long long\nnamespace XSC062 &#123;\nusing namespace fastIO;\nconst int mod = 1e9 + 7;\nconst int maxn = 1e5 + 5;\nint a[maxn];\nint n, mx, ans, res;\nint qkp(int x, int y) &#123;\n    int res = 1;\n    while (y) &#123;\n        if (y &amp; 1) (res *= x) %= mod;\n        (x *= x) %= mod, y &gt;&gt;= 1;\n    &#125;\n    return res;\n&#125;\nint max(int x, int y) &#123; return x &gt; y ? x : y; &#125;\nint main() &#123;\n    read(n);\n    for (int i = 1; i &lt;= n; ++i) \n        read(a[i]), mx = max(mx, a[i]);\n    std::sort(a + 1, a + n + 1);\n    for (int k = 1; k &lt;= mx; ++k) &#123;\n        res = 1;\n        std::vector&lt;int&gt; p;\n        p.push_back(-1); // 占位符，方便下标对齐 \n        for (int i = 1; i * i &lt;= k; ++i) &#123;\n            if (k % i == 0) &#123;\n                p.push_back(i);\n                if (i * i != k) p.push_back(k / i);\n            &#125;\n        &#125;\n        std::sort(p.begin() + 1, p.end());\n        // 先算前 m - 1 个 \n        int m = p.size() - 1;\n        for (int j = 1; j &lt;= m - 1; ++j) &#123;\n            int l, r, x;\n            l = std::lower_bound(a + 1, a + n + 1, p[j]) - a;\n            r = std::lower_bound(a + 1, a + n + 1, p[j + 1]) - a - 1;\n            x = r - l + 1, (res *= qkp(j, x)) %= mod;\n        &#125;\n        int l, r, x;\n        l = std::lower_bound(a + 1, a + n + 1, p[m]) - a;\n        r = n, x = r - l + 1;\n        (res *= (qkp(m, x) - qkp(m - 1, x))) %= mod;\n        (ans += res) %= mod;\n    &#125;\n    print((ans + mod) % mod, &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n</details>\n",
            "tags": [
                "二分",
                "容斥原理"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20230729/",
            "url": "https://xsc062.netlify.app/20230729/",
            "title": "矩阵",
            "date_published": "2023-07-29T07:38:36.000Z",
            "content_html": "<p>Solution to <a href=\"http://222.180.160.110:61235/contest/3825/problem/7\">BZOJ2406 矩阵</a>。</p>\n<span id=\"more\"></span>\n<hr />\n<blockquote>\n<p>赛时公告</p>\n<p>现在呢？：现在有弹窗了吗 「2023-07-19 16:45:07」</p>\n</blockquote>\n<p>此时无声胜有声。</p>\n<hr />\n<h3 id=\"f.bzoj2406矩阵\">F.「BZOJ2406」矩阵</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/3825/problem/7\" class=\"uri\">http://222.180.160.110:61235/contest/3825/problem/7</a></p>\n<p>这是头一次见识到把矩阵和网络流结合在一起的题目。不过这种处理方式也是我们在学习二分图时的常客了：把行和列连边表示某一元素。</p>\n<p>我们发现 <span class=\"math inline\">\\(B_{i, j}\\)</span> 有给定的上下界，故我们考虑 <strong>上下界网络流</strong>。那怎么去表示 <span class=\"math inline\">\\(B_{i, j}\\)</span> 呢？这就要联系到我们刚刚说过的连边方式：用边 <span class=\"math inline\">\\(i\\to j\\)</span> 的流量来表示 <span class=\"math inline\">\\(B_{i, j}\\)</span>，有 <span class=\"math inline\">\\([L, R]\\)</span> 的上下界。</p>\n<p>可是我们除了 <span class=\"math inline\">\\([L,R]\\)</span> 的限制，还有最大值这个条件呀，怎么办呢？</p>\n<p>注意到题目要求最大的最小，自然想到二分答案。设答案为 <span class=\"math inline\">\\(x\\)</span>，则我们需要保证每行每列的答案都 <span class=\"math inline\">\\(\\le x\\)</span>。每行每列，这刚好是我们的建点方式。这对点本身作出了要求，这套路我们熟，让大源点向行连边、列向大汇点连边就好。</p>\n<p>那么这些边的上下界怎么办呢？我们已知 <span class=\"math inline\">\\(|S_A-S_B|\\le x\\)</span>，那么变形得：</p>\n<p><span class=\"math display\">\\[\n\\begin{cases}\nS_B\\ge S_A-x &amp;(S_B \\le S_A) \\\\\nS_B\\le S_A+x &amp;(S_B \\ge S_A)\n\\end{cases}\n\\]</span></p>\n<p>照理来说，两行的符号相反，我们现在已经得到了一个具有对称美的上下界：<span class=\"math inline\">\\(S_A-x\\le S_B\\le S_A+x\\)</span>，就应该速速连边了，可是我怎么看都觉得不舒坦：这个不等式可是带条件的，就这么直接拿来做上下界真的没问题吗？</p>\n<p><del>答案是没问题，因为我看的题解是这么写的</del> 本着探索求真精神，我们考虑尊重原不等式（因为原不等式的每一行刚好也有两个相反的符号），将这些边拆成两条，一条的上下界是 <span class=\"math inline\">\\([S_A-x, S_A]\\)</span>，另一条是 <span class=\"math inline\">\\([S_A,S_A+x]\\)</span>。6。我明白题解为什么这么写了，一个的下界就是另一个的上界，那直接合并不就行了，这个 naive trick 题解都不屑于写出来。</p>\n<p>然后跑个可行流就可以了。注意要保证边的下界为非负。</p>\n<details>\n<pre class=\"cpp\"><code>#define int long long\nnamespace XSC062 &#123;\nusing namespace fastIO;\nconst int lim = 2e5;\nconst int maxn = 405;\nconst int inf = 1e18;\nconst int maxm = 3e5 + 5;\nstruct _ &#123;\n    int v, w, n;\n    _() &#123;&#125;\n    _(int v1, int w1, int n1) &#123;\n        v = v1, w = w1, n = n1;\n    &#125;\n&#125;;\n_ u[maxm];\nint gs, gt, tot;\nint a[maxn][maxn];\nint l, mid, r, res;\nint h[maxn], dif[maxn];\nint n, m, cnt, s, t, L, R;\nint vis[maxn], now[maxn], dep[maxn];\nint max(int x, int y) &#123; return x &gt; y ? x : y; &#125;\nint min(int x, int y) &#123; return x &lt; y ? x : y; &#125;\nbool BFS(int n) &#123;\n    std::fill(vis + 1, vis + n + 1, 0);\n    std::fill(dep + 1, dep + n + 1, 0); \n    std::queue&lt;int&gt; q;\n    dep[gs] = 1, vis[gs] = 1;\n    q.push(gs), now[gs] = h[gs];\n    while (!q.empty()) &#123;\n        int f = q.front(); q.pop();\n        for (int i = h[f]; i; i = u[i].n) &#123;\n            int v = u[i].v, w = u[i].w;\n            if (vis[v] == 1 || w == 0) continue;\n            vis[v] = 1, now[v] = h[v];\n            dep[v] = dep[f] + 1, q.push(v);\n            if (v == gt) return 1;\n        &#125;\n    &#125;\n    return 0;\n&#125;\nint findP(int x, int flow = inf) &#123;\n    if (x == gt) return flow;\n    int rest = flow, i;\n    for (i = now[x]; rest &amp;&amp; i; i = u[i].n) &#123;\n        now[x] = i;\n        int v = u[i].v, w = u[i].w;\n        if (dep[v] != dep[x] + 1 || w == 0) continue;\n        int t = findP(v, min(rest, w));\n        if (t == 0) dep[v] = 0;\n        rest -= t, u[i].w -= t, u[i ^ 1].w += t;\n    &#125;\n    return flow - rest;\n&#125;\nint Dinic(int n) &#123;\n    int res = 0;\n    while (BFS(n)) &#123;\n        int t = findP(gs);\n        while (t) res += t, t = findP(gs);\n    &#125;\n    return res;\n&#125;\nvoid add(int x, int y, int w) &#123;\n    u[++tot] = _(y, w, h[x]), h[x] = tot;\n    return;\n&#125;\nvoid add(int x, int y, int d, int u) &#123;\n    add(x, y, u - d), add(y, x, 0);\n    dif[x] -= d, dif[y] += d;\n    return;\n&#125;\nvoid Init(void) &#123;\n    tot = 1, cnt = 0;\n    memset(h, 0, sizeof (h));\n    memset(dif, 0, sizeof (dif));\n    return;\n&#125;\nbool check(int x) &#123;\n    Init();\n    s = n + m + 1, t = s + 1;\n    add(t, s, inf), add(s, t, 0);\n    gs = t + 1, gt = t + 2;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = 1; j &lt;= m; ++j)\n            add(i, j + n, L, R);\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        int sum = 0;\n        for (int j = 1; j &lt;= m; ++j)\n            sum += a[i][j];\n        add(s, i, max(0, sum - x), sum + x);\n    &#125;\n    for (int j = 1; j &lt;= m; ++j) &#123;\n        int sum = 0;\n        for (int i = 1; i &lt;= n; ++i)\n            sum += a[i][j];\n        add(j + n, t, max(sum - x, 0), sum + x);\n    &#125;\n    for (int i = 1; i &lt;= t; ++i) &#123;\n        if (dif[i] &lt; 0)\n            add(i, gt, -dif[i]), add(gt, i, 0);\n        else if (dif[i] &gt; 0) &#123;\n            add(gs, i, dif[i]);\n            add(i, gs, 0), cnt += dif[i];\n        &#125;\n    &#125;\n    return (Dinic(gt) == cnt);\n&#125;\nint main() &#123;\n    read(n), read(m);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = 1; j &lt;= m; ++j)\n            read(a[i][j]);\n    &#125;\n    read(L), read(R);\n    l = 0, r = lim, res = -1;\n    while (l &lt;= r) &#123;\n        mid = (l + r) &gt;&gt; 1;\n        if (check(mid))\n            res = mid, r = mid - 1;\n        else l = mid + 1;\n    &#125;\n    print(res);\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n</details>\n<hr />\n<p>你最好有要事相求.jpg</p>\n",
            "tags": [
                "网络流",
                "二分",
                "上下界网络流"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20230722/",
            "url": "https://xsc062.netlify.app/20230722/",
            "title": "网络流 24 题",
            "date_published": "2023-07-22T14:17:10.000Z",
            "content_html": "<p>Solution to <a href=\"http://222.180.160.110:61235/contest/3952/problem/1\">网络流 24 题</a>。</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"day-11st---6th\">Day 1：1st - 6th</h2>\n<h3 id=\"a.-星际转移问题\">A. 星际转移问题</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/3952/problem/1\" class=\"uri\">http://222.180.160.110:61235/contest/3952/problem/1</a></p>\n<p>如果就按照题目给的路线图，我们显然无法考虑到飞船到达的时刻。同时 <span class=\"math inline\">\\(n\\)</span> 和 <span class=\"math inline\">\\(m\\)</span> 又很小，我们就知道了，「人不能两次踏进同一条河流」，<span class=\"math inline\">\\(1\\)</span> 时刻的站 <span class=\"math inline\">\\(p\\)</span> 和 <span class=\"math inline\">\\(2\\)</span> 时刻的站 <span class=\"math inline\">\\(p\\)</span> 也不能是同一个站 <span class=\"math inline\">\\(p\\)</span>。</p>\n<p>考虑用 <span class=\"math inline\">\\((p, t)\\)</span> 表示 <span class=\"math inline\">\\(t\\)</span> 时刻的站 <span class=\"math inline\">\\(p\\)</span>，然后对于每条路线跑个暴力连边，容量全部为 <span class=\"math inline\">\\(H_i\\)</span>。</p>\n<p>怎么控制时间最小呢？二分一下就可以了…… 然后最大流判定是不是满流的即可。</p>\n<p>以及注意到对于同一站点，前面的时刻可以留下来等后面的时刻，我们将同一站的前一时刻和后一时刻全部连边，容量为 <span class=\"math inline\">\\(k\\)</span>。以及保留节目对源点拆点以控制流量为 <span class=\"math inline\">\\(k\\)</span>。</p>\n<p><del>经实验答案最大为 29，所以把二分上界设为 30 即可</del> 理论上来说答案可能很大，比如你谷最后一组数据的答案就是 <span class=\"math inline\">\\(900\\)</span> 多，所以我掐指一算用天才般的算术技巧开了 <span class=\"math inline\">\\(10^4\\)</span>。真的，数数位天才就是我。</p>\n<details>\n<p>woc，这题居然没人做，果然我还是太强了。</p>\n<p>为什么都跑去做 T4 了，这个不是按难度顺序排列的吗？</p>\n<p>哦哦，好像不是，那（Na）没（Mei）事（Shi）了（Le）。</p>\n<p><img src=\"https://pic.imgdb.cn/item/64be2f6e1ddac507cc0e0955.png\" /></p>\n<pre class=\"cpp\"><code>#define int long long\nnamespace XSC062 &#123;\nusing namespace fastIO;\nconst int lim = 1e4;\nconst int inf = 1e18;\nconst int maxm = 4e5 + 5;\nconst int maxn = 5e4 + 15;\nstruct _ &#123;\n    int v, w, n;\n    _() &#123;&#125;\n    _(int v1, int w1, int n1) &#123;\n        v = v1, w = w1, n = n1;\n    &#125;\n&#125;;\nstruct __ &#123;\n    int c;\n    std::vector&lt;int&gt; p;\n&#125;;\n_ u[maxm];\n__ w[maxn];\nint h[maxn];\nint l, mid, r;\nint gs, gt, tot = 1;\nint n, m, k, s, mt, x, res, y;\nint vis[maxn], now[maxn], dep[maxn];\nint min(int x, int y) &#123; return x &lt; y ? x : y; &#125;\nint fun(int p, int t) &#123; return (p - 1) * mt + t; &#125;\nbool BFS(int n) &#123;\n    std::fill(vis + 1, vis + n + 1, 0);\n    std::fill(dep + 1, dep + n + 1, 0); \n    std::queue&lt;int&gt; q;\n    dep[gs] = 1, vis[gs] = 1;\n    q.push(gs), now[gs] = h[gs];\n    while (!q.empty()) &#123;\n        int f = q.front(); q.pop();\n        for (int i = h[f]; i; i = u[i].n) &#123;\n            int v = u[i].v, w = u[i].w;\n            if (vis[v] == 1 || w == 0) continue;\n            vis[v] = 1, now[v] = h[v];\n            dep[v] = dep[f] + 1, q.push(v);\n            if (v == gt) return 1;\n        &#125;\n    &#125;\n    return 0;\n&#125;\nint findP(int x, int flow = inf) &#123;\n    if (x == gt) return flow;\n    int rest = flow, i;\n    for (i = now[x]; rest &amp;&amp; i; i = u[i].n) &#123;\n        int v = u[i].v, w = u[i].w;\n        now[x] = i;\n        if (dep[v] != dep[x] + 1 || w == 0)\n            continue;\n        int t = findP(v, min(rest, w));\n        if (t == 0) dep[v] = 0;\n        rest -= t, u[i].w -= t, u[i ^ 1].w += t;\n    &#125;\n    return flow - rest;\n&#125;\nint Dinic(int n) &#123;\n    int res = 0;\n    while (BFS(n)) &#123;\n        int t = findP(gs);\n        while (t) res += t, t = findP(gs);\n    &#125;\n    return res;\n&#125;\nvoid add(int x, int y, int w) &#123;\n    u[++tot] = _(y, w, h[x]);\n    h[x] = tot;\n    return;\n&#125;\nvoid addf(int x, int y, int w) &#123;\n    add(x, y, w), add(y, x, 0);\n    return;\n&#125;\nvoid Init(void) &#123;\n    tot = 1;\n    memset(h, 0, sizeof (h));\n    return;\n&#125;\nbool check(int x) &#123;\n    Init();\n    mt = x, s = fun(n, mt) + 1;\n    gs = s + 1, gt = s + 2;\n    addf(gs, s, k);\n    for (int i = 1; i &lt;= mt; ++i) &#123;\n        addf(s, fun(n - 1, i), k);\n        addf(fun(n, i), gt, k);\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = 1; j &lt; mt; ++j)\n            addf(fun(i, j), fun(i, j + 1), k);\n    &#125;\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        int p = 0, x = 0, la = 0;\n        while (++p &lt;= mt) &#123;\n            if (la != 0)\n                addf(fun(la, p - 1), fun(w[i].p[x], p), w[i].c);\n            la = w[i].p[x];\n            if (++x &gt;= w[i].p.size()) x = 0;\n        &#125;\n    &#125;\n    return (Dinic(gt) == k);\n&#125;\nint main() &#123;\n    read(n), read(m), read(k);\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        read(w[i].c), read(y);\n        while (y--) &#123;\n            read(x);\n            if (x == 0) x = n + 1;\n            else if (x == -1) x = n + 2;\n            w[i].p.push_back(x);\n        &#125;\n    &#125;\n    n += 2;\n    l = 1, r = lim;\n    while (l &lt;= r) &#123;\n        mid = (l + r) &gt;&gt; 1;\n        if (check(mid))\n            res = mid, r = mid - 1;\n        else l = mid + 1;\n    &#125;\n    print(res ? res - 1 : 0, &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n</details>\n<hr />\n<h3 id=\"b.-最长递增子序列\">B. 最长递增子序列</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/3952/problem/2\" class=\"uri\">http://222.180.160.110:61235/contest/3952/problem/2</a></p>\n<p>就算知道不是按难度顺序排列我也要顺序开题。欸嘿，就是玩。</p>\n<p>第一问很水，跑个 DP 就行。</p>\n<p>第二问有点意思，取出就代表只能选一次，总之典中典，把每个数拆成入点和出点，容量为 <span class=\"math inline\">\\(1\\)</span>，这样就可以只选一次了。</p>\n<p>那怎么保证每次找到的流一定是 LIS 呢？其实这和我们 Dinic 的深度分层数组有异曲同工之妙，我们把 <span class=\"math inline\">\\(f_i = f_j + 1(i&gt;j,A_i\\ge A_j)\\)</span> 的 <span class=\"math inline\">\\((j, i)\\)</span> 连边，容量为 <span class=\"math inline\">\\(1\\)</span> 即可。</p>\n<p>然后源点只和满足 <span class=\"math inline\">\\(f_x = 1\\)</span> 的 <span class=\"math inline\">\\(x\\)</span> 连边，相应地，汇点之和满足 <span class=\"math inline\">\\(f_x = \\text{LIS}\\)</span> 的 <span class=\"math inline\">\\(x\\)</span> 连边。</p>\n<p>第三问很好想啊，我们把 <span class=\"math inline\">\\(1\\)</span> 到源点和 <span class=\"math inline\">\\(n\\)</span> 到汇点的容量设成无穷大就好。</p>\n<p>然后踩了半天的坑，这道题的拆点部分不知道为什么必须要连双向边。</p>\n<details>\n<pre class=\"cpp\"><code>#define int long long\nnamespace XSC062 &#123;\nusing namespace fastIO;\nconst int inf = 1e18;\nconst int maxm = 4e5 + 5;\nconst int maxn = 5e5 + 15;\nstruct _ &#123;\n    int v, w, n;\n    _() &#123;&#125;\n    _(int v1, int w1, int n1) &#123;\n        v = v1, w = w1, n = n1;\n    &#125;\n&#125;;\n_ u[maxm];\nint n, res;\nint gs, gt, tot = 1;\nint a[maxn], h[maxn], f[maxn];\nint vis[maxn], now[maxn], dep[maxn];\nint min(int x, int y) &#123; return x &lt; y ? x : y; &#125;\nint max(int x, int y) &#123; return x &gt; y ? x : y; &#125;\nbool BFS(int n) &#123;\n    std::fill(vis + 1, vis + n + 1, 0);\n    std::fill(dep + 1, dep + n + 1, 0); \n    std::queue&lt;int&gt; q;\n    dep[gs] = 1, vis[gs] = 1;\n    q.push(gs), now[gs] = h[gs];\n    while (!q.empty()) &#123;\n        int f = q.front(); q.pop();\n        for (int i = h[f]; i; i = u[i].n) &#123;\n            int v = u[i].v, w = u[i].w;\n            if (vis[v] == 1 || w == 0) continue;\n            vis[v] = 1, now[v] = h[v];\n            dep[v] = dep[f] + 1, q.push(v);\n            if (v == gt) return 1;\n        &#125;\n    &#125;\n    return 0;\n&#125;\nint findP(int x, int flow = inf) &#123;\n    if (x == gt) return flow;\n    int rest = flow, i;\n    for (i = now[x]; rest &amp;&amp; i; i = u[i].n) &#123;\n        int v = u[i].v, w = u[i].w;\n        now[x] = i;\n        if (dep[v] != dep[x] + 1 || w == 0) continue;\n        int t = findP(v, min(rest, w));\n        if (t == 0) dep[v] = 0;\n        rest -= t, u[i].w -= t, u[i ^ 1].w += t;\n    &#125;\n    return flow - rest;\n&#125;\nint Dinic(int n) &#123;\n    int res = 0;\n    while (BFS(n)) &#123;\n        int t = findP(gs);\n        while (t) res += t, t = findP(gs);\n    &#125;\n    return res;\n&#125;\nvoid add(int x, int y, int w) &#123;\n    u[++tot] = _(y, w, h[x]);\n    h[x] = tot;\n    return;\n&#125;\nvoid addf(int x, int y, int w) &#123;\n    add(x, y, w), add(y, x, 0);\n    return;\n&#125;\nint main() &#123;\n    read(n);\n    gs = 2 * n + 1, gt = gs + 1;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        read(a[i]), f[i] = 1;\n        addf(i, i + n, 1);\n        addf(i + n, i, 1);\n        for (int j = 1; j &lt; i; ++j) &#123;\n            if (a[j] &lt;= a[i])\n                f[i] = max(f[i], f[j] + 1);\n        &#125;\n        res = max(res, f[i]);\n        for (int j = 1; j &lt; i; ++j) &#123;\n            if (a[j] &lt;= a[i] &amp;&amp; f[i] == f[j] + 1)\n                addf(j, i + n, 1);\n        &#125;\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        if (f[i] == 1) addf(gs, i, 1);\n        if (f[i] == res) addf(i + n, gt, 1);\n    &#125;\n    print(res, &#39;\\n&#39;);\n    print(Dinic(gt), &#39;\\n&#39;);\n    tot = 1;\n    memset(h, 0, sizeof (h));\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        addf(i, i + n, 1);\n        addf(i + n, i, 1);\n        for (int j = 1; j &lt; i; ++j) &#123;\n            if (a[j] &lt;= a[i] &amp;&amp; f[i] == f[j] + 1)\n                addf(j, i + n, 1);\n        &#125;\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        if (f[i] == 1) &#123;\n            if (i == 1) addf(gs, i, inf);\n            else addf(gs, i, 1);\n        &#125;\n        if (f[i] == res) &#123;\n            if (i == n) addf(i + n, gt, inf);\n            else addf(i + n, gt, 1);\n        &#125;\n    &#125;\n    print(Dinic(gt), &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n</details>\n<hr />\n<h3 id=\"c.-餐巾计划问题\">C. 餐巾计划问题</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/3952/problem/3\" class=\"uri\">http://222.180.160.110:61235/contest/3952/problem/3</a></p>\n<p>这个有点简单啊。就差把费用流三个大字拍你脸上了。</p>\n<p>用过和没用过的餐巾是不能混合处理的，故考虑拆点，把每一天拆出来一个点表示当天所有用过的餐巾量（注意不止是当天用过的，还可以是前几天传下来的）。</p>\n<p>首先不难想到大源点和每天的没用过连边，容量为无穷大，费用为购买费用，表示购买餐巾；用过的和下一天用过的连边，容量为无穷大，费用为 <span class=\"math inline\">\\(0\\)</span>，表示用过的餐巾的继承；用过的和快洗 / 慢洗所需时间后的没用过的连边，容量为无穷大，费用为快洗 / 慢洗费用，表示把用过的洗成没用过的（奇奇怪怪）。</p>\n<p>那么问题来了，怎么表示使用餐巾呢？这里有一个很妙的处理方式，把没用过的朝大汇点连边，容量为当天使用量，费用为 <span class=\"math inline\">\\(0\\)</span>，表示把这么多没用过的餐巾销毁；再把大源点朝用过的连边，容量也为当天使用量，费用为 <span class=\"math inline\">\\(0\\)</span>，表示凭空变出来这么多条用过的餐巾。</p>\n<p>然后跑个费用流就可以了。</p>\n<details>\n<pre class=\"cpp\"><code>#define int long long\nnamespace XSC062 &#123;\nusing namespace fastIO;\nconst int inf = 1e18;\nconst int maxn = 4e3 + 5;\nconst int maxm = 6e5 + 5;\nstruct _ &#123;\n    int v, c, w, n;\n    _() &#123;&#125;\n    _(int v1, int c1, int w1, int n1) &#123;\n        v = v1, c = c1, w = w1, n = n1;\n    &#125;\n&#125;;\n_ u[maxm];\nbool inq[maxn];\nint gs, gt, tot = 1;\nint h[maxn], dis[maxn];\nint fl[maxn], pre[maxn];\nint n, m, t1, c1, t2, c2, res, x;\nint min(int x, int y) &#123; return x &lt; y ? x : y; &#125;\nbool SPFA(int s, int n) &#123;\n    std::queue&lt;int&gt; q;\n    std::fill(dis + 1, dis + n + 1, inf);\n    q.push(s), dis[s] = 0, inq[s] = 1;\n    pre[s] = inf, pre[gt] = 0, fl[s] = inf;\n    while (!q.empty()) &#123;\n        int f = q.front();\n        q.pop(), inq[f] = 0;\n        for (int i = h[f]; i; i = u[i].n) &#123;\n            if (u[i].c == 0) continue;\n            int v = u[i].v, w = u[i].w;\n            if (dis[v] &gt; dis[f] + w) &#123;\n                pre[v] = i ^ 1;\n                dis[v] = dis[f] + w;\n                fl[v] = min(fl[f], u[i].c);\n                if (!inq[v]) inq[v] = 1, q.push(v);\n            &#125;\n        &#125;\n    &#125;\n    return pre[gt];\n&#125;\nvoid SSP(int s, int n) &#123;\n    int p, mn, d;\n    while (SPFA(s, n)) &#123;\n        mn = fl[gt], d = 0;\n        for (p = gt; p != s; p = u[pre[p]].v) &#123;\n            u[pre[p]].c += mn;\n            u[pre[p] ^ 1].c -= mn;\n            d += u[pre[p] ^ 1].w;\n        &#125;\n        res += mn * d;\n    &#125;\n    return;\n&#125;\nvoid add(int x, int y, int c, int w) &#123;\n    u[++tot] = _(y, c, w, h[x]);\n    h[x] = tot;\n    return;\n&#125;\nvoid addf(int x, int y, int c, int w) &#123;\n    add(x, y, c, w), add(y, x, 0, -w);\n    return;\n&#125;\nint main() &#123;\n    read(n);\n    gs = 2 * n + 1, gt = gs + 1;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        read(x);\n        addf(i, gt, x, 0);\n        addf(gs, i + n, x, 0);\n        if (i != n)\n            addf(i + n, i + 1 + n, inf, 0);\n    &#125;\n    read(m), read(t1);\n    read(c1), read(t2), read(c2);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        addf(gs, i, inf, m);\n        if (i + t1 &lt;= n)\n            addf(i + n, i + t1, inf, c1);\n        if (i + t2 &lt;= n)\n            addf(i + n, i + t2, inf, c2);\n    &#125;\n    SSP(gs, gt);\n    print(res, &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n</details>\n<hr />\n<h3 id=\"d.-运输问题\">D. 运输问题</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/3952/problem/4\" class=\"uri\">http://222.180.160.110:61235/contest/3952/problem/4</a></p>\n<p>不是很理解啊，这题就一个普普通通的二分图建模，有什么难点吗，，，</p>\n<p>哦，蓝的，那没事了。</p>\n<details>\n<pre class=\"cpp\"><code>#define int long long\nnamespace XSC062 &#123;\nusing namespace fastIO;\nconst int inf = 1e18;\nconst int maxn = 4e3 + 5;\nconst int maxm = 6e5 + 5;\nstruct _ &#123;\n    int v, c, w, n;\n    _() &#123;&#125;\n    _(int v1, int c1, int w1, int n1) &#123;\n        v = v1, c = c1, w = w1, n = n1;\n    &#125;\n&#125;;\nbool inq[maxn];\nint gs, gt, tot = 1;\n_ u[maxm], u1[maxm];\nint fl[maxn], pre[maxn];\nint h[maxn], dis[maxn], h1[maxn];\nint n, m, t1, c1, t2, c2, res, x;\nint min(int x, int y) &#123;\n    return x &lt; y ? x : y;\n&#125;\nbool SPFA(int s, int n) &#123;\n    std::queue&lt;int&gt; q;\n    std::fill(dis + 1, dis + n + 1, inf);\n    q.push(s), dis[s] = 0, inq[s] = 1;\n    pre[s] = inf, pre[gt] = 0, fl[s] = inf;\n    while (!q.empty()) &#123;\n        int f = q.front();\n        q.pop(), inq[f] = 0;\n        for (int i = h[f]; i; i = u[i].n) &#123;\n            if (u[i].c == 0)\n                continue;\n            int v = u[i].v, w = u[i].w;\n            if (dis[v] &gt; dis[f] + w) &#123;\n                pre[v] = i ^ 1;\n                dis[v] = dis[f] + w;\n                fl[v] = min(fl[f], u[i].c);\n                if (!inq[v]) inq[v] = 1, q.push(v);\n            &#125;\n        &#125;\n    &#125;\n    return pre[gt];\n&#125;\nbool SPFA1(int s, int n) &#123;\n    std::queue&lt;int&gt; q;\n    std::fill(pre + 1, pre + n + 1, 0);\n    std::fill(dis + 1, dis + n + 1, -inf);\n    q.push(s), dis[s] = 0, inq[s] = 1;\n    pre[s] = inf, pre[gt] = 0, fl[s] = inf;\n    while (!q.empty()) &#123;\n        int f = q.front();\n        q.pop(), inq[f] = 0;\n        for (int i = h[f]; i; i = u[i].n) &#123;\n            if (u[i].c == 0) continue;\n            int v = u[i].v, w = u[i].w;\n            if (dis[v] &lt; dis[f] + w) &#123;\n                pre[v] = i ^ 1;\n                dis[v] = dis[f] + w;\n                fl[v] = min(fl[f], u[i].c);\n                if (!inq[v])\n                    inq[v] = 1, q.push(v);\n            &#125;\n        &#125;\n    &#125;\n    return pre[gt];\n&#125;\nvoid SSP(int s, int n) &#123;\n    int p, mn, d;\n    while (SPFA(s, n)) &#123;\n        mn = fl[gt], d = 0;\n        for (p = gt; p != s; p = u[pre[p]].v) &#123;\n            u[pre[p]].c += mn;\n            u[pre[p] ^ 1].c -= mn;\n            d += u[pre[p] ^ 1].w;\n        &#125;\n        res += mn * d;\n    &#125;\n    return;\n&#125;\nvoid SSP1(int s, int n) &#123;\n    int p, mn, d;\n    while (SPFA1(s, n)) &#123;\n        mn = fl[gt], d = 0;\n        for (p = gt; p != s; p = u[pre[p]].v) &#123;\n            u[pre[p]].c += mn;\n            u[pre[p] ^ 1].c -= mn;\n            d += u[pre[p] ^ 1].w;\n        &#125;\n        res += mn * d;\n    &#125;\n    return;\n&#125;\nvoid add(int x, int y, int c, int w) &#123;\n    u[++tot] = _(y, c, w, h[x]);\n    h[x] = tot;\n    return;\n&#125;\nvoid addf(int x, int y, int c, int w) &#123;\n    add(x, y, c, w), add(y, x, 0, -w);\n    return;\n&#125;\nint main() &#123;\n    read(n), read(m);\n    gs = n + m + 1, gt = gs + 1;\n    for (int i = 1; i &lt;= n; ++i)\n        read(x), addf(gs, i, x, 0);\n    for (int i = 1; i &lt;= m; ++i)\n        read(x), addf(i + n, gt, x, 0);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = 1; j &lt;= m; ++j)\n            read(x), addf(i, j + n, inf, x);\n    &#125;\n    memcpy(h1, h, sizeof (h1));\n    memcpy(u1, u, sizeof (u1));\n    SSP(gs, gt);\n    print(res, &#39;\\n&#39;), res = 0;\n    memcpy(h, h1, sizeof (h));\n    memcpy(u, u1, sizeof (u));\n    SSP1(gs, gt);\n    print(res, &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n</details>\n<hr />\n<h3 id=\"e.-最小路径覆盖\">E. 最小路径覆盖</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/3952/problem/5\" class=\"uri\">http://222.180.160.110:61235/contest/3952/problem/5</a></p>\n<p>当我们把所有点视作长度为 <span class=\"math inline\">\\(0\\)</span> 的路径时，答案为 <span class=\"math inline\">\\(n\\)</span>。怎么让这个答案减小呢？我们需要 <strong>合并路径</strong>。</p>\n<p>假设有路径 <span class=\"math inline\">\\(u \\to x\\)</span> 和 <span class=\"math inline\">\\(x \\to v\\)</span>，那么将它们合并为 <span class=\"math inline\">\\(u\\to v\\)</span> 显然可以得到更优的答案。</p>\n<p>那么这个时候就有同学要问了，我选择合并路径的方式会不会对答案产生影响呢？这个不急，我们讲完了再证明。</p>\n<p>首先开一个新图，把所有点整一个保留节目，<span class=\"math inline\">\\(S\\to x\\)</span> 建一条容量为 <span class=\"math inline\">\\(1\\)</span> 的边；<span class=\"math inline\">\\(x&#39; \\to T\\)</span> 建一条容量为 <span class=\"math inline\">\\(1\\)</span> 的边；对于边 <span class=\"math inline\">\\(u\\to v\\)</span>，在 <span class=\"math inline\">\\(u\\to v&#39;\\)</span> 建一条容量为 <span class=\"math inline\">\\(1\\)</span> 的边。</p>\n<p>这个时候我们就有了一个类二分图的模型。想想看，我们在里面跑出来的最大流是什么？</p>\n<p>在这种容量均为 <span class=\"math inline\">\\(1\\)</span> 的类二分图模型中，网络流中找到的路径其实就是二分图中的增广路，因为反向的容量为 <span class=\"math inline\">\\(0\\)</span> 的边就相当于已匹配边，会限制搜索进一步搜下去。</p>\n<p>在二分图中，每找到一条增广路，最大匹配的大小便扩大 <span class=\"math inline\">\\(1\\)</span>；在这里的网络流中也一样，每找到一条路径，最大流的大小便扩大 <span class=\"math inline\">\\(1\\)</span>。</p>\n<p>那么，这里的「路径」究竟有什么含义？</p>\n<p>一条从 <span class=\"math inline\">\\(S\\)</span> 到 <span class=\"math inline\">\\(T\\)</span> 的边，若其流量为 <span class=\"math inline\">\\(1\\)</span>，我们将它视作原图中被选中、加入路径集合的边，你会发现，找最大流（不断延长路径）的过程就相当于在合并路径，而且最后这个新图满足：点和边都不会被重复选中，且因为我们找的是最大流，所有点都会被选中。</p>\n<p>好好好，正确性就很显而易见了，来自于二分图增广路找最大匹配的正确性（被打）。</p>\n<p>那么求出最大流 <span class=\"math inline\">\\(f\\)</span>，因为每合并一次路径，路径的条数就会减少 <span class=\"math inline\">\\(1\\)</span>，所以最后的答案就是 <span class=\"math inline\">\\(N - f\\)</span>。方案呢？</p>\n<p>因为网络流特性，你会发现路径的起点一定是 <span class=\"math inline\">\\(S\\to x\\)</span>（废话），所以找出所有 <span class=\"math inline\">\\(S\\to x\\)</span> 流量为 <span class=\"math inline\">\\(1\\)</span> 的 <span class=\"math inline\">\\(x\\)</span>，它们就是每条路径的起点。</p>\n<p>因为路径没有交叉且肯定联通，所以你沿着这个起点一直找流量为 <span class=\"math inline\">\\(1\\)</span> 的边就能找到头。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int inf = 1e18;\nconst int maxn = 4e3 + 5;\nconst int maxm = 6e5 + 5;\nstruct _ &#123;\n    int v, w, n;\n    _() &#123;&#125;\n    _(int v1, int w1, int n1) &#123;\n        v = v1, w = w1, n = n1;\n    &#125;\n&#125;;\n_ u[maxm];\nbool vis1[maxn];\nint n, m, x, y, res;\nint gs, gt, tot = 1;\nint a[maxn], h[maxn], f[maxn];\nint vis[maxn], now[maxn], dep[maxn];\nint min(int x, int y) &#123; return x &lt; y ? x : y; &#125;\nint max(int x, int y) &#123; return x &gt; y ? x : y; &#125;\nbool BFS(int n) &#123;\n    std::fill(vis + 1, vis + n + 1, 0);\n    std::fill(dep + 1, dep + n + 1, 0); \n    std::queue&lt;int&gt; q;\n    dep[gs] = 1, vis[gs] = 1;\n    q.push(gs), now[gs] = h[gs];\n    while (!q.empty()) &#123;\n        int f = q.front(); q.pop();\n        for (int i = h[f]; i; i = u[i].n) &#123;\n            int v = u[i].v, w = u[i].w;\n            if (vis[v] == 1 || w == 0) continue;\n            vis[v] = 1, now[v] = h[v];\n            dep[v] = dep[f] + 1, q.push(v);\n            if (v == gt) return 1;\n        &#125;\n    &#125;\n    return 0;\n&#125;\nint findP(int x, int flow = inf) &#123;\n    if (x == gt) return flow;\n    int rest = flow, i;\n    for (i = now[x]; rest &amp;&amp; i; i = u[i].n) &#123;\n        int v = u[i].v, w = u[i].w;\n        now[x] = i;\n        if (dep[v] != dep[x] + 1 || w == 0) continue;\n        int t = findP(v, min(rest, w));\n        if (t == 0) dep[v] = 0;\n        rest -= t, u[i].w -= t, u[i ^ 1].w += t;\n    &#125;\n    return flow - rest;\n&#125;\nint Dinic(int n) &#123;\n    int res = 0;\n    while (BFS(n)) &#123;\n        int t = findP(gs);\n        while (t) res += t, t = findP(gs);\n    &#125;\n    return res;\n&#125;\nvoid add(int x, int y, int w) &#123;\n    u[++tot] = _(y, w, h[x]);\n    h[x] = tot;\n    return;\n&#125;\nvoid addf(int x, int y, int w) &#123;\n    add(x, y, w), add(y, x, 0);\n    return;\n&#125;\nvoid output(int x) &#123;\n    if (x == gs) return;\n    print(x, &#39; &#39;), vis1[x] = 1;\n    for (int i = h[x]; i; i = u[i].n) &#123;\n        int v = u[i].v;\n        if (v &lt;= n || v &gt; 2 * n || vis1[v - n])\n            continue;\n        if (u[i].w == 0) &#123;\n            output(u[i].v - n);\n            return;\n        &#125;\n    &#125;\n    return;\n&#125;\nint main() &#123;\n    read(n), read(m);\n    gs = 2 * n + 1, gt = gs + 1;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        addf(gs, i, 1);\n        addf(i + n, gt, 1);\n    &#125;\n    while (m--) &#123;\n        read(x), read(y);\n        addf(x, y + n, 1);\n    &#125;\n    res = n - Dinic(gt);\n    for (int i = h[gt]; i; i = u[i].n) &#123;\n        if (u[i ^ 1].w == 1) &#123;\n            output(u[i].v - n);\n            putchar(&#39;\\n&#39;);\n        &#125;\n    &#125;\n    print(res, &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n</details>\n<hr />\n<h3 id=\"f.-数字梯形\">F. 数字梯形</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/3952/problem/6\" class=\"uri\">http://222.180.160.110:61235/contest/3952/problem/6</a></p>\n<p>在 GM 的强制要求下只能跳了，呜呜呜</p>\n<hr />\n<h2 id=\"day-27th---14th\">Day 2：7th - 14th</h2>\n<h3 id=\"a.-太空飞行计划\">A. 太空飞行计划</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/3976/problem/1\" class=\"uri\">http://222.180.160.110:61235/contest/3976/problem/1</a></p>\n<p>不难想到把大源点和实验连容量为报酬的边；把仪器和大汇点连容量为消费的边；实验和仪器之间连容量为无穷大的边。</p>\n<p>这个时候我们要选择一些实验不去做，选择一些仪器不要，并且要求要和不要的实验和仪器之间不能有边关联，还要求留下的利润最大。</p>\n<p>假如我们把删去一条仪器边视作保留仪器，删去一条实验边视作跳过实验，这是什么？最小割！因为必须保证没有关联，这和最小割要求被分为两个部分是符合的。因为中间的边容量无穷大，故绝对不会选中间的边。同时，它删除了最不赚钱的实验，保留了最便宜的仪器。</p>\n<p>据说这也是个经典最小割模型，建议掌握。</p>\n<p>然后答案呢？先暂时将器材视为负权值，则：</p>\n<ol type=\"1\">\n<li>总收入 为 被选中的实验权值 加上 被选中的器材权值</li>\n<li>被选中的实验权值 为 所有实验权值和 减去 未被选择的实验权值和</li>\n<li>总收入 为 所有实验权值和 减去 未被选择的实验权值和 加上 被选中的器材权值</li>\n<li>总收入 为 所有实验权值和 减去 未被选择的实验权值和 减去 被选中的器材权值的相反数</li>\n<li>最小割 为 未被选择的实验权值和 加上 被选中的器材权值的相反数</li>\n<li>总收入 为 被选中的实验权值 减去 最小割</li>\n</ol>\n<p>那么怎么输出方案呢？</p>\n<p><a href=\"https://www.luogu.com.cn/blog/35891/solution-p2762\" class=\"uri\">https://www.luogu.com.cn/blog/35891/solution-p2762</a></p>\n<p>woc 这篇讲得太好了。最后一次 Dinic 失败了，这是为什么呢？因为 BFS 找不到汇点了，说明若干条残量为 0 的边已经堵死了从源点到汇点的路。这个时候这些残量为 0 的边其实就是最小割。</p>\n<p>那选取的实验和仪器，就是从源点出发可以到达的（已在 BFS 中为其分层作为记号），所以只需统计有层数的点即可。太妙了。</p>\n<details>\n<pre class=\"cpp\"><code>#define int long long\nnamespace XSC062 &#123;\nusing namespace fastIO;\nconst int inf = 1e18;\nconst int maxn = 4e3 + 5;\nconst int maxm = 6e5 + 5;\nstruct _ &#123;\n    int v, w, n;\n    _() &#123;&#125;\n    _(int v1, int w1, int n1) &#123;\n        v = v1, w = w1, n = n1;\n    &#125;\n&#125;;\n_ u[maxm];\nbool vis1[maxn];\nint n, m, x, y, res;\nint gs, gt, tot = 1;\nint a[maxn], h[maxn], f[maxn];\nint vis[maxn], now[maxn], dep[maxn];\nint min(int x, int y) &#123; return x &lt; y ? x : y; &#125;\nint max(int x, int y) &#123; return x &gt; y ? x : y; &#125;\nbool BFS(int n) &#123;\n    std::fill(vis + 1, vis + n + 1, 0);\n    std::fill(dep + 1, dep + n + 1, 0); \n    std::queue&lt;int&gt; q;\n    dep[gs] = 1, vis[gs] = 1;\n    q.push(gs), now[gs] = h[gs];\n    while (!q.empty()) &#123;\n        int f = q.front(); q.pop();\n        for (int i = h[f]; i; i = u[i].n) &#123;\n            int v = u[i].v, w = u[i].w;\n            if (vis[v] == 1 || w == 0) continue;\n            vis[v] = 1, now[v] = h[v];\n            dep[v] = dep[f] + 1, q.push(v);\n            if (v == gt) return 1;\n        &#125;\n    &#125;\n    return 0;\n&#125;\nint findP(int x, int flow = inf) &#123;\n    if (x == gt) return flow;\n    int rest = flow, i;\n    for (i = now[x]; rest &amp;&amp; i; i = u[i].n) &#123;\n        int v = u[i].v, w = u[i].w;\n        now[x] = i;\n        if (dep[v] != dep[x] + 1 || w == 0) continue;\n        int t = findP(v, min(rest, w));\n        if (t == 0) dep[v] = 0;\n        rest -= t, u[i].w -= t, u[i ^ 1].w += t;\n    &#125;\n    return flow - rest;\n&#125;\nint Dinic(int n) &#123;\n    int res = 0;\n    while (BFS(n)) &#123;\n        int t = findP(gs);\n        while (t) res += t, t = findP(gs);\n    &#125;\n    return res;\n&#125;\nvoid add(int x, int y, int w) &#123;\n    u[++tot] = _(y, w, h[x]);\n    h[x] = tot;\n    return;\n&#125;\nvoid addf(int x, int y, int w) &#123;\n    add(x, y, w), add(y, x, 0);\n    return;\n&#125;\nint main() &#123;\n    scanf(&quot;%lld %lld&quot;, &amp;n, &amp;m);\n    gs = n + m + 1, gt = gs + 1;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        scanf(&quot;%lld&quot;, &amp;x);\n        addf(gs, i, x);\n        res += x;\n        std::string tmp;\n        std::getline(std::cin, tmp);\n        std::stringstream t(tmp);\n        while (t &gt;&gt; y)\n            addf(i, y + n, inf);\n    &#125;\n    for (int i = 1; i &lt;= m; ++i)\n        read(x), addf(n + i, gt, x);\n    res -= Dinic(gt);\n    for (int i = 1; i &lt;= n; ++i)\n        if (dep[i] != 0) print(i, &#39; &#39;);\n    putchar(&#39;\\n&#39;);\n    for (int i = n + 1; i &lt;= n + m; ++i)\n        if (dep[i] != 0) print(i - n, &#39; &#39;);\n    putchar(&#39;\\n&#39;), print(res, &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n</details>\n",
            "tags": [
                "网络流"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20230720/",
            "url": "https://xsc062.netlify.app/20230720/",
            "title": "费用流练习",
            "date_published": "2023-07-20T09:57:23.000Z",
            "content_html": "<p><a href=\"http://222.180.160.110:61235/contest/3820\">费用流入门练习</a>。</p>\n<span id=\"more\"></span>\n<hr />\n<h3 id=\"a.-订货\">A. 订货</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/3820/problem/1\" class=\"uri\">http://222.180.160.110:61235/contest/3820/problem/1</a></p>\n<p>这个带继承关系的模型很熟悉，想到了 <a href=\"https://www.cnblogs.com/XSC062/p/17548925.html\">猪</a> 那一题。所以我们试着仿照这个方式来建图。</p>\n<p>题目提到了单位费用，这简直就是直接把边的费用拍你脸上嘲讽。</p>\n<p>我们拉一个大源点，朝每个月连一条容量为无穷大、费用为当月购买单位费用的边，表示每个月的购买。</p>\n<p>拉一个大汇点，每个月朝它连一条容量为当月需求量、费用为 <span class=\"math inline\">\\(0\\)</span> 的边，表示每个月的需求。</p>\n<p>再让每个月朝下一个月连一条容量为仓库容量、费用为贮存费用的边，表示继承。跑一个最小费用最大流即可。</p>\n<details>\n<pre class=\"cpp\"><code>#define int long long\nnamespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 405;\nconst int inf = 1e18;\nconst int maxm = 5e5 + 5;\nstruct _ &#123;\n    int v, c, w, n;\n    _() &#123;&#125;\n    _(int v1, int c1, int w1, int n1) &#123;\n        v = v1, c = c1, w = w1, n = n1;\n    &#125;\n&#125;;\n_ u[maxm];\nbool inq[maxn];\nint n, m, S, x, res;\nint gs, gt, tot = 1;\nint h[maxn], dis[maxn];\nint fl[maxn], pre[maxn];\nint min(int x, int y) &#123;\n    return x &lt; y ? x : y;\n&#125;\nbool SPFA(int s, int n) &#123;\n    std::queue&lt;int&gt; q;\n    std::fill(dis + 1, dis + n + 1, inf);\n    q.push(s), dis[s] = 0, inq[s] = 1;\n    pre[s] = inf, pre[gt] = 0, fl[s] = inf;\n    while (!q.empty()) &#123;\n        int f = q.front();\n        q.pop(), inq[f] = 0;\n        for (int i = h[f]; i; i = u[i].n) &#123;\n            if (u[i].c == 0)\n                continue;\n            int v = u[i].v, w = u[i].w;\n            if (dis[v] &gt; dis[f] + w) &#123;\n                pre[v] = i ^ 1;\n                dis[v] = dis[f] + w;\n                fl[v] = min(fl[f], u[i].c);\n                if (!inq[v])\n                    inq[v] = 1, q.push(v);\n            &#125;\n        &#125;\n    &#125;\n    return pre[gt];\n&#125;\nvoid SSP(int s, int n) &#123;\n    int p, mn, d;\n    while (SPFA(s, n)) &#123;\n        mn = fl[gt], d = 0;\n        for (p = gt; p != s; p = u[pre[p]].v) &#123;\n            u[pre[p]].c += mn;\n            u[pre[p] ^ 1].c -= mn;\n            d += u[pre[p] ^ 1].w;\n        &#125;\n        res += mn * d;\n    &#125;\n    return;\n&#125;\nvoid add(int x, int y, int c, int w) &#123;\n    u[++tot] = _(y, c, w, h[x]);\n    h[x] = tot;\n    return;\n&#125;\nvoid addf(int x, int y, int c, int w) &#123;\n    add(x, y, c, w), add(y, x, 0, -w);\n    return;\n&#125;\nint main() &#123;\n    read(n), read(m), read(S);\n    gs = n + 1, gt = gs + 1;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        read(x);\n        addf(i, gt, x, 0);\n        if (i != n)\n            addf(i, i + 1, S, m);\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        read(x);\n        addf(gs, i, inf, x);\n    &#125;    \n    SSP(gs, gt);\n    print(res, &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int  </code></pre>\n</details>\n<hr />\n<h3 id=\"b.-网络扩容\">B. 网络扩容</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/3820/problem/2\" class=\"uri\">http://222.180.160.110:61235/contest/3820/problem/2</a></p>\n<p>鉴于一道费用流不会无缘无故先让你求一遍最大流，我们先持观望态度，暂且认为最大流对题目有提示作用 <del>而不是说这道题就是个缝合怪</del></p>\n<p>其实看完题我们就悟了，这怎么这么像上下界网络流那个差量网络呀，要不我们试试这么干？</p>\n<p>我们先求得普通网络中的最大流，然后每条边减去流量，就成为了一个「差量网络 Pro」。那么我们现在就要通过扩容让该网络中的最大流变为 <span class=\"math inline\">\\(K\\)</span>。对于扩容的操作，不难想到把每条边的边权设为正无穷，然后费用设为扩容费用。</p>\n<p>现在有了一个问题：原图中未留满的边，在现在的新网络中的残余容量应该如何处理呢？很简单，我们就把它当作已经扩过了这么多容，通过拆边操作拆出来一条容量为原图中残余容量、费用为 <span class=\"math inline\">\\(0\\)</span>「会员通道」，那么算法就会优先选择这条边。</p>\n<p>怎么去控制流量为 <span class=\"math inline\">\\(K\\)</span>？联想到之前的拆边操作，我们考虑拆点。在 <span class=\"math inline\">\\(1\\)</span> 和 <span class=\"math inline\">\\(N\\)</span> 中任选一个拆开作为新的源点 / 汇点，新点和旧点之间的容量为 <span class=\"math inline\">\\(K\\)</span>、费用为 <span class=\"math inline\">\\(0\\)</span> 即可。</p>\n<p>然后跑一个最小费用最大流就行。<del>该说不说题目的正解思路引导做得还挺好的</del></p>\n<p>其实注意到在跑完最大流之后，所有正向边的残余容量已经求得，只要在跑最大流时令所有边的费用为 <span class=\"math inline\">\\(0\\)</span>（毕竟最大流不关心费用），就可以沿用原图，只加新边再跑费用流。</p>\n<details>\n<pre class=\"cpp\"><code>#define int long long\nnamespace XSC062 &#123;\nusing namespace fastIO;\nconst int inf = 1e18;\nconst int maxn = 1e3 + 5;\nconst int maxm = 5e5 + 5;\nstruct _ &#123;\n    int v, c, w, n;\n    _() &#123;&#125;\n    _(int v1, int c1, int w1, int n1) &#123;\n        v = v1, c = c1, w = w1, n = n1;\n    &#125;\n&#125;;\nstruct __ &#123; int x, y, c, w; &#125;;\n_ u[maxm];\n__ w[maxm];\nbool inq[maxn];\nint n, m, k, res;\nint gs, gt, tot = 1;\nint h[maxn], dis[maxn];\nint fl[maxn], pre[maxn];\nint vis[maxn], now[maxn], dep[maxn];\nint min(int x, int y) &#123;\n    return x &lt; y ? x : y;\n&#125;\nbool BFS(int n) &#123;\n    std::fill(vis + 1, vis + n + 1, 0);\n    std::fill(dep + 1, dep + n + 1, 0); \n    std::queue&lt;int&gt; q;\n    dep[gs] = 1, vis[gs] = 1;\n    q.push(gs), now[gs] = h[gs];\n    while (!q.empty()) &#123;\n        int f = q.front();\n        q.pop();\n        for (int i = h[f]; i; i = u[i].n) &#123;\n            int v = u[i].v, w = u[i].c;\n            if (vis[v] == 1 || w == 0)\n                continue;\n            vis[v] = 1, now[v] = h[v];\n            dep[v] = dep[f] + 1, q.push(v);\n            if (v == gt)\n                return 1;\n        &#125;\n    &#125;\n    return 0;\n&#125;\nint findP(int x, int flow = inf) &#123;\n    if (x == gt)\n        return flow;\n    int rest = flow, i;\n    for (i = now[x]; rest &amp;&amp; i; i = u[i].n) &#123;\n        int v = u[i].v, w = u[i].c;\n        now[x] = i;\n        if (dep[v] != dep[x] + 1 || w == 0)\n            continue;\n        int t = findP(v, min(rest, w));\n        if (t == 0)\n            dep[v] = 0;\n        rest -= t;\n        u[i].c -= t, u[i ^ 1].c += t;\n    &#125;\n    return flow - rest;\n&#125;\nint Dinic(int n) &#123;\n    int res = 0;\n    while (BFS(n)) &#123;\n        int t = findP(gs);\n        while (t) &#123;\n            res += t;\n            t = findP(gs);\n        &#125;\n    &#125;\n    return res;\n&#125;\nbool SPFA(int s, int n) &#123;\n    std::queue&lt;int&gt; q;\n    std::fill(dis + 1, dis + n + 1, inf);\n    q.push(s), dis[s] = 0, inq[s] = 1;\n    pre[s] = inf, pre[gt] = 0, fl[s] = inf;\n    while (!q.empty()) &#123;\n        int f = q.front();\n        q.pop(), inq[f] = 0;\n        for (int i = h[f]; i; i = u[i].n) &#123;\n            if (u[i].c == 0)\n                continue;\n            int v = u[i].v, w = u[i].w;\n            if (dis[v] &gt; dis[f] + w) &#123;\n                pre[v] = i ^ 1;\n                dis[v] = dis[f] + w;\n                fl[v] = min(fl[f], u[i].c);\n                if (!inq[v])\n                    inq[v] = 1, q.push(v);\n            &#125;\n        &#125;\n    &#125;\n    return pre[gt];\n&#125;\nvoid SSP(int s, int n) &#123;\n    int p, mn, d;\n    while (SPFA(s, n)) &#123;\n        mn = fl[gt], d = 0;\n        for (p = gt; p != s; p = u[pre[p]].v) &#123;\n            u[pre[p]].c += mn;\n            u[pre[p] ^ 1].c -= mn;\n            d += u[pre[p] ^ 1].w;\n        &#125;\n        res += mn * d;\n    &#125;\n    return;\n&#125;\nvoid add(int x, int y, int c, int w) &#123;\n    u[++tot] = _(y, c, w, h[x]);\n    h[x] = tot;\n    return;\n&#125;\nvoid addf(int x, int y, int c, int w = 0) &#123;\n    add(x, y, c, w), add(y, x, 0, -w);\n    return;\n&#125;\nint main() &#123;\n    read(n), read(m), read(k);\n    gs = 1, gt = n;\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        read(w[i].x), read(w[i].y);\n        read(w[i].c), read(w[i].w);\n        addf(w[i].x, w[i].y, w[i].c);\n    &#125;\n    print(Dinic(n), &#39; &#39;);\n    gs = n + 1, addf(gs, 1, k, 0);\n    for (int i = 1; i &lt;= m; ++i)\n        addf(w[i].x, w[i].y, inf, w[i].w);\n    SSP(gs, gt);\n    print(res, &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n</details>\n<hr />\n<h3 id=\"c.-航班安排\">C. 航班安排</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/3820/problem/3\" class=\"uri\">http://222.180.160.110:61235/contest/3820/problem/3</a></p>\n<p>很简单一个道理，时间的具体值对我们来说并不重要。能到就是能到，不能到就是不能到。</p>\n<p>边权矩阵也并不是全部有用，这条边和任务有关系吗？没有，那就当它是空气。</p>\n<p>那什么会对我们产生限制？飞机数量。故容量由飞机数量决定。什么是我们要最大化的值？收益，故我们的费用是支出。</p>\n<p>如果飞机能在一个任务结束之后，在另一个任务开始之前飞过去，那就将两个任务连边，容量为 <span class=\"math inline\">\\(1\\)</span>，费用为两点间花费。特别地，应将机场拆为大源点和大汇点，并在二者中任选其一拆点（和 T2 类似），好作出 <span class=\"math inline\">\\(K\\)</span> 的流量限制。</p>\n<p>还有一个小细节，对于一个任务的流量我们也要加以约束，不然碰到流入 <span class=\"math inline\">\\(2\\)</span> 流出 <span class=\"math inline\">\\(2\\)</span> 这种平衡但不合法的情况就不行了，所以对于任务我们也要按老套路拆点。</p>\n<details>\n<pre class=\"cpp\"><code>#define int long long\nnamespace XSC062 &#123;\nusing namespace fastIO;\nconst int inf = 1e18;\nconst int maxn = 405;\nconst int maxm = 4e5 + 5;\nstruct _ &#123;\n    int v, c, w, n;\n    _() &#123;&#125;\n    _(int v1, int c1, int w1, int n1) &#123;\n        v = v1, c = c1, w = w1, n = n1;\n    &#125;\n&#125;;\nstruct __ &#123;\n    int x, y, l, r, c;\n    bool operator&lt; (const __ &amp;q) const &#123;\n        return l &lt; q.l;\n    &#125;\n&#125;;\n_ u[maxm];\n__ w[maxn];\nbool inq[maxn];\nint gs, gt, tot = 1;\nint h[maxn], dis[maxn];\nint fl[maxn], pre[maxn];\nint n, m, k, T, res, fs, ft;\nint t[maxn][maxn], f[maxn][maxn];\nint min(int x, int y) &#123;\n    return x &lt; y ? x : y;\n&#125;\nbool SPFA(int s, int n) &#123;\n    std::queue&lt;int&gt; q;\n    std::fill(dis + 1, dis + n + 1, inf);\n    q.push(s), dis[s] = 0, inq[s] = 1;\n    pre[s] = inf, pre[gt] = 0, fl[s] = inf;\n    while (!q.empty()) &#123;\n        int f = q.front();\n        q.pop(), inq[f] = 0;\n        for (int i = h[f]; i; i = u[i].n) &#123;\n            if (u[i].c == 0)\n                continue;\n            int v = u[i].v, w = u[i].w;\n            if (dis[v] &gt; dis[f] + w) &#123;\n                pre[v] = i ^ 1;\n                dis[v] = dis[f] + w;\n                fl[v] = min(fl[f], u[i].c);\n                if (!inq[v])\n                    inq[v] = 1, q.push(v);\n            &#125;\n        &#125;\n    &#125;\n    return pre[gt];\n&#125;\nvoid SSP(int s, int n) &#123;\n    int p, mn, d;\n    while (SPFA(s, n)) &#123;\n        mn = fl[gt], d = 0;\n        for (p = gt; p != s; p = u[pre[p]].v) &#123;\n            u[pre[p]].c += mn;\n            u[pre[p] ^ 1].c -= mn;\n            d += u[pre[p] ^ 1].w;\n        &#125;\n        res += mn * d;\n    &#125;\n    return;\n&#125;\nvoid add(int x, int y, int c, int w) &#123;\n    u[++tot] = _(y, c, w, h[x]);\n    h[x] = tot;\n    return;\n&#125;\nvoid addf(int x, int y, int c, int w) &#123;\n    add(x, y, c, w), add(y, x, 0, -w);\n    return;\n&#125;\nint main() &#123;\n    read(n), read(m), read(k), read(T);\n    fs = 2 * m + 1, ft = 2 * m + 2;\n    gs = 2 * m + 3, gt = 2 * m + 4;\n    addf(gs, fs, k, 0), addf(ft, gt, k, 0);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = 1; j &lt;= n; ++j)\n            read(t[i][j]);\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = 1; j &lt;= n; ++j)\n            read(f[i][j]);\n    &#125;\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        read(w[i].x), read(w[i].y);\n        read(w[i].l), read(w[i].r);\n        read(w[i].c), ++w[i].x, ++w[i].y;\n    &#125;\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        addf(i + m, i, 1, 0);\n        if (t[1][w[i].x] &lt;= w[i].l) &#123;\n            addf(fs, i + m, 1,\n                f[1][w[i].x] - w[i].c);\n        &#125;\n        if (w[i].r + t[w[i].y][1] &lt;= T)\n            addf(i, ft, 1, f[w[i].y][1]);\n        for (int j = 1; j &lt;= m; ++j) &#123;\n            if (i != j &amp;&amp; w[i].r +\n                t[w[i].y][w[j].x] &lt;= w[j].l) &#123;\n                addf(i, j + m, 1,\n                    f[w[i].y][w[j].x] - w[j].c);\n            &#125;\n        &#125;\n    &#125;\n    SSP(gs, gt);\n    print(-res, &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n</details>\n<hr />\n<h3 id=\"d.-修车\">D. 修车</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/3820/problem/4\" class=\"uri\">http://222.180.160.110:61235/contest/3820/problem/4</a></p>\n<p>顾客数一定，所谓平均等待时间不过是个幌子，只需要求得最小等待总时间。</p>\n<p>技术人员不能同时修两辆车，<span class=\"math inline\">\\(M\\)</span> 的范围又这么小，不往拆点想都难。可问题来了，怎么拆呢？</p>\n<p>我一开始的想法是，用点 <span class=\"math inline\">\\((i, j)\\)</span> 表示人 <span class=\"math inline\">\\(i\\)</span> 修车 <span class=\"math inline\">\\(j\\)</span>，但是这样建图怎样也无法达到目的。</p>\n<p>于是我添加了一个维度 <span class=\"math inline\">\\(k\\)</span>，用点 <span class=\"math inline\">\\((i, j, k)\\)</span> 表示人 <span class=\"math inline\">\\(i\\)</span> 修车 <span class=\"math inline\">\\(j\\)</span>，并且这是他修的倒数第 <span class=\"math inline\">\\(k\\)</span> 辆车，这样建图就轻而易举了。但接下来就面临了一个问题：这数据范围跑不过。于是乎审视我们的点，其实 <span class=\"math inline\">\\(j\\)</span> 这个维度是可以被合并的，只保留 <span class=\"math inline\">\\((i, k)\\)</span>，因为不可能存在两辆车同时为人 <span class=\"math inline\">\\(i\\)</span> 的倒数第 <span class=\"math inline\">\\(k\\)</span> 辆车。</p>\n<p>故将大源点和每辆车连边，容量为 <span class=\"math inline\">\\(1\\)</span>，费用为 <span class=\"math inline\">\\(0\\)</span>；将每辆车 <span class=\"math inline\">\\(j\\)</span> 和每个 <span class=\"math inline\">\\((i, k)\\)</span> 连边，容量为 <span class=\"math inline\">\\(1\\)</span>，费用为 <span class=\"math inline\">\\(T_{i, j}\\times k\\)</span>。</p>\n<p>这里有一点点费用提前计算的意思，所以就直接将每个 <span class=\"math inline\">\\((i, j)\\)</span> 和大汇点连边，容量为 <span class=\"math inline\">\\(1\\)</span>，费用为 <span class=\"math inline\">\\(0\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#define int long long\nnamespace XSC062 &#123;\nusing namespace fastIO;\nconst int inf = 1e18;\nconst int maxn = 1e4 + 5;\nconst int maxm = 1e6 + 5;\nstruct _ &#123;\n    int v, c, w, n;\n    _() &#123;&#125;\n    _(int v1, int c1, int w1, int n1) &#123;\n        v = v1, c = c1, w = w1, n = n1;\n    &#125;\n&#125;;\n_ u[maxm];\nbool inq[maxn];\nint n, m, x, res;\nint gs, gt, tot = 1;\nint h[maxn], dis[maxn];\nint fl[maxn], pre[maxn];\nint fun(int i, int j) &#123;\n    return n + (i - 1) * n + j;\n&#125;\nint min(int x, int y) &#123;\n    return x &lt; y ? x : y;\n&#125;\nbool SPFA(int s, int n) &#123;\n    std::queue&lt;int&gt; q;\n    std::fill(dis + 1, dis + n + 1, inf);\n    q.push(s), dis[s] = 0, inq[s] = 1;\n    pre[s] = inf, pre[gt] = 0, fl[s] = inf;\n    while (!q.empty()) &#123;\n        int f = q.front();\n        q.pop(), inq[f] = 0;\n        for (int i = h[f]; i; i = u[i].n) &#123;\n            if (u[i].c == 0)\n                continue;\n            int v = u[i].v, w = u[i].w;\n            if (dis[v] &gt; dis[f] + w) &#123;\n                pre[v] = i ^ 1;\n                dis[v] = dis[f] + w;\n                fl[v] = min(fl[f], u[i].c);\n                if (!inq[v])\n                    inq[v] = 1, q.push(v);\n            &#125;\n        &#125;\n    &#125;\n    return pre[gt];\n&#125;\nvoid SSP(int s, int n) &#123;\n    int p, mn, d;\n    while (SPFA(s, n)) &#123;\n        mn = fl[gt], d = 0;\n        for (p = gt; p != s; p = u[pre[p]].v) &#123;\n            u[pre[p]].c += mn;\n            u[pre[p] ^ 1].c -= mn;\n            d += u[pre[p] ^ 1].w;\n        &#125;\n        res += mn * d;\n    &#125;\n    return;\n&#125;\nvoid add(int x, int y, int c, int w) &#123;\n    u[++tot] = _(y, c, w, h[x]);\n    h[x] = tot;\n    return;\n&#125;\nvoid addf(int x, int y, int c, int w) &#123;\n    add(x, y, c, w), add(y, x, 0, -w);\n    return;\n&#125;\nint main() &#123;\n    read(m), read(n);\n    gs = n * m + n + 1, gt = gs + 1;\n    for (int i = 1; i &lt;= n; ++i)\n        addf(gs, i, 1, 0);\n    for (int i = 1; i &lt;= n * m; ++i)\n        addf(i + n, gt, 1, 0);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = 1; j &lt;= m; ++j) &#123;\n            read(x);\n            for (int k = 1; k &lt;= n; ++k) &#123;\n                addf(i, fun(j, k),\n                            1, x * k);\n            &#125;\n        &#125;\n    &#125;\n    SSP(gs, gt);\n    printf(&quot;%.2lf&quot;, res * 1.0 / n);\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n</details>\n<hr />\n<h3 id=\"e.-连连看\">E. 连连看</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/3820/problem/5\" class=\"uri\">http://222.180.160.110:61235/contest/3820/problem/5</a></p>\n<p>样例已经告诉了我们事实：小心删数，因为会有数同时出现在多组勾股数中。</p>\n<p>还是熟悉的单点 <span class=\"math inline\">\\(1\\)</span> 流量限制，故拆点为入点和出点，入点连大源点容量为 <span class=\"math inline\">\\(1\\)</span> 费用为 <span class=\"math inline\">\\(0\\)</span>，出点连大汇点容量为 <span class=\"math inline\">\\(1\\)</span> 费用为 <span class=\"math inline\">\\(0\\)</span>，满足条件的 <span class=\"math inline\">\\(x\\)</span> 和 <span class=\"math inline\">\\(y\\)</span> 我们为了不整细节就暴力地连双向边然后跑最大费用最大流。</p>\n<p>由于双向边这个神必操作，最后的最大流和最大费用都会翻倍，输出的时候要减半。</p>\n<details>\n<pre class=\"cpp\"><code>#define int long long\nnamespace XSC062 &#123;\nusing namespace fastIO;\nconst int inf = 1e18;\nconst int maxn = 2e3 + 5;\nconst int maxm = 4e5 + 5;\nstruct _ &#123;\n    int v, c, w, n;\n    _() &#123;&#125;\n    _(int v1, int c1, int w1, int n1) &#123;\n        v = v1, c = c1, w = w1, n = n1;\n    &#125;\n&#125;;\n_ u[maxm];\nbool inq[maxn];\nint l, r, res, cnt;\nbool f[maxn][maxn];\nint gs, gt, tot = 1;\nint h[maxn], dis[maxn];\nint fl[maxn], pre[maxn];\nint gcd(int x, int y) &#123;\n    return y ? gcd(y, x % y) : x;\n&#125;\nint min(int x, int y) &#123;\n    return x &lt; y ? x : y;\n&#125;\nbool SPFA(int s, int n) &#123;\n    std::queue&lt;int&gt; q;\n    std::fill(dis + 1, dis + n + 1, -inf);\n    q.push(s), dis[s] = 0, inq[s] = 1;\n    pre[s] = inf, pre[gt] = 0, fl[s] = inf;\n    while (!q.empty()) &#123;\n        int f = q.front();\n        q.pop(), inq[f] = 0;\n        for (int i = h[f]; i; i = u[i].n) &#123;\n            if (u[i].c == 0)\n                continue;\n            int v = u[i].v, w = u[i].w;\n            if (dis[v] &lt; dis[f] + w) &#123;\n                pre[v] = i ^ 1;\n                dis[v] = dis[f] + w;\n                fl[v] = min(fl[f], u[i].c);\n                if (!inq[v])\n                    inq[v] = 1, q.push(v);\n            &#125;\n        &#125;\n    &#125;\n    return pre[gt];\n&#125;\nvoid SSP(int s, int n) &#123;\n    int p, mn, d;\n    while (SPFA(s, n)) &#123;\n        mn = fl[gt], d = 0;\n        for (p = gt; p != s; p = u[pre[p]].v) &#123;\n            u[pre[p]].c += mn;\n            u[pre[p] ^ 1].c -= mn;\n            d += u[pre[p] ^ 1].w;\n        &#125;\n        res += mn * d, cnt += mn;\n    &#125;\n    return;\n&#125;\nvoid add(int x, int y, int c, int w) &#123;\n    u[++tot] = _(y, c, w, h[x]);\n    h[x] = tot;\n    return;\n&#125;\nvoid addf(int x, int y, int c, int w) &#123;\n    if (f[x][y])\n        return;\n    f[x][y] = f[y][x] = 1;\n    add(x, y, c, w), add(y, x, 0, -w);\n    return;\n&#125;\nbool check(int x, int y) &#123;\n    int z = sqrt(x * x - y * y);\n    if (z * z + y * y == x * x)\n        return (gcd(z, y) == 1);\n    return 0;\n&#125;\nint main() &#123;\n    read(l), read(r);\n    gs = 2 * r + 1, gt = 2 * r + 2;\n    for (int i = l; i &lt;= r; ++i) &#123;\n        addf(gs, i, 1, 0);\n        addf(i + r, gt, 1, 0);\n        for (int j = l; j &lt; i; ++j) &#123;\n            if (check(i, j)) &#123;\n                addf(j, i + r, 1, i + j);\n                addf(i, j + r, 1, i + j);\n            &#125;\n        &#125;\n    &#125;\n    SSP(gs, gt);\n    print(cnt / 2, &#39; &#39;), print(res / 2, &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n</details>\n<hr />\n<p>依我看，队名就叫「曾总说的都队」吧 🐵</p>\n",
            "tags": [
                "网络流",
                "费用流"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20230717/",
            "url": "https://xsc062.netlify.app/20230717/",
            "title": "学习小组",
            "date_published": "2023-07-17T07:52:02.000Z",
            "content_html": "<p>Solution to <a href=\"https://codeforces.com/problemset/problem/756/D\">CF756D Bacterial Melee</a>。</p>\n<span id=\"more\"></span>\n<hr />\n<p>给我整不会了。怎么处理平方？怎么控制参与总学生最多？其中一定又有什么我不知道的奇技淫巧。</p>\n<p>一切尽在连边。</p>\n<ul>\n<li><p>处理学生与社团间的选择关系</p>\n<p>把学生向社团连边。学生只能选取某社团一次，故容量为 <span class=\"math inline\">\\(1\\)</span>。</p>\n<p>一个学生选取某个社团并不会立即对最终花费带来可计算的影响，因为最终花费由该社团参与的 <strong>所有学生平方数</strong> 决定。</p>\n故这一步我们先不慌计算社团的代价，只算参与社团本身需要的手续费 <span class=\"math inline\">\\(F_i\\)</span>。但是需要注意到手续费是财务部的收入而非支出，故实际边权为 <span class=\"math inline\">\\(-F_i\\)</span>，计算答案时视作负支出（明显不会因此而产生负环，因此可以放心加边）。</li>\n<li><p>处理学生的选择数量上限</p>\n<p>学生最多只能选择 <span class=\"math inline\">\\(K\\)</span> 个社团，为保证这一点，我们将源点向学生连边，容量为 <span class=\"math inline\">\\(K\\)</span>。</p>\n很明显，代价也不在此处计算，故令费用为 <span class=\"math inline\">\\(0\\)</span>。</li>\n<li><p>保证代价最小</p>\n<p>一开始，我认为最小费用最大流一定会找到最小费用，这个处理是无意义的，后来被打脸了。</p>\n<p>我们若欲在此图中寻得最小费用最大流，则 <strong>流一定最大</strong>。</p>\n<p>而学生的流入容量为 <span class=\"math inline\">\\(K\\)</span>，为了满流，学生一定会尽可能多地选择社团，那么费用就会噌噌上涨。回到目标，即保证学生都选取至少一个社团时，支出最小。</p>\n<p>那我们只要给机会让学生可以只选取一个社团就好了（当然也可以是两个、三个……）。</p>\n<p>故让学生向终点连边，容量为 <span class=\"math inline\">\\(K-1\\)</span>，那么学生可以在选取了所有比较赚的社团后就不再选了，选这条边达到满流。同样因为该边流量只有 <span class=\"math inline\">\\(K-1\\)</span>，学生为了满流就只能再选至少一个社团，满足题意。</p>\n不选社团明显是没有手续费和社团支出的，故费用为 <span class=\"math inline\">\\(0\\)</span>。</li>\n<li><p>处理社团本身支出</p>\n<p>问题在于如何处理 <span class=\"math inline\">\\(a\\)</span> 这个平方项。</p>\n<p>对于平方，我们可以联想到许多数学知识，譬如完全平方、平方差等，这里用到了平方差。</p>\n<p>假如原来的代价是 <span class=\"math inline\">\\(C_i\\times x^2\\)</span>，又加入了一个人，那么费用会变成 <span class=\"math inline\">\\(C_i\\times (x + 1)^2\\)</span>。由平方差得两者之差为 <span class=\"math inline\">\\(C_i\\times (2\\times x + 1)\\)</span>。当 <span class=\"math inline\">\\(x - 1\\)</span> 取为任意正整数时，<span class=\"math inline\">\\(2\\times x + 1\\)</span> 即为所有奇数。</p>\n<p>所以我们将社团向汇点连边，连很多条边，每条边表示 <strong>新增一个团员的代价</strong>，容量为 <span class=\"math inline\">\\(1\\)</span> 表示一个新增团员，费用为从 <span class=\"math inline\">\\(1\\)</span> 开始，一直到 <span class=\"math inline\">\\(2\\times (N - 1) + 1\\)</span> 的所有奇数。</p></li>\n</ul>\n<p>那么问题到这里就算处理完了。直接上费用流即可。</p>\n<p>不知道我的代码遭遇了哪家宇宙射线的侵蚀，Dinic 死活过不去，换成 EK 就过了。同学们如果发现自己的 Dinic 过不了也可以试试换 EK。</p>\n<details>\n<pre class=\"cpp\"><code>#define int long long\nnamespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 405;\nconst int inf = 1e18;\nconst int maxm = 5e5 + 5;\nstruct _ &#123;\n    int v, c, w, n;\n    _() &#123;&#125;\n    _(int v1, int c1, int w1, int n1) &#123;\n        v = v1, c = c1, w = w1, n = n1;\n    &#125;\n&#125;;\n_ u[maxm];\nbool inq[maxn];\nint n, m, k, x, res;\nint gs, gt, tot = 1;\nint c[maxn], f[maxn];\nint h[maxn], dis[maxn];\nint fl[maxn], pre[maxn];\nint min(int x, int y) &#123;\n    return x &lt; y ? x : y;\n&#125;\nbool SPFA(int s, int n) &#123;\n    std::queue&lt;int&gt; q;\n    std::fill(dis + 1, dis + n + 1, inf);\n    q.push(s), dis[s] = 0, inq[s] = 1;\n    pre[s] = inf, pre[gt] = 0, fl[s] = inf;\n    while (!q.empty()) &#123;\n        int f = q.front();\n        q.pop(), inq[f] = 0;\n        for (int i = h[f]; i; i = u[i].n) &#123;\n            if (u[i].c == 0)\n                continue;\n            int v = u[i].v, w = u[i].w;\n            if (dis[v] &gt; dis[f] + w) &#123;\n                pre[v] = i ^ 1;\n                dis[v] = dis[f] + w;\n                fl[v] = min(fl[f], u[i].c);\n                if (!inq[v])\n                    inq[v] = 1, q.push(v);\n            &#125;\n        &#125;\n    &#125;\n    return pre[gt];\n&#125;\nvoid SSP(int s, int n) &#123;\n    int p, mn, d;\n    while (SPFA(s, n)) &#123;\n        mn = fl[gt], d = 0;\n        for (p = gt; p != s; p = u[pre[p]].v) &#123;\n            u[pre[p]].c += mn;\n            u[pre[p] ^ 1].c -= mn;\n            d += u[pre[p] ^ 1].w;\n        &#125;\n        res += mn * d;\n    &#125;\n    return;\n&#125;\nvoid add(int x, int y, int c, int w) &#123;\n    u[++tot] = _(y, c, w, h[x]);\n    h[x] = tot;\n    return;\n&#125;\nvoid readx(int &amp;x) &#123;\n    char ch = nec();\n    while (ch != &#39;0&#39; &amp;&amp; ch != &#39;1&#39;)\n        ch = nec();\n    x = ch - &#39;0&#39;;\n    return;\n&#125;\nint main() &#123;\n    read(n), read(m), read(k);\n    gs = n + m + 1, gt = gs + 1;\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        read(c[i]);\n        for (int j = 0; j &lt; n; ++j) &#123;\n            add(i + n, gt, 1,\n                    (2 * j + 1) * c[i]);\n            add(gt, i + n, 0,\n                    -(2 * j + 1) * c[i]);\n        &#125;\n    &#125;\n    for (int i = 1; i &lt;= m; ++i)\n        read(f[i]);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        add(gs, i, k, 0);\n        add(i, gs, 0, 0);\n        add(i, gt, k - 1, 0);\n        add(gt, i, 0, 0);\n        for (int j = 1; j &lt;= m; ++j) &#123;\n            readx(x);\n            if (x == 1) &#123;\n                add(i, j + n, 1, -f[j]); // 负代价\n                add(j + n, i, 0, f[j]);\n            &#125;\n        &#125;\n    &#125;\n    SSP(gs, gt);\n    print(res, &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n</details>\n",
            "tags": [
                "网络流",
                "费用流"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20230716-1/",
            "url": "https://xsc062.netlify.app/20230716-1/",
            "title": "解题报告 匹配数",
            "date_published": "2023-07-16T14:18:06.000Z",
            "content_html": "<p>老题解批量补档。</p>\n<span id=\"more\"></span>\n<hr />\n<p><a href=\"http://222.180.160.110:61235/contest/3887/problem/2\" class=\"uri\">http://222.180.160.110:61235/contest/3887/problem/2</a></p>\n<blockquote>\n<p>求出最小的、不含前导零的 <span class=\"math inline\">\\(n\\)</span> 位数 <span class=\"math inline\">\\(x\\)</span>，满足 <span class=\"math inline\">\\(n-1\\)</span> 条限制，第 <span class=\"math inline\">\\(i\\)</span> 条限制规定 <span class=\"math inline\">\\(x\\)</span> 的第 <span class=\"math inline\">\\(i\\)</span> 位和 <span class=\"math inline\">\\(i + 1\\)</span> 位的关系（小于、大于、等于、不等于）。</p>\n</blockquote>\n<p>如果正着 DP，也就是说先确定前面的数位再向后 DP，后面的数位就没办法决定选择哪个已有状态进行转移，因为我们没有办法仅凭上一位就得到哪个状态拥有最小的字典序。</p>\n<p>但是题解很风轻云淡地给出了一个我一辈子想不出来的 fix：倒着 DP。我们只要保证每次选取最小的可行的下一位即可，这恰好符合字典序的定义。</p>\n<p>记录前驱（or 后继？）后输出即可。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxm = 15;\nconst int maxn = 2e3 + 5;\nint n;\nchar s[maxn];\nint f[maxn][maxm];\nvoid output(int i, int j) &#123;\n    print(j);\n    if (i != n)\n        output(i + 1, f[i][j]);\n    return;\n&#125;\nint main() &#123;\n    scanf(&quot;%s&quot;, s + 1);\n    n = strlen(s + 1) + 1;\n    memset(f, -1, sizeof (f));\n    for (int i = 0; i &lt;= 9; ++i)\n        f[n][i] = 0x3f3f3f3f;\n    for (int i = n - 1; i; --i) &#123;\n        for (int j = 0; j &lt;= 9; ++j) &#123;\n            if (s[i] == &#39;&gt;&#39;) &#123;\n                for (int k = j - 1; k &gt;= 0; --k) &#123;\n                    if (~f[i + 1][k])\n                        f[i][j] = k;\n                &#125;\n            &#125;\n            else if (s[i] == &#39;&lt;&#39;) &#123;\n                for (int k = 9; k &gt; j; --k) &#123;\n                    if (~f[i + 1][k])\n                        f[i][j] = k;\n                &#125;\n            &#125;\n            else if (s[i] == &#39;=&#39;) &#123;\n                if (~f[i + 1][j])\n                    f[i][j] = j;\n            &#125;\n            else &#123;\n                for (int k = 9; ~k; --k) &#123;\n                    if (k == j)\n                        continue;\n                    if (~f[i + 1][k])\n                        f[i][j] = k;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    for (int i = 1; i &lt;= 9; ++i)\n        if (~f[1][i]) &#123;\n            output(1, i);\n            break;\n        &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n",
            "tags": [
                "DP"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20230716/",
            "url": "https://xsc062.netlify.app/20230716/",
            "title": "解题报告 染色",
            "date_published": "2023-07-16T14:09:39.000Z",
            "content_html": "<p>老题解批量补档。</p>\n<span id=\"more\"></span>\n<hr />\n<p><a href=\"http://222.180.160.110:61235/contest/3887/problem/3\" class=\"uri\">http://222.180.160.110:61235/contest/3887/problem/3</a></p>\n<blockquote>\n<p>有 <span class=\"math inline\">\\(N\\)</span> 个格子排成一排，你需要用至多 <span class=\"math inline\">\\(M\\)</span> 种颜色给这些格子染色，每个格子恰好染成某一种颜色，不需要每种颜色都用上。求有多少种染色方案满足相邻的同色格子不超过 <span class=\"math inline\">\\(K\\)</span> 对。</p>\n</blockquote>\n<p>不妨将一对相邻同色格子称为同色对，将一串连续的相同颜色称作一段，那么最极端的情况下会有 <span class=\"math inline\">\\(N\\)</span> 段（即不存在同色对）。</p>\n<p>构造一段长度为 <span class=\"math inline\">\\(L\\)</span> 的 <span class=\"math inline\">\\(L\\)</span> 段序列（即不存在同色对）。此时将任意一段长度增加 1，则出现一对同色对。接下来，不论是选取长度为 2 的那一段，还是选取剩下的长度为 1 的段，将其长度增加 1，都会且仅会增加 1 对同色对。</p>\n<p>以此类推，进行 <span class=\"math inline\">\\(K\\)</span> 次「选取一段并将其长度增加 1」的操作，可得到刚好 <span class=\"math inline\">\\(K\\)</span> 个同色对，此时序列长度为 <span class=\"math inline\">\\(L + K\\)</span>，而 <strong>段数没有变化</strong>，仍是一开始的 <span class=\"math inline\">\\(L\\)</span>。 所以反过来，如果在长度为 <span class=\"math inline\">\\(N\\)</span> 的序列中存在 <span class=\"math inline\">\\(K\\)</span> 个同色对，那么段数为 <span class=\"math inline\">\\(N-K\\)</span>。<del>很难想象题解用「所以」两个字直接略过了上述推导过程</del></p>\n<p>由此，我们只要考虑分别将序列任意分为非空的 <span class=\"math inline\">\\(N-K\\sim N\\)</span> 段，就可以解决问题，隔板法可得将 <span class=\"math inline\">\\(N\\)</span> 分为 <span class=\"math inline\">\\(T\\)</span> 段的方案数为 <span class=\"math inline\">\\(C_{N-1}^{T-1}\\)</span>。在此基础上考虑染色，由乘法原理，将 <span class=\"math inline\">\\(T\\)</span> 段染色的方案为 <span class=\"math inline\">\\((m - 1)^{T - 1}\\times M\\)</span>。</p>\n<p>取 <span class=\"math inline\">\\(T=N-K\\sim N\\)</span> 并求和问题即解决。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 2e5 + 15;\nconst int mod = 998244353;\nint fac[maxn];\nint n, m, k, res;\ninline int qkp(int x, int y) &#123;\n    int res = 1;\n    while (y) &#123;\n        if (y &amp; 1)\n            (res *= x) %= mod;\n        (x *= x) %= mod;\n        y &gt;&gt;= 1;\n    &#125;\n    return res;\n&#125;\ninline int inv(int x) &#123;\n    return qkp(x, mod - 2);\n&#125;\ninline int A(int n, int m) &#123;\n    return (fac[n] * inv(fac[n - m])) % mod;\n&#125;\ninline int C(int n, int m) &#123;\n    return (A(n, m) * inv(A(m, m))) % mod;\n&#125;\nint main() &#123;\n    read(n), read(m), read(k);\n    fac[0] = 1;\n    for (int i = 1; i &lt;= n + 5; ++i)\n        fac[i] = (fac[i - 1] * i) % mod;\n    for (int i = n - k; i &lt;= n; ++i) &#123;\n        (res += ((C(n - 1, i - 1) *\n                qkp(m - 1, i - 1)) % mod\n                * m) % mod) %= mod;\n    &#125;\n    print(res, &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n</details>\n",
            "tags": [
                "排列组合"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20230527/",
            "url": "https://xsc062.netlify.app/20230527/",
            "title": "中国剩余定理",
            "date_published": "2023-05-27T09:12:13.000Z",
            "content_html": "<p>upd on 04/27/25：发现该文没写完 <img src=\"/em/qd.gif\" /></p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"中国剩余定理\">中国剩余定理</h2>\n<p>给定下列关于 <span class=\"math inline\">\\(x\\)</span> 的一元同余方程组：</p>\n<p><span class=\"math display\">\\[\n\\begin {cases}\nx \\equiv a_1 \\pmod {m_1}  \\\\\nx \\equiv a_2 \\pmod {m_2}  \\\\\n\\quad \\quad \\vdots \\\\\nx \\equiv a_k \\pmod {m_k}\n\\end {cases}\n\\]</span> 其中对于 <span class=\"math inline\">\\(\\forall \\, 1\\le i, j\\le k\\, (i\\ne j)\\)</span>，满足 <span class=\"math inline\">\\(m_i \\, \\bot\\, m_j\\)</span>。下面是求解该方程组的具体方法：</p>\n<p>令 <span class=\"math inline\">\\(M = \\prod \\limits _{i = 1} ^ k m_i, \\, M_i=\\dfrac M {m_i}\\)</span>，则 <span class=\"math inline\">\\(x = \\sum \\limits _{i = 1} ^k a_i\\times M_i\\times M_i ^{-1} \\pmod M\\)</span>。</p>\n<p>其中，<span class=\"math inline\">\\(M_i^{-1}\\)</span> 是 <span class=\"math inline\">\\(M_i\\)</span> 在模 <span class=\"math inline\">\\(m_i\\)</span> 意义下的逆元（所以 <span class=\"math inline\">\\(M_i\\times M_i^{-1}\\)</span> 的值并不是视觉上的 <span class=\"math inline\">\\(1\\)</span>）。</p>\n<p>正确性证明：对于 <span class=\"math inline\">\\(\\forall \\, i\\in \\{1, 2, \\cdots, k\\}\\)</span>，有 <span class=\"math inline\">\\(M_i\\mid M\\)</span>；对于 <span class=\"math inline\">\\(\\forall \\, j\\in \\{1, 2, \\cdots, k\\}\\)</span> 且 <span class=\"math inline\">\\(j\\ne i\\)</span>，有 <span class=\"math inline\">\\(m_i\\mid \\dfrac M{m_j}\\)</span> 即 <span class=\"math inline\">\\(m_i\\mid M_j\\)</span>，即 <span class=\"math inline\">\\(M_j\\equiv 0\\pmod {m_i}\\)</span>。</p>\n<p>又 <span class=\"math inline\">\\(m_i\\mid M\\)</span> 那么就有 <span class=\"math inline\">\\(x\\equiv a_i\\cdot M_i\\cdot {M_i}^{-1}\\equiv a_i\\pmod {n_i}\\)</span>。</p>\n<p>时间复杂度 <span class=\"math inline\">\\(\\mathcal O(n\\log n)\\)</span>。注意求解逆元时要用到 exgcd。</p>\n<details>\n<pre class=\"cpp\"><code>int CRT(int k, int *a, int *m) &#123;\n    int M = 1, x = 0;\n    static int M1[maxn], Mi[maxn]; \n    for (int i = 1; i &lt;= k; ++i)\n        M *= m[i];\n    for (int i = 1; i &lt;= k; ++i) &#123;\n        M1[i] = M / m[i];\n        Mi[i] = getinv(M1[i], m[i]);\n        (x += a[i] * M1[i] * Mi[i]) %= M;\n    &#125;\n    return x;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"扩展中国剩余定理\">扩展中国剩余定理</h2>\n<p>设有如下同余方程组：</p>\n<p><span class=\"math display\">\\[\n\\begin {cases}\nx \\equiv a_1 \\pmod {m_1} \\\\\nx \\equiv a_2 \\pmod {m_2}\n\\end {cases}\n\\]</span></p>\n<p>不保证 <span class=\"math inline\">\\(m_1 \\, \\bot \\, m_2\\)</span>。</p>\n<p>设 <span class=\"math inline\">\\(x = m_1 \\times p_1 + a_1 = m_2 \\times p_2 + a_2\\)</span>，其中 <span class=\"math inline\">\\(p_i \\in \\mathbb Z\\)</span>，则有 <span class=\"math inline\">\\(p_1 \\times m_1 - p_2 \\times m_2 = a_2 - a_1\\)</span>。</p>\n<p><span class=\"math inline\">\\(p_1\\)</span> 的值可以用 exgcd 求解，则原方程的解满足 <span class=\"math inline\">\\(x \\equiv m_1\\times p_1 + a_1 \\pmod {M}\\)</span>，其中 <span class=\"math inline\">\\(M=\\operatorname{lcm}(m_1, m_2)\\)</span>。</p>\n<p>这样我们就得到了一个新的同余方程。对于 <span class=\"math inline\">\\(k&gt;2\\)</span> 的情况，我们不断合并两个同余方程即可得到最终同余方程。</p>\n<p>此时根据题目要求（一般求最小值即 <span class=\"math inline\">\\(m_k\\times p_k + a_k\\)</span>）求解答案即可。</p>\n<p>时间复杂度 <span class=\"math inline\">\\(\\mathcal O(n\\log n)\\)</span>，其中 <span class=\"math inline\">\\(\\log\\)</span> 来自 exgcd。</p>\n<details>\n<pre class=\"cpp\"><code>int calc(int m1, int a1, int m2, int a2) &#123;\n    int p1, p2;\n    if (a2 - a1 &lt; 0)\n        swap(a1, a2), swap(m1, m2);\n    int g = exgcd(m1, p1, m2, p2);\n    if ((a2 - a1) % g)\n        return -1;\n    p1 *= (a2 - a1) / g, m2 /= g;\n    p1 = (p1 % m2 + m2) % m2;\n    return p1 * m1 + a1;\n&#125;\nint exCRT(int k, int *a, int *m) &#123;\n    for (int i = 2; i &lt;= k; ++i) &#123;\n        a[i] = calc(m[i - 1],\n                a[i - 1], m[i], a[i]);\n        if (a[i] == -1)\n            return -1;\n        m[i] = lcm(m[i - 1], m[i]);\n    &#125;\n    return a[k] % m[k];\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"d.-strange-way-to-express-integers\">D. Strange Way to Express Integers</h3>\n<p><a href=\"http://222.180.160.110:1024/contest/3642/problem/4\" class=\"uri\">http://222.180.160.110:1024/contest/3642/problem/4</a></p>\n<p>板。但是要开 <code>__int128</code>。不知道为什么智力只用开 <code>long long</code> 就能跑过，我和揭哥就不行。</p>\n<details>\n<pre class=\"cpp\"><code>#define int __int128\nnamespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 1e5 + 5;\nint n;\nint a[maxn], m[maxn];\nint gcd(int x, int y) &#123;\n    return y ? gcd(y, x % y) : x;\n&#125;\ninline int lcm(int x, int y) &#123;\n    return x / gcd(x, y) * y;\n&#125;\ninline void swap(int &amp;x, int &amp;y) &#123;\n    x ^= y ^= x ^= y;\n    return;\n&#125;\nint exgcd(int a, int &amp;x, int b, int &amp;y) &#123;\n    if (b == 0) &#123;\n        x = 1, y = 0;\n        return a;\n    &#125;\n    int u = exgcd(b, x, a % b, y);\n    int t = x;\n    x = y, y = t - (a / b) * y;\n    return u;\n&#125;\ninline int calc(int m1, int a1,\n                    int m2, int a2) &#123;\n    int p1, p2;\n    if (a2 - a1 &lt; 0)\n        swap(a1, a2), swap(m1, m2);\n    int g = exgcd(m1, p1, m2, p2);\n    if ((a2 - a1) % g)\n        return -1;\n    p1 *= (a2 - a1) / g, m2 /= g;\n    p1 = (p1 % m2 + m2) % m2;\n    return p1 * m1 + a1;\n&#125;\ninline int exCRT(int k, int *a, int *m) &#123;\n    for (int i = 2; i &lt;= k; ++i) &#123;\n        a[i] = calc(m[i - 1],\n                a[i - 1], m[i], a[i]);\n        if (a[i] == -1)\n            return -1;\n        m[i] = lcm(m[i - 1], m[i]);\n    &#125;\n    return a[k] % m[k];\n&#125;\nint main() &#123;\n    while (read(n)) &#123;\n        for (int i = 1; i &lt;= n; ++i)\n            read(m[i]), read(a[i]);\n        print(exCRT(n, a, m), &#39;\\n&#39;);\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n</details>\n",
            "tags": [
                "CRT / exCRT"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20230509/",
            "url": "https://xsc062.netlify.app/20230509/",
            "title": "二分图",
            "date_published": "2023-05-09T12:48:00.000Z",
            "content_html": "<p>你说得对，所以我打网络流。</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"二分图\">二分图</h2>\n<p><del>二分图总体概念不难</del>。主要是其应用广泛，需要注意什么样的题目可以联系到二分图上来。</p>\n<h3 id=\"概念\">概念</h3>\n<p>若图 <span class=\"math inline\">\\(G\\)</span> 可将点集 <span class=\"math inline\">\\(V\\)</span> 分成两个互不相交的子集 <span class=\"math inline\">\\(X\\)</span> 和 <span class=\"math inline\">\\(Y\\)</span>，且每条边连接的两个点都满足一个在 <span class=\"math inline\">\\(X\\)</span> 中，一个在 <span class=\"math inline\">\\(Y\\)</span> 中，则称 <span class=\"math inline\">\\(G\\)</span> 为二分图。</p>\n<p>也就是说，如果一个图有任何一种分组方式满足：把图中的点分成两组，每一组的点两两之间没有连边，那么这个图就是二分图。</p>\n<p>举个例子：</p>\n<figure>\n<img src=\"https://pic.imgdb.cn/item/62c8cd2cf54cd3f9371c4818.jpg\" alt=\"每一组中的点两两之间没有连边，所以该图是二分图。\" /><figcaption>每一组中的点两两之间没有连边，所以该图是二分图。</figcaption>\n</figure>\n<h3 id=\"性质\">性质</h3>\n<ul>\n<li><p>二分图的每条边连接的点属于不同的集合。</p>\n<p>显然。</p></li>\n<li><p>二分图中可能存在环，且长度一定为偶数。</p>\n<p>我们指定环中任意一个点，从该点出发，易得，经过奇数条边时到达另一个集合，反之回到该集合。因为路径是一个环，所以我们最后一定会回到起点所在集合，即经过偶数条边。</p></li>\n</ul>\n<h3 id=\"判定\">判定</h3>\n<p>通常，我们使用图的深度优先遍历每一个点 <span class=\"math inline\">\\(u\\)</span>。</p>\n<p>显然，若已知点 <span class=\"math inline\">\\(u\\)</span> 在 <span class=\"math inline\">\\(X\\)</span> 集，那么所有与 <span class=\"math inline\">\\(u\\)</span> 有连边的点 <span class=\"math inline\">\\(v\\)</span> 一定在 <span class=\"math inline\">\\(Y\\)</span> 集（反之同理）。</p>\n<p>当然，很多图是有环的，不免会产生 <span class=\"math inline\">\\(v\\)</span> 已经被分组的情况。若此时 <span class=\"math inline\">\\(v\\)</span> 恰好在 <span class=\"math inline\">\\(Y\\)</span> 集，皆大欢喜；若 <span class=\"math inline\">\\(v\\)</span> 也在 <span class=\"math inline\">\\(X\\)</span> 集，那么该图一定不为二分图。</p>\n<p>由于每个点最多搜索一次，时间复杂度 <span class=\"math inline\">\\(O(n)\\)</span>。</p>\n<pre class=\"cpp\"><code>int col[maxn];\nbool DFS(int x, int c) &#123;\n    col[x] = c;\n    for (auto i : g[x]) &#123;\n        if (col[i]) &#123;\n            if (col[i] == c)\n                return 0;\n        &#125;\n        else if (!DFS(i, 3 - c))\n            return 0;\n    &#125;\n    return 1;\n&#125;\nint main() &#123; DFS(1, 1); &#125;</code></pre>\n<p>厚颜无耻地推销一下 <a href=\"https://www.luogu.com.cn/problem/U283873\">题目</a>（（（</p>\n<h3 id=\"匹配\">匹配</h3>\n<p>定义：对于一个二分图中的若干条边，若这些边没有任何公共点，则称这些边组成的集合 <span class=\"math inline\">\\(M\\)</span> 是数量为 <span class=\"math inline\">\\(|M|\\)</span> 的 <strong>匹配</strong>。</p>\n<figure>\n<img src=\"https://pic.imgdb.cn/item/62c8cd75f54cd3f9371c866f.jpg\" alt=\"图中红色边展示了一个数量为 4 的匹配\" /><figcaption>图中红色边展示了一个数量为 4 的匹配</figcaption>\n</figure>\n<p>容易看出，对于点 <span class=\"math inline\">\\(u\\)</span>，只会存在 「有一条 <span class=\"math inline\">\\(M\\)</span> 集合内的边与 <span class=\"math inline\">\\(u\\)</span> 相连接」 和 「<span class=\"math inline\">\\(u\\)</span> 连接的边均不在 <span class=\"math inline\">\\(M\\)</span> 集合内」 两种情况。也就是说，从 <span class=\"math inline\">\\(u\\)</span> 出发的 <span class=\"math inline\">\\(M\\)</span> 集合内的边，最多有 <span class=\"math inline\">\\(1\\)</span> 条。</p>\n<p>接下来，我们称 「有任何一条与之相连的边在匹配集合内」 的点为匹配点，「在匹配集合内的边」 为匹配边。</p>\n<h3 id=\"完备匹配\">完备匹配</h3>\n<p>如果 <span class=\"math inline\">\\(|M|=\\dfrac n2\\)</span>，即 <span class=\"math inline\">\\(M\\)</span> 恰好连接了 <span class=\"math inline\">\\(1\\sim n\\)</span> 所有点，我们就称匹配 <span class=\"math inline\">\\(M\\)</span> 为 <strong>完备匹配</strong>。</p>\n<figure>\n<img src=\"https://pic.imgdb.cn/item/62c902d9f54cd3f93755faf9.jpg\" alt=\"一个完备匹配的例子\" /><figcaption>一个完备匹配的例子</figcaption>\n</figure>\n<p>比方说，现在我们知道一些男孩和女孩，他们之间有若干条互相喜欢的关系，我们把此关系抽象成一个二分图，如果每个人都能与自己喜欢的异性配对，那么我们认为这个关系网存在完备匹配。</p>\n<p>显然，完备匹配存在，仅当两集合大小相等。</p>\n<hr />\n<h2 id=\"匈牙利算法\">匈牙利算法</h2>\n<p>匈牙利算法一般用于求解 <span class=\"math inline\">\\(\\max\\{|M|\\}\\)</span>。</p>\n<p>我们将图上满足下列条件的路径 <span class=\"math inline\">\\(P\\)</span> 称为<strong>增广路</strong>：</p>\n<ul>\n<li><span class=\"math inline\">\\(P\\)</span> 的起点和终点均是非匹配点</li>\n<li><span class=\"math inline\">\\(P\\)</span> 的起点和终点不在二分图的同一组内</li>\n<li>路径 <span class=\"math inline\">\\(P\\)</span> 经过的边按 <strong>非</strong> 匹配边，匹配边，<span class=\"math inline\">\\(\\cdots\\)</span>，<strong>非</strong> 匹配边的规律交替。</li>\n</ul>\n<p>最终，<span class=\"math inline\">\\(P\\)</span> 会呈类 「<span class=\"math inline\">\\(\\text Z\\)</span>」 形（值得一提的是，增广路不能经过一整个环，否则其长度将会因为二分图中只存在偶环而变为无穷大）。</p>\n<p>显然，非匹配边比匹配边的数量始终多 <span class=\"math inline\">\\(1\\)</span>。</p>\n<p>此时，我们对 <span class=\"math inline\">\\(P\\)</span> 上匹配的状态取反。也就是说，原来的非匹配边变成匹配边，匹配边变成非匹配边。这样做相当于是在匹配边集仍然合法的情况下将匹配边集的大小扩大了 <span class=\"math inline\">\\(1\\)</span>。</p>\n<p>那么增广路经过的边按非匹配边，匹配边，<span class=\"math inline\">\\(\\cdots\\)</span>，非匹配边顺序交替的原因就很显而易见了。取反前，匹配边不可能连续出现；取反后，匹配边（即取反前的非匹配边）也不可能连续出现。</p>\n<p>而匈牙利算法的主要思路，就是反复寻找增广路，直到无法找到为止。</p>\n<p>这里就必须再提到一个性质：<span class=\"math inline\">\\(M\\)</span> 为图 <span class=\"math inline\">\\(G\\)</span> 的最大匹配，当且仅当无法在 <span class=\"math inline\">\\(M\\)</span> 的基础上找到增广路。</p>\n<p>证明如下：</p>\n<ul>\n<li><p>有引理：对于图 <span class=\"math inline\">\\(G\\)</span> 的任意两个匹配 <span class=\"math inline\">\\(M\\)</span> 和 <span class=\"math inline\">\\(M&#39;\\)</span>，它们的 <a href=\"https://baike.baidu.com/item/%E5%AF%B9%E7%A7%B0%E5%B7%AE\">对称差</a> <span class=\"math inline\">\\(M\\Delta M&#39;\\)</span> 中的每一个连通块都是一条链或一个包含边数为偶数的环。</p>\n<p>证明：</p>\n<p>根据对称差的定义，对于任意边 <span class=\"math inline\">\\(e\\in M\\Delta M&#39;\\)</span>，<span class=\"math inline\">\\(e\\)</span> 要么是 <span class=\"math inline\">\\(M\\)</span> 中的一条匹配边，要么是 <span class=\"math inline\">\\(M&#39;\\)</span> 中的一条匹配边，但不同时被 <span class=\"math inline\">\\(M\\)</span> 和 <span class=\"math inline\">\\(M&#39;\\)</span> 包含。</p>\n<p>因为在同一个匹配中，任意两条匹配边不存在公共顶点，所以对于任意与 <span class=\"math inline\">\\(e\\)</span> 有公共顶点的匹配边 <span class=\"math inline\">\\(e&#39;\\)</span>，<span class=\"math inline\">\\(e\\)</span> 和 <span class=\"math inline\">\\(e&#39;\\)</span> 必然来自两个不同的匹配。</p>\n<p>由此可得，对于任意匹配点 <span class=\"math inline\">\\(u\\)</span>，<span class=\"math inline\">\\(u\\)</span> 的度数为 <span class=\"math inline\">\\(1\\)</span> 或 <span class=\"math inline\">\\(2\\)</span>。</p>\n<p>所以，对称差中的每一个连通块都是链或环。</p>\n<p>对于其中的环，所有相邻的边必定来自不同的匹配，所以环包含的边数为偶数。</p></li>\n<li><p>必要性：当 <span class=\"math inline\">\\(M\\)</span> 为最大匹配时，无法找到 <span class=\"math inline\">\\(M\\)</span> 的增广路。</p>\n<p>我们已经知道了，找到某匹配的增广路 <span class=\"math inline\">\\(P\\)</span> 并将其匹配状态取反，可以使匹配大小加一。</p>\n<p>如果 <span class=\"math inline\">\\(M\\)</span> 存在增广路，则我们可以将其取反，得到一个比 <span class=\"math inline\">\\(M\\)</span> 大小更大的匹配。与 <span class=\"math inline\">\\(M\\)</span> 是最大匹配矛盾。</p>\n<p>所以一定不存在 <span class=\"math inline\">\\(M\\)</span> 的增广路。</p></li>\n<li><p>充分性：如果不存在 <span class=\"math inline\">\\(M\\)</span> 的增广路，<span class=\"math inline\">\\(M\\)</span> 为 <span class=\"math inline\">\\(G\\)</span> 的最大匹配。</p>\n<p>设 <span class=\"math inline\">\\(M&#39;\\)</span> 是一个比 <span class=\"math inline\">\\(M\\)</span> 更大的匹配。</p>\n<p>由引理得：</p>\n<p>在它们的对称差 <span class=\"math inline\">\\(M\\Delta M&#39;\\)</span> 中，连通块为链或环。</p>\n<p>其中，环包含边的数量为偶数，所以必然有同样多的边来自 <span class=\"math inline\">\\(M\\)</span> 和 <span class=\"math inline\">\\(M&#39;\\)</span>。所以我们可以忽视这些环。</p>\n<p>由于 <span class=\"math inline\">\\(|M|&lt;|M&#39;|\\)</span>，存在至少一条链 <span class=\"math inline\">\\(L\\)</span>，且 <span class=\"math inline\">\\(|L|=k-1\\)</span>，包含 <span class=\"math inline\">\\(k\\)</span> 条 <span class=\"math inline\">\\(M\\)</span> 中的边，<span class=\"math inline\">\\(k+1\\)</span> 条来自于 <span class=\"math inline\">\\(M&#39;\\)</span> 的边。</p>\n<p>显然，<span class=\"math inline\">\\(L\\)</span> 就是一条 <span class=\"math inline\">\\(M\\)</span> 的增广路，所以我们必然可以找到一条 <span class=\"math inline\">\\(M\\)</span> 的增广路，命题成立。</p></li>\n</ul>\n<p>对于 「寻找增广路」 这个过程，我们使用 DFS 算法实现。</p>\n<p>对于点 <span class=\"math inline\">\\(x\\)</span>，若与 <span class=\"math inline\">\\(x\\)</span> 有连边的点 <span class=\"math inline\">\\(y\\)</span> 可匹配上 <span class=\"math inline\">\\(x\\)</span>，需要满足下列两个条件之一：</p>\n<ul>\n<li><span class=\"math inline\">\\(y\\)</span> 是非匹配点，此时 <span class=\"math inline\">\\(x\\to y\\)</span> 构成一条增广路，非匹配边的数量已经比匹配边数量多 <span class=\"math inline\">\\(1\\)</span>。</li>\n<li><span class=\"math inline\">\\((u,y)\\)</span> 是已匹配边，且 <span class=\"math inline\">\\((u,v)\\)</span> 是未匹配但合法的边，此时 <span class=\"math inline\">\\(x\\to y\\to u\\to v\\)</span> 构成一条增广路。</li>\n</ul>\n<p>在实现中，我们依次令 <span class=\"math inline\">\\(1\\sim n\\)</span> 内 <strong>所有的非匹配点</strong> 作为起始点 <span class=\"math inline\">\\(x\\)</span> 尝试找到任何一条增广路。当碰到任意非匹配点时结束（增广路判定：起点与终点均为非匹配点），否则向 <strong>该匹配点匹配的点</strong> 继续搜索。</p>\n<p>也就是说，一层 DFS 会寻找一条非匹配边并作为起点，产生以下两种行为：</p>\n<ol type=\"1\">\n<li>该非匹配边终点为非匹配点，以该匹配边结束增广路。</li>\n<li>经过该非匹配边后还能再找到一条匹配边（若情况 1 不满足，显然一定能找到这样一条边），则在终点进行下一层 DFS，寻找下一条非匹配边。</li>\n</ol>\n<p>时间复杂度为 <span class=\"math inline\">\\(O(n^2+nm)\\)</span>，但一般二分图题目的 <span class=\"math inline\">\\(X\\)</span> 与 <span class=\"math inline\">\\(Y\\)</span> 部间的连边偏稠密，所以简化为 <span class=\"math inline\">\\(O(nm)\\)</span>。</p>\n<pre class=\"cpp\"><code>bool Find(int x) &#123;\n    vis[x] = now; // 时间戳标记\n    for (auto i : g[x]) &#123;\n        if (vis[i] == now) // 不经过访问过的 i\n            continue;\n        if (!mat[i] /* 非匹配点，即终点 */ ||\n            (vis[mat[i]] != now /* mat[i] 未访问过，可以经过 */\n            &amp;&amp; Find(mat[i]) /* 可找到增广路 */)) &#123;\n            mat[i] = x; // 匹配\n            return 1;\n        &#125;\n    &#125;\n    return 0;\n&#125;\nint Hungary(int n) &#123;\n    int res = 0;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        ++now;\n        res += Find(i);\n    &#125;\n    return res;\n&#125;</code></pre>\n<p>一般来说，二分图题目对点、边、分组方法和匹配范围的识别较为模糊。但一般的二分图题目都会有一些特点：</p>\n<ul>\n<li>结点能分为两组，且各组内结点间没有连边</li>\n<li>每个结点只能与一条边匹配</li>\n</ul>\n<p>有时候，题目要求判定是否存在 「完备匹配」，也就是说，<span class=\"math inline\">\\(ans=n\\)</span>。即任意一次 <code>find(i)</code> 返回 <code>false</code> 时，完备匹配不存在。</p>\n<p>最后给出与匈牙利算法有关的两个问题：</p>\n<ol type=\"1\">\n<li><p>最小点覆盖：给定一个二分图，求出一个最小的点集，使得这个点集发出的所有边可以覆盖整个二分图。</p>\n<p>定理：该点集的大小是二分图的最大匹配包含的边数。</p></li>\n<li><p>最大独立集：给定一个无向图，求出一个最大的点集，使得该点集中的所有点两两之间没有边相连。</p>\n<p>定理：当该无向图是二分图时，最大独立集的大小等于 <span class=\"math inline\">\\(n\\)</span> 减去最大匹配数。</p>\n<p>证明：由于最小点覆盖可以覆盖所有边，故不存在两个点，使得它们不属于最小点覆盖且有连边。</p>\n<p>所以，当去掉最小点覆盖后，剩余点两两之间没有连边。因为最小点覆盖大小就是最大匹配大小，故原命题成立。</p></li>\n</ol>\n<hr />\n<p>注意二分图的点和边是可以互相转化的，即，若发现信息集中在点上，也可以用二分图解决。匹配边的数量即最终参与匹配的点数较多的一方的匹配点数量。</p>\n<p>对于二分图建图的一个判断方式是，找冲突。找到彼此之间有冲突的两方，连边。这样就能建出二分图。当然要保证两方之间没有交集。</p>\n<p>所谓冲突，就是我们通常理解中的选了一个就不能选另一个。因此也可以通过冲突存在的形式思考建图方式。</p>\n<hr />\n<h3 id=\"a.-棋盘上的骑士\">A. 棋盘上的骑士</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/3699/problem/1\" class=\"uri\">http://222.180.160.110:61235/contest/3699/problem/1</a></p>\n<p>这道题就是我们提到的边转化为点的情况。</p>\n<p>为棋盘上的每个格子编号。骑士走的是日字，所以我们要把周围每个格子日字方向八个格子都连上边。</p>\n<p>那要怎么将所有 <span class=\"math inline\">\\(n\\times n\\)</span> 个格子分为有冲突的两方呢？注意到日字连接的两个格子一定奇偶性相异，故我们以奇偶性分类。</p>\n<p>被挖掉的格子无视即可，不能连任何边，否则该边都有可能被选。然后跑一个最大匹配就行。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 205;\nconst int maxm = 1e5 + 5;\nconst int fx[] = &#123; 1, 1, -1, -1, 2, 2, -2, -2 &#125;;\nconst int fy[] = &#123; 2, -2, 2, -2, 1, -1, 1, -1 &#125;;\nint a[maxn][maxn];\nint mat[maxm], vis[maxm];\nstd::vector&lt;int&gt; g[maxm];\nint n, m, x, y, now, cnt, tot;\nbool Find(int x) &#123;\n    vis[x] = now;\n    for (auto i : g[x]) &#123;\n        if (vis[i] == now)\n            continue;\n        if (!mat[i] || (vis[mat[i]] != now\n                            &amp;&amp; Find(mat[i]))) &#123;\n            mat[i] = x;\n            return 1;\n        &#125;\n    &#125;\n    return 0;\n&#125;\nint Hungary(int n) &#123;\n    int res = 0;\n    for (int i = 1; i &lt;= n; ++i)\n        ++now, res += Find(i);\n    return res;\n&#125;\nvoid add(int x, int y) &#123;\n    g[x].push_back(y);\n    return;\n&#125;\nint main() &#123;\n    read(n), read(m);\n    while (m--) &#123;\n        read(x), read(y);\n        a[x][y] = -1;\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = 1; j &lt;= n; ++j) &#123;\n            if (a[i][j] != -1 &amp;&amp; !((i + j) &amp; 1))\n                a[i][j] = ++cnt;\n        &#125;\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = 1; j &lt;= n; ++j) &#123;\n            if (a[i][j] == -1 || !((i + j) &amp; 1))\n                continue;\n            a[i][j] = ++tot;\n            for (int k = 0; k &lt; 8; ++k) &#123;\n                int nx = i + fx[k];\n                int ny = j + fy[k];\n                if (nx &lt; 1 || ny &lt; 1 || nx &gt; n ||\n                    ny &gt; n || a[nx][ny] == -1)\n                    continue;\n                add(a[i][j], a[nx][ny] + n * n);\n            &#125;\n        &#125;\n    &#125;\n    print(cnt + tot - Hungary(tot), &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"b.-火力网\">B. 火力网</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/3699/problem/2\" class=\"uri\">http://222.180.160.110:61235/contest/3699/problem/2</a></p>\n<p>这里用到了二分图在地图上一个较为常用的分组方法。</p>\n<p>找到每行每列的「连通块」，满足在行上的连通块任意放一个炮台，炮台覆盖连通块内所有点，所有点均被连通块覆盖，列范围内同理。为连通块分别编号，则样例的情况可转化如下：</p>\n<pre class=\"plain\"><code>/* 对于行 */        /* 对于列 */\n  1 - 2 2            1 - 5 6\n  3 3 3 3            1 3 5 6\n  - - 4 4            - - 5 6\n  5 5 5 5            2 4 5 6</code></pre>\n<p>若一个格子为空地，则将其在行 / 列范围内所属的连通块连边。这样，我们在选取该格后，就相当于选取了这条边，由于匹配边不共点，所以合法。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 25;\nconst int maxm = 1e5 + 5;\nchar a[maxn][maxn];\nint mat[maxm], vis[maxm];\nstd::vector&lt;int&gt; g[maxm];\nint n, x, y, now, cnt1, cnt2;\nint t[maxn][maxn], p[maxn][maxn];\nbool Find(int x) &#123;\n    vis[x] = now;\n    for (auto i : g[x]) &#123;\n        if (vis[i] == now)\n            continue;\n        if (!mat[i] || (vis[mat[i]] != now\n                            &amp;&amp; Find(mat[i]))) &#123;\n            mat[i] = x;\n            return 1;\n        &#125;\n    &#125;\n    return 0;\n&#125;\nint Hungary(int n) &#123;\n    int res = 0;\n    for (int i = 1; i &lt;= n; ++i)\n        ++now, res += Find(i);\n    return res;\n&#125;\nvoid add(int x, int y) &#123;\n    g[x].push_back(y);\n    return;\n&#125;\nint main() &#123;\n    scanf(&quot;%d&quot;, &amp;n);\n    for (int i = 1; i &lt;= n; ++i)\n        scanf(&quot;%s&quot;, a[i] + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = 1; j &lt;= n; ++j) &#123;\n            if (a[i][j] == &#39;X&#39;)\n                continue;\n            if (a[i][j - 1] != &#39;.&#39;)\n                t[i][j] = ++cnt1;\n            else t[i][j] = t[i][j - 1];\n        &#125;\n    &#125;\n    for (int j = 1; j &lt;= n; ++j) &#123;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            if (a[i][j] == &#39;X&#39;)\n                continue;\n            if (a[i - 1][j] != &#39;.&#39;)\n                p[i][j] = ++cnt2;\n            else p[i][j] = p[i - 1][j];\n        &#125;\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = 1; j &lt;= n; ++j) &#123;\n            if (a[i][j] == &#39;.&#39;)\n                add(t[i][j], p[i][j] + cnt1);\n        &#125;\n    &#125;\n    print(Hungary(cnt1), &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"c.-超级英雄-hero\">C. 超级英雄 Hero</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/3699/problem/3\" class=\"uri\">http://222.180.160.110:61235/contest/3699/problem/3</a></p>\n<p>分析冲突。每个锦囊只能被一道题使用，一道题只能使用一个锦囊，故考虑将锦囊和题连边。题目要求连续解题最多，故以题目进行匈牙利。</p>\n<p>最后输出匹配数组即可。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 2e4 + 5;\nint n, m, x, y, now, t;\nint mat[maxn], vis[maxn];\nstd::vector&lt;int&gt; g[maxn];\nbool Find(int x) &#123;\n    vis[x] = now;\n    for (auto i : g[x]) &#123;\n        if (vis[i] == now)\n            continue;\n        if (!mat[i] || (vis[mat[i]] != now\n                            &amp;&amp; Find(mat[i]))) &#123;\n            mat[i] = x, mat[x] = i;\n            return 1;\n        &#125;\n    &#125;\n    return 0;\n&#125;\nint Hungary(int n) &#123;\n    int res = 0;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        ++now;\n        if (Find(i))\n            ++res;\n        else break;\n    &#125;\n    return res;\n&#125;\nvoid add(int x, int y) &#123;\n    g[x].push_back(y);\n    return;\n&#125;\nint main() &#123;\n    read(n), read(m);\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        read(x), read(y);\n        add(i, x + m + 1);\n        add(i, y + m + 1);\n    &#125;\n    print(t = Hungary(m), &#39;\\n&#39;);\n    for (int i = 1; i &lt;= t; ++i)\n        print(mat[i] - m - 1, &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h2 id=\"km-算法\">KM 算法</h2>\n<p>还没写…… 咕咕咕</p>\n<hr />\n<h3 id=\"a.-ants\">A. Ants</h3>\n<p><a href=\"https://vjudge.net/contest/554888#problem/A\" class=\"uri\">https://vjudge.net/contest/554888#problem/A</a></p>\n<p>板板题。把黑蚂蚁和白蚂蚁按欧几里得距离连边后 KM 即可。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\ntypedef double db;\nconst db inf = 1e18;\nconst db eps = 1e-5;\nconst int maxn = 205;\nint n, now;\ndb g[maxn][maxn];\ndb u[maxn], up[maxn];\nint vis[maxn], mat[maxn];\nint a[maxn][2], b[maxn][2];\ndb max(db x, db y) &#123;\n    return x &gt; y ? x : y;\n&#125;\ndb min(db x, db y) &#123;\n    return x &lt; y ? x : y;\n&#125;\nbool eq(db x, db y) &#123;\n    return fabs(x - y) &lt;= eps;\n&#125;\nbool Find(int x) &#123;\n    vis[x] = now;\n    for (int i = n + 1; i &lt;= 2 * n; ++i) &#123;\n        if (vis[i] == now)\n            continue;\n        if (eq(u[x] + u[i], g[x][i])) &#123;\n            vis[i] = now;\n            if (!mat[i] || (vis[mat[i]] != now\n                            &amp;&amp; Find(mat[i]))) &#123;\n                mat[i] = x;\n                return 1;\n            &#125;\n        &#125;\n        else &#123;\n            up[i] = min(up[i],\n                u[x] + u[i] - g[x][i]);\n        &#125;\n    &#125;\n    return 0;\n&#125;\nvoid Solve(void) &#123;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        u[i] = -inf;\n        for (int j = n + 1; j &lt;= 2 * n; ++j)\n            u[i] = max(u[i], g[i][j]);\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (;;) &#123;\n            ++now;\n            for (int j = n + 1; j &lt;= 2 * n; ++j)\n                up[j] = inf;\n            if (Find(i))\n                break;\n            db Delta = inf;\n            for (int j = n + 1;\n                            j &lt;= 2 * n; ++j) &#123;\n                if (vis[j] != now)\n                    Delta = min(Delta, up[j]);\n            &#125;            for (int j = 1; j &lt;= n; ++j) &#123;\n                if (vis[j] == now)\n                    u[j] -= Delta;\n            &#125;\n            for (int j = n + 1;\n                            j &lt;= 2 * n; ++j) &#123;\n                if (vis[j] == now)\n                    u[j] += Delta;\n            &#125;\n        &#125;\n    &#125;\n    return;\n&#125;\ndb dist(int x1, int y1, int x2, int y2) &#123;\n    return sqrt((db)(x1 - x2) * (x1 - x2) +\n                    (y1 - y2) * (y1 - y2));\n&#125;\nint main() &#123;\n    read(n);\n    for (int i = 1; i &lt;= n; ++i)\n        read(a[i][0]), read(a[i][1]);\n    for (int i = 1; i &lt;= n; ++i)\n        read(b[i][0]), read(b[i][1]);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = 1; j &lt;= n; ++j) &#123;\n            g[j][i + n] = -dist(a[i][0], a[i][1],\n                            b[j][0], b[j][1]);\n        &#125;\n    &#125;\n    Solve();\n    for (int i = n + 1; i &lt;= 2 * n; ++i)\n        print(mat[i], &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<h3 id=\"b.-奔小康赚大钱\">B. 奔小康赚大钱</h3>\n<p><a href=\"https://vjudge.net/contest/554888#problem/B\" class=\"uri\">https://vjudge.net/contest/554888#problem/B</a></p>\n<p>板板题。把居民和房子连边即可。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 605;\nconst int inf = 0x3f3f3f3f;\nint n, now, res;\nint g[maxn][maxn];\nint u[maxn], up[maxn];\nint vis[maxn], mat[maxn];\nint max(int x, int y) &#123;\n    return x &gt; y ? x : y;\n&#125;\nint min(int x, int y) &#123;\n    return x &lt; y ? x : y;\n&#125;\nbool Find(int x) &#123;\n    vis[x] = now;\n    for (int i = n + 1; i &lt;= 2 * n; ++i) &#123;\n        if (vis[i] == now)\n            continue;\n        if (u[x] + u[i] == g[x][i]) &#123;\n            vis[i] = now;\n            if (!mat[i] || (vis[mat[i]] != now\n                            &amp;&amp; Find(mat[i]))) &#123;\n                mat[i] = x;\n                return 1;\n            &#125;\n        &#125;\n        else &#123;\n            up[i] = min(up[i],\n                u[x] + u[i] - g[x][i]);\n        &#125;\n    &#125;\n    return 0;\n&#125;\nvoid Solve(void) &#123;\n    for (int i = 1; i &lt;= 2 * n; ++i)\n        mat[i] = u[i] = 0;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        u[i] = -inf;\n        for (int j = n + 1; j &lt;= 2 * n; ++j)\n            u[i] = max(u[i], g[i][j]);\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (;;) &#123;\n            ++now;\n            for (int j = n + 1; j &lt;= 2 * n; ++j)\n                up[j] = inf;\n            if (Find(i))\n                break;\n            int Delta = inf;\n            for (int j = n + 1;\n                            j &lt;= 2 * n; ++j) &#123;\n                if (vis[j] != now)\n                    Delta = min(Delta, up[j]);\n            &#125;\n            for (int j = 1; j &lt;= n; ++j) &#123;\n                if (vis[j] == now)\n                    u[j] -= Delta;\n            &#125;\n            for (int j = n + 1;\n                            j &lt;= 2 * n; ++j) &#123;\n                if (vis[j] == now)\n                    u[j] += Delta;\n            &#125;\n        &#125;\n    &#125;\n    return;\n&#125;\nint main() &#123;\n    while(read(n)) &#123;\n        res = 0;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            for (int j = 1; j &lt;= n; ++j)\n                read(g[i][j + n]);\n        &#125;\n        Solve();\n        for (int i = n + 1; i &lt;= 2 * n; ++i)\n            res += g[mat[i]][i];\n        print(res, &#39;\\n&#39;);\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"c.-going-home\">C. Going Home</h3>\n<p><a href=\"https://vjudge.net/contest/554888#problem/C\" class=\"uri\">https://vjudge.net/contest/554888#problem/C</a></p>\n<p>板板题。把人和房子按曼哈顿距离连边即可。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 205;\nconst int inf = 0x3f3f3f3f;\nint g[maxn][maxn];\nchar s[maxn][maxn];\nint u[maxn], up[maxn];\nint h, w, n, m, now, res;\nint vis[maxn], mat[maxn];\nint a[maxn][2], b[maxn][2];\nint max(int x, int y) &#123;\n    return x &gt; y ? x : y;\n&#125;\nint min(int x, int y) &#123;\n    return x &lt; y ? x : y;\n&#125;\nbool Find(int x) &#123;\n    vis[x] = now;\n    for (int i = n + 1; i &lt;= 2 * n; ++i) &#123;\n        if (vis[i] == now)\n            continue;\n        if (u[x] + u[i] == g[x][i]) &#123;\n            vis[i] = now;\n            if (!mat[i] || (vis[mat[i]] != now\n                            &amp;&amp; Find(mat[i]))) &#123;\n                mat[i] = x;\n                return 1;\n            &#125;\n        &#125;\n        else &#123;\n            up[i] = min(up[i],\n                u[x] + u[i] - g[x][i]);\n        &#125;\n    &#125;\n    return 0;\n&#125;\nvoid Solve(void) &#123;\n    for (int i = 1; i &lt;= 2 * n; ++i)\n        mat[i] = u[i] = 0;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        u[i] = -inf;\n        for (int j = n + 1; j &lt;= 2 * n; ++j)\n            u[i] = max(u[i], g[i][j]);\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (;;) &#123;\n            ++now;\n            for (int j = n + 1; j &lt;= 2 * n; ++j)\n                up[j] = inf;\n            if (Find(i))\n                break;\n            int Delta = inf;\n            for (int j = n + 1;\n                            j &lt;= 2 * n; ++j) &#123;\n                if (vis[j] != now)\n                    Delta = min(Delta, up[j]);\n            &#125;\n            for (int j = 1; j &lt;= n; ++j) &#123;\n                if (vis[j] == now)\n                    u[j] -= Delta;\n            &#125;\n            for (int j = n + 1;\n                            j &lt;= 2 * n; ++j) &#123;\n                if (vis[j] == now)\n                    u[j] += Delta;\n            &#125;\n        &#125;\n    &#125;\n    return;\n&#125;\nint abs(int x) &#123;\n    return x &gt;= 0 ? x : -x;\n&#125;\nint dist(int x1, int y1, int x2, int y2) &#123;\n    return abs(x1 - x2) + abs(y1- y2);\n&#125;\nvoid Init(void) &#123;\n    res = n = m = 0;\n    memset(g, 0, sizeof (g));\n    return;\n&#125;\nint main() &#123;\n    scanf(&quot;%d %d&quot;, &amp;h, &amp;w);\n    while (h || w) &#123;\n        Init();\n        for (int i = 1; i &lt;= h; ++i) &#123;\n            scanf(&quot;%s&quot;, s[i] + 1);\n            for (int j = 1; j &lt;= w; ++j) &#123;\n                if (s[i][j] == &#39;H&#39;)\n                    a[++n][0] = i, a[n][1] = j;\n                else if (s[i][j] == &#39;m&#39;)\n                    b[++m][0] = i, b[m][1] = j;\n            &#125;\n        &#125;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            for (int j = 1; j &lt;= n; ++j) &#123;\n                g[i][j + n] = -dist(a[i][0],\n                    a[i][1], b[j][0], b[j][1]);\n            &#125;\n        &#125;\n        Solve();\n        for (int i = n + 1; i &lt;= 2 * n; ++i)\n            res += g[mat[i]][i];\n        print(-res, &#39;\\n&#39;);\n        scanf(&quot;%d %d&quot;, &amp;h, &amp;w);\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"d.-cyclic-tour\">D. Cyclic Tour</h3>\n<p><a href=\"https://vjudge.net/contest/554888#problem/D\" class=\"uri\">https://vjudge.net/contest/554888#problem/D</a></p>\n<p>题意在讲什么啊，看了半天看不懂。</p>\n<p>给定一个有向图，找到若干个互不相交的环覆盖整个图，使得所有环上边权和最小，若找不到方案输出 -1。</p>\n<p>我们知道与这道题相类似的最小路径覆盖问题可以用二分图 + 拆点来解决。那么这里我们也可以小小地拆一拆点。把一个点拆成两个，一个作为起点，一个作为终点，两个点之间连双向边，这样该图就和原图等价。</p>\n<p>拆出来起点之间没有边，拆出来的终点之间也没有边，所以原图是二分图。</p>\n<p>不难发现，假设原图中的环上共有 <span class=\"math inline\">\\(x\\)</span> 个点、<span class=\"math inline\">\\(x\\)</span> 条边，那么拆点后就会有 <span class=\"math inline\">\\(2\\times x\\)</span> 个点和 <span class=\"math inline\">\\(2\\times x\\)</span> 条边，其中 <span class=\"math inline\">\\(x\\)</span> 条边是点 <span class=\"math inline\">\\(i\\)</span> 连向点 <span class=\"math inline\">\\(i&#39;\\)</span>（或反之）的边。</p>\n<p>需要匹配到剩余的实边（而非自己连向自己的虚边）共有 <span class=\"math inline\">\\(x\\)</span> 条，左右部节点都有 <span class=\"math inline\">\\(x\\)</span> 个，考虑设虚边边权为正无穷，进行最小权完美匹配（点和自己连边的操作保证了一定能找到解，不会进入死循环）。</p>\n<p>那么什么时候无解呢？当算法不得不选中虚边时，就说明找不到环了。所以我们判一下匹配有没有包含正无穷边即可。</p>\n<p>记得判重边！</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 205;\nconst int inf = 0x3f3f3f3f;\nint g[maxn][maxn];\nint u[maxn], up[maxn];\nint vis[maxn], mat[maxn];\nint n, m, x, y, now, res, w;\nint max(int x, int y) &#123;\n    return x &gt; y ? x : y;\n&#125;\nint min(int x, int y) &#123;\n    return x &lt; y ? x : y;\n&#125;\nbool Find(int x) &#123;\n    vis[x] = now;\n    for (int i = n + 1; i &lt;= 2 * n; ++i) &#123;\n        if (vis[i] == now)\n            continue;\n        if (u[x] + u[i] == g[x][i]) &#123;\n            vis[i] = now;\n            if (!mat[i] || (vis[mat[i]] != now\n                            &amp;&amp; Find(mat[i]))) &#123;\n                mat[i] = x;\n                return 1;\n            &#125;\n        &#125;\n        else &#123;\n            up[i] = min(up[i],\n                u[x] + u[i] - g[x][i]);\n        &#125;\n    &#125;\n    return 0;\n&#125;\nvoid Solve(void) &#123;\n    for (int i = 1; i &lt;= 2 * n; ++i)\n        mat[i] = u[i] = 0;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        u[i] = -inf;\n        for (int j = n + 1; j &lt;= 2 * n; ++j)\n            u[i] = max(u[i], g[i][j]);\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (;;) &#123;\n            ++now;\n            for (int j = n + 1; j &lt;= 2 * n; ++j)\n                up[j] = inf;\n            if (Find(i))\n                break;\n            int Delta = inf;\n            for (int j = n + 1;\n                            j &lt;= 2 * n; ++j) &#123;\n                if (vis[j] != now)\n                    Delta = min(Delta, up[j]);\n            &#125;\n            for (int j = 1; j &lt;= n; ++j) &#123;\n                if (vis[j] == now)\n                    u[j] -= Delta;\n            &#125;\n            for (int j = n + 1;\n                            j &lt;= 2 * n; ++j) &#123;\n                if (vis[j] == now)\n                    u[j] += Delta;\n            &#125;\n        &#125;\n    &#125;\n    return;\n&#125;\nint main() &#123;\n    while (read(n)) &#123;\n        read(m);\n        res = 0;\n        for (int i = 1; i &lt;= 2 * n; ++i) &#123;\n            for (int j = 1; j &lt;= 2 * n; ++j) \n                g[i][j] = -inf;\n        &#125;\n        while (m--) &#123;\n            read(x), read(y), read(w);\n            g[x][y + n] = max(g[x][y + n], -w);\n        &#125;\n        Solve();\n        for (int i = n + 1; i &lt;= 2 * n; ++i) &#123;\n            if (g[mat[i]][i] &lt;= -inf) &#123;\n                puts(&quot;-1&quot;);\n                goto NoSol;\n            &#125;\n            res += -g[mat[i]][i];\n        &#125;\n        print(res, &#39;\\n&#39;);\n        NoSol: ;\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"e.-tour\">E. Tour</h3>\n<p><a href=\"https://vjudge.net/contest/554888#problem/E\" class=\"uri\">https://vjudge.net/contest/554888#problem/E</a></p>\n<p>把上一题输入方式和数据范围改一改就好了。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 405;\nconst int inf = 0x3f3f3f3f;\nint g[maxn][maxn];\nint u[maxn], up[maxn];\nint vis[maxn], mat[maxn];\nint T, n, m, x, y, now, res, w;\nint max(int x, int y) &#123;\n    return x &gt; y ? x : y;\n&#125;\nint min(int x, int y) &#123;\n    return x &lt; y ? x : y;\n&#125;\nbool Find(int x) &#123;\n    vis[x] = now;\n    for (int i = n + 1; i &lt;= 2 * n; ++i) &#123;\n        if (vis[i] == now)\n            continue;\n        if (u[x] + u[i] == g[x][i]) &#123;\n            vis[i] = now;\n            if (!mat[i] || (vis[mat[i]] != now\n                            &amp;&amp; Find(mat[i]))) &#123;\n                mat[i] = x;\n                return 1;\n            &#125;\n        &#125;\n        else &#123;\n            up[i] = min(up[i],\n                u[x] + u[i] - g[x][i]);\n        &#125;\n    &#125;\n    return 0;\n&#125;\nvoid Solve(void) &#123;\n    for (int i = 1; i &lt;= 2 * n; ++i)\n        mat[i] = u[i] = 0;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        u[i] = -inf;\n        for (int j = n + 1; j &lt;= 2 * n; ++j)\n            u[i] = max(u[i], g[i][j]);\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (;;) &#123;\n            ++now;\n            for (int j = n + 1; j &lt;= 2 * n; ++j)\n                up[j] = inf;\n            if (Find(i))\n                break;\n            int Delta = inf;\n            for (int j = n + 1;\n                            j &lt;= 2 * n; ++j) &#123;\n                if (vis[j] != now)\n                    Delta = min(Delta, up[j]);\n            &#125;\n            for (int j = 1; j &lt;= n; ++j) &#123;\n                if (vis[j] == now)\n                    u[j] -= Delta;\n            &#125;\n            for (int j = n + 1;\n                            j &lt;= 2 * n; ++j) &#123;\n                if (vis[j] == now)\n                    u[j] += Delta;\n            &#125;\n        &#125;\n    &#125;\n    return;\n&#125;\nint main() &#123;\n    read(T);\n    while(T--) &#123;\n        read(n), read(m);\n        res = 0;\n        for (int i = 1; i &lt;= 2 * n; ++i) &#123;\n            for (int j = 1; j &lt;= 2 * n; ++j) \n                g[i][j] = -inf;\n        &#125;\n        while (m--) &#123;\n            read(x), read(y), read(w);\n            g[x][y + n] = max(g[x][y + n], -w);\n        &#125;\n        Solve();\n        for (int i = n + 1; i &lt;= 2 * n; ++i) &#123;\n            if (g[mat[i]][i] &lt;= -inf) &#123;\n                puts(&quot;-1&quot;);\n                goto NoSol;\n            &#125;\n            res += -g[mat[i]][i];\n        &#125;\n        print(res, &#39;\\n&#39;);\n        NoSol: ;\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"d.-导弹防御塔\">D. 导弹防御塔</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/3699/problem/4\" class=\"uri\">http://222.180.160.110:61235/contest/3699/problem/4</a></p>\n<p>GM 说的好哇（指 <em>毛病多，一会儿分钟一会儿秒</em>）。</p>\n<p>寻找冲突。一个敌人只能被一炮打死，故考虑</p>\n<p>但一个塔可以打很多炮，考虑拆点。</p>\n",
            "tags": [
                "二分图"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20230314/",
            "url": "https://xsc062.netlify.app/20230314/",
            "title": "分治",
            "date_published": "2023-03-13T18:33:31.000Z",
            "content_html": "<p>听说是 <a href=\"http://222.180.160.110:61235/contest/3416\">分治场</a>，想起了自己根本没学过分治（甚至从来不知道归并排序的原理 orz）就去听 CDQ 然后一头雾水的惨痛经历，不禁 PTSD 了。</p>\n<span id=\"more\"></span>\n<hr />\n<h3 id=\"a.-老板的又一道题\">A. 老板的又一道题</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/3416/problem/1\" class=\"uri\">http://222.180.160.110:61235/contest/3416/problem/1</a></p>\n<p>这是什么，有序表的最小和，切一下（所以和分治有什么关系啊）。</p>\n<p>首先对数组进行排序（我忘了 orz），然后在优先队列中填入 <span class=\"math inline\">\\(A_{1\\sim n} + B_1\\)</span>。假设当前最小值为 <span class=\"math inline\">\\(A_i + B_j\\)</span>，则输出，弹出并填入 <span class=\"math inline\">\\(A_i + B_{j + 1}\\)</span>。因为 <span class=\"math inline\">\\(B\\)</span> 是单调的，所以我们填入的数（起码在输出时）是单调的。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 1e5 + 5;\nstruct _ &#123;\n    int u, i;\n    _() &#123;&#125;\n    _(int u1, int i1) &#123;\n        u = u1, i = i1;\n    &#125;\n    bool operator&lt; (const _ q) const &#123;\n        return u &gt; q.u;\n    &#125;\n&#125;;\nint n, cnt;\nint a[maxn], b[maxn];\nstd::priority_queue&lt;_&gt; q;\nint main() &#123;\n    read(n);\n    for (int i = 1; i &lt;= n; ++i)\n        read(a[i]);\n    for (int i = 1; i &lt;= n; ++i)\n        read(b[i]);\n    std::sort(a + 1, a + n + 1);\n    std::sort(b + 1, b + n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        q.push(_(a[i] + b[1], 1));\n    while (!q.empty()) &#123;\n        _ f = q.top();\n        q.pop();\n        print(f.u, &#39; &#39;);\n        if (++cnt == n)\n            break;\n        _ t = f;\n        t.u -= b[f.i];\n        t.u += b[++t.i];\n        q.push(t);\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"b.-魔法石的诱惑\">B. 魔法石的诱惑</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/3416/problem/2\" class=\"uri\">http://222.180.160.110:61235/contest/3416/problem/2</a></p>\n<p>这，这不是二分答案？到底和分治有什么关系啊。</p>\n<p>嘶，<span class=\"math inline\">\\(Q\\)</span> 是 <span class=\"math inline\">\\(10^8\\)</span>，算一算 <span class=\"math inline\">\\(n\\)</span> 的范围。不难发现 <span class=\"math inline\">\\(Q=\\sum\\limits_{i&gt;1} \\lfloor \\dfrac n{5^i} \\rfloor\\)</span>，当 <span class=\"math inline\">\\(n=5\\times 10^8\\)</span> 时，<span class=\"math inline\">\\(\\dfrac n5\\)</span> 就已经是 <span class=\"math inline\">\\(10^8\\)</span> 了，所以我们二分的左右边界应为 <span class=\"math inline\">\\([0,5\\times 10^8]\\)</span>。</p>\n<p>然后 <code>check</code> 的话我们就暴力除 <span class=\"math inline\">\\(5\\)</span> 计算答案（就像小奥一样），一次 <code>check</code> 的时间复杂度是 <span class=\"math inline\">\\(\\log_5\\)</span> 的，不会有问题。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nint q, l, mid, r = 5e18, res;\nint check(int x) &#123;\n    int res = 0;\n    while (x / 5)\n        res += (x /= 5);\n    return res;\n&#125;\nint main() &#123;\n    read(q);\n    while (l &lt;= r) &#123;\n        int mid = (l + r) &gt;&gt; 1;\n        if (check(mid) &gt;= q) &#123;\n            res = mid;\n            r = mid - 1;\n        &#125;\n        else l = mid + 1;\n    &#125;\n    if (check(res) == q)\n        print(res);\n    else puts(&quot;No solution&quot;);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"c.-神族文字\">C. 神族文字</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/3416/problem/3\" class=\"uri\">http://222.180.160.110:61235/contest/3416/problem/3</a></p>\n<p>我不理解？这到底和分治有什么关系？GM 不会是纯看标签拉题吧？标签又是哪个聪明打的？</p>\n<p>总而言之，言而总之，我们打一个 <code>map</code>。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nusing str = std::string;\nstr s1, s2, sl;\nstd::map&lt;str, str&gt; t;\nint main() &#123;\n    for (;;) &#123;\n        std::getline(std::cin, sl);\n        std::stringstream s(sl);\n        if (s &gt;&gt; s1) &#123;\n            s &gt;&gt; s2;\n            t[s2] = s1;\n        &#125;\n        else break;\n    &#125;\n    while (std::cin &gt;&gt; s1) &#123;\n        if (t.count(s1))\n            std::cout &lt;&lt; t[s1] &lt;&lt; &#39;\\n&#39;;\n        else puts(&quot;eh&quot;);\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"d.-逃亡\">D. 逃亡</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/3416/problem/4\" class=\"uri\">http://222.180.160.110:61235/contest/3416/problem/4</a></p>\n<p>首先注意到车车是自动驾驶的，就是说一个人下车过后车会自动往另一个人的方向跑。</p>\n<p>明显反复交接的话车会多跑很多路程，所以我们只交接一次。</p>\n<p>所以难点只是用未知数把最终速度表示出来（想起了物理实验题）。</p>\n<p>假设距离为 <span class=\"math inline\">\\(S\\)</span>，车速为 <span class=\"math inline\">\\(v_1\\)</span>，人速为 <span class=\"math inline\">\\(v_2\\)</span>，第一个人一直坐车坐到 <span class=\"math inline\">\\(x\\)</span> 路程，则最终时间为 <span class=\"math inline\">\\(\\max\\left\\{ \\dfrac x{v_1} + \\dfrac {S - x}{v_2}, \\dfrac x{v_1}+\\dfrac {x - \\dfrac x{v_1}\\times v_2}{v_1 + v_2} + \\dfrac {S-\\dfrac x{v_1}\\times v_2 - \\dfrac {x - \\dfrac x{v_1}\\times v_2}{v_1 + v_2} \\times v_2}{v_1}\\right\\}\\)</span>。</p>\n<p>有一个很明显的点，就是 <span class=\"math inline\">\\(x\\)</span> 越大，第一个人用时就越短，第二个人用时就越多。这个时候我们就可以二分 <span class=\"math inline\">\\(x\\)</span>，尽量使第一个人和第二个人用时接近（用时是一个关于 <span class=\"math inline\">\\(x\\)</span> 的分段函数，我们寻找其拐点），最终相同用时即为答案。</p>\n<details>\n<p>因为从来不是很喜欢浮点数二分，采用了先整数二分再框范围取精确答案的方法。</p>\n<p>所以怎么又是二分？说好的分治场呢？</p>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nusing db = double;\nconst db eps = 1e-2;\ndb res, ans = 1e18;\nint s, v1, v2, l, mid, r;\ndb min(db x, db y) &#123;\n    return x &lt; y ? x : y; \n&#125;\ndb max(db x, db y) &#123;\n    return x &gt; y ? x : y;\n&#125;\nbool check(int x) &#123;\n    db t1 = x * 1.0 / v1;\n    db r1 = t1 + (s - x) * 1.0 / v2;\n    db t2 = (x - t1 * v2) / (v1 + v2);\n    db r2 = t1 + t2 + (s - t1 * v2 - t2 * v2) / v1;\n    return r1 &lt;= r2;\n&#125;\nint main() &#123;\n    read(s), read(v2), read(v1);\n    l = 0, r = s;\n    while (l &lt;= r) &#123;\n        mid = (l + r) &gt;&gt; 1;\n        if (check(mid)) &#123;\n            res = (db)mid;\n            r = mid - 1;\n        &#125;\n        else l = mid + 1;\n    &#125;\n    for (db i = res - 2; i &lt;= res + 2; i += eps) &#123;\n        db t1 = i * 1.0 / v1;\n        db r1 = t1 + (s - i) * 1.0 / v2;\n        db t2 = (i - t1 * v2) / (v1 + v2);\n        db r2 = t1 + t2 +\n                (s - t1 * v2 - t2 * v2) / v1;\n        ans = min(ans, max(r1, r2));\n    &#125;\n    printf(&quot;%.2lf&quot;, ans);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"e.-剔除多余括号\">E. 剔除多余括号</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/3416/problem/5\" class=\"uri\">http://222.180.160.110:61235/contest/3416/problem/5</a></p>\n<p><em>为了套取数据理解题意，我用 python 交了一个 <code>print(input())</code>，结果总司令在上，得到了 33pts 的高分…</em></p>\n<p>什么叫多余括号呢？括号前后的符号优先级小于等于括号中的符号，并且若括号内存在括号与括号前同级，则括号前不为 <code>-</code> 或 <code>/</code>。</p>\n<p>这样就可以了。我们将问题划分为若干个子问题，对每个括号内的内容进行相同方式的处理：对比括号内优先级最高的符号和括号前后符号的优先级，处理括号内的内容时若遇到括号，则递归地进行相似的处理。</p>\n<details>\n<p>其实这个充其量只能算是模拟…… 跟分治并不是很有关系，和 CSP-J 2022 T3 有点像。</p>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 260;\nint n;\nchar s[maxn];\nbool vis[maxn];\nint max(int x, int y) &#123;\n    return x &gt; y ? x : y;\n&#125;\nint Deal(int l, int r) &#123;\n    int res = 1;\n    for (int i = l; i &lt;= r; ++i) &#123;\n        if (s[i] == &#39;+&#39; || s[i] == &#39;-&#39;)\n            res = max(res, 1);\n        else if (s[i] == &#39;*&#39; || s[i] == &#39;/&#39;)\n            res = 2;\n        else if (s[i] == &#39;(&#39;) &#123;\n            int cnt = 1, j;\n            for (j = i + 1; j &lt;= r; ++j) &#123;\n                if (s[j] == &#39;(&#39;)\n                    ++cnt;\n                else if (s[j] == &#39;)&#39;)\n                    --cnt;\n                if (cnt == 0)\n                    break;\n            &#125;\n            cnt = Deal(i + 1, j - 1);\n            int t = 1;\n            int p1 = i - 1, p2 = j + 1;\n            while (s[p1] == &#39;(&#39; || s[p1] == &#39;)&#39;)\n                --p1;\n            while (s[p2] == &#39;(&#39; || s[p2] == &#39;)&#39;)\n                ++p2;\n            if (s[p1] == &#39;+&#39; || s[p1] == &#39;-&#39;)\n                t = max(t, 1);\n            else t = max(t, 2);\n            if (s[p2] == &#39;+&#39; || s[p2] == &#39;-&#39;)\n                t = max(t, 1);\n            else t = max(t, 2);\n            if (t &lt; cnt)\n                vis[i] = vis[j] = 1;\n            else if (t == cnt) &#123;\n                if (s[p1] != &#39;-&#39; &amp;&amp; s[p1] != &#39;/&#39;)\n                    vis[i] = vis[j] = 1;\n            &#125;\n            i = j;\n        &#125;\n    &#125;\n    return res;\n&#125;\nint main() &#123;\n    s[1] = &#39;+&#39;;\n    scanf(&quot;%s&quot;, s + 2);\n    n = strlen(s + 1) + 1;\n    s[n] = &#39;+&#39;;\n    Deal(1, n);\n    for (int i = 2; i &lt; n; ++i) &#123;\n        if (!vis[i])\n            putchar(s[i]);\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"f.-最接近点对问题\">F. 最接近点对问题</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/3416/problem/6\" class=\"uri\">http://222.180.160.110:61235/contest/3416/problem/6</a></p>\n<p>分治典中典。</p>\n<p>我们将点按照横坐标排序，对点 <span class=\"math inline\">\\(1\\sim n\\)</span> 进行分治。</p>\n<p>将求解区间包含的点分为两部分，假设左边部分和右边部分已经分别求解出了最近点对（出口即为求解区间仅包含两点，直接求出距离），考虑合并状态。则情况无非有三种：</p>\n<ol type=\"1\">\n<li>答案为左边部分的答案</li>\n<li>答案为右边部分的答案</li>\n<li>答案为左、右各选取一点</li>\n</ol>\n<p>前两者是已知量，则我们求解出第三种情况，选择最小值即可。</p>\n<p>第三种情况有个很妙的处理方式：我们设前两种情况的答案较小者为 <span class=\"math inline\">\\(d\\)</span>，设求解区间最靠中间的点为 <span class=\"math inline\">\\(m\\)</span>。</p>\n<ul>\n<li><p>若 <span class=\"math inline\">\\(m\\)</span> 为左边部分的点</p>\n<p>则由于我们对半二分，<span class=\"math inline\">\\(m\\)</span> 一定是左边部分最靠右的点。</p>\n<ul>\n<li><p>对于其余左边部分的节点：</p>\n若它们与 <span class=\"math inline\">\\(m\\)</span> 的横向距离已经大于等于 <span class=\"math inline\">\\(d\\)</span>，则它们与右边部分的点的横向距离会更大。连横向距离都已经大于等于当前最优解了，无需考虑纵向距离，筛除这部分点。</li>\n<li><p>对于右边部分的节点：</p>\n<p>若它们与 <span class=\"math inline\">\\(m\\)</span> 的横向距离已经大于等于 <span class=\"math inline\">\\(d\\)</span>，则它们与更左边的其他左边部分节点的横向距离会更大，故筛除这部分点。</p></li>\n</ul></li>\n<li><p>若 <span class=\"math inline\">\\(m\\)</span> 为右边部分的点</p>\n<p>同理。</p></li>\n</ul>\n<p>综上，我们只用考虑求解区间内与 <span class=\"math inline\">\\(m\\)</span> 的横向距离小于 <span class=\"math inline\">\\(d\\)</span> 的点。</p>\n<p>在筛选出这些点后，我们如何进行进一步的处理呢？答案是，<strong>枚举</strong>。</p>\n<p>我们枚举每一对点，计算它们间的距离。若比答案小，则更新答案。</p>\n<p>那这复杂度也太神奇了。所以我们给出一个同样神奇的优化：按纵坐标递增对筛选出的点排序。当二重循环筛选时，若当前第一层循环 <span class=\"math inline\">\\(i\\)</span> 与第二层循环 <span class=\"math inline\">\\(j\\)</span> 的纵向距离大于等于了当前最小答案，就可以将第二层循环 <code>break</code> 了。因为纵坐标单调，继续枚举距离会继续增加，离答案更远。</p>\n<p>那看起来复杂度还是很神奇，理论上来说应该是 <span class=\"math inline\">\\(O(n^2\\log n)\\)</span> 的呀？</p>\n<p>考虑第一层循环 <span class=\"math inline\">\\(i\\)</span>。对于点 <span class=\"math inline\">\\(i\\)</span>，有哪些 <span class=\"math inline\">\\(j\\)</span> 可以满足它的要求，从而被枚举到呢？</p>\n<ul>\n<li>由于点对无序，所以 <span class=\"math inline\">\\(j\\)</span> 从 <span class=\"math inline\">\\(i+1\\)</span> 开始枚举，所以 <span class=\"math inline\">\\(y_j&gt;y_i\\)</span>。</li>\n<li>由于筛选条件，<span class=\"math inline\">\\(|x_i-x_m|&lt; d\\)</span> 且 <span class=\"math inline\">\\(|x_j-x_m|&lt; d\\)</span>。</li>\n<li>由于 <code>break</code> 条件，<span class=\"math inline\">\\(y_j-y_i&lt; d\\)</span>。</li>\n</ul>\n<p>合并一下就是，<span class=\"math inline\">\\(|x_i-x_j|\\le 2\\times d\\)</span>，且 <span class=\"math inline\">\\(0\\le y_j - y_i \\le d\\)</span>。那么我们可以画出一个底为 <span class=\"math inline\">\\(2\\times d\\)</span>，高为 <span class=\"math inline\">\\(d\\)</span> 的矩形，且它的中轴线为 <span class=\"math inline\">\\(x=x_m\\)</span>，中轴线左右两边均为 <span class=\"math inline\">\\(d\\times d\\)</span> 的正方形。</p>\n<p>若任意两个点同在左边部分或同在右边部分，那么这一对点的贡献已经在分治时计算完成了，所以一定不会比 <span class=\"math inline\">\\(d\\)</span> 小。</p>\n<p>有一个很妙的结论：满足条件的 <span class=\"math inline\">\\(j\\)</span> 在矩形的左半边和右半边最多只有三个。</p>\n<p>为什么？同一部分中，任意两个 <span class=\"math inline\">\\(j\\)</span> 的距离至少为 <span class=\"math inline\">\\(d\\)</span>。那么四个 <span class=\"math inline\">\\(j\\)</span>，距离都为 <span class=\"math inline\">\\(d\\)</span>，那么正好就是整个左半边的正方形。别忘了一点，<span class=\"math inline\">\\(j\\)</span> 需满足的三个条件都是严格小于，所以不能碰到整个矩形的边界，所以一个部分中最多只能存在三个 <span class=\"math inline\">\\(j\\)</span>。</p>\n<p>那么实际上看似 <span class=\"math inline\">\\(n^2\\)</span> 的枚举，在多个优化下就变成了 <span class=\"math inline\">\\(O(n)\\)</span>。再加上对筛选出的点纵坐标排序的时间，总体时间复杂度为 <span class=\"math inline\">\\(O(n\\log^2 n)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing db = double;\nconst db inf = 1e18;\nconst int maxn = 6e4 + 5;\nstruct _ &#123; db x, y; &#125;;\nint n;\n_ a[maxn];\ndb dis(db x1, db y1, db x2, db y2) &#123;\n    return sqrt((x1 - x2) * (x1 - x2) +\n                (y1 - y2) * (y1 - y2));\n&#125;\ndb min(db x, db y) &#123;\n    return x &lt; y ? x : y;\n&#125;\ndb abs(db x) &#123;\n    return x &gt;= 0 ? x : -x;\n&#125;\ndb Solu(int l, int r) &#123;\n    if (l == r)\n        return inf;\n    if (l + 1 == r)\n        return dis(a[l].x, a[l].y, a[r].x, a[r].y);\n    int mid = (l + r) &gt;&gt; 1;\n    db d = min(Solu(l, mid), Solu(mid + 1, r));\n    std::vector&lt;_&gt; t;\n    for (int i = l; i &lt;= r; ++i) &#123;\n        if (abs(a[i].x - a[mid].x) &lt; d)\n            t.push_back(a[i]);\n    &#125;\n    std::sort(t.begin(), t.end(),\n        [&amp;](_ x, _ y) &#123; return x.y &lt; y.y; &#125;);\n    for (int i = 0; i &lt; (int)t.size(); ++i) &#123;\n        for (int j = i + 1; j &lt; (int)t.size(); ++j) &#123;\n            if (t[j].y - t[i].y &gt;= d)\n                break;\n            d = min(d, dis(t[i].x, t[i].y,\n                                t[j].x, t[j].y));\n        &#125;\n    &#125;\n    return d;\n&#125;\nint main() &#123;\n    scanf(&quot;%d&quot;, &amp;n);\n    for (int i = 1; i &lt;= n; ++i)\n        scanf(&quot;%lf %lf&quot;, &amp;a[i].x, &amp;a[i].y);\n    std::sort(a + 1, a + n + 1,\n        [&amp;](_ x, _ y) &#123; return x.x &lt; y.x; &#125;);\n    printf(&quot;%.2lf\\n&quot;, Solu(1, n) / 2);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<p>考虑一个问题。代码的时间复杂度有两个 <span class=\"math inline\">\\(\\log\\)</span>，这是极不好的（will be fixed）。</p>\n<hr />\n<h3 id=\"g.-残缺棋盘问题\">G. 残缺棋盘问题</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/3416/problem/7\" class=\"uri\">http://222.180.160.110:61235/contest/3416/problem/7</a></p>\n<p>首先考虑一个有趣的问题：<span class=\"math inline\">\\(4^n-1\\)</span> 一定被 <span class=\"math inline\">\\(3\\)</span> 整除吗？</p>\n<p>一个简单的方法是使用数学归纳法进行证明，其思想也会在这道题中体现。</p>\n<p>不过还有另一个方法：<span class=\"math inline\">\\(4^n-1=(3+1)^n-1\\)</span>，使用二项式定理则有：</p>\n<p><span class=\"math display\">\\[\n(3+1)^n-1=\\sum_{i=0}^n {n\\choose i} \\times 3^{n-i}\\times 1^i - 1\n\\]</span></p>\n<p>不难发现除 <span class=\"math inline\">\\(i=n\\)</span> 时，前面每一项都有因子 <span class=\"math inline\">\\(3\\)</span>，而当 <span class=\"math inline\">\\(i=n\\)</span> 时，<span class=\"math inline\">\\({n\\choose n}\\times 3^0\\times 1^n=1\\)</span>，与后面的 <span class=\"math inline\">\\(-1\\)</span> 抵消，故得证。</p>\n<hr />\n<p>考虑将棋盘划分为若干个 <span class=\"math inline\">\\(2\\times 2\\)</span> 的 1 级区域。对于缺口所在的 1 级区域，我们使用一个刚好贴合的三格板将其补齐成为一个完整的 1 级区域。</p>\n<p>我们称包含四个完整的 <span class=\"math inline\">\\(2\\times 2\\)</span> 的 1 级区域的 <span class=\"math inline\">\\(4\\times 4\\)</span> 的区域为 2 级区域，对于包含了我们刚刚补齐的 1 级区域的 2 级区域，我们将最中间的四个格子视为一个 1 级区域并填充，接下来剩余的 3 个完整 1 级区域为各自失去一个能填充的格子，我们选取对应的三格板填充即可。</p>\n<p>对于一个 <span class=\"math inline\">\\(8\\times 8\\)</span> 的 3 级区域，若其包含我们填充完毕的 2 级区域，我们将最中间 <span class=\"math inline\">\\(2\\times 2\\)</span> 的格子视为一个 1 级区域并填充。接下来，剩余的 3 个完整的 2 级区域成为缺失 1 个格子的 2 级区域，按之前的方法填充即可。</p>\n<p>以此类推即可递归地填充完成整个棋盘。但现在又来了一个问题：这道题没有 SPJ。根据样例可知，填充规则是由外到内，中、左上、左下、右上、右下，我们按照此顺序进行分治递归即可。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 105;\nint n, x, y, cnt;\nint t[maxn][maxn];\nvoid getColor(int c, int r, int l, int x, int y) &#123;\n    if (l == 2) &#123;\n        ++cnt;\n        for (int i = c; i &lt;= c + 1; ++i) &#123;\n            for (int j = r; j &lt;= r + 1; ++j) &#123;\n                if (i != x || j != y)\n                    t[i][j] = cnt;\n            &#125;\n        &#125;\n        return;\n    &#125;\n    l /= 2;\n    if (x - c &lt; l) &#123;\n        if (y - r &lt; l) &#123;\n            getColor(c + l - 1, r + l - 1,\n                        2, c + l - 1, r + l - 1);\n            getColor(c, r, l, x, y);\n            getColor(c + l, r, l, c + l, r + l - 1);\n            getColor(c, r + l, l, c + l - 1, r + l);\n            getColor(c + l, r + l, l, c + l, r + l);\n        &#125;\n        else &#123;\n            getColor(c + l - 1, r + l - 1,\n                        2, c + l - 1, r + l);\n            getColor(c, r, l, c + l - 1, r + l - 1);\n            getColor(c + l, r, l, c + l, r + l - 1);\n            getColor(c, r + l, l, x, y);\n            getColor(c + l, r + l, l, c + l, r + l);\n        &#125;\n    &#125;\n    else &#123;\n        if (y - r &lt; l) &#123;\n            getColor(c + l - 1, r + l - 1,\n                            2, c + l, r + l - 1);\n            getColor(c, r, l, c + l - 1, r + l - 1);\n            getColor(c + l, r, l, x, y);\n            getColor(c, r + l, l, c + l - 1, r + l);\n            getColor(c + l, r + l, l, c + l, r + l);\n        &#125;\n        else &#123;\n            getColor(c + l - 1, r + l - 1,\n                            2, c + l, r + l);\n            getColor(c, r, l, c + l - 1, r + l - 1);\n            getColor(c + l, r, l, c + l, r + l - 1);\n            getColor(c, r + l, l, c + l - 1, r + l);\n            getColor(c + l, r + l, l, x, y);\n        &#125;\n    &#125;\n    return;\n&#125;\nint main() &#123;\n    read(n), read(x), read(y);\n    getColor(1, 1, n, x, y);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = 1; j &lt;= n; ++j)\n            print(t[i][j], &#39; &#39;);\n        putchar(&#39;\\n&#39;);\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"h.-tricky-function\">H. Tricky Function</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/3416/problem/8\" class=\"uri\">http://222.180.160.110:61235/contest/3416/problem/8</a></p>\n<p>GM 提示了这道题就是平面最近点对。豁然开朗。</p>\n<p>不妨将 <span class=\"math inline\">\\(i\\)</span> 视作 <span class=\"math inline\">\\(x_i\\)</span>，将 <span class=\"math inline\">\\(\\sum_{k=1}^i a_k\\)</span> 视作 <span class=\"math inline\">\\(y_i\\)</span>，则直接求解平面最近点对即可。</p>\n",
            "tags": [
                "分治"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20230203/",
            "url": "https://xsc062.netlify.app/20230203/",
            "title": "美丽的柠檬花！",
            "date_published": "2023-02-03T08:00:59.000Z",
            "content_html": "<p>Solution to <a href=\"https://codeforces.com/problemset/problem/1733/D2\">CF1733D2 Zero-One (Hard Version)</a>。</p>\n<span id=\"more\"></span>\n<hr />\n<p>没做过简单版本，模拟赛上遇到，乍一看是个贪心，但贪心思维太弱想不到怎么贪。所以思考其他方法。</p>\n<p>下文称同时取反 <span class=\"math inline\">\\(a_i\\)</span> 和 <span class=\"math inline\">\\(a_j\\)</span> 的一次操作为「取反 <span class=\"math inline\">\\((a_i, a_j)\\)</span>」，称 <span class=\"math inline\">\\(a_i=b_i\\)</span> 的状态为「匹配」。</p>\n<hr />\n<h3 id=\"思维关键点\">思维关键点</h3>\n<p>若我们想要将 <span class=\"math inline\">\\((a_i,a_j)\\)</span> 取反，我们可以怎么做？</p>\n<p>不难发现，分 <span class=\"math inline\">\\(a_i\\)</span> 与 <span class=\"math inline\">\\(a_j\\)</span> 相邻和不相邻两种情况：</p>\n<ol type=\"1\">\n<li><p><span class=\"math inline\">\\(a_i\\)</span> 与 <span class=\"math inline\">\\(a_j\\)</span> 相邻：</p>\n<ol type=\"1\">\n<li>直接取反，代价为 <span class=\"math inline\">\\(x\\)</span>。</li>\n<li>寻找到一个与 <span class=\"math inline\">\\(a_i\\)</span> 和 <span class=\"math inline\">\\(a_j\\)</span> 都不相邻的 <span class=\"math inline\">\\(a_k\\)</span>，先将 <span class=\"math inline\">\\((a_i,a_k)\\)</span> 取反，再将 <span class=\"math inline\">\\((a_j,a_k)\\)</span> 取反，代价为 <span class=\"math inline\">\\(2\\times y\\)</span>。</li>\n</ol></li>\n<li><p><span class=\"math inline\">\\(a_i\\)</span> 与 <span class=\"math inline\">\\(a_j\\)</span> 不相邻：</p>\n<ol type=\"1\">\n<li>直接取反，代价为 <span class=\"math inline\">\\(y\\)</span>。</li>\n<li>将 <span class=\"math inline\">\\((a_i,a_{i + 1}),(a_{i + 1}, a_{i + 2}),\\cdots,(a_{j - 1}, a_{j})\\)</span> 取反，代价为 <span class=\"math inline\">\\((j - i)\\times x\\)</span>。</li>\n</ol></li>\n</ol>\n<p>接下来考虑另一个问题：我们要取反哪些 <span class=\"math inline\">\\((a_i,a_j)\\)</span> 呢？</p>\n<p>假设现在有 <span class=\"math inline\">\\(a_p\\)</span> 与 <span class=\"math inline\">\\(b_p\\)</span> 不匹配，<span class=\"math inline\">\\(a_q\\)</span> 与 <span class=\"math inline\">\\(b_q\\)</span> 不匹配，那么我们肯定选择将 <span class=\"math inline\">\\((a_p,a_q)\\)</span> 取反。</p>\n<p>原因很简单，假设有 <span class=\"math inline\">\\(a_k=b_k\\)</span>，如果我们将 <span class=\"math inline\">\\((a_p,a_k)\\)</span> 取反，那么 <span class=\"math inline\">\\(a_k\\ne b_k\\)</span>，我们需要额外的一次与 <span class=\"math inline\">\\(a_k\\)</span> 有关的操作将其复原。如果我们挑选一个 <span class=\"math inline\">\\(a_l=b_l\\)</span>，并将 <span class=\"math inline\">\\((a_k,a_l)\\)</span> 取反，那么 <span class=\"math inline\">\\(a_l\\)</span> 与 <span class=\"math inline\">\\(b_l\\)</span> 又会不匹配，又需要一次操作；如果挑选一个 <span class=\"math inline\">\\(a_l\\ne b_l\\)</span>，并将 <span class=\"math inline\">\\((a_k,a_l)\\)</span> 取反，那么为什么不能在一开始就将 <span class=\"math inline\">\\((a_p,a_l)\\)</span> 取反呢？此时的 <span class=\"math inline\">\\(a_k\\)</span> 相当于一个中继，而这种情况我们已经在取反 <span class=\"math inline\">\\((a_p,a_l)\\)</span> 时考虑到了。</p>\n<p>也就是说，我们每次取反 <strong>只</strong> 选择两个无法与 <span class=\"math inline\">\\(b\\)</span> 匹配的 <span class=\"math inline\">\\(a\\)</span>。</p>\n<p>那么，有没有一种情况，让我们无法选择两个无法匹配的值呢？</p>\n<p>那就是不匹配的值的数量有奇数个，才会让我们两个两个选的时候有元素落单。</p>\n<p>不妨思考一次取反操作所有可能的情况（假设不受上面的结论限制）：</p>\n<ol type=\"1\">\n<li><p>取反一个匹配值和一个不匹配值</p>\n此时匹配值变为非匹配，不匹配值变为匹配，不匹配的元素总数不变。</li>\n<li><p>取反两个不匹配值</p>\n两个不匹配值都变为匹配，不匹配元素的总数量增加 <span class=\"math inline\">\\(-2\\)</span>。</li>\n<li><p>取反两个匹配值</p>\n<p>两个匹配值都变为非匹配，不匹配元素的总数量增加 <span class=\"math inline\">\\(2\\)</span>。</p></li>\n</ol>\n<p>综上，一次操作对不匹配元素总数带来的更改只可能为 <span class=\"math inline\">\\(0,2,-2\\)</span>，均为偶数。当不匹配元素为奇数时，必定无法将其更改至刚好为 <span class=\"math inline\">\\(0\\)</span>。此时输出 <span class=\"math inline\">\\(-1\\)</span>。</p>\n<p>我们上面结论的可实现性也得到了保障：只取反两个不匹配的 <span class=\"math inline\">\\(a\\)</span>，不会有元素落单。</p>\n<p>下文记从前往后第 <span class=\"math inline\">\\(i\\)</span> 个与 <span class=\"math inline\">\\(b\\)</span> 不匹配的 <span class=\"math inline\">\\(a\\)</span> 的下标为 <span class=\"math inline\">\\(d_i\\)</span>。</p>\n<hr />\n<h3 id=\"确定实现方法\">确定实现方法</h3>\n<p>发现 <span class=\"math inline\">\\(\\sum n\\le 5\\times 10^3\\)</span>，确定算法复杂度为 <span class=\"math inline\">\\(O(n^2)\\)</span>。</p>\n<p>首先不难想到暴力搜索，每次枚举将哪一对 <span class=\"math inline\">\\((d_i, d_j)\\)</span> 取反。</p>\n<p>亦或是使用 <code>bitset</code> 记录哪些非匹配值已被取反（被取反为 <span class=\"math inline\">\\(1\\)</span>，否则为 <span class=\"math inline\">\\(0\\)</span>），枚举数对暴力 DP 更新最小值。</p>\n<p>但以上两种方法铁定超时。</p>\n<p>受到上面两种方法的启发，扩展思维，我们发现：</p>\n<ul>\n<li><p>取反操作的顺序不会影响最终答案。</p>\n因为每个数被取反的次数一定，最终结果也就一定。</li>\n<li><p>我们可以通过 DP 的方式寻找最小值。</p></li>\n</ul>\n<p>设计状态。</p>\n<p>不妨考虑让问题麻烦起来的是什么，对于 <span class=\"math inline\">\\(d_i\\)</span> 与 <span class=\"math inline\">\\(d_j\\)</span> 不相邻时的取反，我们无法得知 <span class=\"math inline\">\\(d_i\\)</span> 需要哪一个 <span class=\"math inline\">\\(d_j\\)</span>（而对于 <span class=\"math inline\">\\(d_i\\)</span> 与 <span class=\"math inline\">\\(d_j\\)</span> 相邻的情况，<span class=\"math inline\">\\(d_j\\)</span> 就是 <span class=\"math inline\">\\(d_{i + 1}\\)</span>，位置是确定的）。</p>\n<p>但我们同时也发现，与相邻时的代价不同，不相邻时的操作代价与 <span class=\"math inline\">\\(i\\)</span>，<span class=\"math inline\">\\(j\\)</span> 的具体值无关。</p>\n<p>所以不妨用 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示，已枚举到 <span class=\"math inline\">\\(d_i\\)</span>，前面有 <span class=\"math inline\">\\(j\\)</span> 个数需要后面 <strong>与它们不相邻的数</strong> 用以和它们配对取反。</p>\n<p>假设已枚举到 <span class=\"math inline\">\\(d_i\\)</span>，当前面有 <span class=\"math inline\">\\(s\\)</span> 个数需要配对时，有以下的情况：</p>\n<ul>\n<li><p>当 <span class=\"math inline\">\\(s = 1\\)</span>，即只有一个数需要配对时：</p>\n<ul>\n<li><p>如果这个数是 <span class=\"math inline\">\\(d_{i - 1}\\)</span>，那么代价为 <span class=\"math inline\">\\(2\\times y\\)</span>。</p>\n注意，这里只枚举了需要不相邻的数来配对的情况，相邻的情况将会另外计算，所以代价不能为 <span class=\"math inline\">\\(x\\)</span>。</li>\n<li>否则，代价为 <span class=\"math inline\">\\(y\\)</span>。</li>\n</ul></li>\n<li><p>当 <span class=\"math inline\">\\(s&gt;1\\)</span> 时，即有多个数需要配对时：</p>\n<p>不管 <span class=\"math inline\">\\(d_{i-1}\\)</span> 是否需要配对，我们都不选它。因为选它的代价是 <span class=\"math inline\">\\(2\\times y\\)</span>，而随便选另一个待配对数的代价都只有 <span class=\"math inline\">\\(y\\)</span>。</p></li>\n</ul>\n<p>那么问题来了，我咋知道它们相不相邻？</p>\n<p>再多开一维 <span class=\"math inline\">\\(0/1\\)</span> 状态，记录最后一个需要与其他后面的元素配对值是否是 <span class=\"math inline\">\\(a_{i-1}\\)</span> 即可。</p>\n<p>假设现在已经枚举到 <span class=\"math inline\">\\(f_{i,j,0/1}\\)</span>，即已枚举完 <span class=\"math inline\">\\(d_i\\)</span>，有 <span class=\"math inline\">\\(j\\)</span> 个元素需要配对。</p>\n<p>则更新 <span class=\"math inline\">\\(d_{i+1}\\)</span> 的状态：</p>\n<ul>\n<li><p>若我们想要让 <span class=\"math inline\">\\(d_{i+1}\\)</span> 与后面的元素配对，则代价至少为 <span class=\"math inline\">\\(y\\)</span>。至于是否会因为待配对元素相邻而额外增加 <span class=\"math inline\">\\(y\\)</span> 的代价，我们在待配对元素处计算。</p>\n<span class=\"math display\">\\[\n f_{i+1,j+1,1}\\gets\\min(f_{i,j,0},f_{i,j,1}) + y\n \\]</span></li>\n<li><p>若我们想要让 <span class=\"math inline\">\\(d_{i+1}\\)</span> 与其相邻的 <span class=\"math inline\">\\(a_{i+2}\\)</span> 匹配，那么 <span class=\"math inline\">\\(d_{i+2}\\)</span> 就不需要再与后面的元素配对了，故最后一维为 <span class=\"math inline\">\\(0\\)</span>。</p>\n<span class=\"math display\">\\[\n f_{i+2,j,0}\\gets\\min(f_{i,j,0},f_{i,j,1})+(d_{i+2}-d_{i+1})\\times x\n \\]</span></li>\n<li><p>如果我们想让 <span class=\"math inline\">\\(d_{i+1}\\)</span> 与前面的待配对元素配对：</p>\n<p>在此种大前提下，<span class=\"math inline\">\\(d_{i+1}\\)</span> 一定不需要与后面的元素配对，故最后一维为 <span class=\"math inline\">\\(0\\)</span>。</p>\n<ul>\n<li><p>当 <span class=\"math inline\">\\(j=1\\)</span> 且 <span class=\"math inline\">\\(d_i+1=d_{i+1}\\)</span> 时，即存在其相邻元素，且只有一个配对可选项时：</p>\n<ul>\n<li>如果这个数是 <span class=\"math inline\">\\(d_{i}\\)</span>，则 <span class=\"math inline\">\\(d_{i+1}\\)</span> 必须与相邻元素配对。</li>\n</ul>\n<p><span class=\"math display\">\\[\n f_{i+1,j-1,0}\\gets f_{i,j,1}+y\n \\]</span></p>\n因为在计算 <span class=\"math inline\">\\(f_{i,j,1}\\)</span> 时已计算了一个 <span class=\"math inline\">\\(y\\)</span>，所以此处只用加一个 <span class=\"math inline\">\\(y\\)</span>。\n<ul>\n<li><p>否则，该元素完成配对，不产生任何代价。</p>\n<span class=\"math display\">\\[\n f_{i+1,j-1,0}\\gets f_{i,j,0}\n \\]</span></li>\n</ul></li>\n<li><p>否则，随意选择前面的一个数。</p>\n<p>因为此时，要么前面有除了相邻元素的其他数可选，要么根本没有相邻元素，所以该数完成配对不会产生任何代价（因为 <span class=\"math inline\">\\(y\\)</span> 已经加过了）。</p>\n<p><span class=\"math display\">\\[\n f_{i+1,j-1,0}\\gets \\min(f_{i,j,0},f_{i,j,1})\n \\]</span></p></li>\n</ul></li>\n</ul>\n<p>至此，全部情况讨论完毕。因为不能让最后一个元素再去与后面的元素配对，最终答案为 <span class=\"math inline\">\\(f_{tot,0,0}\\)</span>，其中 <span class=\"math inline\">\\(tot\\)</span> 为 <span class=\"math inline\">\\(d\\)</span> 数组长度。</p>\n<p>时间复杂度 <span class=\"math inline\">\\(O(n^2)\\)</span>，空间复杂度 <span class=\"math inline\">\\(O(n^2)\\)</span>。</p>\n<p>因为 <span class=\"math inline\">\\(x,y\\le 10^9\\)</span>，最坏情况下需要加 <span class=\"math inline\">\\(\\dfrac n2\\)</span> 次，故需要为 DP 数组开 <code>long long</code>。尽管热心人士 @<a href=\"/user/428358\">cqbztzl</a> 帮助我计算得出使用空间约为 300 兆，但仍然会 MLE。</p>\n<p>不难发现，第一维枚举到 <span class=\"math inline\">\\(i\\)</span> 时，只需要更新第一维为 <span class=\"math inline\">\\(i+1\\)</span> 和 <span class=\"math inline\">\\(i+2\\)</span> 状态的值，而不需要其他任何 DP 值，故将第一维模 <span class=\"math inline\">\\(3\\)</span>，滚动为 <span class=\"math inline\">\\(0\\sim 2\\)</span>。</p>\n<hr />\n<pre class=\"cpp\"><code>// 代码里可能有一些赛时的神秘注释 hhh\nnamespace XSC062 &#123;\nusing namespace fastIO;\nconst ll inf = 1e18;\nconst int maxn = 5e3 + 5;\nll x, y;\nint T, n, tot;\nll f[3][maxn][2];\nint diff[maxn], a[maxn], b[maxn];\nll min(ll x, ll y) &#123;\n    return x &lt; y ? x : y;\n&#125;\nvoid upd(int i, int j, int k, ll y) &#123;\n    f[i % 3][j][k] = min(f[i % 3][j][k], y);\n    return;\n&#125;\nint main() &#123;\n    read(T);\n    while (T--) &#123;\n        read(n), read(x), read(y);\n        tot = 0;\n        for (int i = 1; i &lt;= n; ++i)\n            getnum(a[i]);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            getnum(b[i]);\n            if (a[i] != b[i])\n                diff[++tot] = i;\n        &#125;\n        if (tot &amp; 1) &#123;\n            puts(&quot;-1&quot;);\n            continue;\n        &#125;\n        memset(f, 0x3f, sizeof (f));\n        f[0][0][0] = 0;\n        for (int i = 0; i &lt;= tot; ++i) &#123;\n            for (int j = 0; j &lt;= i; ++j) &#123;\n                // 新增起点\n                if (i + 1 &lt;= tot) &#123;\n                    upd(i + 1, j + 1, 1,\n                        min(f[i % 3][j][0],\n                            f[i % 3][j][1]) + y);\n                &#125;\n                // 碾过去 \n                if (i + 2 &lt;= tot) &#123;\n                    upd(i + 2, j, 0,\n                        min(f[i % 3][j][0],\n                            f[i % 3][j][1]) +\n                            (diff[i + 2] -\n                            diff[i + 1]) * x);\n                &#125;\n                // 使用起点\n                if (j &gt; 0 &amp;&amp; i + 1 &lt;= tot) &#123;\n                    if (j == 1 &amp;&amp; diff[i] + 1 ==\n                                        diff[i + 1]) &#123;\n                        upd(i + 1, j - 1, 0,\n                                f[i % 3][j][1] + y);\n                        upd(i + 1, j - 1, 0,\n                                f[i % 3][j][0]);\n                    &#125;\n                    else &#123;\n                        upd(i + 1, j - 1, 0,\n                            min(f[i % 3][j][0],\n                                f[i % 3][j][1]));\n                    &#125;\n                &#125;\n                if (i != tot) &#123;\n                    f[i % 3][j][0] =\n                        f[i % 3][j][1] = inf;\n                &#125;\n            &#125;\n        &#125;\n        print(f[tot % 3][0][0], &#39;\\n&#39;);\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n",
            "tags": [
                "DP"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20230111/",
            "url": "https://xsc062.netlify.app/20230111/",
            "title": "瑰丽华尔兹",
            "date_published": "2023-01-10T18:21:35.000Z",
            "content_html": "<p>Solution to<a href=\"http://222.180.160.110:61235/problem/8965\">「NOI2005」瑰丽华尔兹</a>。</p>\n<span id=\"more\"></span>\n<hr />\n<p>单调队列优化 DP。</p>\n<p>不难发现，题意可转化为：</p>\n<p>从 <span class=\"math inline\">\\((x,y)\\)</span> 出发，按顺序向 <span class=\"math inline\">\\(d_i\\)</span> 方向移动 <span class=\"math inline\">\\([0,t_i−s_i+1]\\)</span> 距离，问最大移动距离。</p>\n<p>为了方便描述，我们把一次「向 <span class=\"math inline\">\\(d_i\\)</span> 方向移动 <span class=\"math inline\">\\([0,t_i−s_i+1]\\)</span> 距离」的操作称为「一步」。</p>\n<p>设计状态。不难发现位置信息必须出现在 DP 的维度中（因为当前位置会影响下一步滑动的距离），而其他信息均不会对下一步滑动产生影响。</p>\n<p>故可令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示完成当前次滑动后，从起点滑动到 <span class=\"math inline\">\\((i,j)\\)</span> 可得到的最大滑动距离。</p>\n<p>以方向上为例，可列 DP 式：</p>\n<p><span class=\"math display\">\\[\nf_{i,j}=\\max_{i&lt;k≤i+(ti−si+1)}\\{f_{k,j}+k−i\\}\n\\]</span></p>\n<p>此时可枚举每一列的所有状态，使用单调队列优化。</p>\n<p>但实际操作中会出现问题。因为单调队列从下向上更新状态时，<span class=\"math inline\">\\(f_{k,j}\\)</span> 会比 <span class=\"math inline\">\\(f_{i,j}\\)</span> 先更新（参考 01 背包倒序枚举容量），导致每一「步」会重复被走很多次。但单调队列的特性限制了我们只能从下向上枚举，此时可新开一个数组记录 <span class=\"math inline\">\\(f\\)</span> 当次被更新之前的值。</p>\n<p>障碍物如何处理呢？我们知道，如果 <span class=\"math inline\">\\((i,j)\\)</span> 下面某一位置有障碍物，那么障碍物下面所有的 <span class=\"math inline\">\\((k,j)\\)</span> 都不能用于更新 <span class=\"math inline\">\\(f_{i,j}\\)</span>（因为被挡住了滑不上来）。所以我们在从下往上枚举时，遇到障碍物就清空单调队列即可。</p>\n<p>下、左、右方向的处理方式类似。</p>\n<p>只需顺序执行操作，根据当前操作方向对应处理即可。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 205;\nconst int inf = 1e18;\nint q[maxn];\nchar a[maxn][maxn];\nint f[maxn][maxn], d[maxn][maxn];\nint n, m, x, y, k, u, h, t, res;\nint max(int x, int y) &#123;\n    return x &gt; y ? x : y;\n&#125;\nint main() &#123;\n    memset(f, -0x3f, sizeof (f));\n    read(n), read(m);\n    read(x), read(y), read(k);\n    f[x][y] = 0;\n    for (int i = 1; i &lt;= n; ++i)\n        scanf(&quot;%s&quot;, a[i] + 1);\n    while (k--) &#123;\n        read(x), read(y), read(u);\n        y = y - x + 1;\n        if (u == 1) &#123;\n            for (int j = 1; j &lt;= m; ++j) &#123;\n                h = 1, t = 0;\n                for (int i = n; i; --i) &#123;\n                    if (a[i][j] == &#39;x&#39;) &#123;\n                        h = 1, t = 0;\n                        continue;\n                    &#125;\n                    while (h &lt;= t &amp;&amp; q[h] - i &gt; y)\n                        ++h;\n                    d[i][j] = f[i][j];\n                    if (h &lt;= t) &#123;\n                        f[i][j] = max(f[i][j],\n                                    d[q[h]][j] + q[h] - i);\n                    &#125;\n                    while (h &lt;= t &amp;&amp; d[i][j] + i\n                                    &gt;= d[q[t]][j] + q[t])\n                        --t;\n                    q[++t] = i;\n                &#125;\n            &#125;\n        &#125;\n        else if (u == 2) &#123;\n            for (int j = 1; j &lt;= m; ++j) &#123;\n                h = 1, t = 0;\n                for (int i = 1; i &lt;= n; ++i) &#123;\n                    if (a[i][j] == &#39;x&#39;) &#123;\n                        h = 1, t = 0;\n                        continue;\n                    &#125;\n                    while (h &lt;= t &amp;&amp; i - q[h] &gt; y)\n                        ++h;\n                    d[i][j] = f[i][j];\n                    if (h &lt;= t) &#123;\n                        f[i][j] = max(f[i][j],\n                                    d[q[h]][j] + i - q[h]);\n                    &#125;\n                    while (h &lt;= t &amp;&amp; d[i][j] - i\n                                &gt;= d[q[t]][j] - q[t])\n                        --t;\n                    q[++t] = i;\n                &#125;\n            &#125;\n        &#125;\n        else if (u == 3) &#123;\n            for (int i = 1; i &lt;= n; ++i) &#123;\n                h = 1, t = 0;\n                for (int j = m; j; --j) &#123;\n                    if (a[i][j] == &#39;x&#39;) &#123;\n                        h = 1, t = 0;\n                        continue;\n                    &#125;\n                    while (h &lt;= t &amp;&amp; q[h] - j &gt; y)\n                        ++h;\n                    d[i][j] = f[i][j];\n                    if (h &lt;= t) &#123;\n                        f[i][j] = max(f[i][j],\n                                    d[i][q[h]] + q[h] - j);\n                    &#125;\n                    while (h &lt;= t &amp;&amp; d[i][j] + j\n                                &gt;= d[i][q[t]] + q[t])\n                        --t;\n                    q[++t] = j;\n                &#125;\n            &#125;\n        &#125;\n        else &#123;\n            for (int i = 1; i &lt;= n; ++i) &#123;\n                h = 1, t = 0;\n                for (int j = 1; j &lt;= m; ++j) &#123;\n                    if (a[i][j] == &#39;x&#39;) &#123;\n                        h = 1, t = 0;\n                        continue;\n                    &#125;\n                    while (h &lt;= t &amp;&amp; j - q[h] &gt; y)\n                        ++h;\n                    d[i][j] = f[i][j];\n                    if (h &lt;= t) &#123;\n                        f[i][j] = max(f[i][j],\n                                    d[i][q[h]] + j - q[h]);\n                    &#125;\n                    while (h &lt;= t &amp;&amp; d[i][j] - j\n                                &gt;= d[i][q[t]] - q[t])\n                        --t;\n                    q[++t] = j;\n                &#125;\n            &#125;\n        &#125;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            for (int j = 1; j &lt;= m; ++j)\n                res = max(res, f[i][j]);\n        &#125;\n    &#125;\n    print(res);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n",
            "tags": [
                "DP",
                "单调队列"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20230110/",
            "url": "https://xsc062.netlify.app/20230110/",
            "title": "背单词",
            "date_published": "2023-01-09T18:27:46.000Z",
            "content_html": "<p>Solution to<a href=\"http://222.180.160.110:61235/problem/59\">「SCOI2016」背单词</a>。</p>\n<span id=\"more\"></span>\n<hr />\n<p>题解 P3294。</p>\n<p>我们看到字典树这个标签，下意识想到了前缀。</p>\n<p>但是题目让我们求后缀，所以我们把所有字符串先 <code>reverse</code> 一下，将问题转化为前缀，方便描述。</p>\n<hr />\n<p>我们发现，因为 <span class=\"math inline\">\\(y &lt; x \\le n\\)</span>，所以三种情况的花费排序为 <span class=\"math inline\">\\(x-y&lt;x&lt;n\\times n\\)</span>。</p>\n<p>不难发现，我们可以很简单地通过「把某单词的所有前缀单词放到它之前」消除开销为 <span class=\"math inline\">\\(n\\times n\\)</span> 的情况。此时开销最劣情况下为 <span class=\"math inline\">\\(\\sum\\limits_{i=1}^ni &lt; n\\times n\\)</span>。</p>\n<p>接下来，问题在于怎样在满足「把某单词的所有前缀单词放到它之前」的条件下，最小化开销。不难发现，当我们去除第一种情况后，剩下的 <span class=\"math inline\">\\(x\\)</span> 和 <span class=\"math inline\">\\(x-y\\)</span> 都包含 <span class=\"math inline\">\\(x\\)</span> 项，也就是说，我们只需要最小化 <span class=\"math inline\">\\(\\sum -y\\)</span> 的值，也就是最大化 <span class=\"math inline\">\\(\\sum y\\)</span> 的值。而 <span class=\"math inline\">\\(\\sum x\\)</span> 为定值 <span class=\"math inline\">\\(\\sum\\limits_{i=1}^ni\\)</span>。</p>\n<p><strong>关于处理方式：不难发现一个单词的最长前缀单词最多只有一个，但以该单词为最长前缀单词的单词可能有多个，联想到树。</strong></p>\n<p><strong>我们将每个单词的最长前缀和该单词连边，会得到一个森林。</strong></p>\n<p>不妨先考虑问题的简化，假设有两条链（即，不会同时存在多个单词，使得它们的最长前缀单词相同），应该如何安排其顺序。</p>\n<p>如图所示，考虑「同一条链均匀分散到序列中」和「同一条链集中在一起」两种有规律的安排方式，得到：</p>\n<p><img src=\"1.jpg\" /></p>\n<p>可以发现，第二种情况明显更优。</p>\n<p>所以我们扩展猜想：对于某一单词，以它为前缀的所有单词必须紧随其后。该结论是可递归的。</p>\n<p>继续处理细节部分。考虑两条链长度不同，应如何排列它们的位置？</p>\n<p>下图展示了「前短后长」和「前长后短」两种方案：</p>\n<p><img src=\"2.jpg\" /></p>\n<p>可以发现，前短后长的方案更优。</p>\n<p>扩展得到猜想，同一单词的所有子树中，大小更小的应在更前面。该结论是可递归的。</p>\n<hr />\n<p>接下来对猜想进行证明。</p>\n<p>假设现在已有一条链。我们只有把整条链连在一起，短单词放到长单词前面这一种方法。</p>\n<p>然后新来了一个不属于这条链的节点，明显，因为节点不管放到哪里，其 <span class=\"math inline\">\\(y\\)</span> 值不变，但会改变已有链的 <span class=\"math inline\">\\(y\\)</span> 值，所以放到最前面最优。</p>\n<p>又来了一个节点，和刚才新增的节点属于同一条链，一样，不管这个节点何去何从，其 <span class=\"math inline\">\\(y\\)</span> 不变，但放在越前面，后面的节点的 <span class=\"math inline\">\\(y\\)</span> 值增加得越多。</p>\n<p>以此类推可得到结论，同一条链放到一起。短链放到长链前面也是比较好想的。假设有两条链，短链长度为 <span class=\"math inline\">\\(a\\)</span>，长链长度为 <span class=\"math inline\">\\(b\\)</span>，放置起点为 <span class=\"math inline\">\\(l\\)</span>，则前短后长和钱长后短的 y 之和分别为 <span class=\"math inline\">\\(\\dfrac{(l + l + a - 2) \\times (a - 1) + (l + a + l + a + b - 2) \\times (b - 1)} 2\\)</span> 和 <span class=\"math inline\">\\(\\dfrac{(l + l + b - 2) \\times (b - 1) + (l + b + l + b + a - 2) \\times (b - 1)} 2\\)</span>（运用等差数列求和公式），解不等式可得前短后长一定更优。</p>\n<p>接下来是从链扩展到树。那么我们想到了什么？树链剖分。</p>\n<p>我们化用树剖思想，以最轻边为剖分条件，将树划分为有顺序的链，按照上述方式排列其顺序即可。</p>\n<p>此时我们记录下每个单词的直系父亲（即其最长前缀单词），在唯一序列中模拟计分操作，即可得到答案。</p>\n<hr />\n<p>为了方便，可将所有入度为 <span class=\"math inline\">\\(0\\)</span> 的点与一个虚点相连，将森林转化为树。</p>\n<p>注意 <code>long long</code>。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nusing str = std::string;\nconst int maxn = 1e6 + 5;\nconst int maxm = 1e6 + 5;\nstr s[maxn];\nint T[maxm][26];\nint kaz[maxn], siz[maxn]; // kaz 表示单词在最终序列中所处的位置\nstd::vector&lt;int&gt; g[maxn];\nint n, l, res, cnt = 1, ti;\nint tot[maxm], fa[maxn], deg[maxn];\nvoid Insert(int k) &#123; \n    int f = 1, len = s[k].length();\n    for(int i = 0; i &lt; len; ++i) &#123;\n        if (!T[f][s[k][i] - &#39;a&#39;]) \n            T[f][s[k][i] - &#39;a&#39;] = ++cnt;\n        f = T[f][s[k][i]-&#39;a&#39;];\n    &#125;\n    tot[f] = k;\n    return;\n&#125;\nvoid Search(int k) &#123;\n    int f = 1;\n    int len = s[k].length();\n    for (int i = 0; i &lt; len; ++i) &#123;\n        f = T[f][s[k][i] - &#39;a&#39;];\n        if (tot[f]) &#123;\n            if (tot[f] != k)\n                fa[k] = tot[f]; // 记录当前最长前缀\n        &#125;\n    &#125;\n    return;\n&#125;\nvoid add(int x, int y) &#123;\n    ++deg[y];\n    g[x].push_back(y);\n    return;\n&#125;\nvoid DFS1(int x) &#123; // 提前计算每个子树的 size\n    siz[x] = 1;\n    for (auto i : g[x]) &#123;\n        DFS1(i);\n        siz[x] += siz[i];\n    &#125;\n    return;\n&#125;\nvoid DFS2(int x) &#123;\n    kaz[x] = ti++;  // 时间戳即为单词位置\n    std::sort(g[x].begin(), g[x].end(),\n        [&amp;](int x, int y) &#123; return siz[x] &lt; siz[y]; &#125;); // 按子树 size 排序\n    for (auto i : g[x])\n        DFS2(i);\n    return;\n&#125;\nint main() &#123;\n    scanf(&quot;%lld&quot;, &amp;n);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; s[i];\n        std::reverse(s[i].begin(), s[i].end());  // 后缀转前缀\n        Insert(i);\n        res += i;\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        Search(i);\n        if (fa[i])\n            add(fa[i], i); // 建图\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        if (!deg[i]) // 建虚点方便操作\n            add(n + 1, i), fa[i] = n + 1;\n    &#125;\n    DFS1(n + 1), DFS2(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        res -= kaz[fa[i]]; // 处理 y 值\n    print(res);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n",
            "tags": [
                "字典树"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20221010/",
            "url": "https://xsc062.netlify.app/20221010/",
            "title": "解题报告 博弈",
            "date_published": "2022-10-10T14:31:28.000Z",
            "content_html": "<p>老题解批量补档。</p>\n<span id=\"more\"></span>\n<hr />\n<blockquote>\n<p>给定一棵带权树，将 <span class=\"math inline\">\\((u,v)\\)</span> 间简单路径上的边权生成数组，两个人在数组中轮流选数，每次选走的数必须 <span class=\"math inline\">\\(\\le\\)</span> 上一个人选走的数，不能选的人输，问有多少个 <span class=\"math inline\">\\((u,v)\\)</span> 满足先手必胜。</p>\n</blockquote>\n<p>如果在 <span class=\"math inline\">\\((u, v)\\)</span> 的路径上有任何一种边权的数量是奇数，那么就要统计 <span class=\"math inline\">\\((u,v)\\)</span>。</p>\n<p>对于最小的、出现次数为奇数的边权 <span class=\"math inline\">\\(w\\)</span>，先手选择 <span class=\"math inline\">\\(w\\)</span>，此时剩下偶数个可选项。后手选择 <span class=\"math inline\">\\(w&#39;\\)</span>，这会删除 <span class=\"math inline\">\\(&gt;w&#39;\\)</span> 且 <span class=\"math inline\">\\(\\le w\\)</span> 的所有可选项。发现被删掉偶数个选项；剩下奇数个选项。易知先手必胜。</p>\n<p>若不存在出现次数为奇数的边权，从刚刚后手的处境可以看出先手必败。所以，问题就转化为了：统计点对 <span class=\"math inline\">\\((u, v)\\)</span> 的数量，满足 <span class=\"math inline\">\\(u\\)</span> 到 <span class=\"math inline\">\\(v\\)</span> 的简单路径中存在出现次数为奇数的边权。</p>\n<p>给每个边权映射一个值，为 <code>base</code> 的 <code>rand()</code> 次方，自然溢出即可。然后直接按照之前的操作处理就好了。</p>\n<p>如果一个你想找到类似于 <code>1 ^ 2 ^ 3 = 0</code> 的情况，其出现概率与数字的二进制位数有关。因为 <code>xor</code> 只针对于同一位，结果不会被上一位或下一位干扰，所以每一位出现异或起来为 <span class=\"math inline\">\\(0\\)</span> 的概率是 <span class=\"math inline\">\\(\\dfrac 12\\)</span>。只要我们整点比较强力的 <span class=\"math inline\">\\(k\\)</span> 位二进制数，那么出现以上情况的概率就是 <span class=\"math inline\">\\(2^{-k}\\)</span>。</p>\n<p>那么这个比较强力的 <span class=\"math inline\">\\(k\\)</span> 位二进制数，用比较强力的类字符串哈希生成方式，再使用一个很大很大的随机数替代字符串哈希中表示下标的 <span class=\"math inline\">\\(i\\)</span>，用自然溢出让它显得更加稳妥就好。所以现在我们程序寄掉的概率就是 <span class=\"math inline\">\\(\\dfrac 1{2^{64}}\\)</span>，好事情啊好事情。</p>\n<p>时间复杂度 <span class=\"math inline\">\\(\\mathcal O(n\\log n)\\)</span>，<span class=\"math inline\">\\(\\log n\\)</span> 来源于映射。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int _p = 13331;\nconst int maxn = 5e5 + 5;\nstruct _ &#123;\n    int v;\n    ull w;\n    _ () &#123;&#125;\n    _ (int v1, ull w1) &#123;\n        v = v1, w = w1;\n    &#125;\n&#125;;\null w;\null f[maxn];\nint T, n, x, y, ans;\nstd::map&lt;ull, int&gt; t;\nstd::map&lt;ull, ull&gt; q;\nstd::vector&lt;_&gt; g[maxn];\ninline void Init(int n) &#123;\n    t.clear();\n    q.clear();\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        f[i] = 0;\n        g[i].clear();\n        g[i].shrink_to_fit();\n    &#125;\n    return;\n&#125;\nvoid DFS(int x, int fa) &#123;\n    ++t[f[x]];\n    for (auto i : g[x]) &#123;\n        if (i.v == fa)\n            continue;\n        f[i.v] = f[x] ^ i.w;\n        DFS(i.v, x);\n    &#125;\n    return;\n&#125;\ninline void add(int x, int y, ull w) &#123;\n    g[x].push_back(_(y, w));\n    return;\n&#125;\ninline ull randint(void) &#123;\n    ull res = rand();\n    res *= rand();\n    res *= rand();\n    return res;\n&#125;\ninline ull qkp(ull x, ull y) &#123;\n    ull res = 1;\n    while (y) &#123;\n        if (y &amp; 1)\n            res *= x;\n        x *= x;\n        y &gt;&gt;= 1;\n    &#125; \n    return res;\n&#125;\nint main() &#123;\n    read(T);\n    srand(time(NULL));\n    while (T--) &#123;\n        read(n);\n        Init(n);\n        ans = n * (n - 1) / 2;\n        for (int i = 1; i &lt; n; ++i) &#123;\n            read(x), read(y), read(w);\n            if (!q.count(w))\n                q[w] = qkp(_p, randint());\n            w = q[w];\n            add(x, y, w), add(y, x, w);\n        &#125;\n        DFS(1, -1);\n        for (auto i : t)\n            ans -= i.second * (i.second - 1) / 2;\n        print(ans, &#39;\\n&#39;);\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n",
            "tags": [
                "哈希"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20220927/",
            "url": "https://xsc062.netlify.app/20220927/",
            "title": "悬线法",
            "date_published": "2022-09-27T02:53:00.000Z",
            "content_html": "<p>有一段时间看见单调栈就抑郁，所以做题的时候就东贺贺，西贺贺，最终了解到了世界上还有一种很神奇的方法叫悬线法。</p>\n<span id=\"more\"></span>\n<p>本文中的「单调栈」均指依赖于顺序维护信息的工具，单纯利用单调性质作为数据结构独立存在的单调栈不在本篇文章 <strong>批判</strong> 范围之内。</p>\n<hr />\n<h2 id=\"引入土豪聪要请客\">引入：土豪聪要请客</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/2870/problem/4\" class=\"uri\">http://222.180.160.110:61235/contest/2870/problem/4</a></p>\n<p>题意简述：给定一个 <span class=\"math inline\">\\(n\\times m\\)</span> 的矩阵，其中有一部分地方有障碍。在整个地图上找到周长最大的、不包含障碍的矩形。</p>\n<p>输入一个由 <code>.</code>（空地）和 <code>X</code>（障碍）组成的矩阵，输出最大矩形周长减 <span class=\"math inline\">\\(1\\)</span>。</p>\n<details>\n<p><summary>一些鲜花</summary></p>\n<p>看到题后即可想到悬线法，但是中午太困了处于游离状态一直掉线，所以干瞪着电脑屏幕打瞌睡。</p>\n<p><del>于是这篇文章从 220927 被拖到了 230916，哈哈真神奇</del> 现在是 231004 了，我才动笔。</p>\n</details>\n<hr />\n<p>首先预处理出 <span class=\"math inline\">\\(s_{i, j}\\)</span>，表示从 <span class=\"math inline\">\\((i,\\,j)\\)</span> 向上，共有多少个连续的 <code>.</code>。</p>\n<pre class=\"cpp\"><code>for (int i = 1; i &lt;= n; ++i) &#123;\n    for (int j = 1; j &lt;= m; ++j)\n        s[i][j] = (a[i][j] == &#39;.&#39; ? s[i - 1][j] + 1 : 0);\n&#125;</code></pre>\n<p>悬线法的名字很形象，拎着一根细线的头，让它自然下垂。</p>\n<p>为了方便思考和实现，我们这样想象：一个地图，我们手里拿着一根硬棒朝上举，然后固定我们手只能在一行上运动，用它左右「刷」沿途的矩形。</p>\n<p>具象地说，选定一行 <span class=\"math inline\">\\(i\\)</span>，枚举每一个 <span class=\"math inline\">\\(j\\)</span>，寻找以第 <span class=\"math inline\">\\(i\\)</span> 行为底，包含 <span class=\"math inline\">\\((i,\\,j)\\)</span>，高为 <span class=\"math inline\">\\(s_{i,\\,j}\\)</span> 的最宽矩形。</p>\n<p>也就是从 <span class=\"math inline\">\\((i, j)\\)</span> 出发，往左右分别找到最远的一个位置 <span class=\"math inline\">\\(L_j, R_j\\)</span>，满足 <span class=\"math inline\">\\(s_{i, L_j \\sim R_j} \\ge s_{i, j}\\)</span>。那么悬线法最抽象的部分就讲完了，接下来是最神奇的部分。</p>\n<p>在第 <span class=\"math inline\">\\(i\\)</span> 行内，从每个 <span class=\"math inline\">\\((i, j)\\)</span> 开始找到 <span class=\"math inline\">\\(L_j, R_j\\)</span>，如果暴力那么明显是个 <span class=\"math inline\">\\(O(m^2)\\)</span> 的时间。</p>\n<p>但是我们考虑这么一件事情。假设 <span class=\"math inline\">\\(L_{i-1}\\)</span> 已经求出。</p>\n<p>令 <span class=\"math inline\">\\(k = j-1\\)</span>，<span class=\"math inline\">\\(L_j\\)</span> 初值赋为 <span class=\"math inline\">\\(j\\)</span>（左端点至少是自己）。</p>\n<ol type=\"1\">\n<li>当 <span class=\"math inline\">\\(L_j=1\\)</span> 时 即刻停止算法，因为 <span class=\"math inline\">\\(1\\)</span> 是可达的最左位置，不能再往左了。</li>\n<li>当 <span class=\"math inline\">\\(a_k &gt; a_j\\)</span> 时 <span class=\"math inline\">\\(a_k\\)</span> 就像一堵墙，堵住了我们要继续往左刷的硬棒，故不改变 <span class=\"math inline\">\\(L_j\\)</span> 并停止算法。</li>\n<li>否则，由于 <span class=\"math inline\">\\(a_{L_k\\sim k}\\ge a_k\\ge a_j\\)</span>，从 <span class=\"math inline\">\\(j\\)</span> 开始往左刷至少都能够到 <span class=\"math inline\">\\(L_k\\)</span>。此时我们令 <span class=\"math inline\">\\(k=L_k-1\\)</span>，回到第一步。</li>\n</ol>\n<p>我们就可以求解到正确的 <span class=\"math inline\">\\(L_j\\)</span> 的。求解 <span class=\"math inline\">\\(R_j\\)</span> 的流程和上述大致相同，不再赘述。</p>\n<hr />\n<p>那么是一个非常神奇的事情。悬线法的时间复杂度怎么证明呢？</p>\n<p>我们思考。假设 <span class=\"math inline\">\\(a_{j-1}&gt;a_j\\)</span>，算法会即刻停止；否则，当前定位直接跳到 <span class=\"math inline\">\\(L_{j-1}\\)</span> 之前，也就是说，为了求解 <span class=\"math inline\">\\(L_{j-1}\\)</span> 而遍历过的位置，求解 <span class=\"math inline\">\\(L_j\\)</span> 时都不会再遍历第二遍。</p>\n<p>没有值会被遍历第二遍，所以是 <span class=\"math inline\">\\(O(m)\\)</span> 的。</p>\n<hr />\n<p>按照上述流程，算法总体时间复杂度 <span class=\"math inline\">\\(O(n\\times m)\\)</span>，和单调栈完全一致。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 2e3 + 5;\nint n, m, ans;\nchar a[maxn][maxn];\nint s[maxn][maxn], l[maxn][maxn], r[maxn][maxn];\nint max(int x, int y) &#123;\n    return x &gt; y ? x : y;\n&#125;\nint main() &#123;\n    read(n);\n    read(m);\n    for (int i = 1; i &lt;= n; ++i)\n        scanf(&quot;%s&quot;, a[i] + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = 1; j &lt;= m; ++j)\n            s[i][j] = (a[i][j] == &#39;.&#39; ? s[i - 1][j] + 1 : 0);\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = 1; j &lt;= m; ++j) &#123;\n            l[i][j] = j;\n            while (l[i][j] &gt; 1 &amp;&amp; s[i][j] &lt;= s[i][l[i][j] - 1])\n                l[i][j] = l[i][l[i][j] - 1];\n        &#125;\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = m; j; --j) &#123;\n            r[i][j] = j;\n            while (r[i][j] &lt; m &amp;&amp; s[i][j] &lt;= s[i][r[i][j] + 1])\n                r[i][j] = r[i][r[i][j] + 1];\n        &#125;\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = 1; j &lt;= m; ++j) &#123;\n            if (!s[i][j])\n                continue;\n            ans = max(ans, (s[i][j] +\n                      (r[i][j] - l[i][j] + 1)) * 2);\n        &#125;\n    &#125;\n    printf(&quot;%d&quot;, ans - 1);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<p>上述处理 <span class=\"math inline\">\\(s\\)</span> 数组的「竖向压缩」技巧是处理矩阵类悬线法题目的常用技巧，这里使用另一道题来举例子。</p>\n<h3 id=\"例玉蟾宫-city-game-城市游戏\">例：玉蟾宫 / City Game / 城市游戏</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/1655/problem/2\" class=\"uri\">http://222.180.160.110:61235/contest/1655/problem/2</a></p>\n<p>这道题和上一道非常相似，只需改变求答案的式子即可。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 1e3 + 5; \nchar t;\nint n, m, ans;\nint s[maxn][maxn];\nint l[maxn][maxn], r[maxn][maxn];\nint max(int x, int y) &#123;\n    return x &gt; y ? x : y;\n&#125;\nint main() &#123;\n    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = 1; j &lt;= m; ++j) &#123;\n            scanf(&quot;%1s&quot;, &amp;t);\n            if (t == &#39;F&#39;)\n                s[i][j] = s[i - 1][j] + 1;\n            l[i][j] = j;\n            while (l[i][j] &gt; 1 &amp;&amp; s[i][j]\n                        &lt;= s[i][l[i][j] - 1])\n                l[i][j] = l[i][l[i][j] - 1];\n        &#125;\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        r[i][m + 1] = m + 1;\n        for (int j = m; j; --j) &#123;\n            r[i][j] = j;\n            while (r[i][j] &lt; m &amp;&amp; s[i][j]\n                         &lt;= s[i][r[i][j] + 1])\n                r[i][j] = r[i][r[i][j] + 1];\n            ans = max(ans, s[i][j] *\n                        (r[i][j] - l[i][j] + 1));\n        &#125;\n    &#125;\n    print(ans * 3, &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h2 id=\"悬线法能维护的数据特点\">悬线法能维护的数据特点</h2>\n<p>值得注意的是，悬线法仅指求解最远左右端点的技巧。</p>\n<p>同时可以维护过程中的其它信息，例如 <a href=\"/20231004\">情景剧</a> 一题。链接中有详细叙述，此处略。</p>\n<p>根据本题带来的启发，我们认识到悬线可在求解过程中维护的内容更多。</p>\n<p><del>不像你单调栈随随便便删这删那信息全部断层什么都维护不了</del></p>\n<hr />\n<h2 id=\"进一步地悬线法与单调栈\">进一步地，悬线法与单调栈？</h2>\n<p>和 <span class=\"citation\" data-cites=\"Rosmist\">@Rosmist</span> 辩经的时候，Rosmist 激情爆典：「悬线不就是可持久化单调栈吗？」</p>\n<p>很有道理。容易发现单调栈在每一个 <span class=\"math inline\">\\(i\\)</span> 时刻的栈内元素就是从 <span class=\"math inline\">\\(i\\)</span> 开始往起始方向跳，经过的所有元素。由于悬线存储的数据是不会更改的，倒推回去我们可以知道，悬线存储了每个时刻的单调栈信息并有多个点共享前驱 / 后继，其实就是一种另类的可持久化单调栈，并且复杂度与单调栈本体相同。</p>\n<hr />\n<h2 id=\"与笛卡尔树的关联\">与笛卡尔树的关联</h2>\n<p><em>upd on 240704</em>，学习了笛卡尔树。现在介绍悬线与笛卡尔树的关系。</p>\n<p>容易发现元素 <span class=\"math inline\">\\(i\\)</span> 的 <span class=\"math inline\">\\(l_i,r_i\\)</span> 二值就是其在笛卡尔树上对应的区间。</p>\n<p>更抽象的一点是悬线法中跳一跳的操作在笛卡尔树中的对应内涵。以小根堆为背景、在 <span class=\"math inline\">\\(l\\)</span> 上向左跳为例，注意到该操作相当于从左到右向笛卡尔树中新增节点。</p>\n<p>这也进一步验证了悬线法复杂度的正确性：我们都知道，在新加入节点时，若从树中提取出由根节点和其一直向右走直到节点不存在右儿子构成的链，则该点被添加到链中某一点的右儿子，该点原本的右子树（完整包含了链的剩余部分）成为新建节点的左子树。</p>\n<p>而悬线实现的就是从链的最低点暴力爬山，直到找到合法点；而根据上面的结论，被枚举过的链上较低点不会作为新节点的右边的子孙，自然也不会再次被枚举到。</p>\n<p>故而每个点最多被枚举到一次，得证。</p>\n<p>进一步的，可以开发出悬线法 <span class=\"math inline\">\\(O(n)\\)</span> 建笛卡尔树的方法：</p>\n<p>每次求解完 <span class=\"math inline\">\\(l_i\\)</span> 后，令 <span class=\"math inline\">\\(rc_{l_i-1}=i\\)</span> 即可（当然 <span class=\"math inline\">\\(rc_{l_i-1}\\)</span> 是会被多次更新的，这也是不直接用邻接表 / 前向星连边的原因），<span class=\"math inline\">\\(r_i\\)</span> 与 <span class=\"math inline\">\\(lc\\)</span> 同理。</p>\n<pre class=\"cpp\"><code>for (int i = 1; i &lt;= n; ++i) &#123;\n    l[i] = i;\n    while (l[i] != 1 &amp;&amp; a[l[i] - 1] &gt; a[i])\n        l[i] = l[l[i] - 1];\n    rc[l[i] - 1] = i;\n&#125;\nfor (int i = n; i; --i) &#123;\n    r[i] = i;\n    while (r[i] != n &amp;&amp; a[r[i] + 1] &gt; a[i])\n        r[i] = r[r[i] + 1];\n    lc[r[i] + 1] = i;\n&#125;</code></pre>\n<p>其中，根节点即为 <code>rc[0]</code> 或 <code>lc[n + 1]</code>。</p>\n<hr />\n<p>进一步从笛卡尔树出发，探究悬线法能够循环内维护的数据特点。</p>\n<p>为何是循环内维护？因为循环外维护就只能从左右的直接儿子进行更新，那和笛卡尔树就没有区别了。</p>\n<p>但其实结果是没什么可探究的，因为其经过的节点——自己左子树下最右端链——实在不具有什么特殊性，它们所对应的区间——从 <span class=\"math inline\">\\([l_i, i - 1]\\)</span> 到 <span class=\"math inline\">\\([i - 1, i - 1]\\)</span> 也看不出什么值得研究的，更何况可以被笛卡尔树更具象地代替；如果你要从前缀最值的角度出发，那就没意思了，完全等价于单调栈。</p>\n<p>所以我们认为这次悬线法的开发最终以失败告终，<del>不然它早被别人开发了</del>，我在此能给出的意见是，可以用悬线法完成矩形题目等不需要笛卡尔树树形结构的问题，至于其他，甚至包括上面提到的 <a href=\"/20231004\">情景剧</a> 一题，都可以直接上笛卡尔树。</p>\n<p>但笛卡尔树的建树我还是肯定会用悬线的！毕竟照应开头，我不会单调栈 <img src=\"/em/dy.gif\" alt=\"得意\" /></p>\n",
            "tags": [
                "悬线法"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20220808/",
            "url": "https://xsc062.netlify.app/20220808/",
            "title": "解题报告 One-Dimensional Battle Ships",
            "date_published": "2022-08-07T23:56:40.000Z",
            "content_html": "<p>老题解批量补档。</p>\n<span id=\"more\"></span>\n<hr />\n<p><a href=\"https://www.luogu.com.cn/problem/CF567D\" class=\"uri\">https://www.luogu.com.cn/problem/CF567D</a></p>\n<p>因为「某一时刻是否一定被击中过」具有单调性，考虑先提前发射所有炮弹，倒序枚举炮弹，不断「撤销」当前最后一发炮弹的发射，如果在「撤销」这发炮弹后，存在任意一种放下 <span class=\"math inline\">\\(k\\)</span> 艘完整的战舰的方案，说明在发射这一发炮弹之后绝对能够击中。</p>\n<p>如果发射所有炮弹后，依然存在一种放下 <span class=\"math inline\">\\(k\\)</span> 艘完整的战舰的方案，则无解。</p>\n<p>具体实现可以使用并查集维护连通块大小，每「撤销」一发炮弹的发射相当于合并三个连通块：炮弹的落点、落点的前一个元素（若不存在或已被炮弹摧毁则忽略）、落点的后一个元素（若不存在或已被炮弹摧毁则忽略）。</p>\n<p>设某连通块大小为 <span class=\"math inline\">\\(x\\)</span>，可容纳战舰数为 <span class=\"math inline\">\\(res\\)</span>，显然有 <span class=\"math inline\">\\(res = \\lfloor (x + 1) \\div (p + 1) \\rfloor\\)</span>。</p>\n<p>记统计当前可容纳战舰的数量为 <span class=\"math inline\">\\(ans\\)</span>，在并查集合并时，<span class=\"math inline\">\\(ans\\)</span> 分别减去两个待合并连通块的可容纳战舰的数量，再加上新连通块可容纳战舰的数量。最靠后的 <span class=\"math inline\">\\(ans\\ge k\\)</span> 的时刻即为所求。</p>\n<p>同时使用路径压缩和按秩合并，时空复杂度均为 <span class=\"math inline\">\\(\\mathcal O(n)\\)</span>。优于 multiset 解法。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 2e5 + 15;\nbool vis[maxn];\nint n, k, p, m, x, ans;\nint a[maxn], f[maxn], siz[maxn];\ninline void swap(int &amp;x, int &amp;y)&#123;\n    x ^= y ^= x ^= y;\n    return 0;\n&#125;\ninline int calc(int x) &#123;\n    return (x + 1) / (p + 1);\n&#125;\ninline void Init(int n) &#123;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        f[i] = i;\n        siz[i] = 1;\n    &#125;\n    return;\n&#125;\nint find(int x) &#123;\n    return x == f[x] ? x : f[x] = find(f[x]);\n&#125;\ninline void merge(int x, int y) &#123;\n    int fx = find(x);\n    int fy = find(y);\n    if (fx == fy)\n        return;\n    ans -= calc(siz[fx]);\n    ans -= calc(siz[fy]);\n    if (siz[fy] &gt; siz[fx])\n        swap(fx, fy);\n    ans += calc(siz[fy]);\n    f[fx] = fy;\n    return;\n&#125;\nint main() &#123;\n    read(n);\n    read(k);\n    read(p);\n    read(m);\n    Init(n + 5);\n    ans = (n - m) * (2 / (p + 1));\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        read(a[i]);\n        vis[a[i]] = 1;\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        if (vis[i] || vis[i - 1])\n            continue;\n        merge(i, i - 1);\n    &#125; \n    if (ans &gt;= k) &#123;\n        puts(&quot;-1&quot;);\n        return 0;\n    &#125;\n    for (int i = m; i; --i) &#123;\n        vis[a[i]] = 0;\n        ans += 2 / (p + 1);\n        if (a[i] - 1 &amp;&amp; !vis[a[i] - 1])\n            merge(a[i], a[i] - 1);\n        if (a[i] + 1 &lt;= n &amp;&amp; !vis[a[i] + 1])\n            merge(a[i], a[i] + 1);\n        if (ans &gt;= k) &#123;\n            printf(&quot;%d&quot;, i);\n            return 0;\n        &#125;\n    &#125;\n    puts(&quot;-1&quot;);\n    return 0;\n&#125;\n&#125; // namespace XSC062\nint main() &#123;\n    XSC062::main();\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "并查集"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20210214/",
            "url": "https://xsc062.netlify.app/20210214/",
            "title": "【总结】斜率优化 DP",
            "date_published": "2021-02-06T15:59:00.000Z",
            "content_html": "<p>于是，XSC062 开始写总结。</p>\n<h2 id=\"斜率优化-dp\">斜率优化 DP</h2>\n<p><strong>前置芝士</strong></p>\n<p><a href=\"https://www.cnblogs.com/XSC062/p/14383610.html\">单调队列优化 DP</a></p>\n<p><strong>正文</strong></p>\n<p>我们以一道题为例。</p>\n<h3 id=\"打印文章\"><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=3507\">打印文章</a></h3>\n<p><a href=\"https://loj.ac/p/10191\">双倍经验</a> | <a href=\"https://www.acwing.com/problem/content/1096/\">三倍经验</a></p>\n<h4 id=\"solution\">Solution</h4>\n<p>明显 DP。</p>\n<p>那么 DP 式就是： <span class=\"math display\">\\[\n\\begin{aligned}\nf_i&amp;=\\min\\{f_j+(s_i-s_j)^2+M\\}\n\\\\\n&amp;=\\min\\{f_j+{s_i}^2-2\\times s_i\\times s_j+{s_j}^2+M\\}\n\\\\\n&amp;=\\min\\{f_j-2\\times s_i\\times s_j+{s_j}^2\\}+{s_i}^2+M\n\\end{aligned}\n\\]</span> 其中 <span class=\"math inline\">\\(s\\)</span> 为 <span class=\"math inline\">\\(c\\)</span> 的前缀和。</p>\n<p>时间复杂度 <span class=\"math inline\">\\(\\mathcal O(n^2)\\)</span>，明显爆炸，所以我们需要优化。</p>\n<p>在上一篇的 <a href=\"https://www.cnblogs.com/XSC062/p/14383610.html\">单调队列优化DP</a> 中，我们提到过，只有 DP 式中的与 <span class=\"math inline\">\\(i\\)</span> 有关的项能直接提出来时，我们才能使用单调队列优化，而这里的 <span class=\"math inline\">\\(s_i\\)</span> 与 <span class=\"math inline\">\\(s_j\\)</span> 相乘，无法使用单调队列优化。</p>\n<p>我们思考，对于 <span class=\"math inline\">\\(f_i\\)</span> 来说，无非就是选出最优的 <span class=\"math inline\">\\(j\\)</span> 来构造它。</p>\n<p>假设有 <span class=\"math inline\">\\(j\\)</span> 与 <span class=\"math inline\">\\(k\\)</span>，如何判断 <span class=\"math inline\">\\(j\\)</span> 与 <span class=\"math inline\">\\(k\\)</span> 谁更优呢？</p>\n<p>我们先钦定 <span class=\"math inline\">\\(j\\)</span> 优于 <span class=\"math inline\">\\(k\\)</span>，且 <span class=\"math inline\">\\(j&lt;k\\)</span>。</p>\n<p>那么可以得到： <span class=\"math display\">\\[\nf_j-2\\times s_i\\times s_j+{s_j}^2+{s_i}^2+M&lt;f_k-2\\times s_i\\times s_k+{s_k}^2+{s_i}^2+M\n\\]</span> 化简得： <span class=\"math display\">\\[\nf_j-2\\times s_i\\times s_j+{s_j}^2&lt;f_k-2\\times s_i\\times s_k+{s_k}^2\n\\]</span> 再将<strong>只</strong>与 <span class=\"math inline\">\\(j,k\\)</span> 有关的项放到左边，与 <span class=\"math inline\">\\(i\\)</span> 有关的项放到右边： <span class=\"math display\">\\[\nf_j-f_k+{s_j}^2-{s_k}^2&lt;2\\times s_i\\times s_j-2\\times s_i\\times s_k\n\\\\\nf_j-f_k+{s_j}^2-{s_k}^2&lt;2\\times s_i\\times(s_j-s_k)\n\\]</span> 左右两边同时 <span class=\"math inline\">\\(\\div\\)</span> 与 <span class=\"math inline\">\\(i\\)</span> 无关的项 <span class=\"math inline\">\\(2\\times(s_j-s_k)\\)</span> ： <span class=\"math display\">\\[\n\\dfrac{(f_j+{s_j}^2)-(f_k+{s_k}^2)}{(2\\times s_j)-(2\\times s_k)}&lt;s_i\n\\]</span> 如果满足上式 ，则 <span class=\"math inline\">\\(j&lt;k\\)</span> 且 <span class=\"math inline\">\\(j\\)</span> 优于 <span class=\"math inline\">\\(k\\)</span>。</p>\n<p>接下来是斜率优化的重点部分。</p>\n<blockquote>\n<p>在义务教育阶段，学生学习了 <a href=\"https://baike.baidu.com/item/一次函数\">一次函数</a>，它的几何意义表示为一条直线，一次项的系数就是直线的斜率，只不过当直线与 <span class=\"math inline\">\\(x\\)</span> 轴垂直的时候无法表示。虽然没有明确给出斜率这个名词，但实际上思想已经渗透到其中。</p>\n<p>直线对 <span class=\"math inline\">\\(x\\)</span> 轴的倾斜角 <span class=\"math inline\">\\(\\alpha\\)</span> 的正切值 <span class=\"math inline\">\\(\\tan\\alpha\\)</span> 称为该直线的“斜率”，并记作 <span class=\"math inline\">\\(k\\)</span> ，公式为 <span class=\"math inline\">\\(k=\\tan\\alpha\\)</span>。</p>\n<p>即 <span class=\"math inline\">\\(k=\\tan\\alpha=\\dfrac{\\Delta y}{\\Delta x}=\\dfrac{y_2-y_1}{x_2-x_1}\\)</span> 或 <span class=\"math inline\">\\(\\dfrac{y_1-y_2}{x_1-x_2}\\)</span> 。</p>\n<p align=\"right\">\n——选自 <a href=\"https://baike.baidu.com/item/%E6%96%9C%E7%8E%87/4914111?fr=aladdin\">斜率_百度百科</a>\n</p>\n</blockquote>\n<p>XSC062 看完了百度百科表示 <del>你 TM 在说些啥是不是欺负我六年义务教育的小学生</del> 恍然大悟</p>\n<p>上面推出来的那个关于 <span class=\"math inline\">\\(j\\)</span> 和 <span class=\"math inline\">\\(k\\)</span> 的DP式，不就是求两个点 <span class=\"math inline\">\\((2\\times s_j,f_j+{s_j}^2)\\)</span> 和 <span class=\"math inline\">\\((2\\times s_k,f_j+{s_k}^2)\\)</span> 连成一条线之后的坡度吗？</p>\n<p>本文后面的部分，<span class=\"math inline\">\\(x\\)</span> 的含义会在「点<span class=\"math inline\">\\((2\\times s_x,f_x+{s_x}^2)\\)</span> 」和「下标 <span class=\"math inline\">\\(x\\)</span> 」之间漂浮，请根据语境识别。</p>\n<p>随后 XSC062 边打瞌睡边听 GM 讲课（特异功能），勉强算是明白了中心意思：</p>\n<p>如图，假设有三个点 <span class=\"math inline\">\\(A,B,C\\)</span>，以及 <span class=\"math inline\">\\(l_{AB}\\)</span> 的斜率 <span class=\"math inline\">\\(k_1\\)</span>，<span class=\"math inline\">\\(l_{BC}\\)</span> 的斜率 <span class=\"math inline\">\\(k_2\\)</span>。</p>\n<figure>\n<img src=\"https://img-blog.csdnimg.cn/img_convert/3bc5fea553ad6b06229ef9e9fa4c9664.png\" alt=\"上凸\" /><figcaption>上凸</figcaption>\n</figure>\n<p>我们暂且把这个向外凸起的奇怪玩意儿称为一个「上凸」。</p>\n<p>回到前面的我们得到的那个结论：</p>\n<blockquote>\n<p><span class=\"math display\">\\[\n\\dfrac{(f_j+{s_j}^2)-(f_k+{s_k}^2)}{(2\\times s_j)-(2\\times s_k)}&lt;s_i\n\\]</span></p>\n<p>如果满足上式 ，则 <span class=\"math inline\">\\(j&lt;k\\)</span> 且 <span class=\"math inline\">\\(j\\)</span> 优于 <span class=\"math inline\">\\(k\\)</span>。</p>\n</blockquote>\n<p>简单记忆为：</p>\n<ul>\n<li>若 <span class=\"math inline\">\\(l_{NM}\\)</span> 的斜率比 <span class=\"math inline\">\\(s_i\\)</span> 小，则 <span class=\"math inline\">\\(N&lt;M\\)</span> 且 <span class=\"math inline\">\\(N\\)</span> 优于 <span class=\"math inline\">\\(M\\)</span> 。</li>\n<li>反之，若点 <span class=\"math inline\">\\(l_{NM}\\)</span> 的斜率比 <span class=\"math inline\">\\(s_i\\)</span> 大，则 <span class=\"math inline\">\\(M&lt;N\\)</span> 且 <span class=\"math inline\">\\(M\\)</span> 优于 <span class=\"math inline\">\\(N\\)</span>。</li>\n</ul>\n<p>将 <span class=\"math inline\">\\(A,B\\)</span> 代入，我们得知：</p>\n<ol type=\"1\">\n<li>若 <span class=\"math inline\">\\(k_1\\leqslant s_i\\)</span>，则 <span class=\"math inline\">\\(B\\)</span> 优于 <span class=\"math inline\">\\(A\\)</span>。</li>\n<li>若 <span class=\"math inline\">\\(k_1&gt;s_i\\)</span>，则 <span class=\"math inline\">\\(A\\)</span> 优于 <span class=\"math inline\">\\(B\\)</span>。</li>\n<li>若 <span class=\"math inline\">\\(k_2\\leqslant s_i\\)</span>，则 <span class=\"math inline\">\\(C\\)</span> 优于 <span class=\"math inline\">\\(B\\)</span>。</li>\n<li>若 <span class=\"math inline\">\\(k_2&gt;s_i\\)</span>，则 <span class=\"math inline\">\\(B\\)</span> 优于 <span class=\"math inline\">\\(C\\)</span>。</li>\n</ol>\n<p>因为斜率 = 倾斜度 = 竖得有多高，明显 <span class=\"math inline\">\\(k_1&gt;k_2\\)</span>。所以针对一个大小关系，<span class=\"math inline\">\\(k_1\\)</span> 和 <span class=\"math inline\">\\(k_2\\)</span> 之间只有可能有：</p>\n<ol type=\"1\">\n<li><span class=\"math inline\">\\(s_i&lt;k_2&lt;k_1\\)</span>，此时 <span class=\"math inline\">\\(B\\)</span> 优于 <span class=\"math inline\">\\(C\\)</span>，<span class=\"math inline\">\\(A\\)</span> 优于 <span class=\"math inline\">\\(B\\)</span>，<span class=\"math inline\">\\(A\\)</span> 为最优解。</li>\n<li><span class=\"math inline\">\\(k_2&lt;s_i&lt;k_1\\)</span>，此时 <span class=\"math inline\">\\(C\\)</span> 优于 <span class=\"math inline\">\\(B\\)</span>，<span class=\"math inline\">\\(A\\)</span> 优于 <span class=\"math inline\">\\(B\\)</span>，<span class=\"math inline\">\\(A,C\\)</span> 为最优解。</li>\n<li><span class=\"math inline\">\\(k_2&lt;k_1&lt;s_i\\)</span>，此时 <span class=\"math inline\">\\(C\\)</span> 优于 <span class=\"math inline\">\\(B\\)</span>，<span class=\"math inline\">\\(B\\)</span> 优于 <span class=\"math inline\">\\(A\\)</span>，<span class=\"math inline\">\\(C\\)</span> 为最优解。</li>\n</ol>\n<p>发现了吗？<span class=\"math inline\">\\(B\\)</span> 永远都不可能是最优解。</p>\n<p>所以如果我们要维护一个最优解的序列，就可以不要 <span class=\"math inline\">\\(B\\)</span> 了。</p>\n<figure>\n<img src=\"0.png\" alt=\"上凸\" /><figcaption>上凸</figcaption>\n</figure>\n<p>那么，因为我们已经删掉了所有「上凸」的突起部分，所以这个最优解序列里肯定不会再存在「上凸」了。</p>\n<p>如果是这样的「下凸」呢？</p>\n<figure>\n<img src=\"1.png\" alt=\"下凸\" /><figcaption>下凸</figcaption>\n</figure>\n<p><span class=\"math inline\">\\(k_1\\)</span> 为 <span class=\"math inline\">\\(l_{AB}\\)</span> 的斜率，<span class=\"math inline\">\\(k_2\\)</span> 为 <span class=\"math inline\">\\(l_{BC}\\)</span> 的斜率。</p>\n<p>将 <span class=\"math inline\">\\(A,B\\)</span> 代入，我们得知：</p>\n<ol type=\"1\">\n<li>若 <span class=\"math inline\">\\(k_1\\leqslant s_i\\)</span>，则 <span class=\"math inline\">\\(B\\)</span> 优于 <span class=\"math inline\">\\(A\\)</span>。</li>\n<li>若 <span class=\"math inline\">\\(k_1&gt;s_i\\)</span>，则 <span class=\"math inline\">\\(A\\)</span> 优于 <span class=\"math inline\">\\(B\\)</span>。</li>\n<li>若 <span class=\"math inline\">\\(k_2\\leqslant s_i\\)</span>，则 <span class=\"math inline\">\\(C\\)</span> 优于 <span class=\"math inline\">\\(B\\)</span>。</li>\n<li>若 <span class=\"math inline\">\\(k_2&gt;s_i\\)</span>，则 <span class=\"math inline\">\\(B\\)</span> 优于 <span class=\"math inline\">\\(C\\)</span>。</li>\n</ol>\n<p>明显 <span class=\"math inline\">\\(k_1&lt;k_2\\)</span>。所以 <span class=\"math inline\">\\(k_1\\)</span> 和 <span class=\"math inline\">\\(k_2\\)</span> 之间只有可能有：</p>\n<ol type=\"1\">\n<li><span class=\"math inline\">\\(s_i&lt;k_1&lt;k_2\\)</span>，此时 <span class=\"math inline\">\\(B\\)</span> 优于 <span class=\"math inline\">\\(C\\)</span>，<span class=\"math inline\">\\(A\\)</span> 优于 <span class=\"math inline\">\\(B\\)</span>，<span class=\"math inline\">\\(A\\)</span> 为最优解。</li>\n<li><span class=\"math inline\">\\(k_1&lt;s_i&lt;k_2\\)</span>，此时 <span class=\"math inline\">\\(B\\)</span> 优于 <span class=\"math inline\">\\(C\\)</span>，<span class=\"math inline\">\\(B\\)</span> 优于 <span class=\"math inline\">\\(A\\)</span>，<span class=\"math inline\">\\(B\\)</span> 为最优解。</li>\n<li><span class=\"math inline\">\\(k_1&lt;k_2&lt;s_i\\)</span>，此时 <span class=\"math inline\">\\(C\\)</span> 优于 <span class=\"math inline\">\\(B\\)</span>，<span class=\"math inline\">\\(B\\)</span> 优于 <span class=\"math inline\">\\(A\\)</span>，<span class=\"math inline\">\\(C\\)</span> 为最优解。</li>\n</ol>\n<p>所以，在下凸的情况中，三个点都有可能是最优解，都需要保留。</p>\n<p>现在呢，所有上凸都被去掉了，只剩下凸，所以大概最后的最优解序列就长这个样子：</p>\n<figure>\n<img src=\"2.png\" alt=\"下凸包\" /><figcaption>下凸包</figcaption>\n</figure>\n<p><del>下 秃 包</del></p>\n<p><del>反过来看就是 lifan 的脑袋了</del></p>\n<p>观察发现，斜率是从左往右递增的。</p>\n<p>所以，我们考虑用单调队列来当这个「最优解序列」。</p>\n<h5 id=\"维护队头\">维护队头</h5>\n<p>即保证队头元素为最优解。</p>\n<p>设队头为 <span class=\"math inline\">\\(q_l\\)</span>。</p>\n<p>如果 <span class=\"math inline\">\\(q_{l+1}\\)</span> 与 <span class=\"math inline\">\\(q_l\\)</span> 形成的斜率 <span class=\"math inline\">\\(\\leqslant s_i\\)</span>，根据上面推出来的玩意儿，得到 <span class=\"math inline\">\\(q_{l+1}\\)</span> 优于 <span class=\"math inline\">\\(q_l\\)</span>。</p>\n<p>那还要 <span class=\"math inline\">\\(q_l\\)</span> 干啥，直接 <code>l++</code>。</p>\n<h5 id=\"更新-dp-值\">更新 DP 值</h5>\n<p><span class=\"math inline\">\\(f_i=f_{q_l}-2\\times s_i\\times s_{q_l}+{s_{q_l}}^2+{s_i}^2+M\\)</span></p>\n<h5 id=\"维护队尾\">维护队尾</h5>\n<p>即保证里面塞的点相邻两个的斜率递增。</p>\n<p>设队尾为 <span class=\"math inline\">\\(q_r\\)</span>，我们要往最优解队列里 <code>push</code> 一个 <span class=\"math inline\">\\(i\\)</span> 。</p>\n<p>若队尾两个点 <span class=\"math inline\">\\(q_r,q_{r-1}\\)</span> 形成的斜率比 <span class=\"math inline\">\\(i,q_r\\)</span> 形成的斜率大，那么<code>push(i)</code>后，整个队列的斜率就不再单调递增，所以此时要将<code>r--</code>。（因为 <a href=\"https://www.cnblogs.com/XSC062/p/14383610.html\">上一篇关于单调队列的博客</a> 中讲到的 <span class=\"math inline\">\\(i\\)</span> 必须入队，只能委屈一下 <span class=\"math inline\">\\(q_r\\)</span> 了）</p>\n<p><strong>注意事项</strong></p>\n<p>众所周知，斜率是个浮点数。为了避免损失精度造成的一些惨案，我们交叉相乘，将分子、分母分开处理。</p>\n<p>以及时刻都要保证队列中至少有两个点，因为要访问 <span class=\"math inline\">\\(q_l,q_{l+1}\\)</span> 和 <span class=\"math inline\">\\(q_r,q_{r-1}\\)</span>。</p>\n<h4 id=\"code\">Code</h4>\n<pre class=\"cpp\"><code>#include &lt;cstdio&gt;\nconst int maxn = 5e5 + 5;\nint n, m, l, r;\nint f[maxn], c[maxn], q[maxn];\ninline int getDP(int i, int j) &#123;\n    return f[j] + m + (c[i] - c[j]) * (c[i] - c[j]);\n&#125;\ninline int getup(int j, int k)&#123;\n    return f[j] + c[j] * c[j] - f[k] - c[k] * c[k]; // 计算分子的值\n&#125;\ninline int getdown(int j, int k) &#123;\n    return (c[j] - c[k]) * 2; // 计算分母的值\n&#125;\nint main()&#123;\n    while (~scanf(&quot;%d %d&quot;, &amp;n, &amp;m)) &#123;\n        l = r = 1; // 凡是涉及到前缀和的单调队列，队列中必须存在初始 0\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            scanf(&quot;%d&quot;, &amp;c[i]); // c 自给自足\n            c[i] += c[i - 1];\n            // # 维护队头\n            // 注意此处的条件为 l &lt; r，因为队列中至少需要存在两个点\n            while (l &lt; r &amp;&amp; getup(q[l+1], q[l]) &lt;= c[i] * getdown(q[l + 1],q[l]))\n                l++;\n            // # 转移状态\n            f[i] = getDP(i, q[l]);\n            // # 维护队尾\n            while(l &lt; r&amp;&amp; getup(i, q[r]) * getdown(q[r], q[r-1]) &lt;= getup(q[r] ,q[r - 1]) * getdown(i, q[r]))\n                r--;\n            q[++r] = i;\n        &#125;\n        printf(&quot;%d\\n&quot;,f[n]);\n    &#125;\n    return 0;\n&#125;</code></pre>\n<p>在对 DP 式变形时，我们最好将其化为 <span class=\"math inline\">\\(\\dfrac{(j)-(k)}{(j)-(k)}&lt;x\\)</span> 或 <span class=\"math inline\">\\(\\dfrac{(j)-(k)}{(j)-(k)}&gt;x\\)</span> 的形式。</p>\n<p>这个板子只适用于维护下凸包的情况。当中间的符号为 <span class=\"math inline\">\\(&gt;\\)</span> 时，我们会在这份代码上稍作改动，维护一个上凸包，后文会提到有关内容。</p>\n<hr />\n<h3 id=\"玩具装箱\"><a href=\"https://www.luogu.com.cn/problem/P3195\">玩具装箱</a></h3>\n<p><a href=\"https://loj.ac/p/10188\">双倍经验</a> | <a href=\"https://www.acwing.com/problem/content/1094/\">三倍经验</a></p>\n<p>从今往后我们就只讲怎么推式子，不再证明下凸等性质了。</p>\n<p>设 <span class=\"math inline\">\\(f_i\\)</span> 表示第 <span class=\"math inline\">\\(i\\)</span> 个玩具放完后的最小费用。 <span class=\"math display\">\\[\nf_i=\\min\\{f_j+(i-j-1+\\sum\\limits_{k=i}^jC_k-L)^2\\}\n\\]</span> 为了让这个式子好拆，我们在一开始让 <code>l++</code>，并且 <span class=\"math inline\">\\(C\\)</span> 再次自给自足，为输入的 <span class=\"math inline\">\\(C\\)</span> 的前缀和数组。</p>\n<p>于是式子就变成： <span class=\"math display\">\\[\nf_i=\\min\\{f_j+(i-j-L+C_i-C_j)^2\\}\n\\]</span> 明显硬拆会死人。（反正我试过，比较适合用来发泄</p>\n<p>所以我们把式子变成这样： <span class=\"math display\">\\[\nf_i=\\min\\{f_j+((C_i+i)-(C_j+j)-L)^2\\}\n\\]</span> 既然 <span class=\"math inline\">\\(C_i\\)</span> 与 <span class=\"math inline\">\\(i\\)</span>，<span class=\"math inline\">\\(C_j\\)</span> 与 <span class=\"math inline\">\\(j\\)</span> 是对应的，那么直接预处理，给 <span class=\"math inline\">\\(C_i\\)</span> 加上 <span class=\"math inline\">\\(i\\)</span> 不就行了？</p>\n<p>现在这个 <span class=\"math inline\">\\(C_i\\)</span> 的含义和实现就变得有点曲折难懂了。</p>\n<p>具体实现如下：</p>\n<pre class=\"cpp\"><code>for (int i = 1; i &lt;= n; ++i) &#123;\n    scanf(&quot;%lld&quot;, &amp;c[i]);\n    c[i] += c[i - 1];\n&#125;\nfor (int i = 1; i &lt;= n; ++i)\n    c[i] += i;</code></pre>\n<p>也就是说，<span class=\"math inline\">\\(C_i\\)</span> 是在前缀和的基础上加了一个 <span class=\"math inline\">\\(i\\)</span>，注意不能把 <span class=\"math inline\">\\(i\\)</span> 也一起前缀和了。</p>\n<p>然后式子就变成了这样： <span class=\"math display\">\\[\n\\begin{aligned}\nf_i&amp;=\\min\\{f_j+(C_i-C_j-L)^2\\}\n\\\\\n&amp;=\\min\\{f_j+{C_i}^2+{C_j}^2+L^2-2\\times C_i\\times C_j-2\\times C_i\\times L+2\\times C_j\\times L\\}\n\\\\\n&amp;=\\min\\{f_j+{C_j}^2-2\\times C_i\\times C_j+2\\times C_j\\times L\\}+{C_i}^2+L^2-2\\times C_i\\times L\n\\end{aligned}\n\\]</span></p>\n<p>令 <span class=\"math inline\">\\(j\\)</span> 优于 <span class=\"math inline\">\\(k\\)</span> 且 <span class=\"math inline\">\\(j&lt;k\\)</span>。</p>\n<p>得： <span class=\"math display\">\\[\nf_j+{C_j}^2-2\\times C_i\\times C_j+2\\times C_j\\times L&lt;f_k+{C_k}^2-2\\times C_i\\times C_k+2\\times C_k\\times L\n\\\\\nf_j-f_k+{C_j}^2-{C_k}^2+2\\times C_j\\times L-2\\times C_k\\times L&lt;2\\times C_i\\times C_j-2\\times C_i\\times C_k\n\\\\\nf_j-f_k+{C_j}^2-{C_k}^2+2\\times C_j\\times L-2\\times C_k\\times L&lt;2\\times(C_j-C_k)\\times C_i\n\\\\\n\\dfrac{f_j-f_k+{C_j}^2-{C_k}^2}{2\\times(C_j-C_k)}&lt;C_i\n\\\\\n\\dfrac{(f_j+{C_j}^2)-(f_k+{C_k}^2)}{(2\\times C_j)-(2\\times C_k)}&lt;C_i\n\\]</span></p>\n<pre class=\"cpp\"><code>#include &lt;cstdio&gt;\n#define int long long\nconst int maxn = 5e5 + 5;\nconst int LEN = (1 &lt;&lt; 20);\nint n, m, h, t;\nint c[maxn], q[maxn], f[maxn];\n#define nec getchar\ninline bool read(int &amp;x) &#123;\n    char ch = nec();\n    bool f = 0; x = 0;\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1; ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\ninline int getup(int j, int k) &#123;\n    return (f[j] + c[j] * c[j] + 2 * c[j] * m)\n           - (f[k] + c[k] * c[k] + 2 * c[k] * m);\n&#125;\ninline int getdown(int j, int k) &#123;\n    return (2 * c[j]) - (2 * c[k]);\n&#125;\ninline int getDP(int i, int j) &#123;\n    return f[j] + (c[i] - c[j] - m) * (c[i] - c[j] - m);\n&#125;\nsigned main() &#123;\n    read(n); read(m); h = t = 1; ++m;\n    for (int i = 1; i &lt;= n; ++i)\n        read(c[i]), c[i] += c[i - 1];\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        c[i] += i;\n        while (h &lt; t &amp;&amp; getup(q[h + 1], q[h]) &lt;\n               c[i] * getdown(q[h + 1], q[h])) ++h;\n        f[i] = getDP(i, q[h]);\n        while (h &lt; t\n               &amp;&amp; getup(i, q[t]) * getdown(q[t], q[t - 1]) &lt;=\n               getdown(i, q[t]) * getup(q[t], q[t - 1])) --t;\n        q[++t] = i;\n    &#125;\n    printf(&quot;%lld&quot;, f[n]);\n    return 0;\n&#125;</code></pre>\n<hr />\n<h3 id=\"任务安排-1\"><a href=\"https://loj.ac/p/10184\">任务安排 1</a></h3>\n<p><a href=\"https://www.acwing.com/problem/content/302/\">双倍经验</a> | <a href=\"https://www.luogu.com.cn/problem/P2365\">三倍经验</a></p>\n<p>感谢蓝书。这里按着蓝书上的思维走。</p>\n<h4 id=\"解法一\">解法一</h4>\n<p>暴力。</p>\n<p>此处的 <span class=\"math inline\">\\(t,c\\)</span> 为输入的 <span class=\"math inline\">\\(t,c\\)</span> 的前缀和数组。</p>\n<p>设 <span class=\"math inline\">\\(f_{i,j}\\)</span> 为前 <span class=\"math inline\">\\(i\\)</span> 个任务分成 <span class=\"math inline\">\\(j\\)</span> 批的最小费用。</p>\n<p>故 <span class=\"math inline\">\\(S\\times j+t_i\\)</span> 为第 <span class=\"math inline\">\\(i\\)</span> 个任务的完成时间。</p>\n<p>得出状态转移方程（<span class=\"math inline\">\\(k\\)</span> 枚举上一批任务结束位置）： <span class=\"math display\">\\[\nf_{i,j}=\\min\\limits_{0\\leqslant k&lt;i}\\{f_{k,j-1}+(S\\times j+t_i)\\times(c_i-c_k)\\}\n\\]</span> 时间复杂度 <span class=\"math inline\">\\(\\mathcal O(n^3)\\)</span>。</p>\n<pre class=\"cpp\"><code>#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#define int long long\nconst int inf = 1e18;\nconst int maxn = 5005;\nconst int LEN = (1 &lt;&lt; 20);\nint f[maxn][maxn];\nint n, s, ans = inf;\nint t[maxn], c[maxn];\ninline int min(int x, int y) &#123; return x &lt; y ? x : y; &#125;\n#ifdef ONLINE_JUDGE\ninline int nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF; p = buf;\n    &#125;\n    return *p++;\n&#125;\n#else\n#define nec getchar\n#endif\ninline bool read(int &amp;x) &#123;\n    char ch = nec();\n    bool f = 0; x = 0;\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nsigned main() &#123;\n    read(n); read(s);\n    memset(f, 0x3f, sizeof (f));\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        read(t[i]); read(c[i]);\n        t[i] += t[i - 1];\n        c[i] += c[i - 1];\n        f[i][1] = (s + t[i]) * c[i]; // 初始化\n    &#125;\n    for (int i = 2; i &lt;= n; ++i) &#123;\n        for (int j = 2; j &lt;= i; ++j) &#123;\n            for (int k = 1; k &lt; i; ++k)\n                f[i][j] = min(f[i][j], f[k][j - 1] + (t[i] + s * j) * (c[i] - c[k]));\n        &#125;\n    &#125;\n    for (int i = 1; i &lt;= n; ++i)\n        ans = min(ans, f[n][i]);\n    printf(&quot;%lld&quot;, ans);\n    return 0;\n&#125;</code></pre>\n<p><del>亲测 TLE 70</del></p>\n<h4 id=\"解法二\">解法二</h4>\n<p>脑子炸了，想了好久才想明白这个优化的正确性。</p>\n<p>思考，以上代码需要 <span class=\"math inline\">\\(j\\)</span> 这一维的根本原因是什么？</p>\n<p>因为我们无法确定之前已经划分了多少批，也就是无法确定 <span class=\"math inline\">\\(S\\)</span> 的个数。</p>\n<p>换个角度思考，我们无法确定之前，却可以确定之后。</p>\n<p>什么意思呢？如果我们在任务 <span class=\"math inline\">\\(i\\)</span> 处划分，那么任务 <span class=\"math inline\">\\(i\\)</span> 以及任务 <span class=\"math inline\">\\(i\\)</span> 以后的所有任务的执行时间都会延后 <span class=\"math inline\">\\(S\\)</span>。</p>\n<p>因为 <span class=\"math inline\">\\(i\\)</span> 以后的状态也会使用 <span class=\"math inline\">\\(f_i\\)</span> 的值，我们在计算 <span class=\"math inline\">\\(f_i\\)</span> 时就将 <span class=\"math inline\">\\(S\\)</span> 提出来，提前把后面的 <span class=\"math inline\">\\(c\\)</span> 乘上不就行了？</p>\n<p>中间的结果不对劲也无所谓，只要最后的答案是对的就行了。</p>\n<blockquote>\n<p>也就是说，我们没有直接求出每批任务的完成时刻，而是在一批任务<strong>「开始」</strong>对后续任务产生影响时，就先把费用累加到答案中。这是一种名为<strong>「费用提前计算」</strong>的经典思想。</p>\n<p align=\"right\">\n——李煜东《算法竞赛进阶指南》\n</p>\n</blockquote>\n<p>状态转移方程： <span class=\"math display\">\\[\nf_i=\\min\\limits_{0\\leqslant j&lt;i}\\{f_j+(c_i-c_j)\\times t_i+s\\times(c_n-c_j)\\}\n\\]</span> 此处，<span class=\"math inline\">\\(f_i\\)</span> 没有具体含义。</p>\n<pre class=\"cpp\"><code>#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#define int long long\nconst int maxn = 1e4 + 5;\nconst int LEN = (1 &lt;&lt; 20);\nint n, s;\nint f[maxn], t[maxn], c[maxn];\ninline int min(int x, int y) &#123; return x &lt; y ? x : y; &#125;\n#ifdef ONLINE_JUDGE\ninline int nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF; p = buf;\n    &#125;\n    return *p++;\n&#125;\n#else\n#define nec getchar\n#endif\ninline bool read(int &amp;x) &#123;\n    char ch = nec();\n    bool f = 0; x = 0;\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nsigned main() &#123;\n    read(n); read(s);\n    memset(f, 0x3f, sizeof (f));\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        read(t[i]); read(c[i]);\n        t[i] += t[i - 1];\n        c[i] += c[i - 1];\n    &#125;\n    f[0] = 0;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = 0; j &lt; i; ++j)\n            f[i] = min(f[i], f[j] + t[i]* (c[i] - c[j]) + s * (c[n] - c[j]));\n    &#125;\n    printf(&quot;%lld&quot;, f[n]);\n    return 0;\n&#125;</code></pre>\n<hr />\n<h3 id=\"任务安排-2\"><a href=\"https://loj.ac/p/10185\">任务安排 2</a></h3>\n<p><a href=\"https://www.acwing.com/problem/content/303/\">双倍经验</a></p>\n<p><span class=\"math inline\">\\(n\\)</span> 的范围变大了，<span class=\"math inline\">\\(n^2\\)</span> 过不了。</p>\n<p>这不随手加个斜率优化的事儿吗。</p>\n<p>我们继续瞎搞这个式子。 <span class=\"math display\">\\[\n\\begin{aligned}\nf_i&amp;=\\min\\{f_j+(c_i-c_j)\\times t_i+s\\times(c_n-c_j)\\}\n\\\\\n&amp;=\\min\\{f_j+c_i\\times t_i-c_j\\times t_i+s\\times c_n-s\\times c_j\\}\n\\\\\n&amp;=\\min\\{f_j-c_j\\times t_i-s\\times c_j\\}+c_i\\times t_i+s\\times c_n\n\\end{aligned}\n\\]</span> 令 <span class=\"math inline\">\\(j\\)</span> 优于 <span class=\"math inline\">\\(k\\)</span> 且 <span class=\"math inline\">\\(j&lt;k\\)</span> 。</p>\n<p>则有： <span class=\"math display\">\\[\nf_j-c_j\\times t_i-s\\times c_j&lt;f_k-c_k\\times t_i-s\\times c_k\n\\\\\nf_j-f_k-s\\times c_j+s\\times c_k&lt;c_j\\times t_i-c_k\\times t_i\n\\\\\nf_j-f_k-s\\times c_j+s\\times c_k&lt;t_i\\times(c_j-c_k)\n\\\\\n\\dfrac{(f_j-s\\times c_j)-(f_k-s\\times c_k)}{(c_j)-(c_k)}&lt;t_i\n\\]</span> 然后就是老套路。</p>\n<p>时间复杂度 <span class=\"math inline\">\\(\\mathcal O(n)\\)</span>。</p>\n<pre class=\"cpp\"><code>#include &lt;cstdio&gt;\n#define int long long\nconst int maxn = 5e5 + 5;\nconst int LEN = (1 &lt;&lt; 20);\nint n, s, L, R;\nint f[maxn], t[maxn], c[maxn], q[maxn];\n#define nec getchar\ninline bool read(int &amp;x) &#123;\n    char ch = nec();\n    bool f = 0; x = 0;\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1; ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\ninline int getup(int j, int k) &#123; return (f[j] - s * c[j]) - (f[k] - s * c[k]); &#125;\ninline int getdown(int j, int k) &#123; return (c[j]) - (c[k]); &#125;\ninline int getDP(int i, int j) &#123; return f[j] + (c[i] - c[j]) * t[i] + s * (c[n] - c[j]); &#125;\nsigned main() &#123;\n    read(n); read(s);\n    L = R = 1;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        read(t[i]); read(c[i]);\n        t[i] += t[i - 1];\n        c[i] += c[i - 1];\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        while (L &lt; R &amp;&amp; getup(q[L + 1], q[L]) &lt;= t[i] * getdown(q[L + 1], q[L]))\n            ++L;\n        f[i] = getDP(i, q[L]);\n        while (L &lt; R &amp;&amp; getup(i, q[R]) * getdown(q[R], q[R - 1]) &lt;= getdown(i, q[R]) * getup(q[R], q[R - 1]))\n            --R;\n        q[++R] = i;\n    &#125;\n    printf(&quot;%lld&quot;, f[n]);\n    return 0;\n&#125;</code></pre>\n<hr />\n<h3 id=\"任务安排-3\"><a href=\"https://www.luogu.com.cn/problem/P5785\">任务安排 3</a></h3>\n<p><a href=\"https://loj.ac/p/10186\">双倍经验</a> | <a href=\"https://www.acwing.com/problem/content/304/\">三倍经验</a></p>\n<p>注意 <span class=\"math inline\">\\(t\\)</span> 有可能是负数。</p>\n<p><span class=\"math inline\">\\(t\\)</span> （输入）有可能为负，代表着 <span class=\"math inline\">\\(t\\)</span>（前缀和）不再单调递增，用不单调的对象作为单调队列的条件一看就十分不讲武德，这样维护出来的队头显然不是正确答案。</p>\n<p>后面的 <span class=\"math inline\">\\(t,c\\)</span> 默认为前缀和。</p>\n<p>我们感性证明一下。</p>\n<p>一个最普通的例子，假设输入了一个负数，导致 <span class=\"math inline\">\\(t_i&lt;t_{i-1}\\)</span>，且有一斜率 <span class=\"math inline\">\\(&gt;t_i\\)</span> 且 <span class=\"math inline\">\\(&lt;t_{i-1}\\)</span>。</p>\n<p>那么在 <span class=\"math inline\">\\(i-1\\)</span> 时，它就被维护队头的操作剔掉了，但也许它凑巧就是 <span class=\"math inline\">\\(i\\)</span> 的最优解，呜呼哀哉。</p>\n<p>于是我们不能删队头元素了。那怎么查询最优解呢？</p>\n<p>单调队列里装的始终还是个具有单调性的下凸包，于是我们可以在队列中二分一个 <span class=\"math inline\">\\(pos\\)</span>，<span class=\"math inline\">\\(pos\\)</span> 与 <span class=\"math inline\">\\(pos-1\\)</span> 形成的斜率比 <span class=\"math inline\">\\(t_i\\)</span> 小，<span class=\"math inline\">\\(pos+1\\)</span> 与 <span class=\"math inline\">\\(pos\\)</span> 形成的斜率比 <span class=\"math inline\">\\(t_i\\)</span> 大。</p>\n<p>然后把 <span class=\"math inline\">\\(pos\\)</span> 当成 <span class=\"math inline\">\\(q_l\\)</span> 来处理就好了。</p>\n<p>队尾还是维护一个下凸。</p>\n<p>时间复杂度 <span class=\"math inline\">\\(\\mathcal O(n\\log_2n)\\)</span>。</p>\n<p><em>强烈建议不要去动 AcWing 版本的那道。</em></p>\n<p><em>最后两组数据堪称毒瘤。</em></p>\n<p><em>卡 <code>long long</code> 乘法，卡 <code>__int128</code> 时限，卡 <code>double</code>精度，非 T 即 WA。</em></p>\n<p><em>反正我搞了半个小时硬是没有搞出来。</em></p>\n<pre class=\"cpp\"><code>#include &lt;cstdio&gt;\n#define int long long\nconst int maxn = 3e5 + 5;\nconst int LEN = (1 &lt;&lt; 20);\nint n, s, L, R;\nint f[maxn], t[maxn], c[maxn], q[maxn];\n#define nec getchar\ninline bool read(int &amp;x) &#123;\n    char ch = nec();\n    bool f = 0; x = 0;\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1; ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\ninline int getup(int j, int k) &#123; return (f[j] - s * c[j]) - (f[k] - s * c[k]); &#125;\ninline int getdown(int j, int k) &#123; return (c[j]) - (c[k]); &#125;\ninline int getDP(int i, int j) &#123; return f[j] + t[i] * (c[i] - c[j]) + s * (c[n] - c[j]); &#125;\ninline int Func(int u) &#123;\n    if (L == R) return q[L];\n    int l = L, r = R;\n    while (l &lt; r) &#123;\n        int mid = l + r &gt;&gt; 1;\n        if (getup(q[mid + 1], q[mid]) &lt;= u * getdown(q[mid + 1], q[mid]))\n            l = mid + 1;\n        else r = mid;\n    &#125;\n    return l;\n&#125;\nsigned main() &#123;\n    read(n); read(s);\n    L = R = 1;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        read(t[i]); read(c[i]);\n        t[i] += t[i - 1];\n        c[i] += c[i - 1];\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        int Best = Func(t[i]);\n        f[i] = getDP(i, q[Best]);\n        while (L &lt; R &amp;&amp; getup(i, q[R]) * getdown(q[R], q[R - 1]) &lt;= getdown(i, q[R]) * getup(q[R], q[R - 1]))\n            --R;\n        q[++R] = i;\n    &#125;\n    printf(&quot;%lld&quot;, f[n]);\n    return 0;\n&#125;</code></pre>\n<hr />\n<h3 id=\"土地购买\"><a href=\"https://www.luogu.com.cn/problem/P2900\">土地购买</a></h3>\n<p>首先我们想明白一件事情：如果一块土地，有另一块土地的长和宽都比它大，那就不用再理它了，直接从总序列里剔除。</p>\n<pre class=\"cpp\"><code>struct _ &#123;\n    int w, l;\n    bool operator&lt; (const _ q) const &#123;\n        return w == q.w ? l &gt; q.l : w &gt; q.w;\n    &#125;\n&#125; a[maxn];\n...\n\nstd::sort(a + 1, a + n + 1);\nfor (int i = 1; i &lt;= n; ++i) &#123;\n    if (a[i].l &gt; a[cnt].l)\n        a[++cnt] = a[i];\n&#125;</code></pre>\n<p>然后就推式子。</p>\n<p>贪心地想，在前面的操作后，<span class=\"math inline\">\\(a\\)</span> 是一个 <span class=\"math inline\">\\(w\\)</span> 递减，<span class=\"math inline\">\\(l\\)</span> 递增的土地序列。</p>\n<p>所以我们选择将连续的一段区间分为一组，这样的话，一个组里的一段连续的土地 <span class=\"math inline\">\\([x,y]\\)</span> 就只有 <span class=\"math inline\">\\(w_x\\)</span> 和 <span class=\"math inline\">\\(l_y\\)</span> 起了作用，又没有中间那一段的事了。</p>\n<p>设 <span class=\"math inline\">\\(f_i\\)</span> 表示分配完第 <span class=\"math inline\">\\(i\\)</span> 块土地后的最小花费。</p>\n<p>则有： <span class=\"math display\">\\[\nf_i=\\min\\{f_j+w_{j+1}\\times l_i\\}\n\\]</span> 令 <span class=\"math inline\">\\(j\\)</span> 优于 <span class=\"math inline\">\\(k\\)</span>。</p>\n<p>则有： <span class=\"math display\">\\[\nf_j+w_{j+1}\\times l_i&lt;f_k+w_{k+1}\\times l_i\n\\\\\nf_j-f_k&lt;(-w_{j+1}+w_{k+1})\\times l_i\n\\\\\n\\dfrac{(f_j)-(f_k)}{(-w_{j+1})+(w_{k+1})}&lt;l_i\n\\]</span></p>\n<pre class=\"cpp\"><code>#include &lt;cstdio&gt;\n#include &lt;algorithm&gt;\n#define int long long\nconst int maxn = 5e4 + 5;\nstruct _ &#123;\n    int w, l;\n    bool operator&lt; (const _ q) const&#123;\n        return w == q.w ? l &gt; q.l : w &gt; q.w;\n    &#125;\n&#125;;\n_ a[maxn];\nint n, cnt, l, r;\nint q[maxn], f[maxn];\nint getup(int j, int k) &#123; return f[j] - f[k]; &#125;\nint getdown(int j,int k) &#123; return a[k + 1].w - a[j + 1].w; &#125;\nint getDP(int i,int j) &#123; return f[j] + a[j + 1].w * a[i].l; &#125;\nsigned main() &#123;\n    scanf(&quot;%lld&quot;, &amp;n);\n    for(int i = 1; i &lt;= n; ++i)\n        scanf(&quot;%lld %lld&quot;, &amp;a[i].w, &amp;a[i].l);\n    std::sort(a + 1, a + n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        if (a[i].l &gt; a[cnt].l)\n            a[++cnt] = a[i];\n    &#125;\n    n = cnt; l = r = 1;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        while (l &lt; r &amp;&amp; getup(q[l + 1], q[l]) &lt;= a[i].l * getdown(q[l + 1], q[l]))\n            l++;\n        f[i] = getDP(i, q[l]);\n        while (l &lt; r &amp;&amp; getup(i, q[r]) * getdown(q[r], q[r - 1]) &lt;= getup(q[r],q[r - 1]) * getdown(i, q[r]))\n            r--;\n        q[++r] = i;\n    &#125;\n    printf(&quot;%lld&quot;, f[n]);\n    return 0;\n&#125;</code></pre>\n<hr />\n<h3 id=\"仓库建设\"><a href=\"https://www.luogu.com.cn/problem/P2120\">仓库建设</a></h3>\n<p><a href=\"https://loj.ac/p/10189\">双倍经验</a> | <a href=\"https://www.acwing.com/problem/content/description/1095/\">三倍经验</a></p>\n<p>设 <span class=\"math inline\">\\(f_i\\)</span> 表示在 <span class=\"math inline\">\\(i\\)</span> 工厂建立仓库的最小花费。</p>\n<p>则有： <span class=\"math display\">\\[\n\\begin{aligned}\nf_i&amp;=\\min\\{f_j+\\sum\\limits_{k=j+1}^{i-1}[(x_i-x_k)\\times p_k]+c_i\\}\n\\\\\n&amp;=\\min\\{f_j+\\sum\\limits_{k=j+1}^{i-1}(x_i\\times p_k)-\\sum\\limits_{k=j+1}^{i-1}(x_k\\times p_k)\\}+c_i\n\\\\\n&amp;=\\min\\{f_j+x_i\\times\\sum\\limits_{k=j+1}^{i-1}p_k-\\sum\\limits_{k=j+1}^{i-1}(x_k\\times p_k)\\}+c_i\n\\end{aligned}\n\\]</span> 利用前缀和优化：设 <span class=\"math inline\">\\(a\\)</span> 为 <span class=\"math inline\">\\(p\\)</span> 的前缀和数组，<span class=\"math inline\">\\(b\\)</span> 为 <span class=\"math inline\">\\(x_i\\times p_i\\)</span> 的前缀和数组。</p>\n<p>则原式可化为： <span class=\"math display\">\\[\n\\begin{aligned}\nf_i&amp;=\\min\\{f_j+x_i\\times(a_{i-1}-a_j)-(b_{i-1}-b_j)\\}+c_i\n\\\\\n&amp;=\\min\\{f_j+x_i\\times a_{i-1}-x_i\\times a_j-b_{i-1}+b_j\\}+c_i\n\\\\\n&amp;=\\min\\{f_j-x_i\\times a_j+b_j\\}+x_i\\times a_{i-1}-b_{i-1}+c_i\n\\end{aligned}\n\\]</span> 令 <span class=\"math inline\">\\(j\\)</span> 优于 <span class=\"math inline\">\\(k\\)</span> 。</p>\n<p>则有： <span class=\"math display\">\\[\nf_j-x_i\\times a_j+b_j&lt;f_k-x_i\\times a_k+b_k\n\\\\\nf_j-f_k+b_j-b_k&lt;x_i\\times a_j-x_i\\times a_k\n\\\\\n\\dfrac{(f_j+b_j)-(f_k+b_k)}{a_j-a_k}&lt;x_i\n\\]</span></p>\n<p><em>想感受人生的同学们可以尝试做一下 AcWing 那个版本，非 MLE 即 WA，爽到炸。</em></p>\n<pre class=\"cpp\"><code>#include &lt;cstdio&gt;\n#define int long long\nconst int maxn = 1e6 + 5;\nconst int LEN = (1 &lt;&lt; 20);\nint n, L, R;\nint f[maxn], x[maxn], p[maxn];\nint a[maxn], b[maxn], c[maxn], q[maxn];\n#ifdef ONLINE_JUDGE\ninline int nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF; p = buf;\n    &#125;\n    return *p++;\n&#125;\n#else\n#define nec getchar\n#endif\ninline bool read(int &amp;x) &#123;\n    char ch = nec();\n    bool f = 0; x = 0;\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\ninline int getup(int j, int k) &#123; return (f[j] + b[j]) - (f[k] + b[k]); &#125;\ninline int getdown(int j, int k) &#123; return (a[j]) - (a[k]); &#125;\ninline int getDP(int i, int j) &#123; return f[j] - x[i] * a[j] + b[j] + x[i] * a[i - 1] - b[i - 1] + c[i]; &#125;\nsigned main() &#123;\n    read(n); L = R = 1;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        read(x[i]); read(p[i]); read(c[i]);\n        a[i] = a[i - 1] + p[i];\n        b[i] = b[i - 1] + x[i] * p[i];\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        while (L &lt; R &amp;&amp; getup(q[L + 1], q[L]) &lt;= x[i] * getdown(q[L + 1], q[L]))\n            ++L;\n        f[i] = getDP(i, q[L]);\n        while (L &lt; R &amp;&amp; getup(i, q[R]) * getdown(q[R], q[R - 1]) &lt;= getdown(i, q[R]) * getup(q[R], q[R - 1]))\n            --R;\n        q[++R] = i;\n    &#125;\n    printf(&quot;%lld&quot;, f[n]);\n    return 0;\n&#125;</code></pre>\n<hr />\n<h3 id=\"锯木厂选址\"><a href=\"https://www.luogu.com.cn/problem/P4360\">锯木厂选址</a></h3>\n<p><a href=\"https://loj.ac/p/10192\">双倍经验</a> | <a href=\"https://www.acwing.com/problem/content/1097/\">三倍经验</a></p>\n<p>和仓库建设很像。</p>\n<p>设 <span class=\"math inline\">\\(A_i=\\sum\\limits_{j=i}^nd_j\\)</span>，表示第 <span class=\"math inline\">\\(i\\)</span> 棵树与山脚的距离；<span class=\"math inline\">\\(B_i=\\sum\\limits_{j=1}^iw_j\\)</span>，表示 <span class=\"math inline\">\\(w\\)</span> 的前缀和；<span class=\"math inline\">\\(S=\\sum\\limits_{i=1}^nA_i\\times w_i\\)</span>，表示将所有树全部运到山脚的花费总和。</p>\n<p>假设在 <span class=\"math inline\">\\(j\\)</span> 处建立第 <span class=\"math inline\">\\(1\\)</span> 座锯木厂，在 <span class=\"math inline\">\\(i\\)</span> 处建立第 <span class=\"math inline\">\\(2\\)</span> 座锯木厂，此时：</p>\n<ul>\n<li>对于第 <span class=\"math inline\">\\(1\\sim j\\)</span> 棵树来说，<span class=\"math inline\">\\(S\\)</span> 比实际情况多运了 <span class=\"math inline\">\\(A_j\\)</span> 的路程；</li>\n<li>对于第 <span class=\"math inline\">\\(j+1\\sim i\\)</span> 棵树来说，<span class=\"math inline\">\\(S\\)</span> 比实际情况多运了 <span class=\"math inline\">\\(A_i\\)</span> 的路程。</li>\n</ul>\n<p>将对应的多运的距离与花费相乘的结果，让 <span class=\"math inline\">\\(S\\)</span> 将其减去即可。 <span class=\"math display\">\\[\n\\begin{aligned}\nans&amp;=\\min\\{S-A_j\\times B_j-(B_i-B_j)\\times A_i\\}\\\\\n   &amp;=\\min\\{A_i\\times B_j-A_j\\times B_j\\}+S-A_i\\times B_i\n\\end{aligned}\n\\]</span> 令 <span class=\"math inline\">\\(j&lt;k\\)</span> 且 <span class=\"math inline\">\\(j\\)</span> 优于 <span class=\"math inline\">\\(k\\)</span>，则有： <span class=\"math display\">\\[\n\\begin{aligned}\nA_i\\times B_j-A_j\\times B_j&amp;&lt;A_i\\times B_k-A_k\\times B_k\\\\\n-A_j\\times B_j+A_k\\times B_k&amp;&lt;-A_i\\times B_j+A_i\\times B_k\\\\\n\\dfrac{-A_j\\times B_j+A_k\\times B_k}{-B_j+B_k}&amp;&lt;A_i\\\\\n\\dfrac{A_j\\times B_j-A_k\\times B_k}{B_j-B_k}&amp;&lt;A_i\\\\\n\\end{aligned}\n\\]</span> 其中，<span class=\"math inline\">\\(A_i\\)</span> 具有单调性，可以直接套板子。</p>\n<pre class=\"cpp\"><code>#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\n#define int long long\nconst int inf = 1e18;\nconst int maxn = 1e6 + 5;\nconst int LEN = (1 &lt;&lt; 20);\nint w[maxn], d[maxn];\nint n, L, R, s, ans = inf;\nint q[maxn], a[maxn], b[maxn];\ninline int min(int x, int y) &#123; return x &lt; y ? x : y; &#125;\ninline int getDP(int i, int j) &#123;\n    return s - a[j] * b[j] - (b[i] - b[j]) * a[i];\n&#125;\ninline int getup(int j, int k) &#123;\n    return a[j] * b[j] - a[k] * b[k];\n&#125;\ninline int getdown(int j, int k) &#123;\n    return b[j] - b[k];\n&#125;\n#ifdef ONLINE_JUDGE\ninline int nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF; p = buf;\n    &#125;\n    return *p++;\n&#125;\n#else\n#define nec getchar\n#endif\ninline bool read(int &amp;x) &#123;\n    char ch = nec();\n    bool f = 0; x = 0;\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nsigned main() &#123;\n    read(n);\n    L = R = 1;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        read(w[i]), read(d[i]);\n        b[i] = b[i - 1] + w[i];\n    &#125;\n    for (int i = n; i; --i) &#123;\n        a[i] = a[i + 1] + d[i];\n        s += a[i] * w[i];\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        while (L &lt; R &amp;&amp; getup(q[L + 1], q[L]) &gt;= a[i] * getdown(q[L + 1], q[L]))\n            ++L;\n        ans = min(ans, getDP(i, q[L]));\n        while (L &lt; R &amp;&amp; getup(i, q[R]) * getdown(q[R], q[R - 1]) &gt;= getup(q[R], q[R - 1]) * getdown(i, q[R]))\n            --R;\n        q[++R] = i;\n    &#125;\n    printf(&quot;%lld&quot;, ans);\n    return 0;\n&#125;</code></pre>\n<hr />\n<h3 id=\"cats-transport\"><a href=\"https://www.luogu.com.cn/problem/CF311B\">Cats Transport</a></h3>\n<p><a href=\"https://www.acwing.com/problem/content/305/\">双倍经验</a> | <a href=\"http://codeforces.com/problemset/problem/311/B\">三倍经验</a></p>\n<p>经验：洛谷的题面比蓝书和 AcWing 上的标准多了，蓝书的题意不清。</p>\n<p>研究表明，边猛灌养乐多边看蓝书有助于理解。</p>\n<p>这道题难在推式子。<del>不然还能难在哪里</del></p>\n<p>设 <span class=\"math inline\">\\(A_i\\)</span> 表示要接到第 <span class=\"math inline\">\\(i\\)</span> 只猫的最早出发时间，也就是说，在此时出发，猫 <span class=\"math inline\">\\(i\\)</span> 的等待时间为 <span class=\"math inline\">\\(0\\)</span>。</p>\n<p>即 <span class=\"math inline\">\\(A_i=T_i-\\sum\\limits_{j=1}^{H_i}D_j\\)</span>，也就是出发时间=到达时间-经过时间。</p>\n<p>此时我们可以把其他所有因素去掉，题意转换为：</p>\n<blockquote>\n<p>已知在 <span class=\"math inline\">\\(\\geqslant A_i\\)</span> 的时刻出发可以接到猫 <span class=\"math inline\">\\(i\\)</span> ，在 <span class=\"math inline\">\\(P\\)</span> 次出发次数的限制内接到所有猫，猫的等待时间之和最小是多少？</p>\n</blockquote>\n<p>假设饲养员在 <span class=\"math inline\">\\(t\\)</span> 时刻出发，猫 <span class=\"math inline\">\\(i\\)</span> 的等待时间就是 <span class=\"math inline\">\\(t-A_i\\)</span>。</p>\n<p>对 <span class=\"math inline\">\\(A_i\\)</span> 从小到大排序。</p>\n<p>显然，一次接一段连续的猫，花费自然是最小的。</p>\n<p>若我们要接 <span class=\"math inline\">\\([k+1,j]\\)</span> 范围内的猫，它们的等待时间之和就是： <span class=\"math display\">\\[\n\\begin{aligned}\n\\sum\\limits_{p=k+1}^{j}(A_j-A_p)&amp;=[j-(k+1)+1]A_j-\\sum\\limits_{p=k+1}^{j}A_p\n\\\\\n&amp;=(j-k)\\times A_j-(S_j-S_k)\n\\\\\n&amp;=j\\times A_j-k\\times A_j-S_j+S_k\n\\end{aligned}\n\\]</span> 其中 <span class=\"math inline\">\\(S\\)</span> 为 <span class=\"math inline\">\\(A\\)</span> 的前缀和。</p>\n<p>设 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示前 <span class=\"math inline\">\\(i\\)</span> 个饲养员带走前 <span class=\"math inline\">\\(j\\)</span> 只猫的最小花费。</p>\n<p>则有： <span class=\"math display\">\\[\n\\begin{aligned}\nf_{i,j}&amp;=\\min\\{f_{i-1,k}+j\\times A_j-k\\times A_j-S_j+S_k\\}\n\\\\\n&amp;=\\min\\{f_{i-1,k}-A_j\\times k+S_k\\}+A_j\\times j-S_j\n\\end{aligned}\n\\]</span></p>\n<p>我们将循环地枚举每个饲养员的循环变量 <span class=\"math inline\">\\(i\\)</span> 看做常量。</p>\n<p>令 <span class=\"math inline\">\\(x\\)</span> 优于 <span class=\"math inline\">\\(y\\)</span>，则有： <span class=\"math display\">\\[\nf_{i-1,x}-A_j\\times x+S_x&lt;f_{i-1,y}-A_j\\times y+S_y\n\\\\\n\\dfrac{(f_{i-1,x}+S_x)-(f_{i-1,y+S_y})}{x-y}&lt;A_j\n\\]</span> <strong>注意事项</strong></p>\n<p><span class=\"math inline\">\\(f\\)</span> 初始化为极大值。</p>\n<pre class=\"cpp\"><code>#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\n#define int long long\nconst int maxp = 105;\nconst int maxn = 1e5 + 5;\nconst int LEN = (1 &lt;&lt; 20);\nint f[maxp][maxn];\nint n, m, p, L, R, t, h;\nint q[maxn], a[maxn], d[maxn], s[maxn];\ninline int getDP(int i, int j, int k) &#123;\n    return f[i - 1][k] + (j - k) * a[j] - (s[j] - s[k]);\n&#125;\ninline int getup(int i, int j, int k) &#123;\n    return (f[i - 1][j] + s[j]) - (f[i - 1][k] + s[k]);\n&#125;\ninline int getdown(int j, int k) &#123;\n    return (j) - (k);\n&#125;\n#ifdef ONLINE_JUDGE\ninline int nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF; p = buf;\n    &#125;\n    return *p++;\n&#125;\n#else\n#define nec getchar\n#endif\ninline bool read(int &amp;x) &#123;\n    char ch = nec();\n    bool f = 0; x = 0;\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nsigned main() &#123;\n    read(n); read(m); read(p);\n    memset(f, 0x3f, sizeof (f));\n    for (int i = 2; i &lt;= n; ++i)\n        read(d[i]), d[i] += d[i - 1];\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        read(h); read(t);\n        a[i] = t - d[h];\n    &#125;\n    std::sort(a + 1, a + m + 1);\n    for (int i = 1; i &lt;= m; ++i)\n        s[i] = s[i - 1] + a[i];\n    f[0][0] = 0;\n    for (int i = 1; i &lt;= p; ++i) &#123;\n        L = R = 1;\n        for (int j = 1; j &lt;= m; ++j) &#123;\n            while (L &lt; R &amp;&amp; getup(i, q[L + 1], q[L]) &lt;= a[j] * getdown(q[L + 1], q[L]))\n                ++L;\n            f[i][j] = getDP(i, j, q[L]);\n            while (L &lt; R &amp;&amp; getup(i, j, q[R]) * getdown(q[R], q[R - 1]) &lt;= getup(i, q[R], q[R - 1]) * getdown(j, q[R]))\n                --R;\n            q[++R] = j;\n        &#125;\n    &#125;\n    printf(&quot;%lld&quot;, f[p][m]);\n    return 0;\n&#125;</code></pre>\n<hr />\n<h3 id=\"特别行动队\"><a href=\"https://www.luogu.com.cn/problem/P3628\">特别行动队</a></h3>\n<p><a href=\"https://www.acwing.com/problem/content/337/\">双倍经验</a> | <a href=\"https://loj.ac/p/10190\">三倍经验</a></p>\n<p>直接推式子。 <span class=\"math display\">\\[\n\\begin{aligned}\nf_i&amp;=\\max\\{f_j+a\\times(s_i-s_j)^2+b\\times(s_i-s_j)+c\\ \\}\\\\\n&amp;=\\max\\{f_j+a\\times({s_i}^2-2\\times s_i\\times s_j+{s_j}^2)+b\\times s_i-b\\times s_j\\ \\}+c\\\\\n&amp;=\\max\\{f_j+a\\times{s_i}^2-2\\times a\\times s_i\\times s_j+a\\times{s_j}^2-b\\times s_j\\ \\}+b\\times s_i+c\\\\\n&amp;=\\max\\{f_j-2\\times a\\times s_i\\times s_j+a\\times{s_j}^2-b\\times s_j\\ \\}+a\\times{s_i}^2+b\\times s_i+c\\\\\n\\end{aligned}\n\\]</span> 令 <span class=\"math inline\">\\(j\\)</span> 优于 <span class=\"math inline\">\\(k\\)</span>，则有： <span class=\"math display\">\\[\n\\begin{aligned}\nf_j-2\\times a\\times s_i\\times s_j+a\\times{s_j}^2-b\\times s_j&amp;&gt;f_k-2\\times a\\times s_i\\times s_k+a\\times{s_k}^2-b\\times s_k\\\\\n(f_j+a\\times{s_j}^2-b\\times s_j)-(f_k+a\\times{s_k}^2-b\\times s_k)&amp;&gt;(2\\times a\\times s_i\\times s_j)-(2\\times a\\times s_i\\times s_k)\\\\\n\\dfrac{(f_j+a\\times{s_j}^2-b\\times s_j)-(f_k+a\\times{s_k}^2-b\\times s_k)}{(2\\times a\\times s_j) - (2\\times a\\times s_k)}&amp;&gt;s_i\\\\\n\\end{aligned}\n\\]</span> 我们发现中间的符号是 <span class=\"math inline\">\\(&gt;\\)</span>。</p>\n<p>所以我们在弹队头的时候，要把判断条件中的符号反过来。</p>\n<pre class=\"cpp\"><code>#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\n#define int long long\nconst int maxn = 1e6 + 5;\nconst int LEN = (1 &lt;&lt; 20);\nint n, L, R, a, b ,c;\nint q[maxn], s[maxn], f[maxn];\ninline int getDP(int i, int j) &#123;\n    return f[j] + a * (s[i] - s[j]) * (s[i] - s[j]) + b * (s[i] - s[j]) + c;\n&#125;\ninline int getup(int j, int k) &#123;\n    return (f[j] + a * s[j] * s[j] - b * s[j]) - (f[k] + a * s[k] * s[k] - b * s[k]);\n&#125;\ninline int getdown(int j, int k) &#123;\n    return (2 * a * s[j]) - (2 * a * s[k]);\n&#125;\n#ifdef ONLINE_JUDGE\ninline int nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF; p = buf;\n    &#125;\n    return *p++;\n&#125;\n#else\n#define nec getchar\n#endif\ninline bool read(int &amp;x) &#123;\n    char ch = nec();\n    bool f = 0; x = 0;\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nsigned main() &#123;\n    read(n); read(a); read(b); read(c);\n    L = R = 1;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        read(s[i]), s[i] += s[i - 1];\n        while (L &lt; R &amp;&amp; getup(q[L + 1], q[L]) &gt;= s[i] * getdown(q[L + 1], q[L]))\n            ++L;\n        f[i] = getDP(i, q[L]);\n        while (L &lt; R &amp;&amp; getup(i, q[R]) * getdown(q[R], q[R - 1]) &lt;= getup(q[R], q[R - 1]) * getdown(i, q[R]))\n            --R;\n        q[++R] = i;\n    &#125;\n    printf(&quot;%lld&quot;, f[n]);\n    return 0;\n&#125;</code></pre>\n<hr />\n<h3 id=\"征途\"><a href=\"https://www.luogu.com.cn/problem/P4072\">征途</a></h3>\n<p><a href=\"https://loj.ac/p/2035\">双倍经验</a> | <a href=\"https://www.acwing.com/problem/content/2575/\">三倍经验</a></p>\n<p>明显，不化掉 <span class=\"math inline\">\\(v\\times m^2\\)</span> 就无法进行优化。</p>\n<p>设 <span class=\"math inline\">\\(x\\)</span> 为当前休息站点与上一休息站点的距离， <span class=\"math inline\">\\(x_0\\)</span> 为 <span class=\"math inline\">\\(x_1\\sim x_n\\)</span> 的平均数，<span class=\"math inline\">\\(S\\)</span> 为 <span class=\"math inline\">\\(x\\)</span> 的前缀和。 <span class=\"math display\">\\[\n\\begin{aligned}\nV\\times m^2&amp;=[(x_1-x_0)^2+(x_2-x_0)^2+\\cdots+(x_m-x_0)^2]\\times m\n\\\\\n&amp;=m\\times \\sum\\limits_{i=1}^{m}{x_i}^2+(m\\times {x_0})^2-2\\times (x_0\\times m)\\times \\sum\\limits_{i=1}^{m}x_i\n\\\\\n&amp;=m\\times \\sum\\limits_{i=1}^{m}{x_i}^2+{S_m}^2-2\\times{S_m}^2\n\\\\\n&amp;=m\\times \\sum\\limits_{i=1}^{m}{x_i}^2-{S_m}^2\n\\end{aligned}\n\\]</span></p>\n<p>其中 <span class=\"math inline\">\\(S_m\\)</span> 是一个定值（即输入所有路的长度和）。</p>\n<p>唯一需要计算的，就是 <span class=\"math inline\">\\(\\sum\\limits_{i=1}^{m}{x_i}^{2}\\)</span>，所以我们就来 DP 它。</p>\n<p>设 <span class=\"math inline\">\\(a\\)</span> 为输入道路长度的前缀和数组，<span class=\"math inline\">\\(f_{i,j}\\)</span> 表示第 <span class=\"math inline\">\\(i\\)</span> 次休息在 <span class=\"math inline\">\\(j\\)</span> 处时 <span class=\"math inline\">\\(\\min\\{\\sum\\limits_{k=1}^{i}{x_k}^2\\}\\)</span> 的值，则有： <span class=\"math display\">\\[\n\\begin{aligned}\nf_{i,j}&amp;=\\min\\{f_{i-1,j}+(a_i-a_j)^2\\}\n\\\\\n&amp;=\\min\\{f_{i-1,j}+{a_i}^2-2\\times a_i\\times a_j+{a_j}^2\\}\n\\end{aligned}\n\\]</span> 令 <span class=\"math inline\">\\(j\\)</span> 优于 <span class=\"math inline\">\\(k\\)</span>，则有： <span class=\"math display\">\\[\nf_{i-1,j}-2\\times a_i\\times a_j+{a_j}^2&lt;f_{i-1,k}-2\\times a_i\\times a_k+{a_k}^2\n\\\\\nf_{i-1,j}-f_{i-1,k}+{a_j}^2-{a_k}^2&lt;2\\times a_i\\times(a_j-a_k)\n\\\\\n\\dfrac{f_{i-1,j}-f_{i-1,k}+{a_j}^2-{a_k}^2}{2\\times(a_j-a_k)}&lt;a_i\n\\]</span></p>\n<p>初始化。</p>\n<p>将 <span class=\"math inline\">\\(f\\)</span> 初始化为极大值。</p>\n<p>在 AcWing 上将 <code>memset</code> 改为初始化 <code>f[0][i] = a[i] * a[i]</code> 就可以过了，不然会 MLE，也许是因为没开滚动。（本来也用不着滚</p>\n<pre class=\"cpp\"><code>#include &lt;cstdio&gt;\n#define int long long\nconst int inf = 1e18;\nconst int maxn = 3005;\nconst int LEN = (1 &lt;&lt; 20);\nint f[maxn][maxn];\nint a[maxn], q[maxn];\nint n, m, L, R, ans = inf;\n#ifdef ONLINE_JUDGE\ninline int nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF; p = buf;\n    &#125;\n    return *p++;\n&#125;\n#else\n#define nec getchar\n#endif\ninline bool read(int &amp;x) &#123;\n    char ch = nec();\n    bool f = 0; x = 0;\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\ninline int min(int x, int y) &#123; return x &lt; y ? x : y; &#125;\nint getDP(int i, int j, int k) &#123;\n    return f[k - 1][j] + (a[i] - a[j]) * (a[i] - a[j]);\n&#125;\nint getup(int j, int k, int i) &#123;\n    return f[i - 1][j] - f[i - 1][k] + a[j] * a[j] - a[k] * a[k];\n&#125;\nint getdown(int j, int k) &#123;\n    return (a[j] - a[k]) &lt;&lt; 1;\n&#125;\nsigned main()&#123;\n    read(n); read(m);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        read(a[i]);\n        a[i] += a[i - 1];\n        f[0][i] = a[i] * a[i];\n    &#125;\n    for (int i = 1; i &lt; m; ++i) &#123;\n        L = R = 1; q[L] = i;\n        for (int j = i; j &lt;= n; ++j) &#123;\n            while (L &lt; R &amp;&amp; getup(q[L + 1], q[L], i) &lt;= a[j] * getdown(q[L + 1], q[L]))\n                ++L;\n            f[i][j] = getDP(j, q[L], i);\n            while (L &lt; R &amp;&amp; getup(i, q[R], i) * getdown(q[R], q[R - 1]) &lt;= getup(q[R], q[R - 1], i) * getdown(i, q[R]))\n                --R;\n            q[++R] = j;\n        &#125;\n    &#125;\n    printf(&quot;%lld&quot;,m * f[m - 1][n] - a[n] * a[n]);\n    return 0;\n&#125;</code></pre>\n<hr />\n<h3 id=\"柠檬\"><a href=\"https://www.luogu.com.cn/problem/P5504\">柠檬</a></h3>\n<p><a href=\"https://www.acwing.com/problem/content/2396/\">双倍经验</a></p>\n<p>是边写这篇题解边做的（</p>\n<p>题意：</p>\n<p>有一个含有 <span class=\"math inline\">\\(n\\)</span> 个元素的序列 <span class=\"math inline\">\\(s\\)</span>。将这个序列分成连续的若干段，定义每一段的价值为「在这一段当中任选某个元素的个数的平方再乘上这个元素」的最大值。求将 <span class=\"math inline\">\\(s\\)</span> 划分后的最大价值。</p>\n<p>不难想到分成的每一段首尾元素必须相等。</p>\n<p>比如有这样一个序列 <span class=\"math inline\">\\(x,a_1,a_2,a_3,\\cdots,a_k,x,y\\)</span> 。假设我们求的是这一段包含 <span class=\"math inline\">\\(x\\)</span> 的个数的平方，那么完全可以将 <span class=\"math inline\">\\(y\\)</span> 从这一段中分离，单独为一段，明显更优。</p>\n<p>而其他所有情况都是这种情况的拓展。</p>\n<p>于是得到式子： <span class=\"math display\">\\[\nf_i=\\max\\{f_{j-1}+s_i\\times(cnt_i-cnt_j+1)^2\\}\n\\]</span> 其中 <span class=\"math inline\">\\(cnt_i\\)</span> 为 <span class=\"math inline\">\\(s_i\\)</span> 已经出现了多少次。</p>\n<p>然后就是套路。 <span class=\"math display\">\\[\n\\begin{aligned}\nf_i&amp;=\\max\\{f_{j-1}+s_i\\times({cnt_i}^2+{cnt_j}^2-2\\times cnt_i\\times cnt_j+2\\times cnt_i-2\\times cnt_j+1)\\}\n\\\\\n&amp;=\\max\\{f_{j-1}+s_i\\times{cnt_i}^2+s_i\\times{cnt_j}^2-2\\times s_i\\times cnt_i\\times cnt_j+2\\times s_i\\times cnt_i-2\\times s_i\\times cnt_j+s_i\\}\n\\\\\n&amp;=\\max\\{f_{j-1}+s_i\\times {cnt_j}^2-2\\times s_i\\times cnt_i\\times cnt_j-2\\times s_i\\times cnt_j\\}+s_i\\times {cnt_i}^2+2\\times s_i\\times cnt_i+s_i\n\\end{aligned}\n\\]</span> 这次不是 <span class=\"math inline\">\\(\\min\\)</span>，而是 <span class=\"math inline\">\\(\\max\\)</span>，我们还能像以前那样推吗？</p>\n<p>不急，我们先按以前的方法试试，见机行事。</p>\n<p>令 <span class=\"math inline\">\\(j\\)</span> 优于 <span class=\"math inline\">\\(k\\)</span>，则有： <span class=\"math display\">\\[\nf_{j-1}+s_i\\times {cnt_j}^2-2\\times s_i\\times cnt_i\\times cnt_j-2\\times s_i\\times cnt_j&gt;f_{k-1}+s_i\\times {cnt_k}^2-2\\times s_i\\times cnt_i\\times cnt_k-2\\times s_i\\times cnt_k\n\\]</span> 暴力搞不出来，因为那个 <span class=\"math inline\">\\(s_i\\)</span> 乘上的平方项。</p>\n<p>那我们想一个办法，把 <span class=\"math inline\">\\(s_i\\)</span> 给灭掉就行了。</p>\n<p>既然我们已知一段的首尾元素必须相等，那不就说明 <span class=\"math inline\">\\(s_i,s_j,s_k\\)</span> 可以相互替换吗？</p>\n<p>继续搞。 <span class=\"math display\">\\[\nf_{j-1}+s_j\\times {cnt_j}^2-2\\times s_i\\times cnt_i\\times cnt_j-2\\times s_j\\times cnt_j&gt;f_{k-1}+s_k\\times {cnt_k}^2-2\\times s_i\\times cnt_i\\times cnt_k-2\\times s_k\\times cnt_k\n\\\\\nf_{j-1}-f_{k-1}+s_j\\times {cnt_j}^2-s_k\\times {cnt_k}^2-2\\times s_j\\times cnt_j+2\\times s_k\\times cnt_k&gt;2\\times s_i\\times cnt_i\\times cnt_j-2\\times s_i\\times cnt_i\\times cnt_k\n\\\\\n\\dfrac{f_{j-1}-f_{k-1}+s_j\\times {cnt_j}^2-s_k\\times {cnt_k}^2-2\\times s_j\\times cnt_j+2\\times s_k\\times cnt_k}{cnt_j-cnt_k}&gt;2\\times s_i\\times cnt_i\n\\]</span></p>\n<p>这里的符号变成 <span class=\"math inline\">\\(&gt;\\)</span> 了。</p>\n<p>易得，这里要维护的是一个斜率单调递减的上凸包最优解序列。</p>\n<p>因为 <span class=\"math inline\">\\(s_i\\)</span> 必须与 <span class=\"math inline\">\\(s_j,s_k\\)</span> 相同，明显要针对每个 <span class=\"math inline\">\\(s_i\\)</span> 维护不同的最优解序列，在每次对应的序列中计算。</p>\n<p>维护的斜率单调递减，而对于每一个相等的 <span class=\"math inline\">\\(s_i\\)</span>， <span class=\"math inline\">\\(2\\times s_i\\times cnt_i\\)</span> 一定是单调递增的，导致了这个序列大概长这个样子：斜率单调递减，但末尾的最小的斜率仍大于 <span class=\"math inline\">\\(2\\times s_i\\times cnt_i\\)</span>。</p>\n<p>单调栈可以自行研究，因为作者瞄了一眼时间发现已经是明天了。（什</p>\n<pre class=\"cpp\"><code>#include&lt;cstdio&gt;\n#include&lt;vector&gt;\nusing namespace std;\n#define int long long\n#define top q[x].size() - 1\nconst int maxn = 1e5 + 5;\nconst int maxm = 1e4 + 5;\nint n;\nvector&lt;int&gt; q[maxm]; // 不用 vector 会 MLE\nint f[maxn], s[maxn];\nint cnt[maxn], tot[maxm];\nint getDP(int i,int j)&#123;\n    return f[j-1]+(cnt[i]-cnt[j]+1)*(cnt[i]-cnt[j]+1)*s[i];\n&#125;\nint getup(int j,int k)&#123;\n    return f[j-1]-f[k-1]+s[j]*cnt[j]*cnt[j]-s[k]*cnt[k]*cnt[k]-2*s[j]*cnt[j]+2*s[k]*cnt[k];\n&#125;\nint getdown(int j,int k)&#123;\n    return cnt[j]-cnt[k];\n&#125;\nsigned main()&#123;\n    scanf(&quot;%lld&quot;,&amp;n);\n    for(int i=1;i&lt;=n;++i)&#123;\n        scanf(&quot;%lld&quot;,&amp;s[i]);\n        cnt[i]=++tot[s[i]];\n    &#125;\n    for(int i=1;i&lt;=n;++i)&#123;\n        int x=s[i];\n        while(q[x].size()&gt;=2&amp;&amp;getup(q[x][top-1],i)*getdown(q[x][top-1],q[x][top])&gt;=getup(q[x][top-1],q[x][top])*getdown(q[x][top-1],i))\n            q[x].pop_back();\n        q[x].push_back(i);\n        while(q[x].size()&gt;=2&amp;&amp;getDP(i,q[x][top])&lt;=getDP(i,q[x][top-1]))\n            q[x].pop_back();\n        f[i]=getDP(i,q[x][top]);\n    &#125;\n    printf(&quot;%lld&quot;,f[n]);\n    return 0;\n&#125;</code></pre>\n<hr />\n<h3 id=\"总结\">总结</h3>\n<p>总结斜优的步骤：</p>\n<ol type=\"1\">\n<li>推 DP 式子</li>\n<li>对式子进行巧妙的优化，使其易于化简</li>\n<li>假设 <span class=\"math inline\">\\(j\\)</span> 优于 <span class=\"math inline\">\\(k\\)</span>，将式子化成 <span class=\"math inline\">\\(\\dfrac{(j)-(k)}{(j)-(k)}&gt; \\text{or} &lt;x\\)</span> 的形式</li>\n<li>单调队列或单调栈优化</li>\n</ol>\n",
            "tags": [
                "斜率优化"
            ]
        }
    ]
}