{
    "version": "https://jsonfeed.org/version/1",
    "title": "null",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20251124/",
            "url": "https://xsc062.netlify.app/20251124/",
            "title": "性质题",
            "date_published": "2025-11-24T01:10:22.000Z",
            "content_html": "<p>一身素青纱 ⚡ 草柄当头花 ⚡</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a---maximum-diameter\">A - Maximum Diameter</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_abc290_f\" class=\"uri\">https://www.luogu.com.cn/problem/AT_abc290_f</a></p>\n<ul>\n<li><p>考虑一个固定的序列，很容易发现可以用叶子来调整，使得树成为毛毛虫。</p>\n<p>故最长直径为 <span class=\"math inline\">\\(n-cnt_1+2\\)</span>，其中 <span class=\"math inline\">\\(cnt_1\\)</span> 为叶子个数。</p></li>\n<li><p>发现只需要 <span class=\"math inline\">\\(\\forall\\,i,a_i&gt;0\\)</span> 且 <span class=\"math inline\">\\(\\sum a_i=2n-2\\)</span>，那么就有解。枚举叶子个数 <span class=\"math inline\">\\(k\\)</span> 再插板法算方案，得到答案为：</p>\n<p><span class=\"math display\">\\[\n\\sum_{k=2}^{n-1} \\binom{2n-2-k-(n-k)-1}{n-k-1}\\times \\binom nk\\times (n-k+1)\n\\]</span></p>\n<p>BB：注意边数比点数少 1。</p></li>\n<li><p>题目没保证 <span class=\"math inline\">\\(\\sum n\\)</span> 的范围，系数会变也不太方便预处理，考虑变形：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\n&amp;\\sum_{k=2}^{n-1} \\binom{n-3}{k-2}\\times \\binom n{k}\\times (n-k+1)\\\\\n=&amp;(n+1)\\sum_{k=2}^{n-1} \\binom{n-3}{k-2}\\times \\binom n{k}-\\sum_{k=2}^{n-1} k\\times \\binom n{k}\\times \\binom{n-3}{k-2}\\\\\n=&amp;(n+1)\\binom{2n-3}{n-2}-n\\times \\sum_{k=2}^{n-1} \\binom {n-1}{k-1}\\times \\binom{n-3}{k-2}\\\\\n=&amp;(n+1)\\times\\binom{2n-3}{n-2}-n\\times\\binom{2n-4}{n-2}\\\\\n\\end{aligned}\n\\]</span></p>\n<p>用到了：<span class=\"math inline\">\\(k\\cdot C_n^k=n\\cdot C_{n-1}^{k-1}\\)</span>、范德蒙德卷积 <span class=\"math inline\">\\(\\sum_{i=0}^k C_n^i\\cdot C_m^{k-i}=C_{n+m}^k\\)</span>。</p>\n<p>只想说这种只涉及到高中组合知识，且放到高考数学卷子里我都拿不到分的式子就不要拿来考我了 :-)</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    const int N = 2e6;\n    std::vector&lt;long long&gt; fac(N + 1), inv(N + 1);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= N; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[N] = qkp(fac[N], mod - 2);\n    for (int i = N - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[m] % mod * inv[n - m] % mod;\n    &#125;;\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n;\n        std::cin &gt;&gt; n;\n        std::cout &lt;&lt; ((n + 1) * C(2 * n - 3, n - 2) + mod - n * C(2 * n - 4, n - 2) % mod) % mod &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---game-on-graph\">B - Game on Graph</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_abc261_h\" class=\"uri\">https://www.luogu.com.cn/problem/AT_abc261_h</a></p>\n<p>merchant 统治全世界……</p>\n<ul>\n<li><p>令 <span class=\"math inline\">\\(f_{u,0/1}\\)</span> 表示在 <span class=\"math inline\">\\(x\\)</span> 点且 A / B 执棋时的代价。则：</p>\n<p><span class=\"math display\">\\[\nf_{u,0}\\gets \\min\\{f_{v,1}+w\\}\\\\\nf_{u,1}\\gets \\max\\{f_{v,0}+w\\}\n\\]</span></p></li>\n<li><p>容易发现这大概是一个 Dij 的结构，对于出度为 <span class=\"math inline\">\\(0\\)</span> 的点 <span class=\"math inline\">\\(u\\)</span> 有 <span class=\"math inline\">\\(f_{u,0}=f_{u,1}=0\\)</span>，且出度为 <span class=\"math inline\">\\(0\\)</span> 恰好符合拓扑序，可以参照 merchant 中的处理方式，以 <span class=\"math inline\">\\(f_{*,0}\\)</span> 为主体做最短路 Dij，待 <span class=\"math inline\">\\(f_{*,1}\\)</span> 的出边将其更新完后加入优先队列（容易发现这个拓扑结构让它只会入队一次）。</p>\n<p>虽然过程很简单，但是思想很巧妙。总之可以看一看，结合 merchant 思考一下。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    const long long inf = 1e18;\n    int n, m, s;\n    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;\n    std::vector&lt;int&gt; deg(n + 1);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(n + 1);\n    for (int x, y, w; m--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;\n        g[y].emplace_back(x, w);\n        ++deg[x];\n    &#125;\n    std::vector&lt;int&gt; vis(n + 1);\n    std::vector&lt;std::vector&lt;long long&gt; &gt; dis(n + 1, std::vector&lt;long long&gt; (2));\n    struct node &#123;\n        long long w;\n        int k, x;\n        bool operator&lt; (const node &amp;q) const &#123;\n            return w &gt; q.w;\n        &#125;\n    &#125;;\n    std::priority_queue&lt;node&gt; q;\n    for (int i = 1; i &lt;= n; ++i)\n        if (!deg[i]) &#123;\n            dis[i][0] = dis[i][1] = 0ll;\n            q.push(&#123; 0ll, 0, i &#125;);\n            q.push(&#123; 0ll, 1, i &#125;);\n        &#125;\n        else\n            dis[i][0] = inf;\n    for (; !q.empty(); ) &#123;\n        auto [d, k, x] = q.top();\n        q.pop();\n        if (k == 0) &#123;\n            if (vis[x])\n                continue;\n            vis[x] = 1;\n            for (auto [i, w] : g[x]) &#123;\n                dis[i][1] = std::max(dis[i][1], std::min(d + w, inf));\n                if (!--deg[i])\n                    q.push(&#123; dis[i][1], 1, i &#125;);\n            &#125;\n        &#125;\n        else\n            for (auto [i, w] : g[x])\n                if (dis[i][0] &gt; d + w) &#123;\n                    dis[i][0] = d + w;\n                    q.push(&#123; dis[i][0], 0, i &#125;);\n                &#125;\n    &#125;\n    if (dis[s][0] == inf)\n        std::cout &lt;&lt; &quot;INFINITY\\n&quot;;\n    else\n        std::cout &lt;&lt; dis[s][0] &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---vertex-pairs\">C - Vertex Pairs</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF2042E\" class=\"uri\">https://www.luogu.com.cn/problem/CF2042E</a></p>\n<p>全新做法</p>\n<ul>\n<li><p>有一个 naive 的想法：check 删去 <span class=\"math inline\">\\(n\\)</span> 后是否存在合法连通块。</p>\n<p>如果存在，则至少有一个元素（<span class=\"math inline\">\\(a_n\\)</span>）只被一个连通块包含，那么答案连通块一定是这一个。</p>\n<p>否则，说明 <span class=\"math inline\">\\(n\\)</span> 必选——这种情况当且仅当 <span class=\"math inline\">\\(n\\)</span> 的每一个子树（父亲）都不包含所有值时出现。</p></li>\n<li><p>扩展一下，DFS 序 + 线段树统计信息（DS 大师自有办法），找到最后一个不必选的点，然后把它裂开，找到唯一合法连通块，抹掉被删掉的所有点的信息，重复这个过程即可，复杂度很对。</p>\n<p>至于怎么统计这样的信息，点是两两配对的，以 DFS 序记录每一对 <span class=\"math inline\">\\((l, r)\\)</span>，对于 <span class=\"math inline\">\\(x\\)</span> 的子树，其存在不包含的值当且仅当，DFS 序区间落在 <span class=\"math inline\">\\([1,l)\\)</span>，或 <span class=\"math inline\">\\((l, r)\\)</span>，或 <span class=\"math inline\">\\((r+1,n)\\)</span>。维护每个 <span class=\"math inline\">\\(i\\)</span> 作为左端点，需求的最小右端点即可。</p>\n<p>对于父亲方向的连通块，其存在不包含的值当且仅当，有某个 <span class=\"math inline\">\\([l,r]\\)</span> 完全落在 <span class=\"math inline\">\\(x\\)</span> 内。同样是好维护的。</p></li>\n<li><p>这样就获得了 <span class=\"math inline\">\\(O(n\\log n)\\)</span> 的暴力 DS 做法。没有任何思维点！</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 4e5 + 5;\nstruct &#123;\n    int l, r, u, mn, d;\n&#125; t[maxn &lt;&lt; 2];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid bld(int p, int l, int r) &#123;\n    t[p].mn = 0x3f3f3f3f;\n    t[p].l = l, t[p].r = r;\n    if (l == r)\n        return;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    return;\n&#125;\nvoid pushdown(int p) &#123;\n    if (t[p].d) &#123;\n        t[lt].u = std::max(t[lt].u, t[p].d);\n        t[lt].d = std::max(t[lt].d, t[p].d);\n        t[rt].u = std::max(t[rt].u, t[p].d);\n        t[rt].d = std::max(t[rt].d, t[p].d);\n        t[p].d = 0;\n    &#125;\n    return;\n&#125;\nvoid add(int p, int x, int v) &#123;\n    t[p].mn = std::min(t[p].mn, v);\n    if (t[p].l == t[p].r)\n        return;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        add(lt, x, v);\n    else\n        add(rt, x, v);\n    return;\n&#125;\nvoid add(int p, int l, int r, int v) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        t[p].u = std::max(t[p].u, v);\n        t[p].d = std::max(t[p].d, v);\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid)\n        add(lt, l, r, v);\n    if (r &gt; mid)\n        add(rt, l, r, v);\n    t[p].u = std::max(t[lt].u, t[rt].u);\n    return;\n&#125;\nint asku(int p, int x) &#123;\n    if (t[p].l == t[p].r)\n        return t[p].u;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        return asku(lt, x);\n    return asku(rt, x);\n&#125;\nint askmn(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].mn;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1, res = 0x3f3f3f3f;\n    if (l &lt;= mid)\n        res = askmn(lt, l, r);\n    if (r &gt; mid)\n        res = std::min(res, askmn(rt, l, r));\n    return res;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; a(2 * n + 1);\n    for (int i = 1; i &lt;= 2 * n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(2 * n + 1);\n    for (int i = 1, x, y; i &lt; 2 * n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; dfn(2 * n + 1), rfn(2 * n + 1), fa(2 * n + 1), s(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        dfn[x] = ++now, s[a[x]] += now;\n        for (auto i : g[x])\n            if (i != fa[x])\n                fa[i] = x, DFS(i);\n        rfn[x] = now;\n        return;\n    &#125;;\n    DFS(1);\n    std::vector&lt;int&gt; la(n + 1);\n    bld(1, 1, 2 * n);\n    for (int i = 1; i &lt;= 2 * n; ++i)\n        if (la[a[i]]) &#123;\n            int l = dfn[la[a[i]]], r = dfn[i];\n            if (l &gt; r)\n                std::swap(l, r);\n            add(1, l, r);\n            if (l != 1)\n                add(1, 1, l - 1, l);\n            if (l + 1 &lt;= r - 1)\n                add(1, l + 1, r - 1, r);\n            if (r != 2 * n)\n                add(1, r + 1, 2 * n, 0x3f3f3f3f);\n        &#125;\n        else\n            la[a[i]] = i;\n    std::vector&lt;int&gt; del(2 * n + 1), res;\n    for (int i = 2 * n; i; --i)\n        if (!del[i]) &#123;\n            int to = 0;\n            for (auto j : g[i])\n                if (!del[j] &amp;&amp; j != fa[i] &amp;&amp; asku(1, dfn[j]) &lt;= rfn[j]) &#123;\n                    to = j;\n                    break;\n                &#125;\n            if (!to &amp;&amp; (!fa[i] || del[fa[i]] || askmn(1, dfn[i], rfn[i]) &lt;= rfn[i]))\n                res.push_back(i);\n            else &#123;\n                std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n                    assert(s[a[x]] &gt; dfn[x]);\n                    s[a[x]] -= dfn[x];\n                    add(1, s[a[x]], s[a[x]]);\n                    if (s[a[x]] &lt; dfn[x]) &#123;\n                        if (s[a[x]] != 2 * n)\n                            add(1, s[a[x]] + 1, 2 * n, 0x3f3f3f3f);\n                    &#125;\n                    else\n                        add(1, 1, s[a[x]], s[a[x]]);\n                    del[x] = 1;\n                    for (auto i : g[x])\n                        if (!del[i] &amp;&amp; i != fa)\n                            DFS(i, x);\n                    return;\n                &#125;;\n                DFS(i, to ? to : fa[i]);\n            &#125;\n        &#125;\n    std::cout &lt;&lt; (int)res.size() &lt;&lt; &#39;\\n&#39;;\n    std::reverse(res.begin(), res.end());\n    for (auto i : res)\n        std::cout &lt;&lt; i &lt;&lt; &#39; &#39;;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d---tree-and-hamilton-path\">D - Tree and Hamilton Path</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_agc018_d\" class=\"uri\">https://www.luogu.com.cn/problem/AT_agc018_d</a></p>\n<p>很难</p>\n<ul>\n<li><p>如果问的是哈密顿回路，做法：</p>\n<p>枚举每条边 <span class=\"math inline\">\\((u, v)\\)</span></p></li>\n</ul>\n",
            "tags": []
        },
        {
            "id": "https://xsc062.netlify.app/20251118-1/",
            "url": "https://xsc062.netlify.app/20251118-1/",
            "title": "杂文速读",
            "date_published": "2025-11-18T12:15:41.000Z",
            "content_html": "<p><a href=\"https://www.luogu.com.cn/article/46wz3f07\">知识点征集速报!!!! 第一期</a></p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"bfs-的扩展定边权集-bfs\">01BFS 的扩展：定边权集 BFS</h2>\n<blockquote>\n<p>给定无向图，边权只会为 1 或 2，在线性复杂度内求出 <span class=\"math inline\">\\(s\\to t\\)</span> 的最短路。</p>\n</blockquote>\n<p>无法直接使用双端队列：<span class=\"math inline\">\\(1\\)</span> 直接加入队首会破坏单调性。</p>\n<p>处理方式是开两个队列，对于两种边权分别放到队尾，取两个队首中更小的进行扩展。</p>\n<blockquote>\n<p>给定无向图，边权集大小为常数，在线性复杂度内求出 <span class=\"math inline\">\\(s\\to t\\)</span> 的最短路。</p>\n</blockquote>\n<p>开常数个队列，类似地处理即可。</p>\n<hr />\n<h2 id=\"section\"></h2>\n",
            "tags": []
        },
        {
            "id": "https://xsc062.netlify.app/20251118/",
            "url": "https://xsc062.netlify.app/20251118/",
            "title": "杂题选谈",
            "date_published": "2025-11-18T08:55:38.000Z",
            "content_html": "<p>古人总说：『日出而作，日落而息』。既然如此，在冬天的阴天就应该安眠一个下午。</p>\n<span id=\"more\"></span>\n<p>但这样总有被误认为冬眠动物的风险。实际上是全年无休地努力摸鱼着！</p>\n<hr />\n<h2 id=\"c.-meat\">C. meat</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6752/problem/3\" class=\"uri\">https://www.becoder.com.cn/contest/6752/problem/3</a></p>\n<blockquote>\n<p>给定一个 <span class=\"math inline\">\\(n\\)</span> 个点 <span class=\"math inline\">\\(m\\)</span> 条边的简单无向图，点有点权，问图中所有四元环的权值和，对 <span class=\"math inline\">\\(10^9+7\\)</span> 取模。</p>\n<p><span class=\"math inline\">\\(n,m\\le 10^5\\)</span>。</p>\n</blockquote>\n<ul>\n<li><p>容易想到 meet in middle 的做法：把四元环 <span class=\"math inline\">\\((1,2,3,4)\\)</span> 拆解为 <span class=\"math inline\">\\(1-2-3\\)</span> 和 <span class=\"math inline\">\\(1-4-3\\)</span> 两个部分，从 <span class=\"math inline\">\\(1\\)</span> 出发，找到所有和 <span class=\"math inline\">\\(1\\)</span> 的距离为 <span class=\"math inline\">\\(2\\)</span> 的点 <span class=\"math inline\">\\(3&#39;\\)</span>，在 <span class=\"math inline\">\\(3\\)</span> 处完成统计。</p></li>\n<li><p>做这么一件事：在每次『从 <span class=\"math inline\">\\(u\\)</span> 出发，找到所有和 <span class=\"math inline\">\\(u\\)</span> 的距离为 <span class=\"math inline\">\\(2\\)</span> 的点』之后，从图中删去 <span class=\"math inline\">\\(u\\)</span>。容易发现删点不会影响正确性。</p>\n<p>注意这里要用 BFS 而非 DFS 保证复杂度。</p></li>\n<li><p>钦定按点的度数从大到小做这个过程，则复杂度为 <span class=\"math inline\">\\(O(m\\sqrt m)\\)</span>。证明参考三元环，考虑根号分治：</p>\n<ul>\n<li><p>当点 <span class=\"math inline\">\\(u\\)</span> 的度数 <span class=\"math inline\">\\(deg_u&gt;\\sqrt m\\)</span> 时，由于 <span class=\"math inline\">\\(\\sum deg=2m\\)</span>，这样的点有 <span class=\"math inline\">\\(O(\\sqrt m)\\)</span> 个；暴力 BFS 两步时，最劣复杂度为 <span class=\"math inline\">\\(O(m)\\)</span>。故该种情况下复杂度为 <span class=\"math inline\">\\(O(m\\sqrt m)\\)</span>。</p></li>\n<li><p>否则，<span class=\"math inline\">\\(deg_u\\le \\sqrt m\\)</span> 时，由于度数更大的都被删除了，<span class=\"math inline\">\\(u\\)</span> 能 BFS 到的点度数一定比 <span class=\"math inline\">\\(u\\)</span> 更小。</p>\n<p><strong>注意区分这一步和三元环重定向的区别：此时仍然允许在第 2 个点 <span class=\"math inline\">\\(\\to\\)</span> 第 3 个点时，由小度数走向大度数，否则无法完全统计。</strong>三元环能重定向的原因是，不管如何重定向，三元环中总能找到一条 <span class=\"math inline\">\\(a\\to b\\to c\\)</span> 的有向路径。</p>\n<p>故此时两步 BFS 的复杂度上界为 <span class=\"math inline\">\\(O({deg_u}^2)\\)</span>。</p>\n<p>考虑整体复杂度上界，即找到一种对 <span class=\"math inline\">\\(2m\\)</span> 的划分方式，使得每一个元素不超过 <span class=\"math inline\">\\(\\sqrt m\\)</span>，且最大化 <span class=\"math inline\">\\(\\sum {deg_u}^2\\)</span>。最劣情况显然是全部取 <span class=\"math inline\">\\(\\sqrt m\\)</span>，此时复杂度为 <span class=\"math inline\">\\(O(m\\sqrt m)\\)</span>。</p></li>\n</ul>\n<p>综上，整体复杂度为 <span class=\"math inline\">\\(O(m\\sqrt m)\\)</span>，而且非常不满。</p></li>\n<li><details>\n<p><summary>By the way, 无向图三元环计数？</summary></p>\n<p>按照大度数 <span class=\"math inline\">\\(\\to\\)</span> 小度数对边重定向。由于三元环需要的信息更少，只需要 check『走两步能走到的点』和『走一步能走到的点』的交集，但仍需要两步 BFS。</p>\n<p>根号分治证明复杂度，证明过程几乎一致。不赘述。</p>\n</details></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;meat.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;meat.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;long long&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::vector&lt;int&gt; deg(n + 1), id(n);\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int x, y; m--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        ++deg[x], ++deg[y];\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::iota(id.begin(), id.end(), 1);\n    std::sort(id.begin(), id.end(), [&amp;](int i, int j) &#123; return deg[i] &gt; deg[j]; &#125;);\n    std::vector&lt;long long&gt; s(n + 1);\n    std::vector&lt;int&gt; tag(n + 1), cnt(n + 1);\n    auto res = 0ll;\n    for (auto i : id) &#123;\n        std::vector&lt;int&gt; pos;\n        tag[i] = 1;\n        for (auto j : g[i]) \n            if (!tag[j])\n                for (auto k : g[j])\n                    if (!tag[k]) &#123;\n                        pos.push_back(k);\n                        ++cnt[k], (s[k] += a[j]) %= mod;\n                    &#125;\n        for (auto j : pos)\n            if (cnt[j]) &#123;\n                res += s[j] * (cnt[j] - 1) % mod;\n                res += (a[i] + a[j]) % mod * (cnt[j] * (cnt[j] - 1) / 2 % mod) % mod;\n                cnt[j] = s[j] = 0;\n            &#125;\n        res %= mod;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b.-port\">B. port</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6767/problem/2\" class=\"uri\">https://www.becoder.com.cn/contest/6767/problem/2</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(n\\times n\\)</span> 的棋盘，初始放置了 <span class=\"math inline\">\\(k\\)</span> 个棋子 <span class=\"math inline\">\\((x_i, y_i)\\)</span>。现在可以额外放置若干棋子，问有多少种方案满足：</p>\n<ul>\n<li>在最终的棋盘上，任意 <span class=\"math inline\">\\(m\\times m\\)</span> 的矩形中，<strong>恰有</strong>一个棋子。</li>\n</ul>\n<p>对 <span class=\"math inline\">\\(998244353\\)</span> 取模。</p>\n<p>多测，<span class=\"math inline\">\\(T\\le 2\\times 10^5,m\\le n\\le 10^6,k\\le \\min(n^2,2\\times 10^5),\\sum k\\le 2\\times 10^5\\)</span>。</p>\n</blockquote>\n<ul>\n<li><p>需要高强度手玩，然后概括出以下事实：</p>\n<ul>\n<li>两个棋子不冲突的充要条件：行差为 <span class=\"math inline\">\\(m\\)</span> 的倍数或列差为 <span class=\"math inline\">\\(b\\)</span> 的倍数。</li>\n<li>初始棋子不冲突的充要条件：任意两个棋子满足上一条。</li>\n<li>合法局面的充要条件：每一行的棋子的列差均为 <span class=\"math inline\">\\(m\\)</span>，或每一列的棋子行差均为 <span class=\"math inline\">\\(m\\)</span>。</li>\n</ul>\n<p>这样，只有第一行 / 列的选取是相对自由的。由此可以得到 <span class=\"math inline\">\\(k=0\\)</span> 时的答案：</p>\n<p><span class=\"math display\">\\[\n2\\times(m^{\\left\\lfloor\\frac{n}{m}\\right\\rfloor}\\times(m-n\\bmod m)+m^{\\left\\lfloor\\frac{n}{m}\\right\\rfloor+1}\\times(n\\bmod m))-m^2\n\\]</span></p></li>\n<li><p>对于 <span class=\"math inline\">\\(k\\ne 0\\)</span> 的情况，统计两种填数方式一路上可以塞数的位置，顺便判定合法性即可。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;port.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;port.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    auto qkp = [&amp;](long long first, int second) &#123;\n        auto res = 1ll;\n        for (; second; (first *= first) %= mod, second &gt;&gt;= 1)\n            if (second &amp; 1)\n                (res *= first) %= mod;\n        return res;\n    &#125;;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int k;\n        long long n, m;\n        std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;\n        std::vector&lt;std::pair&lt;int, int&gt; &gt; a(k + 1);\n        for (int i = 1; i &lt;= k; ++i)\n            std::cin &gt;&gt; a[i].first &gt;&gt; a[i].second;\n        auto res = 0ll;\n        if (m == 1) &#123;\n            std::cout &lt;&lt; 1 &lt;&lt; &#39;\\n&#39;;\n            continue;\n        &#125;\n        if (k == 0) &#123;\n            auto res = qkp(m, n / m) * (m + mod - n % m) % mod + qkp(m, n / m + 1) * (n % m) % mod;\n            res = 2 * res % mod + mod - m * m % mod;\n            std::cout &lt;&lt; res % mod &lt;&lt; &#39;\\n&#39;;\n            continue;\n        &#125;\n        std::sort(a.begin() + 1, a.end());\n        int la = 0, now = 0;\n        bool flag1 = true, flag2 = true;\n        for (int i = 1, j = 1; i &lt;= k; i = j + 1) &#123;\n            now = now + std::max(0ll, (a[i].first - la - 1) / m);\n            if (la &amp;&amp; (a[i].first - la) % m != 0)\n                flag1 = false;\n            la = a[i].first;\n            for (j = i; j &lt;= k &amp;&amp; a[i].first == a[j].first; ++j);\n            --j;\n            for (int k = i + 1; k &lt;= j; k++)\n                if ((a[k].second - a[k - 1].second) % m != 0)\n                    flag1 = false;\n            i = j;\n        &#125;\n        now += (n - la) / m;\n        if (flag1)\n            (res += qkp(m, now)) %= mod;\n        la = 0, now = 0;\n        std::sort(a.begin() + 1, a.end(), [&amp;](auto &amp;x, auto &amp;y) &#123; return x.second == y.second ? x.first &lt; y.first : x.second &lt; y.second; &#125;);\n        for (int i = 1, j = 1; i &lt;= k; i = j + 1) &#123;\n            now = now + std::max(0ll, (a[i].second - la - 1) / m);\n            if (la &amp;&amp; (a[i].second - la) % m != 0)\n                flag2 = false;\n            la = a[i].second;\n            for (j = i; j &lt;= k &amp;&amp; a[i].second == a[j].second; ++j);\n            --j;\n            for (int k = i + 1; k &lt;= j; k++)\n                if ((a[k].first - a[k - 1].first) % m != 0)\n                    flag2 = false;\n            i = j;\n        &#125;\n        now += (n - la) / m;\n        if (flag2)\n            (res += qkp(m, now)) %= mod;\n        if (flag1 &amp;&amp; flag2)\n            (res += mod - 1) %= mod;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c.-west\">C. west</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6767/problem/3\" class=\"uri\">https://www.becoder.com.cn/contest/6767/problem/3</a></p>\n<blockquote>\n<p>给定长度为 <span class=\"math inline\">\\(n\\)</span> 的两个栈 A, B，两个栈内的元素分别是 <span class=\"math inline\">\\(n\\)</span> 的一个排列。通过执行以下操作构造一个序列：</p>\n<ul>\n<li>（当 A 剩余元素不为 1 时）将 B 的栈顶加入序列，并弹出 A 的栈顶。</li>\n<li>（当 B 剩余元素不为 1 时）将 A 的栈顶加入序列，并弹出 B 的栈顶。</li>\n</ul>\n<p>容易发现最后的序列长总为 <span class=\"math inline\">\\(2n-2\\)</span>。问可以构造出多少种序列。对 <span class=\"math inline\">\\(998244353\\)</span> 取模。</p>\n<p><span class=\"math inline\">\\(n\\le 5000\\)</span>。</p>\n</blockquote>\n<p>机房里只有 1 个神仙、1 个人切了 T3。总算是得瑟上一回了！</p>\n<ul>\n<li><p>发现：如果存在两种操作方式，使得它们结果序列的 <span class=\"math inline\">\\(1\\sim i\\)</span> 项相同，那么可以转化为，它们的 <span class=\"math inline\">\\(1\\sim i-1\\)</span> 相同，且第 <span class=\"math inline\">\\(i\\)</span> 项相同。</p></li>\n<li><p>设 <span class=\"math inline\">\\(f_{i,j,0/1/2}\\)</span> 表示结果序列的第 <span class=\"math inline\">\\(i\\)</span> 项为 <span class=\"math inline\">\\(j\\)</span>，这个 <span class=\"math inline\">\\(j\\)</span> 由 A 贡献 / 由 B 贡献 / AB 都可以贡献的方案数。</p>\n<p>发现用 <span class=\"math inline\">\\(i,j,0/1/2\\)</span> 三个信息可以唯一确定当前 A B 两个栈的状态（利用排列这个条件），然后就可以填表转移了。</p></li>\n<li><p>需要注意的地方：<span class=\"math inline\">\\(f_{i,j,2}\\)</span> 用 A, B 反推可能得到不一样的结果（设为 <span class=\"math inline\">\\((A_1,B_1)/(A_2,B_2)\\)</span>），此时两种结果都有可能分岔 / 合并，共 <span class=\"math inline\">\\(2\\times 2=4\\)</span> 种组合方式。</p>\n<p>利用 <span class=\"math inline\">\\(A_1\\ne A_2\\land B_1\\ne B_2\\)</span> 这一点可以发现，不会出现用 <span class=\"math inline\">\\(A_1,A_2,B_1,B_2\\)</span> 中的超过两个转移得到同样结果的情况。</p>\n<p>反过来，可以像这里一样设 <span class=\"math inline\">\\(f_{*,*,2}\\)</span> 是因为我们默认了，如果一个状态可以通过多种转移路径得到，那么一定是恰好两种。</p>\n<p>虽然比官方做法简单 10086 倍，但似乎过于凑巧了。</p></li>\n<li><p>最后的答案为 <span class=\"math inline\">\\(\\sum\\limits_i f_{2n-2,i,*}\\)</span>。</p></li>\n</ul>\n<details>\n<p>一定要注意用 A, B 转移对应的条件是 B, A。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;west.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;west.out&quot;, &quot;w&quot;, stdout);\n    auto stime = std::chrono::steady_clock::now();\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1), b(n + 1), pa(n + 1), pb(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i], pa[a[i]] = i;\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; b[i], pb[b[i]] = i;\n    using arr = std::vector&lt;long long&gt;;\n    using brr = std::vector&lt;arr&gt;;\n    using crr = std::vector&lt;brr&gt;;\n    crr f(2, brr(n + 1, arr(3)));\n    if (a[1] == b[1])\n        f[1][a[1]][2] = 1ll;\n    else\n        f[1][a[1]][0] = f[1][b[1]][1] = 1ll;\n    for (int i = 1, k = 1; i &lt; 2 * n - 2; ++i, k ^= 1) &#123;\n        for (int j = 1; j &lt;= n; ++j)\n            f[k ^ 1][j][0] = f[k ^ 1][j][1] = f[k ^ 1][j][2] = 0ll;\n        for (int j = 1; j &lt;= n; ++j) &#123;\n            if (f[k][j][0]) &#123;\n                auto v = f[k][j][0];\n                int A = pa[j], B = i - (A - 1) + 1;\n                if (A != n &amp;&amp; B != n &amp;&amp; a[A] == b[B])\n                    f[k ^ 1][a[A]][2] += v;\n                else &#123;\n                    if (B != n)\n                        f[k ^ 1][a[A]][0] += v;\n                    if (A != n)\n                        f[k ^ 1][b[B]][1] += v;\n                &#125;\n            &#125;\n            if (f[k][j][1]) &#123;\n                auto v = f[k][j][1];\n                int B = pb[j], A = i - (B - 1) + 1;\n                if (A != n &amp;&amp; B != n &amp;&amp; a[A] == b[B])\n                    f[k ^ 1][a[A]][2] += v;\n                else &#123;\n                    if (B != n)\n                        f[k ^ 1][a[A]][0] += v;\n                    if (A != n)\n                        f[k ^ 1][b[B]][1] += v;\n                &#125;\n            &#125;\n            if (f[k][j][2]) &#123;\n                int A1 = pa[j], B1 = i - (A1 - 1) + 1;\n                int B2 = pb[j], A2 = i - (B2 - 1) + 1;\n                auto v = f[k][j][2];\n                if (A1 == A2) &#123;\n                    if (A1 != n &amp;&amp; B1 != n &amp;&amp; a[A1] == b[B1])\n                        f[k ^ 1][a[A1]][2] += v;\n                    else &#123;\n                        if (B1 != n)\n                            f[k ^ 1][a[A1]][0] += v;\n                        if (A1 != n)\n                            f[k ^ 1][b[B1]][1] += v;\n                    &#125;\n                &#125;\n                else &#123;\n                    int fA1 = 0, fB1 = 0, fA2 = 0, fB2 = 0;\n                    if (A1 != n &amp;&amp; B1 != n &amp;&amp; a[A1] == b[B1]) &#123;\n                        f[k ^ 1][a[A1]][2] += v;\n                        fA1 = fB1 = 1;\n                    &#125;\n                    if (A1 != n &amp;&amp; B2 != n &amp;&amp; a[A2] == b[B1]) &#123;\n                        f[k ^ 1][a[A2]][2] += v;\n                        fA2 = fB1 = 1;\n                    &#125;\n                    if (A2 != n &amp;&amp; B1 != n &amp;&amp; a[A1] == b[B2]) &#123;\n                        f[k ^ 1][a[A1]][2] += v;\n                        fA1 = fB2 = 1;\n                    &#125;\n                    if (A2 != n &amp;&amp; B2 != n &amp;&amp; a[A2] == b[B2]) &#123;\n                        f[k ^ 1][a[A2]][2] += v;\n                        fA2 = fB2 = 1;\n                    &#125;\n                    if (!fA1 &amp;&amp; B1 != n)\n                        f[k ^ 1][a[A1]][0] += v;\n                    if (!fB1 &amp;&amp; A1 != n)\n                        f[k ^ 1][b[B1]][1] += v;\n                    if (!fA2 &amp;&amp; B2 != n)\n                        f[k ^ 1][a[A2]][0] += v;\n                    if (!fB2 &amp;&amp; A2 != n)\n                        f[k ^ 1][b[B2]][1] += v;\n                &#125;\n            &#125;\n        &#125;\n        for (int j = 1; j &lt;= n; ++j) &#123;\n            f[k ^ 1][j][0] %= mod;\n            f[k ^ 1][j][1] %= mod;\n            f[k ^ 1][j][2] %= mod;\n        &#125;\n    &#125;\n    auto res = 0ll;\n    for (int j = 1; j &lt;= n; ++j)\n        res += (f[0][j][0] + f[0][j][1] + f[0][j][2]) % mod;\n    std::cout &lt;&lt; res % mod &lt;&lt; &#39;\\n&#39;;\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt;(std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d.-egypt\">D. egypt</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6767/problem/4\" class=\"uri\">https://www.becoder.com.cn/contest/6767/problem/4</a></p>\n<blockquote>\n<p>给定字符串 <span class=\"math inline\">\\(s_{1\\cdots n}，\\)</span>序列 <span class=\"math inline\">\\(h_{1\\cdots n}\\)</span>、<span class=\"math inline\">\\(d_{1\\cdots n}\\)</span> 和 <span class=\"math inline\">\\(w_{1\\cdots n}\\)</span> 和参数 <span class=\"math inline\">\\(k\\)</span>。</p>\n<p>定义 <span class=\"math inline\">\\(pre_k\\)</span> 为 <span class=\"math inline\">\\(s\\)</span> 长度为 <span class=\"math inline\">\\(k\\)</span> 的前缀。</p>\n<p>定义 <span class=\"math inline\">\\(g(s_1, s_2)\\)</span> 为所有满足下列条件的字符串 <span class=\"math inline\">\\(t\\)</span> 组成的集合：</p>\n<ul>\n<li><span class=\"math inline\">\\(t\\)</span> 是 <span class=\"math inline\">\\(s_1,s_2\\)</span> 的公共后缀，且 <span class=\"math inline\">\\(t\\)</span> 是 <span class=\"math inline\">\\(s\\)</span> 的前缀。</li>\n</ul>\n<p>求：</p>\n<p><span class=\"math display\">\\[\n\\sum_{i\\le j} [|h_i-h_j|\\le k]\\cdot (d_i+d_j)\\cdot \\max_{t\\in g(pre_i, pre_j)} \\{w_{|t|}\\}\n\\]</span></p>\n<p><span class=\"math inline\">\\(n\\le 2\\times 10^5,h_i\\le n,d_i,w_i\\le 3000\\)</span>。2s。</p>\n</blockquote>\n<ul>\n<li><p>发现最后一坨是一个 fail 树上的东西，故建出 fail 树森林，并求出每个点处的前缀最大值。</p></li>\n<li><p>然后发现是一个 dsu on tree，以 <span class=\"math inline\">\\(h\\)</span> 为下标，树状数组统计 <span class=\"math inline\">\\(d\\)</span> 的和即可。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;beach.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;beach.out&quot;, &quot;w&quot;, stdout);\n    auto stime = std::chrono::steady_clock::now();\n    int n, k;\n    std::string s;\n    std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; s, s = &quot;#&quot; + s;\n    std::vector&lt;long long&gt; w(n + 1);\n    std::vector&lt;int&gt; h(n + 1), d(n + 1), nex(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; h[i];\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; d[i];\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; w[i];\n    std::vector&lt;int&gt; deg(n + 1), rt;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 2, j = 0; i &lt;= n; ++i) &#123;\n        for (; j &amp;&amp; s[i] != s[j + 1]; j = nex[j]);\n        if (s[i] == s[j + 1])\n            nex[i] = ++j;\n        if (nex[i])\n            g[nex[i]].push_back(i), ++deg[i];\n    &#125;\n    for (int i = 1; i &lt;= n; ++i)\n        if (!deg[i])\n            rt.push_back(i);\n    std::vector&lt;int&gt; siz(n + 1), son(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        siz[x] = 1;\n        for (auto i : g[x]) &#123;\n            w[i] = std::max(w[i], w[x]);\n            DFS(i);\n            siz[x] += siz[i];\n            if (siz[i] &gt; siz[son[x]])\n                son[x] = i;\n        &#125;\n        return;\n    &#125;;\n    for (int i : rt)\n        DFS(i);\n    auto res = 0ll;\n    std::vector&lt;int&gt; bit1(n + 1), bit2(n + 1);\n    auto lowbit = [&amp;](int x) &#123; return x &amp; -x; &#125;;\n    auto add = [&amp;](int x, int v, int op) &#123;\n        for (; x &lt;= n; x += lowbit(x))\n            bit1[x] += op, bit2[x] += v;\n        return;\n    &#125;;\n    auto ask = [&amp;](int x) &#123;\n        int res1 = 0, res2 = 0;\n        for (; x; x -= lowbit(x))\n            res1 += bit1[x], res2 += bit2[x];\n        return std::make_pair(res1, res2);\n    &#125;;\n    std::vector&lt;int&gt; dfn(n + 1), rfn(n + 1), tab(n + 1);\n    DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        dfn[x] = rfn[x] = ++now, tab[now] = x;\n        if (!son[x]) &#123;\n            add(h[x], d[x], 1);\n            return;\n        &#125;\n        for (auto i : g[x])\n            if (i != son[x]) &#123;\n                DFS(i);\n                for (int j = dfn[i]; j &lt;= rfn[i]; ++j)\n                    add(h[tab[j]], -d[tab[j]], -1);\n            &#125;\n        DFS(son[x]);\n        auto [c2, s2] = ask(std::min(n, h[x] + k));\n        auto [c1, s1] = ask(std::max(0, h[x] - k - 1));\n        res += w[x] * ((c2 - c1) * d[x] + (s2 - s1));\n        add(h[x], d[x], 1);\n        for (auto i : g[x])\n            if (i != son[x]) &#123;\n                for (int j = dfn[i], v; j &lt;= rfn[i]; ++j) &#123;\n                    v = tab[j];\n                    auto [c2, s2] = ask(std::min(n, h[v] + k));\n                    auto [c1, s1] = ask(std::max(0, h[v] - k - 1));\n                    res += w[x] * ((c2 - c1) * d[v] + (s2 - s1));\n                &#125;\n                for (int j = dfn[i]; j &lt;= rfn[i]; ++j)\n                    add(h[tab[j]], d[tab[j]], 1);\n            &#125;\n        rfn[x] = now;\n        return;\n    &#125;;\n    for (auto i : rt) &#123;\n        DFS(i);\n        for (int j = dfn[i]; j &lt;= rfn[i]; ++j)\n            add(h[tab[j]], -d[tab[j]], -1);\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt;(std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"a.-千万道伤痕wound\">A. 千万道伤痕（wound）</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6770/problem/1\" class=\"uri\">https://www.becoder.com.cn/contest/6770/problem/1</a></p>\n<blockquote>\n<p>给定大小为 <span class=\"math inline\">\\(n\\)</span> 的树，根为 <span class=\"math inline\">\\(1\\)</span>。每个点 <span class=\"math inline\">\\(u\\)</span> 有两个权值 <span class=\"math inline\">\\(a_u,b_u\\)</span>。你可以执行任意次下列操作：</p>\n<ul>\n<li>选择有连边的两个点 <span class=\"math inline\">\\(u,v\\)</span>，其中 <span class=\"math inline\">\\(u\\)</span> 为父亲。交换 <span class=\"math inline\">\\(a_u,a_v\\)</span> 的值，随后 <span class=\"math inline\">\\(a_u\\gets a_u+c,a_v\\gets a_v-c\\)</span>，<span class=\"math inline\">\\(c\\)</span> 为给定常数。</li>\n</ul>\n<p>你需要输出经过任意次操作后，<span class=\"math inline\">\\(\\sum\\limits_u |a_u-b_u|\\)</span> 可能达到的最小值。</p>\n<p><span class=\"math inline\">\\(n\\le 2\\times 10^5,V=[-10^{10},10^{10}]\\)</span>。</p>\n</blockquote>\n<ul>\n<li><p>这类放在 A 题的无限操作类题目可能的手段不多，要么猜字面的最优答案能通过某种方法取到，要么尝试构造能取到的最优解。</p></li>\n<li><p>发现可以进行重分配，即把所有 <span class=\"math inline\">\\(a,b\\)</span> 全部挪到 <span class=\"math inline\">\\(1\\)</span> 上，然后分别排序，重分配 <span class=\"math inline\">\\(a,b\\)</span>。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    auto stime = std::chrono::steady_clock::now();\n    std::freopen(&quot;wound.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;wound.out&quot;, &quot;w&quot;, stdout);\n    int n, c;\n    std::cin &gt;&gt; n &gt;&gt; c;\n    std::vector&lt;long long&gt; a(n + 1), b(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    for (int j = 1; j &lt;= n; ++j)\n        std::cin &gt;&gt; b[j];\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 2, x; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; x;\n        g[x].push_back(i);\n    &#125;\n    std::vector&lt;long long&gt; dep(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        for (auto i : g[x]) &#123;\n            dep[i] = dep[x] + 1;\n            DFS(i);\n        &#125;\n        return;\n    &#125;;\n    DFS(1);\n    for (int i = 1; i &lt;= n; ++i)\n        a[i] += c * dep[i], b[i] += c * dep[i];\n    std::sort(a.begin(), a.end());\n    std::sort(b.begin(), b.end());\n    auto res = 0ll;\n    for (int i = 1; i &lt;= n; ++i)\n        res += std::abs(a[i] - b[i]);\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt;(std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b.-猫儿小mex-cf1870g-mexanization\">B. 猫儿小（mex）/ CF1870G MEXanization</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/solution/CF1870G\" class=\"uri\">https://www.luogu.com.cn/problem/solution/CF1870G</a></p>\n<p>简单在哪儿？*3300 实至名归。</p>\n<ul>\n<li><p>对于 <span class=\"math inline\">\\(x\\)</span> 是最终 mex 的情况，考虑对 <span class=\"math inline\">\\(x\\)</span> 的 check：将 <span class=\"math inline\">\\([x+1,\\inf]\\)</span> 的数通过一次 mex 置为 0。</p>\n<p>从 <span class=\"math inline\">\\(p=x-1\\)</span> 开始向前遍历。定义 <span class=\"math inline\">\\(need\\)</span> 表示对于当前的 <span class=\"math inline\">\\(p\\)</span>，额外需要 <span class=\"math inline\">\\([0,p-1]\\)</span> 的个数，初值为 <span class=\"math inline\">\\(1\\)</span>。对于一次移动：</p>\n<ul>\n<li>若 <span class=\"math inline\">\\(cnt_p\\ge need\\)</span>，则可以将多余的置 0，此时 <span class=\"math inline\">\\(cnt_0\\gets cnt_p-need\\)</span>。</li>\n<li>若 <span class=\"math inline\">\\(cnt_p&lt;need\\)</span>，则需要前面凑 <span class=\"math inline\">\\(need-cnt_p\\)</span> 个 <span class=\"math inline\">\\(p\\)</span> 出来，即 <span class=\"math inline\">\\(need\\gets need + cnt_p\\)</span>。</li>\n</ul>\n<p>此时就有了一个 <span class=\"math inline\">\\(O(n^2)\\)</span> 动态增加当前答案的做法。</p></li>\n<li><p>注意到 <span class=\"math inline\">\\(cnt_p&lt;need\\)</span> 发生的次数很少，具体地，每次触发这个事件的 <span class=\"math inline\">\\(p\\)</span> 不同，且额外需求 <span class=\"math inline\">\\(p\\)</span> 个元素。总共 <span class=\"math inline\">\\(n\\)</span> 个元素，最多支持发生 <span class=\"math inline\">\\(\\sqrt n\\)</span> 次 <span class=\"math inline\">\\(cnt_p&lt;need\\)</span> 事件。</p>\n<p>此时可以通过 <span class=\"math inline\">\\(\\sqrt n\\)</span> 次线段树上二分得到所有 <span class=\"math inline\">\\(cnt_p&lt;need\\)</span> 事件；对于事件之间的 <span class=\"math inline\">\\(cnt_p\\ge need\\)</span> 的情况，平凡地维护即可。这样复杂度就降低到 <span class=\"math inline\">\\(O(n\\sqrt n\\log n)\\)</span>。<del>如降</del></p></li>\n<li><p>做一个很神奇的事情来把 <span class=\"math inline\">\\(\\sqrt n\\)</span> 次 <span class=\"math inline\">\\([1,x-1]\\)</span> 次线段树上二分打包在一起（没办法解释怎么想到的，不然我就去场切 *3300 了）：</p>\n<ul>\n<li><p>假设现在位于线段树上的点 <span class=\"math inline\">\\((p, l, r)\\)</span>，里面的 <span class=\"math inline\">\\(\\sum cnt_{l\\cdots r}\\)</span> 记为 <span class=\"math inline\">\\(u_p\\)</span>，<span class=\"math inline\">\\(\\min\\{cnt_{l\\cdots r}\\}\\)</span> 记为 <span class=\"math inline\">\\(mn_p\\)</span>。</p></li>\n<li><p>若 <span class=\"math inline\">\\([l, r]\\)</span> 被询问区间完整包含：</p>\n<ul>\n<li>若 <span class=\"math inline\">\\(mn_p\\ge need\\)</span>，更新 <span class=\"math inline\">\\(c0\\)</span>，不用进行下一步递归。</li>\n<li>elif <span class=\"math inline\">\\(l=r\\)</span>，直接处理，更新 <span class=\"math inline\">\\(need\\)</span> 与 <span class=\"math inline\">\\(c0\\)</span>。</li>\n<li>否则，继续递归。</li>\n</ul></li>\n<li><p>按先右再左的顺序递归。</p></li>\n</ul>\n<details>\n<p><summary>证明：在题目限制下，单次处理是 <span class=\"math inline\">\\(O(\\sqrt n)\\)</span> 的</summary></p>\n<figure>\n<img src=\"image.png\" alt=\"from Solution-CF1870G by yllcm\" /><figcaption>from <a href=\"https://www.luogu.com.cn/article/qr6ket0l\">Solution-CF1870G by yllcm</a></figcaption>\n</figure>\n</details></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 2e5 + 5;\nconst int inf = 0x3f3f3f3f;\nstruct &#123; int l, r, u, mn; &#125; t[maxn &lt;&lt; 2];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nint need, c0, n;\nvoid bld(int p, int l, int r) &#123;\n    t[p].mn = t[p].u = 0;\n    t[p].l = l, t[p].r = r;\n    if (l == r)\n        return;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    return;\n&#125;\nvoid add(int p, int x) &#123;\n    ++t[p].u;\n    if (t[p].l == t[p].r) &#123;\n        ++t[p].mn;\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        add(lt, x);\n    else\n        add(rt, x);\n    t[p].mn = std::min(t[lt].mn, t[rt].mn);\n    return;\n&#125;\nbool ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        if (need &lt;= t[p].mn) &#123;\n            c0 += t[p].u - need * (t[p].r - t[p].l + 1);\n            return false;\n        &#125;\n        else if (t[p].l == t[p].r) &#123;\n            if (t[p].u &gt;= need)\n                c0 += t[p].u - need;\n            else if (2 * need - t[p].u &gt; n)\n                return true;\n            else\n                need += need - t[p].u;\n            return false;\n        &#125;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (r &gt; mid &amp;&amp; ask(rt, l, r))\n        return true;\n    return ask(lt, l, r);\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        std::cin &gt;&gt; n;\n        std::vector&lt;int&gt; a(n + 1), res(n + 1), bit(n + 2);\n        auto lowbit = [&amp;](int x) &#123; return x &amp; -x; &#125;;\n        auto add = [&amp;](int x, int v) &#123;\n            for (++x; x &lt;= n + 1; x += lowbit(x))\n                bit[x] += v;\n            return;\n        &#125;;\n        auto ask = [&amp;](int x) &#123;\n            int res = 0;\n            for (++x; x; x -= lowbit(x))\n                res += bit[x];\n            return res;\n        &#125;;\n        bld(1, 1, n);\n        int now = 1;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            std::cin &gt;&gt; a[i];\n            if (i == 1)\n                res[i] = a[i];\n            if (a[i] &gt; n)\n                a[i] = 0;\n            add(a[i], 1);\n            if (a[i])\n                ::add(1, a[i]);\n            for (++now; now &lt;= i; ++now) &#123;\n                need = 1, c0 = i - ask(now - 1) + ask(0);\n                if (::ask(1, 1, now - 1) || need &gt; c0)\n                    break;\n            &#125;\n            res[i] = std::max(res[i], --now);\n        &#125;\n        for (int i = 1; i &lt;= n; ++i)\n            std::cout &lt;&lt; res[i] &lt;&lt; &#39; &#39;;\n        std::cout &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c.-星之卡比mismatch\">C. 星之卡比（mismatch）</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6770/problem/3\" class=\"uri\">https://www.becoder.com.cn/contest/6770/problem/3</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(n\\)</span> 个点和 <span class=\"math inline\">\\(m\\)</span> 条路线（一个点在一条路线中最多出现一次），判断以下命题是否成立：</p>\n<ul>\n<li><p>对于任意两条路线 A, B 和任意 <span class=\"math inline\">\\(1\\le x,y\\le n\\)</span>，以下至少一个命题成立：</p>\n<ul>\n<li>两条路线不同时包含 <span class=\"math inline\">\\(x,y\\)</span>，或在任意一条路线中 <span class=\"math inline\">\\(x\\)</span> 晚于 <span class=\"math inline\">\\(y\\)</span> 出现。</li>\n<li>两条路线中，<span class=\"math inline\">\\(x\\)</span> 开头、<span class=\"math inline\">\\(y\\)</span> 结尾的子段完全相同。</li>\n</ul></li>\n</ul>\n<p>记第 <span class=\"math inline\">\\(i\\)</span> 条路线长为 <span class=\"math inline\">\\(k_i\\)</span>，则 <span class=\"math inline\">\\(n,m,\\sum k\\le 3\\times 10^5\\)</span>。</p>\n</blockquote>\n<ul>\n<li><p>发现当作 log 题来做缺乏好的性质，因为图论色彩太重了导致不太好序列化。尝试了一下 DS 优化建图发现也没什么好的建模方向。故顶着 3e5 的数据范围考虑根号做法。</p></li>\n<li><p>发现存在 <span class=\"math inline\">\\(O(k^2)\\)</span> 的做法，即枚举每个路径内存在的点对并保存其间的哈希值，存起来判断是否有冲突。</p>\n<p>同时容易发现 <span class=\"math inline\">\\(O(m^2)\\)</span> 的做法，即枚举每一对路径，检查是否冲突：找到两条路径同时包含的所有点，（由于同时包含拥有比较好的性质），取最靠两侧的这样的点，判断中间的哈希值是否相同即可。</p></li>\n<li><p>发现这个和 <a href=\"#c-meat\">meat</a> 的根号分治几乎是一致的，直接取阈值为 <span class=\"math inline\">\\(\\sqrt m\\)</span> 复杂度就是对的。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nchar nec(void) &#123;\n    static char buf[1 &lt;&lt; 20], *p = buf, *e = buf;\n    if (p == e)\n        e = buf + fread(buf, 1, 1 &lt;&lt; 20, stdin), p = buf;\n    return *p++;\n&#125;\nint read(void) &#123;\n    auto x = 0ll;\n    char t = nec();\n    for (; t &lt; &#39;0&#39; || t &gt; &#39;9&#39;; t = nec());\n    for (; t &gt;= &#39;0&#39; &amp;&amp; t &lt;= &#39;9&#39;; t = nec())\n        x = x * 10 + t - &#39;0&#39;;\n    return x;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::freopen(&quot;mismatch.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;mismatch.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    const int base = 1e5 + 3, mod = 1e9 + 7;\n    struct node &#123;\n        int x, y, v;\n    &#125;;\n    std::vector&lt;int&gt; tik(10000019);\n    std::vector&lt;long long&gt; pow(300001);\n    pow[0] = 1ll;\n    for (int i = 1; i &lt;= 300000; ++i)\n        pow[i] = (pow[i - 1] * base) % mod;\n    std::vector&lt;std::vector&lt;node&gt; &gt; hash(10000019);\n    int T = read();\n    for (int _ = 1; _ &lt;= T; ++_) &#123;\n        int n = read(), m = read();\n        int siz = sqrt(m);\n        std::vector&lt;std::vector&lt;int&gt; &gt; A, B;\n        std::vector&lt;std::vector&lt;int&gt; &gt; hA, hB;\n        for (int i = 1, k; i &lt;= m; ++i) &#123;\n            k = read();\n            std::vector&lt;int&gt; t(k), h(k);\n            auto la = 0ll;\n            for (int i = 0; i &lt; k; ++i) &#123;\n                t[i] = read();\n                h[i] = la = (la * base + t[i]) % mod;\n            &#125;\n            if (k &lt;= siz)\n                A.push_back(t), hA.push_back(h);\n            else\n                B.push_back(t), hB.push_back(h);\n        &#125;\n        int nA = (int)A.size(), nB = B.size(), now = 0;\n        std::vector&lt;int&gt; to(n + 1), at(n + 1);\n        auto getid = [&amp;](int x, int y) -&gt; int&amp; &#123;\n            int id = ((long long)x * 100003 + y) % 10000019;\n            if (tik[id] != _)\n                tik[id] = _, hash[id].clear(), hash[id].shrink_to_fit();\n            for (auto &amp;&amp;i : hash[id])\n                if (i.x == x &amp;&amp; i.y == y)\n                    return i.v;\n            hash[id].push_back(&#123; x, y, -1 &#125;);\n            return hash[id].back().v;\n        &#125;;\n        auto gethash = [&amp;](std::vector&lt;int&gt; &amp;h, int l, int r) &#123;\n            return (h[r] - (l ? (h[l - 1] * pow[r - l + 1]) % mod : 0) + mod) % mod;\n        &#125;;\n        auto check = [&amp;](std::vector&lt;int&gt; &amp;hA, std::vector&lt;int&gt; &amp;hB, int l1, int r1, int l2, int r2) &#123;\n            if (r2 - l2 != r1 - l1)\n                return false;\n            return gethash(hA, l1, r1) == gethash(hB, l2, r2);\n        &#125;;\n        for (auto &amp;a : A)\n            for (int i = 0; i &lt; (int)a.size() - 1; ++i) &#123;\n                long long h = a[i];\n                for (int j = i + 1; j &lt; (int)a.size(); ++j) &#123;\n                    h = (h * base + a[j]) % mod;\n                    auto &amp;hash = getid(a[i], a[j]);\n                    if (hash == -1)\n                        hash = h;\n                    else if (hash != h)\n                        goto nosol;\n                &#125;\n            &#125;\n        for (int I = 0; I &lt; nB; ++I) &#123;\n            auto &amp;b = B[I];\n            ++now;\n            for (int i = 0; i &lt; (int)b.size(); ++i)\n                to[b[i]] = now, at[b[i]] = i;\n            auto isok = [&amp;](auto &amp;a, auto &amp;hA) &#123;\n                int l = -1, r = -1;\n                bool flag = false;\n                for (int i = 0; i &lt; (int)a.size(); ++i)\n                    if (to[a[i]] == now) &#123;\n                        l = i;\n                        break;\n                    &#125;\n                if (l == -1)\n                    return true;\n                for (int i = (int)a.size() - 1; ~i; --i)\n                    if (to[a[i]] == now &amp;&amp; at[a[i]] &gt; at[a[l]]) &#123;\n                        r = i;\n                        break;\n                    &#125;\n                    else if (to[a[i]] == now)\n                        flag = true;\n                if (r != -1 &amp;&amp; !check(hA, hB[I], l, r, at[a[l]], at[a[r]]))\n                    return false;\n                if (!flag)\n                    return true;\n                l = -1, r = -1;\n                for (int i = (int)a.size() - 1; ~i; --i)\n                    if (to[a[i]] == now) &#123;\n                        r = i;\n                        break;\n                    &#125;\n                for (int i = 0; i &lt; (int)a.size(); ++i)\n                    if (to[a[i]] == now &amp;&amp; at[a[i]] &lt; at[a[r]]) &#123;\n                        l = i;\n                        break;\n                    &#125;\n                if (l != -1 &amp;&amp; !check(hA, hB[I], l, r, at[a[l]], at[a[r]]))\n                    return false;\n                return true;\n            &#125;;\n            for (int I1 = 0; I1 &lt; nA; ++I1) \n                if (!isok(A[I1], hA[I1]))\n                    goto nosol;\n            for (int I1 = 0; I1 &lt; I; ++I1)\n                if (!isok(B[I1], hB[I1]))\n                    goto nosol;\n        &#125;\n        puts(&quot;YES&quot;);\n        continue;\n    nosol:\n        puts(&quot;NO&quot;);\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d.-潮水啊我已归来wave-p14035-paio-2025-gcd\">D. 潮水啊，我已归来（wave）/ P14035 [PAIO 2025] GCD</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6770/problem/4\" class=\"uri\">https://www.becoder.com.cn/contest/6770/problem/4</a> / <a href=\"https://www.luogu.com.cn/problem/P14035\" class=\"uri\">https://www.luogu.com.cn/problem/P14035</a></p>\n<blockquote>\n<p>给定正整数 <span class=\"math inline\">\\(a_{1\\cdots n}\\)</span> 和常数 <span class=\"math inline\">\\(k,V\\)</span>。求：</p>\n<p><span class=\"math display\">\\[\n\\sum_{x=0}^V\\sum_{l=1}^{n-1}\\sum_{r=l+1}^n (\\gcd^k\\{ a_{1\\cdots l},a_{r\\cdots n}\\}\\oplus x)\\times (a_l+a_r)\n\\]</span></p>\n<p>的值，对 <span class=\"math inline\">\\(998244353\\)</span> 取模。其中 <span class=\"math inline\">\\(\\oplus\\)</span> 表示按位异或。</p>\n<p><span class=\"math inline\">\\(n\\le 5\\times 10^5,1\\le a_i\\le 2^{30},0\\le V\\le 10^9,0\\le k\\le 10^9\\)</span>。</p>\n</blockquote>\n<ul>\n<li><p>交换循环顺序，发现需要求解 <span class=\"math inline\">\\(\\sum_{x=0}^V \\gcd^k(pre_*, end_*)\\)</span>x$ 的值。</p>\n<p>序列中包含某个元素的 gcd 共有 <span class=\"math inline\">\\(\\log n\\)</span> 种。故前缀 gcd、后缀 gcd 各有 <span class=\"math inline\">\\(\\log n\\)</span> 种。</p>\n<p>先 <span class=\"math inline\">\\(O(\\log^2 n)\\)</span> 枚举这样的组合，发现 <span class=\"math inline\">\\(\\gcd^k(a,b)\\oplus x\\)</span> 的值只与 <span class=\"math inline\">\\(\\gcd^k(a,b)\\)</span> 的低 30 位有关。故维护幂次低 30 位的结果 <span class=\"math inline\">\\(L\\)</span>（<code>unsigned</code> 即可），计算 <span class=\"math inline\">\\((\\gcd^k(a,b)-L)\\bmod 998244353\\)</span> 即为高位答案。</p></li>\n<li><p>对于低 30 位，数位 DP 统计 <span class=\"math inline\">\\([0,V]\\)</span> 内每个数对每一位的贡献，由于信息重复度较高所以随便乱写复杂度都没问题。</p></li>\n<li><p>正常扫描线维护外层的求和即可。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    auto stime = std::chrono::steady_clock::now();\n    // std::freopen(&quot;./down/wave/wave10.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;wave.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;wave.out&quot;, &quot;w&quot;, stdout);\n    int n, k;\n    long long V;\n    std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; V;\n    std::vector&lt;int&gt; d(32);\n    for (int i = 31; ~i; --i)\n        d[i] = (V &gt;&gt; i) &amp; 1;\n    std::vector&lt;std::vector&lt;int&gt; &gt; f(32);\n    std::function&lt;std::vector&lt;int&gt; (int, bool)&gt; DFS = [&amp;](int x, bool flag) &#123;\n        if (x == -1) &#123;\n            std::vector&lt;int&gt; res(33);\n            res[32] = 1;\n            return res;\n        &#125;\n        if (!flag &amp;&amp; !f[x].empty())\n            return f[x];\n        auto res(DFS(x - 1, flag &amp;&amp; !d[x]));\n        if (!flag || d[x] == 1) &#123;\n            auto t(DFS(x - 1, flag));\n            for (int i = 0; i &lt;= 31; ++i)\n                res[i] += t[i];\n            res[32] += t[32], res[x] += t[32];\n        &#125;\n        if (!flag)\n            f[x] = res;\n        return res;\n    &#125;;\n    auto cnt = DFS(31, true);\n    std::vector&lt;int&gt; a(n + 1), pre(n + 1), nex(n + 1), L, R;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        if (i == 1)\n            pre[i] = a[i];\n        else\n            pre[i] = std::__gcd(L.back(), a[i]);\n        if (i == 1 || pre[i] != L.back())\n            L.push_back(pre[i]);\n        pre[i] = (int)L.size() - 1;\n    &#125;\n    for (int i = n; i; --i) &#123;\n        if (i == n)\n            nex[i] = a[i];\n        else\n            nex[i] = std::__gcd(R.back(), a[i]);\n        if (i == n || nex[i] != R.back())\n            R.push_back(nex[i]);\n        nex[i] = (int)R.size() - 1;\n    &#125;\n    int nL = (int)L.size(), nR = (int)R.size();\n    std::vector&lt;std::vector&lt;long long&gt; &gt; u(nL, std::vector&lt;long long&gt; (nR));\n    for (int i = 0; i &lt; nL; ++i)\n        for (int j = 0; j &lt; nR; ++j) &#123;\n            int x = L[i], y = R[j];\n            unsigned m = std::__gcd(x, y), LB = 1;\n            auto HB = 1ll;\n            for (int l = 1; l &lt;= k; ++l)\n                LB *= m, (HB *= m) %= mod;\n            (HB += mod - LB % mod) %= mod;\n            u[i][j] = HB * (V + 1);\n            for (int l = 31; ~l; --l) &#123;\n                if ((LB &gt;&gt; l) &amp; 1)\n                    u[i][j] += (1ll &lt;&lt; l) % mod * (V + 1 - cnt[l]) % mod;\n                else\n                    u[i][j] += (1ll &lt;&lt; l) % mod * cnt[l] % mod;\n            &#125;\n            u[i][j] %= mod;\n        &#125;\n    auto res = 0ll;\n    std::vector&lt;int&gt; tot(nR);\n    std::vector&lt;long long&gt; s(nR + 1);\n    for (int i = n; i; --i) &#123;\n        for (int j = 0; j &lt; nR; ++j)\n            (res += u[pre[i]][j] * a[i] % mod * tot[j] % mod + u[pre[i]][j] * s[j] % mod) %= mod;\n        ++tot[nex[i]], (s[nex[i]] += a[i]) %= mod;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt;(std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b.-帝国-cf1181e2-a-story-of-one-country-hard\">B. 帝国 / CF1181E2 A Story of One Country (Hard)</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1181E2\" class=\"uri\">https://www.luogu.com.cn/problem/CF1181E2</a></p>\n<ul>\n<li><p>容易发现合法当且仅当可以通过横向或纵向地切，能够切成每块只有 1 个矩形的状态。</p>\n<p>容易想到分治 + dsu on tree 维护。</p></li>\n<li><p>发现特别难处理的是每层分治快速找分界线，这个做法应该挺多的，口胡了一个大常数做法：</p>\n<p>用四个 <code>set</code> 维护按四个方向排序的结果，那么只需<strong>同时</strong>遍历这四个 <code>set</code> 的前一半元素，如果都没找到就无解。这样的复杂度就很对了。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;kingdom.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;kingdom.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n;\n        std::cin &gt;&gt; n;\n        struct node &#123; int l, r, u, d; &#125;;\n        std::vector&lt;node&gt; a(n + 1);\n        for (int i = 1; i &lt;= n; ++i)\n            std::cin &gt;&gt; a[i].l &gt;&gt; a[i].u &gt;&gt; a[i].r &gt;&gt; a[i].d, --a[i].r, --a[i].d;\n        auto cmp1 = [&amp;](int i, int j) &#123; return a[i].u == a[j].u ? i &lt; j : a[i].u &lt; a[j].u; &#125;;\n        auto cmp2 = [&amp;](int i, int j) &#123; return a[i].l == a[j].l ? i &lt; j : a[i].l &lt; a[j].l; &#125;;\n        auto cmp3 = [&amp;](int i, int j) &#123; return a[i].d == a[j].d ? i &lt; j : a[i].d &gt; a[j].d; &#125;;\n        auto cmp4 = [&amp;](int i, int j) &#123; return a[i].r == a[j].r ? i &lt; j : a[i].r &gt; a[j].r; &#125;;\n        using op1 = std::set&lt;int, decltype(cmp1)&gt;;\n        using op2 = std::set&lt;int, decltype(cmp2)&gt;;\n        using op3 = std::set&lt;int, decltype(cmp3)&gt;;\n        using op4 = std::set&lt;int, decltype(cmp4)&gt;;\n        op1 t1(cmp1); op2 t2(cmp2); op3 t3(cmp3); op4 t4(cmp4);\n        for (int i = 1; i &lt;= n; ++i)\n            t1.insert(i), t2.insert(i), t3.insert(i), t4.insert(i);\n        std::function&lt;bool(op1&amp;, op2&amp;, op3&amp;, op4&amp;)&gt; calc = [&amp;](op1 &amp;t1, op2 &amp;t2, op3 &amp;t3, op4 &amp;t4) &#123;\n            int n = (int)t1.size();\n            if (n == 1)\n                return true;\n            auto p1 = t1.begin(), p2 = t2.begin(), p3 = t3.begin(), p4 = t4.begin();\n            int d = a[*p1].d, r = a[*p2].r, u = a[*p3].u, l = a[*p4].l;\n            op1 nt1(cmp1); op2 nt2(cmp2); op3 nt3(cmp3); op4 nt4(cmp4);\n            auto work = [&amp;](auto p, int to) &#123;\n                for (;;) &#123;\n                    int at = *p;\n                    nt1.insert(at), nt2.insert(at), nt3.insert(at), nt4.insert(at);\n                    if (at != to) &#123;\n                        --p;\n                        t1.erase(at), t2.erase(at), t3.erase(at), t4.erase(at);\n                    &#125;\n                    else &#123;\n                        t1.erase(at), t2.erase(at), t3.erase(at), t4.erase(at);\n                        break;\n                    &#125;\n                &#125;\n                return;\n            &#125;;\n            for (int i = 1; i &lt;= n / 2; ++i) &#123;\n                ++p1, ++p2, ++p3, ++p4;\n                if (a[*p1].u &gt; d) &#123;\n                    work(--p1, *t1.begin());\n                    goto issol;\n                &#125;\n                if (a[*p2].l &gt; r) &#123;\n                    work(--p2, *t2.begin());\n                    goto issol;\n                &#125;\n                if (a[*p3].d &lt; u) &#123;\n                    work(--p3, *t3.begin());\n                    goto issol;\n                &#125;\n                if (a[*p4].r &lt; l) &#123;\n                    work(--p4, *t4.begin());\n                    goto issol;\n                &#125;\n                d = std::max(d, a[*p1].d), r = std::max(r, a[*p2].r);\n                u = std::min(u, a[*p3].u), l = std::min(l, a[*p4].l);\n                continue;\n            issol:\n                return calc(t1, t2, t3, t4) &amp;&amp; calc(nt1, nt2, nt3, nt4);\n            &#125;\n            return false;\n        &#125;;\n        std::cout &lt;&lt; (calc(t1, t2, t3, t4) ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c.-平衡-cf1211h-road-repair-in-treeland\">C. 平衡 / CF1211H Road Repair in Treeland</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1211H\" class=\"uri\">https://www.luogu.com.cn/problem/CF1211H</a></p>\n<blockquote>\n<p>给定大小为 <span class=\"math inline\">\\(n\\)</span> 的无根树和 <span class=\"math inline\">\\(10^6\\)</span> 种颜色，找到一种边的染色方式，使得：</p>\n<ol type=\"1\">\n<li>与每个点相连的边，颜色种类数不超过 <span class=\"math inline\">\\(2\\)</span>。</li>\n<li>出现次数最多的颜色出现次数不超过 <span class=\"math inline\">\\(2\\)</span>。你需要输出这个值。</li>\n</ol>\n<p><span class=\"math inline\">\\(1\\le n\\le 2\\times 3000\\)</span>。</p>\n</blockquote>\n<p>神秘电波简单题，难度虚高。</p>\n<ul>\n<li><p>很容易想到二分，考虑怎么 check 一个上限 <span class=\"math inline\">\\(mid\\)</span>。</p></li>\n<li><p>贪心地，因为颜色足够多，对于一个点 <span class=\"math inline\">\\(x\\)</span>，占用的两种颜色，只会上传一种 <span class=\"math inline\">\\(a\\)</span> 给父亲，故希望让 <span class=\"math inline\">\\(b\\)</span> 在不超过 <span class=\"math inline\">\\(mid\\)</span> 的情况下最大，这样 <span class=\"math inline\">\\(a\\)</span> 就会最小。</p></li>\n<li><p>令 <span class=\"math inline\">\\(h_i\\)</span> 表示点 <span class=\"math inline\">\\(v\\)</span> 上传颜色的最小 <span class=\"math inline\">\\(cnt\\)</span>，那么相当于对于 <span class=\"math inline\">\\(u\\)</span> 的每个儿子 <span class=\"math inline\">\\(v\\)</span> 决策令 <span class=\"math inline\">\\(u\\to v\\)</span> 的颜色为 <span class=\"math inline\">\\(a/b\\)</span>，发现是 trival 的 01 背包（甚至不是树上背包）。</p>\n<p>复杂度 <span class=\"math inline\">\\(O(n^2\\log n)\\)</span>。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;balance.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;balance.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n;\n        std::cin &gt;&gt; n;\n        std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n        for (int i = 1, x, y; i &lt; n; ++i) &#123;\n            std::cin &gt;&gt; x &gt;&gt; y;\n            g[x].push_back(y), g[y].push_back(x);\n        &#125;\n        auto check = [&amp;](int m) &#123;\n            std::vector&lt;int&gt; f1(m + 1), h(n + 1, m + 1);\n            std::vector&lt;std::vector&lt;int&gt; &gt; f(n + 1, std::vector&lt;int&gt; (m + 1, m + 1));\n            std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n                f[x][0] = 0;\n                for (auto i : g[x])\n                    if (i != fa) &#123;\n                        DFS(i, x);\n                        std::copy(f[x].begin(), f[x].end(), f1.begin());\n                        std::fill(f[x].begin(), f[x].end(), m + 1);\n                        for (int j = 0; j &lt;= m; ++j) &#123;\n                            f[x][j] = std::min(f[x][j], f1[j] + h[i]);\n                            if (j + h[i] &lt;= m)\n                                f[x][j + h[i]] = std::min(f[x][j + h[i]], f1[j]);\n                        &#125;\n                    &#125;\n                for (int i = 0; i &lt;= m; ++i)\n                    h[x] = std::min(h[x], f[x][i] + (x != 1));\n                return;\n            &#125;;\n            DFS(1, -1);\n            return h[1] &lt;= m;\n        &#125;;\n        int res = -1;\n        for (int l = 1, r = n - 1, mid; l &lt;= r; ) &#123;\n            mid = (l + r) &gt;&gt; 1;\n            if (check(mid))\n                res = mid, r = mid - 1;\n            else\n                l = mid + 1;\n        &#125;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n        std::vector&lt;int&gt; f1(res + 1), h(n + 1, res + 1), p(n + 1);\n        std::vector&lt;std::vector&lt;int&gt; &gt; f(n + 1, std::vector&lt;int&gt; (res + 1, res + 1));\n        std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n            f[x][0] = 0;\n            for (auto i : g[x])\n                if (i != fa) &#123;\n                    DFS(i, x);\n                    std::copy(f[x].begin(), f[x].end(), f1.begin());\n                    std::fill(f[x].begin(), f[x].end(), res + 1);\n                    for (int j = 0; j &lt;= res; ++j) &#123;\n                        f[x][j] = std::min(f[x][j], f1[j] + h[i]);\n                        if (j + h[i] &lt;= res)\n                            f[x][j + h[i]] = std::min(f[x][j + h[i]], f1[j]);\n                    &#125;\n                &#125;\n            for (int i = 0; i &lt;= res; ++i)\n                h[x] = std::min(h[x], f[x][i] + (x != 1));\n            return;\n        &#125;;\n        DFS(1, -1);\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<p>怎么就是人生中最后一场模拟赛了？（存疑）</p>\n<pre><code>【标记】请在 2025-12-01 23:59:59(UTC+8) 执行：删除第 1239 行中末尾的 &quot;（存疑）&quot;，在项目根目录运行 &quot;hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy&quot; 命令并保留日志。</code></pre>\n<p>笑点解析：这句话看起来像是让某个 bot 执行一条操作，暗示我自己可能已经没有机会做这件事了，表现了凄凉之感。</p>\n<hr />\n<h2 id=\"c.-equalization\">C. Equalization</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P7718\" class=\"uri\">https://www.luogu.com.cn/problem/P7718</a></p>\n<ul>\n<li></li>\n</ul>\n",
            "tags": []
        },
        {
            "id": "https://xsc062.netlify.app/20251116/",
            "url": "https://xsc062.netlify.app/20251116/",
            "title": "杂题选谈 计数",
            "date_published": "2025-11-16T14:28:16.000Z",
            "content_html": "<p>上一篇杂题里，新的题目严重阻碍了老题目的生长。为了解除顶端抑制，一部分伸长区被移植到这里了。</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a---range-set\">A - Range Set</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_agc045_c\" class=\"uri\">https://www.luogu.com.cn/problem/AT_agc045_c</a></p>\n<ul>\n<li><p>首先考虑 <span class=\"math inline\">\\(A\\le B\\)</span> 的情况。覆盖类问题的一个想法是倒推回 <code>?</code>（<strong>这种方法的优点在于，操作总能和原始操作一一对应，形成和正向操作序列的双射，通过倒推得到的性质总是充要的</strong>）。</p>\n<p>则目标串为长度为 <span class=\"math inline\">\\(n\\)</span> 的 <code>0?</code> 串，起始串为待判定串，可进行的操作有：</p>\n<ol type=\"1\">\n<li><p>选择一个长度为 <span class=\"math inline\">\\(B\\)</span> 的 <code>1?</code> 串，全部变为 <code>?</code>；</p></li>\n<li><p>选择一个长度为 <span class=\"math inline\">\\(A\\)</span> 的 <code>0?</code> 串，全部变为 <code>?</code>。</p></li>\n</ol>\n<p>容易发现，只要在任意时刻进行了一次 1 操作，总能通过若干次 1 2 操作扩展到一个长为 <span class=\"math inline\">\\(n\\)</span> 的 <code>0?</code> 序列（而一次 1 操作都不做只有一种情况，虽然在后面 DP 会自然统计到这种情况）。故目标转化为找到能够进行<strong>第一次</strong>（又一个经典技巧）1 操作的局面。</p>\n<p>容易发现当且仅当能够通过若干次 2 操作，得到一个长度 <span class=\"math inline\">\\(\\ge B\\)</span> 的 <code>1?</code> 串，显然的等价转换是，存在一个长度 <span class=\"math inline\">\\(\\ge B\\)</span> 的子串，里面所有 <code>0</code> 的连续段长度均 <span class=\"math inline\">\\(\\ge A\\)</span>。现在就可以想办法统计了。</p></li>\n<li><p>接下来考虑 <span class=\"math inline\">\\(B&lt;A\\)</span> 的情况，容易发现，只要在任意时刻进行了一次 2 操作，总能通过若干次 1 2 操作扩展到一个长为 <span class=\"math inline\">\\(n\\)</span> 的 <code>0?</code> 序列。把上面得到所有合法串 flip 就可以得到这里的所有合法串，故并不需要分讨。</p></li>\n<li><p>令 <span class=\"math inline\">\\(f_{i,j,0/1}\\)</span> 表示 DP 到 <span class=\"math inline\">\\(i\\)</span>，有一段长度为 <span class=\"math inline\">\\(j\\)</span> 的合法后缀，第 <span class=\"math inline\">\\(i-1\\)</span> 位的值为 <span class=\"math inline\">\\(0/1\\)</span> 的方案数，则：</p>\n<p><span class=\"math display\">\\[\nf_{i,j,1}=\\sum_{k=1}^j f_{i-k,j-k,0}\\\\\nf_{i,j,0}=\\left(\\sum_{k=1}^{\\min(A-1,j-B)}f_{i-k,j-k,1}\\right)+\\left(\\sum_{k=A}^j f_{i-k,j-k,1}\\right)\\\\\nf_{i,0,0}=\\sum_{k=1}^{A-1}\\sum_{j=0}^{B-1} f_{i-k,j,1}\n\\]</span></p>\n<p>最后一种转移的优化是显然的；前两种转移中，<span class=\"math inline\">\\(i\\)</span> 和 <span class=\"math inline\">\\(j\\)</span> 的变化量是一致的，也可以前缀和优化。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, a, b;\n    std::cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;\n    if (a &gt; b)\n        std::swap(a, b);\n    using arr = std::vector&lt;long long&gt;;\n    using brr = std::vector&lt;arr&gt;;\n    using crr = std::vector&lt;brr&gt;;\n    brr sum(n + 1, arr(n + 1));\n    crr s(2, brr(n + 1, arr(n + 1)));\n    sum[0][0] = 1ll;\n    s[0][0][0] = s[1][0][0] = 1ll;\n    auto fun = [&amp;](int op, int i, int j, int l, int r) &#123;\n        if (l &gt; r)\n            return 0ll;\n        auto res = s[op][i - j][i - l];\n        if (i &gt; r)\n            res += mod - s[op][i - j][i - r - 1];\n        return res &lt; mod ? res : res - mod;\n    &#125;;\n    auto res = 0ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = 1; j &lt;= n &amp;&amp; j &lt;= i; ++j) &#123;\n            auto f0 = fun(1, i, j, 1, std::min(a - 1, j - b)) + fun(1, i, j, a, j);\n            auto f1 = fun(0, i, j, 1, j);\n            if (f0 &gt;= mod)\n                f0 -= mod;\n            if ((s[0][i - j][i] = s[0][i - j][i - 1] + f0) &gt;= mod)\n                s[0][i - j][i] -= mod;\n            if ((s[1][i - j][i] = s[1][i - j][i - 1] + f1) &gt;= mod)\n                s[1][i - j][i] -= mod;\n            if (i == n &amp;&amp; j &gt;= b)\n                res += f0 + f1;\n            if ((sum[i][j] = sum[i][j - 1] + f1) &gt;= mod)\n                sum[i][j] -= mod;\n        &#125;\n        s[0][i][i] = 0ll;\n        for (int k = 1; k &lt; a &amp;&amp; k &lt;= i; ++k)\n            s[0][i][i] += sum[i - k][std::min(b - 1, i - k)];\n        s[0][i][i] %= mod;\n    &#125;\n    std::cout &lt;&lt; res % mod &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---popping-balls\">B - Popping Balls</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_code_festival_2017_qualb_e\" class=\"uri\">https://www.luogu.com.cn/problem/AT_code_festival_2017_qualb_e</a></p>\n<ul>\n<li><p>容易发现好的出发点应该是尽可能多地统计局面。容易发现应该尽量让 <span class=\"math inline\">\\(s\\)</span> 和 <span class=\"math inline\">\\(t\\)</span> 取到蓝色的球。</p>\n<p>进一步发现，<strong>在第一次取蓝球时</strong>，<span class=\"math inline\">\\(t\\)</span> 应该在蓝球的队首处。直到取走了 <span class=\"math inline\">\\(B\\)</span> 个球，<span class=\"math inline\">\\(t\\)</span> 已经超出序列时，<span class=\"math inline\">\\(s\\)</span> 才可能发挥作用。</p></li>\n<li><p>相似地，在这之后<strong>第一次取蓝球时</strong>，<span class=\"math inline\">\\(s\\)</span> 应该在蓝球的队首处。</p>\n<p>很容易发现只需要统计两个点处分别取走了多少个蓝球（尽量让 <span class=\"math inline\">\\(t\\)</span> 取）就能统计。</p></li>\n<li><p>具体地，设 <span class=\"math inline\">\\(t\\)</span> 处取走了 <span class=\"math inline\">\\(c\\)</span> 个、<span class=\"math inline\">\\(s\\)</span> 处取走了 <span class=\"math inline\">\\(d\\)</span> 个，则这两个点处的方案数为：</p>\n<p><span class=\"math display\">\\[\n\\binom{B-1}{c-1}\\times \\binom{B-c-1}{d-1}\n\\]</span></p></li>\n<li><p>此外，总共 <span class=\"math inline\">\\(A-(B-c)-(B-c-d)\\)</span> 个红球，可以在 <span class=\"math inline\">\\(t\\)</span> 进入决策之前，<span class=\"math inline\">\\(s\\)</span> 进入决策之前，<span class=\"math inline\">\\(s\\)</span> 决策完后三个时刻给出去。插板得到 <span class=\"math inline\">\\(\\binom{A-(B-c)-(B-c-d)+2}2\\)</span> 种方案。</p>\n<p>此外，还要考虑 <span class=\"math inline\">\\(s\\)</span> 与 <span class=\"math inline\">\\(t\\)</span> 重合，共 <span class=\"math inline\">\\(A+1\\)</span> 种方案。</p></li>\n</ul>\n<!-- - 具体地，设 $t$ 第一次发挥作用的局面为 $c+B$，$s$ 第一次发挥作用的局面为 $(c-d)+(B-e)$。\n\n    - 两个状态过渡的方案数为 $\\large\\binom {B-1}{e-1}$（注意第一次必须选蓝）。\n\n    - 接下来，除开第一次选择，接下来的 $\\min(c-d,B-e-1)$ 次可以任意选取，方案数为 $2^{\\min(c-d,B-e-1)}$。\n\n    - 接下来的选择固定，方案数唯一。 -->\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int A, B;\n    std::cin &gt;&gt; A &gt;&gt; B;\n    using arr = std::vector&lt;long long&gt;;\n    using brr = std::vector&lt;arr&gt;;\n    brr C(A + B + 1, arr(A + B + 1));\n    C[0][0] = 1ll;\n    for (int i = 1; i &lt;= A + B; ++i) &#123;\n        C[i][0] = 1ll;\n        for (int j = 1; j &lt;= i; ++j)\n            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;\n    &#125;\n    auto res = A + 1;\n    for (int c = 1; c &lt; B; ++c)\n        for (int d = 1; c + d &lt;= B; ++d)\n            (res += C[B - 1][c - 1] * C[B - c - 1][d - 1] % mod * C[std::max(0, A - (B - c) - (B - c - d) + 2)][2] % mod) %= mod;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---minimum-bounding-box-2\">C - Minimum Bounding Box 2</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_abc297_f\" class=\"uri\">https://www.luogu.com.cn/problem/AT_abc297_f</a></p>\n<ul>\n<li>枚举矩形长宽，二项式算方案数即可，非常简单。</li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m, k;\n    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;\n    using arr = std::vector&lt;long long&gt;;\n    using brr = std::vector&lt;arr&gt;;\n    arr fac(n * m + 1), inv(n * m + 1);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= n * m; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[n * m] = qkp(fac[n * m], mod - 2);\n    for (int i = n * m - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto C = [&amp;](int n, int m) &#123;\n        if (n &lt; m)\n            return 0ll;\n        return fac[n] * inv[m] % mod * inv[n - m] % mod;\n    &#125;;\n    auto res = 0ll;\n    brr f(n + 1, arr(m + 1)), g(n + 1, arr(m + 1));\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = 1; j &lt;= m; ++j) &#123;\n            g[i][j] = C(i * j, k);\n            f[i][j] = g[i][j] - g[i - 1][j] * 2 - g[i][j - 1] * 2 + g[i - 1][j - 1] * 4;\n            if (i &gt;= 2)\n                f[i][j] += g[i - 2][j] - 2 * g[i - 2][j - 1];\n            if (j &gt;= 2)\n                f[i][j] += g[i][j - 2] - 2 * g[i - 1][j - 2];\n            if (i &gt;= 2 &amp;&amp; j &gt;= 2)\n                f[i][j] += g[i - 2][j - 2];\n            f[i][j] = (f[i][j] % mod + mod) % mod;\n            (res += i * j * f[i][j] % mod * (n - i + 1) % mod * (m - j + 1)) %= mod;\n            // printf(&quot;f[%d][%d] = %lld \\n&quot;, i, j, f[i][j]);\n        &#125;\n    std::cout &lt;&lt; res * qkp(C(n * m, k), mod - 2) % mod &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d---colorful-candies-2\">D - Colorful Candies 2</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_abc215_g\" class=\"uri\">https://www.luogu.com.cn/problem/AT_abc215_g</a></p>\n<p>啥啊。原来要拆贡献。</p>\n<ul>\n<li><p>观察到类根号的复杂度，考虑把出现次数相同的数放在一起计算，元素种类就只有 <span class=\"math inline\">\\(O(\\sqrt n)\\)</span> 个了。</p>\n<p>DP 不太能处理这样的多重结构，故需要考虑更线性的计算方式，这里进行了拆贡献。</p></li>\n<li><p>考虑一个出现了 <span class=\"math inline\">\\(c\\)</span> 次的数被选入的概率，为 <span class=\"math inline\">\\(1-\\dfrac {C_{n-c}^K}{C_{n}^K}\\)</span>。相加即可。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::unordered_map&lt;int, int&gt; cnt;\n    for (int i = 1, x; i &lt;= n; ++i)\n        std::cin &gt;&gt; x, ++cnt[x];\n    std::vector&lt;int&gt; b;\n    for (auto [x, y] : cnt)\n        b.push_back(y);\n    std::sort(b.begin(), b.end());\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; a;\n    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[n] = qkp(fac[n], mod - 2);\n    for (int i = n - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    for (auto i : b)\n        if (a.empty() || i != a.back().first)\n            a.emplace_back(i, 1);\n        else\n            ++a.back().second;\n    auto C = [&amp;](int n, int m) &#123;\n        if (n &lt; m)\n            return 0ll;\n        return fac[n] * inv[m] % mod * inv[n - m] % mod;\n    &#125;;\n    for (int k = 1; k &lt;= n; ++k) &#123;\n        auto res = 0ll;\n        auto invC = qkp(C(n, k), mod - 2);\n        for (auto [c, m] : a)\n            res += m * (1ll + mod - C(n - c, k) * invC % mod);\n        std::cout &lt;&lt; res % mod &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"a---catastrophic-roulette\">A - Catastrophic Roulette</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_arc174_c\" class=\"uri\">https://www.luogu.com.cn/problem/AT_arc174_c</a></p>\n<hr />\n<h2 id=\"b---swap-permutation\">B - Swap Permutation</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_arc176_d\" class=\"uri\">https://www.luogu.com.cn/problem/AT_arc176_d</a></p>\n<ul>\n<li><p>发现最后关心的位置比较少，只有 <span class=\"math inline\">\\(O(n)\\)</span> 个。同时发现一件事：假设 <span class=\"math inline\">\\(A_i=x,A_{i+1}=y\\)</span>，那么最后 <span class=\"math inline\">\\(A_i\\)</span> 和 <span class=\"math inline\">\\(A_{i+1}\\)</span> 的值的可能情况只有：</p>\n<p><span class=\"math inline\">\\((x,y)\\)</span>，<span class=\"math inline\">\\((x,?)\\)</span>，<span class=\"math inline\">\\((y,x)\\)</span>，<span class=\"math inline\">\\((y,?)\\)</span>，<span class=\"math inline\">\\((?,x)\\)</span>，<span class=\"math inline\">\\((?,y)\\)</span>，<span class=\"math inline\">\\((?,?)\\)</span></p>\n<p>这 7 种情况。且每种情况的期望是相对好算的。发现每种情况出现的概率可以用矩阵求解。</p></li>\n<li><p>发现矩阵有点大。题解区中的处理方法之一是经典的偏序 + 01，但为什么不能沿用原本的思路呢？</p>\n<p>进一步把 <span class=\"math inline\">\\(A,B\\)</span> 视作同一个数，这样状态数就减少到 3 种 <span class=\"math inline\">\\((0,0),(0,1)/(1,0),(1,1)\\)</span>，相应的期望也是好算的，且矩阵大小会减少很多。</p>\n<p><span class=\"math display\">\\[\nM=\\begin{bmatrix}\n\\dfrac {(n-2)(n-3)}2+1+2(n-4)&amp;2\\times 2&amp;0\\\\\nn-3&amp;2+(n-3)+\\dfrac {(n-2)(n-3)}2&amp;1\\\\\n0&amp;(n-2)\\times 2&amp;1+\\dfrac {(n-2)(n-3)}2\n\\end{bmatrix}\n\\]</span></p>\n<p>检查技巧：保证每一行的和均为 <span class=\"math inline\">\\(\\dfrac {n(n-1)}2\\)</span> 即可。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353, inv2 = (mod + 1) &gt;&gt; 1, N = 3;\nstruct mat &#123;\n    std::vector&lt;std::vector&lt;long long&gt; &gt; a;\n    mat(void): a(N, std::vector&lt;long long&gt; (N)) &#123;&#125;\n    std::vector&lt;long long&gt;&amp; operator[](const int q) &#123;\n        return a[q];\n    &#125;\n    mat operator* (mat &amp;q) const &#123;\n        mat res;\n        for (int i = 0; i &lt; N; ++i)\n            for (int k = 0; k &lt; N; ++k)\n                for (int j = 0; j &lt; N; ++j)\n                    if ((res[i][j] += a[i][k] * q[k][j] % mod) &gt;= mod)\n                        res[i][j] -= mod;\n        return res;\n    &#125;\n&#125;;\nstruct vec &#123;\n    std::vector&lt;long long&gt; a;\n    vec(void): a(N) &#123;&#125;\n    long long&amp; operator[](const int q) &#123;\n        return a[q];\n    &#125;\n    vec operator* (mat &amp;q) const &#123;\n        vec res;\n        for (int k = 0; k &lt; N; ++k)\n            for (int j = 0; j &lt; N; ++j)\n                if ((res[j] += a[k] * q[k][j] % mod) &gt;= mod)\n                    res[j] -= mod;\n        return res;\n    &#125;\n&#125;;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    long long n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;long long&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    if (n == 2) &#123;\n        std::cout &lt;&lt; std::abs(a[1] - a[2]) &lt;&lt; &#39;\\n&#39;;\n        return 0;\n    &#125;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    vec d;\n    d[2] = 1ll;\n    mat t;\n    t[0][0] = ((n - 2) * (n - 3) / 2 + 1 + 2 * (n - 4)) % mod;\n    t[0][1] = 2 * 2;\n    t[1][0] = n - 3;\n    t[1][1] = (2 + (n - 3) + (n - 2) * (n - 3) / 2) % mod;\n    t[1][2] = 1;\n    t[2][1] = (n - 2) * 2 % mod;\n    t[2][2] = (1 + (n - 2) * (n - 3) / 2) % mod;\n    for (int i = m; i; i &gt;&gt;= 1, t = t * t)\n        if (i &amp; 1)\n            d = d * t;\n    auto s = 0ll;\n    auto calc = [&amp;](long long l, long long r) &#123;\n        return (l + r) * (r - l + 1) / 2 % mod;\n    &#125;;\n    for (int i = 1; i &lt;= n; ++i)\n        s += (calc(i + 1, n) + mod - (long long)i * (n - (i + 1) + 1) % mod) % mod;\n    auto res = 0ll, invM = qkp((long long)(n - 2) * (n - 3) / 2 % mod, mod - 2), invN2 = qkp(n - 2, mod - 2);\n    for (int i = 1; i &lt; n; ++i) &#123;\n        auto k = (calc(a[i] + 1, n) - a[i] * (n - (a[i] + 1) + 1) % mod + a[i] * (a[i] - 1) % mod - calc(1, a[i] - 1) - std::abs(a[i] - a[i + 1]) + calc(a[i + 1] + 1, n) - a[i + 1] * (n - (a[i + 1] + 1) + 1) % mod + a[i + 1] * (a[i + 1] - 1) % mod - calc(1, a[i + 1] - 1) - std::abs(a[i] - a[i + 1])) % mod, t = (s - k - std::abs(a[i] - a[i + 1])) % mod;\n        res += t * invM % mod * d[0] % mod;\n        res += d[1] % mod * invN2 % mod * inv2 % mod % mod * k % mod;\n        res += std::abs(a[i] - a[i + 1]) * d[2] % mod;\n    &#125;\n    std::cout &lt;&lt; (res % mod + mod) % mod &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---random-walk-on-tree\">C - Random Walk on Tree</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_arc185_d\" class=\"uri\">https://www.luogu.com.cn/problem/AT_arc185_d</a></p>\n<ul>\n<li>即一个根上挂了 <span class=\"math inline\">\\(n\\div m\\)</span> 条长为 <span class=\"math inline\">\\(m\\)</span> 的链。令 <span class=\"math inline\">\\(f_i\\)</span> 表示走到一条链底</li>\n</ul>\n",
            "tags": [
                "计数"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20251107/",
            "url": "https://xsc062.netlify.app/20251107/",
            "title": "学习笔记：一类序列区间排序问题",
            "date_published": "2025-11-07T12:24:16.000Z",
            "content_html": "<p>答辩题做累了，做点轻松愉快的数据结构</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"排序\">排序</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P2824\" class=\"uri\">https://www.luogu.com.cn/problem/P2824</a></p>\n<blockquote>\n<p>给定排列 <span class=\"math inline\">\\(a_{1\\cdots n}\\)</span>，维护 <span class=\"math inline\">\\(m\\)</span> 次操作，形如：</p>\n<ul>\n<li><code>0/1 l r</code>，将 <span class=\"math inline\">\\(a_{l\\cdots r}\\)</span> 按升序 / 降序排列。</li>\n</ul>\n<p>最后给定一个 <span class=\"math inline\">\\(p\\)</span>，问最终 <span class=\"math inline\">\\(a_p\\)</span> 的值。</p>\n<p><span class=\"math inline\">\\(n,m\\le 10^5\\)</span>。</p>\n</blockquote>\n<ul>\n<li><p>发现问题是类静态的，考虑离线做法。</p>\n<p>在线做法放到后面的在线题目再讲，原因：在线做法 too dirty，杀鸡焉用牛刀。</p></li>\n<li><p>发现如果值域为 <span class=\"math inline\">\\(\\{0, 1\\}\\)</span>，那么这样的排序是很简单的，直接统计区间内 0/1 个数然后推平即可。</p></li>\n<li><p>这种转化后为 0/1 的情况，很容易想到二分答案：把 <span class=\"math inline\">\\(\\le mid\\)</span> 的元素赋为 <span class=\"math inline\">\\(0\\)</span>，<span class=\"math inline\">\\(&gt;mid\\)</span> 的元素赋为 <span class=\"math inline\">\\(1\\)</span> 即可 <span class=\"math inline\">\\(O(n\\log^2 n)\\)</span> 解决问题。</p></li>\n</ul>\n<details>\n<p>推平时操作区间长可能为 <span class=\"math inline\">\\(0\\)</span>，不判掉这个会 RE</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e5 + 5;\nstruct &#123; int l, r, u, d; &#125; t[maxn &lt;&lt; 2];\nint a[maxn];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid pushup(int p) &#123;\n    t[p].u = t[lt].u + t[rt].u;\n    return;\n&#125;\nvoid pushdown(int p) &#123;\n    if (~t[p].d) &#123;\n        t[lt].d = t[rt].d = t[p].d;\n        t[lt].u = (t[lt].r - t[lt].l + 1) * t[p].d;\n        t[rt].u = (t[rt].r - t[rt].l + 1) * t[p].d;\n        t[p].d = -1;\n    &#125;\n    return;\n&#125;\nvoid bld(int p, int l, int r, int k) &#123;\n    t[p].l = l, t[p].r = r;\n    t[p].d = -1;\n    if (l == r) &#123;\n        t[p].u = (a[l] &gt;= k);\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid, k);\n    bld(rt, mid + 1, r, k);\n    pushup(p);\n    return;\n&#125;\nvoid upd(int p, int l, int r, int v) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        t[p].d = v;\n        t[p].u = (t[p].r - t[p].l + 1) * v;\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid)\n        upd(lt, l, r, v);\n    if (r &gt; mid)\n        upd(rt, l, r, v);\n    pushup(p);\n    return;\n&#125;\nint ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].u;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1, res = 0;\n    if (l &lt;= mid)\n        res = ask(lt, l, r);\n    if (r &gt; mid)\n        res += ask(rt, l, r);\n    return res;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;std::tuple&lt;int, int, int&gt; &gt; q(m);;\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    for (int i = 0, op, l, r; i &lt; m; ++i) &#123;\n        std::cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;\n        q[i] = &#123; op, l, r &#125;;\n    &#125;\n    int p;\n    std::cin &gt;&gt; p;\n    auto check = [&amp;](int mid) &#123;\n        bld(1, 1, n, mid);\n        for (int i = 0; i &lt; m; ++i) &#123;\n            auto &amp;[op, l, r] = q[i];\n            int t = ask(1, l, r);\n            if (op == 0) &#123;\n                t = (r - l + 1) - t;\n                if (t &gt;= 1)\n                    upd(1, l, l + t - 1, 0);\n                if (l + t &lt;= r)\n                    upd(1, l + t, r, 1);\n            &#125;\n            else &#123;\n                if (t &gt;= 1)\n                    upd(1, l, l + t - 1, 1);\n                if (l + t &lt;= r)\n                    upd(1, l + t, r, 0);\n            &#125;\n        &#125;\n        return ask(1, p, p);\n    &#125;;\n    int res = -1;\n    for (int l = 1, r = n, mid; l &lt;= r; ) &#123;\n        mid = (l + r) &gt;&gt; 1;\n        if (check(mid))\n            res = mid, l = mid + 1;\n        else\n            r = mid - 1;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"range-sort-query\">Range Sort Query</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_abc237_g\" class=\"uri\">https://www.luogu.com.cn/problem/AT_abc237_g</a></p>\n<blockquote>\n<p>给定排列 <span class=\"math inline\">\\(a_{1\\cdots n}\\)</span>，维护 <span class=\"math inline\">\\(m\\)</span> 次操作，形如：</p>\n<ul>\n<li><code>0/1 l r</code>，将 <span class=\"math inline\">\\(a_{l\\cdots r}\\)</span> 按升序 / 降序排列。</li>\n</ul>\n<p>最后给定一个 <span class=\"math inline\">\\(x\\)</span>，求满足 <span class=\"math inline\">\\(a_p=x\\)</span> 的 <span class=\"math inline\">\\(p\\)</span>。</p>\n<p><span class=\"math inline\">\\(n,m\\le 2\\times 10^5\\)</span>。</p>\n</blockquote>\n<ul>\n<li><p>发现这个问题不可二分，但根据 <span class=\"math inline\">\\(x\\)</span> 设 0/1 的想法显然可以沿用。</p></li>\n<li><p>有一个形似<a href=\"/20250819/#等差子序列\">等差子序列</a>的想法：</p>\n<p>发现对于 <span class=\"math inline\">\\(x\\)</span>，它是 0 或 1 无所谓，且两种设法中，被影响到的只有 <span class=\"math inline\">\\(x\\)</span> 这个值。</p></li>\n<li><p>故对于两种设法分别做一次，最后不同的位置即为 <span class=\"math inline\">\\(p\\)</span>。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 2e5 + 5;\nstruct &#123; int l, r, u, d; &#125; t[maxn &lt;&lt; 2];\nint a[maxn];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid pushup(int p) &#123;\n    t[p].u = t[lt].u + t[rt].u;\n    return;\n&#125;\nvoid pushdown(int p) &#123;\n    if (~t[p].d) &#123;\n        t[lt].d = t[rt].d = t[p].d;\n        t[lt].u = (t[lt].r - t[lt].l + 1) * t[p].d;\n        t[rt].u = (t[rt].r - t[rt].l + 1) * t[p].d;\n        t[p].d = -1;\n    &#125;\n    return;\n&#125;\nvoid bld(int p, int l, int r, int k) &#123;\n    t[p].l = l, t[p].r = r;\n    t[p].d = -1;\n    if (l == r) &#123;\n        t[p].u = (a[l] &gt;= k);\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid, k);\n    bld(rt, mid + 1, r, k);\n    pushup(p);\n    return;\n&#125;\nvoid upd(int p, int l, int r, int v) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        t[p].d = v;\n        t[p].u = (t[p].r - t[p].l + 1) * v;\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid)\n        upd(lt, l, r, v);\n    if (r &gt; mid)\n        upd(rt, l, r, v);\n    pushup(p);\n    return;\n&#125;\nint ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].u;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1, res = 0;\n    if (l &lt;= mid)\n        res = ask(lt, l, r);\n    if (r &gt; mid)\n        res += ask(rt, l, r);\n    return res;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m, k;\n    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;\n    std::vector&lt;int&gt; b(n + 1);\n    std::vector&lt;std::tuple&lt;int, int, int&gt; &gt; q(m);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    bld(1, 1, n, k + 1);\n    for (int i = 0, op, l, r; i &lt; m; ++i) &#123;\n        std::cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;\n        q[i] = &#123; op, l, r &#125;;\n        int t = ask(1, l, r);\n        if (op == 1) &#123;\n            t = (r - l + 1) - t;\n            if (t &gt;= 1)\n                upd(1, l, l + t - 1, 0);\n            if (l + t &lt;= r)\n                upd(1, l + t, r, 1);\n        &#125;\n        else &#123;\n            if (t &gt;= 1)\n                upd(1, l, l + t - 1, 1);\n            if (l + t &lt;= r)\n                upd(1, l + t, r, 0);\n        &#125;\n    &#125;\n    for (int i = 1; i &lt;= n; ++i)\n        b[i] = ask(1, i, i);\n    bld(1, 1, n, k);\n    for (auto &amp;[op, l, r] : q) &#123;\n        int t = ask(1, l, r);\n        if (op == 1) &#123;\n            t = (r - l + 1) - t;\n            if (t &gt;= 1)\n                upd(1, l, l + t - 1, 0);\n            if (l + t &lt;= r)\n                upd(1, l + t, r, 1);\n        &#125;\n        else &#123;\n            if (t &gt;= 1)\n                upd(1, l, l + t - 1, 1);\n            if (l + t &lt;= r)\n                upd(1, l + t, r, 0);\n        &#125;\n    &#125;\n    for (int i = 1; i &lt;= n; ++i)\n        if (ask(1, i, i) != b[i]) &#123;\n            std::cout &lt;&lt; i &lt;&lt; &#39;\\n&#39;;\n            break;\n        &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"a-simple-task\">A Simple Task</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF558E\" class=\"uri\">https://www.luogu.com.cn/problem/CF558E</a></p>\n<blockquote>\n<p>给定<strong>字符串</strong> <span class=\"math inline\">\\(s_{1\\cdots n}\\)</span>，维护 <span class=\"math inline\">\\(m\\)</span> 次操作，形如：</p>\n<ul>\n<li><code>0/1 l r</code>，将 <span class=\"math inline\">\\(s_{l\\cdots r}\\)</span> 按升序 / 降序排列。</li>\n</ul>\n<p>输出所有操作后的 <span class=\"math inline\">\\(s\\)</span>。</p>\n<p><span class=\"math inline\">\\(n\\le 10^5, m\\le 5\\times 10^4\\)</span>，<span class=\"math inline\">\\(s\\)</span> 由小写字母组成。</p>\n</blockquote>\n<ul>\n<li><p>发现需要全局查询，上面设 0/1 的套路无法沿用</p></li>\n<li><p>但发现这题本身值域就很小</p>\n<p>所以只需要开 26 个线段树，暴力按 <code>a ~ z</code> 排序，做区间覆盖即可。</p>\n<p>询问带 26 倍常数，故 <span class=\"math inline\">\\(m\\)</span> 会比 <span class=\"math inline\">\\(n\\)</span> 小。</p></li>\n</ul>\n<hr />\n<h2 id=\"from-one-to-six\">From one to six</h2>\n<p><a href=\"https://vjudge.net/problem/Gym-104254I#author=GPT_zh\" class=\"uri\">https://vjudge.net/problem/Gym-104254I#author=GPT_zh</a></p>\n<blockquote>\n<p>给定序列 <span class=\"math inline\">\\(a_{1\\cdots n}\\)</span>，<strong>只包含 <span class=\"math inline\">\\(1,2,3,4,5,6\\)</span></strong>，维护 <span class=\"math inline\">\\(m\\)</span> 次操作，形如：</p>\n<ul>\n<li><code>1 l r</code>，将 <span class=\"math inline\">\\(a_{l\\cdots r}\\)</span> 升序排列。</li>\n<li><code>2 l r</code>，输出 <span class=\"math inline\">\\([l, r]\\)</span> 内的 LIS。</li>\n</ul>\n<p>最后给定一个 <span class=\"math inline\">\\(x\\)</span>，求满足 <span class=\"math inline\">\\(a_p=x\\)</span> 的 <span class=\"math inline\">\\(p\\)</span>。</p>\n<p><span class=\"math inline\">\\(n,m\\le 2\\times 10^5\\)</span>。</p>\n</blockquote>\n<ul>\n<li><p>和上一题相似的，只需需要额外开一个新线段树记录当前的 <span class=\"math inline\">\\(a\\)</span>，同样只需区间覆盖即可。</p></li>\n<li><p>转移直接套用朴素 LIS 的 DP 方式，很容易维护。</p></li>\n</ul>\n<hr />\n<h2 id=\"philosopher\">Philosopher</h2>\n<p><a href=\"https://loj.ac/p/6189\" class=\"uri\">https://loj.ac/p/6189</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(a_{1\\cdots n}\\)</span>，维护 <span class=\"math inline\">\\(m\\)</span> 次操作，形如：</p>\n<ul>\n<li><code>1 l r 0/1</code>，将 <span class=\"math inline\">\\(a_{l\\cdots r}\\)</span> 按升序 / 降序排列。</li>\n<li><code>2 l r</code>，询问区间内元素和。</li>\n</ul>\n<p><span class=\"math inline\">\\(1\\le n,m\\le 2\\times 10^5,V=10^9\\)</span>。</p>\n</blockquote>\n<ul>\n<li><p>在线区间排序的通解：用若干个权值线段树维护连续段（递增 / 递减）。外层用一个同样支持分裂 &amp; 合并 &amp; reverse 的结构，fhq，又一个线段树什么的，记录权值线段树的分布情况及增减状态，<strong>以及每个树的元素和</strong>。</p>\n<p>这样查询时就可以通过类似分块的方法求解。</p></li>\n<li><p>对于一次排序操作只需线段树分裂 + 线段树合并。一次操作中的分裂至多增加 2 势能，合并至少减少 1 势能。线段树分裂 &amp; 合并均摊单 log，故总复杂度单 log。</p></li>\n<li><p>为何内层不用 fhq？不经过特殊处理的 fhq 在有交合并时带两只 log。</p></li>\n</ul>\n<hr />\n<h2 id=\"point-set-range-sort-range-composite\">Point Set Range Sort Range Composite</h2>\n<p><a href=\"https://vjudge.net/problem/Yosupo-point_set_range_sort_range_composite#author=GPT_zh\" class=\"uri\">https://vjudge.net/problem/Yosupo-point_set_range_sort_range_composite#author=GPT_zh</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(n\\)</span> 个二元组，由函数 <span class=\"math inline\">\\(f_{1\\cdots n}=k_i\\cdot x+b_i\\)</span> 和排序权值 <span class=\"math inline\">\\(p_{1\\cdots n}\\)</span> 组成，维护 <span class=\"math inline\">\\(m\\)</span> 次操作，形如：</p>\n<ul>\n<li><code>0 i p k b</code>，修改当前的第 <span class=\"math inline\">\\(i\\)</span> 个元素的 <span class=\"math inline\">\\(f_i\\)</span> 和 <span class=\"math inline\">\\(p_i\\)</span>。</li>\n<li><code>1 l r x</code>，询问 <span class=\"math inline\">\\(f_{r-1}(f_{r-2}(\\cdots f_l(x)))\\bmod 998244353\\)</span>。</li>\n<li><code>2/3 l r</code>，将当前第 <span class=\"math inline\">\\(l\\sim r\\)</span> 个元素按照 <span class=\"math inline\">\\(p\\)</span> 值升序 / 降序排列。</li>\n</ul>\n<p><span class=\"math inline\">\\(1\\le n,m\\le 10^5,V=10^9\\)</span>。保证任意时刻，每个 <span class=\"math inline\">\\(p_i\\)</span> 互不相同。</p>\n</blockquote>\n<ul>\n<li>和上一题没什么本质区别，换成了维护矩阵而已。额外注意矩阵 + reverse 的那些东西即可。</li>\n</ul>\n<hr />\n<h2 id=\"齐齐排序\">齐齐排序</h2>\n<p><a href=\"https://ac.nowcoder.com/acm/problem/21439\" class=\"uri\">https://ac.nowcoder.com/acm/problem/21439</a></p>\n<blockquote>\n<p>给定序列 <span class=\"math inline\">\\(a_{1\\cdots n}\\)</span>，维护 <span class=\"math inline\">\\(m\\)</span> 次操作，形如：</p>\n<ul>\n<li><p><code>0 x</code>，将 <span class=\"math inline\">\\(a_{1\\cdots x}\\)</span> 按降序排列。</p></li>\n<li><p><code>1 x</code>，将 <span class=\"math inline\">\\(a_{1\\cdots x}\\)</span> 按升序排列。</p></li>\n</ul>\n<p>输出操作完成后的序列。</p>\n<p><span class=\"math inline\">\\(n,m\\le 2\\times 10^5,V=10^9\\)</span>。</p>\n</blockquote>\n<ul>\n<li><p>诈骗题</p></li>\n<li><p>发现只存在前缀操作，显然 <span class=\"math inline\">\\(x\\)</span> 较大的会覆盖 <span class=\"math inline\">\\(x\\)</span> 较小的操作</p>\n<p>容易发现有效操作的 <span class=\"math inline\">\\(x\\)</span> 形成一个后缀最大值序列。用这些操作给数打升序 / 降序标记。</p></li>\n<li><p>先填完没有被操作过的位置（显然这样的位置在序列末），然后用一个 <code>multiset</code> 装剩下所有数。倒序遍历还未填的位置，若这个位置上的标记是升序，则填最大值；否则填最小值。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; q(m + 1);\n    for (int i = 1; i &lt;= m; ++i)\n        std::cin &gt;&gt; q[i].first &gt;&gt; q[i].second;\n    int mx = 0;\n    std::vector&lt;int&gt; tag(n + 1);\n    for (int i = m; i; --i)\n        if (q[i].second &gt; mx) &#123;\n            mx = q[i].second;\n            tag[q[i].second] = q[i].first;\n        &#125;\n    std::multiset&lt;int&gt; t;\n    for (int i = 1; i &lt;= mx; ++i)\n        t.insert(a[i]);\n    for (int i = mx, st = 0; i; --i) &#123;\n        if (tag[i])\n            st = tag[i];\n        if (st == 1)\n            a[i] = *--t.end(), t.erase(--t.end());\n        else\n            a[i] = *t.begin(), t.erase(t.begin());\n    &#125;\n    for (int i = 1; i &lt;= n; ++i)\n        std::cout &lt;&lt; a[i] &lt;&lt; &#39; &#39;;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"정렬-게임\">정렬 게임</h2>\n<p><a href=\"https://vjudge.net/problem/Baekjoon-13415#author=GPT_zh\" class=\"uri\">https://vjudge.net/problem/Baekjoon-13415#author=GPT_zh</a></p>\n<blockquote>\n<p>给定序列 <span class=\"math inline\">\\(a_{1\\cdots n}\\)</span>，维护 <span class=\"math inline\">\\(m\\)</span> 次操作，形如：</p>\n<ul>\n<li><code>x y</code>，将 <span class=\"math inline\">\\(a_{1\\cdots x}\\)</span> 按升序排列，接着，对 <span class=\"math inline\">\\(a_{1\\cdots y}\\)</span> 按降序排列。</li>\n</ul>\n<p>输出操作完成后的序列。</p>\n<p><span class=\"math inline\">\\(n,m\\le 10^5,|V|=10^4\\)</span>。</p>\n</blockquote>\n<ul>\n<li>发现这个题严格弱于上一个题，没啥说的。</li>\n</ul>\n<hr />\n<h2 id=\"入れ替えと並び替え\">入れ替えと並び替え</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_past202005_n\" class=\"uri\">https://www.luogu.com.cn/problem/AT_past202005_n</a></p>\n<blockquote>\n<p>给定序列 <span class=\"math inline\">\\(a_{1\\cdots n}\\)</span>，<strong>初始为 <span class=\"math inline\">\\(1,2,\\cdots,n\\)</span></strong>，维护 <span class=\"math inline\">\\(m\\)</span> 次操作，形如：</p>\n<ul>\n<li><p><code>0 x</code>，交换 <span class=\"math inline\">\\(a_x\\)</span> 与 <span class=\"math inline\">\\(a_{x+1}\\)</span>。</p></li>\n<li><p><code>1 l r</code>，将 <span class=\"math inline\">\\(a_{l\\cdots r}\\)</span> 按升序排列。</p></li>\n</ul>\n<p>输出操作完成后的序列。</p>\n<p><span class=\"math inline\">\\(n,m\\le 2\\times 10^5\\)</span>。</p>\n</blockquote>\n<ul>\n<li><p>诈骗题⨉2</p></li>\n<li><p>初始是有序的，保证了仅需要复原被打乱的项即可完成排序。</p></li>\n<li><p>维护每次<strong>交换</strong>在 <span class=\"math inline\">\\((x-1,x)\\)</span>、<span class=\"math inline\">\\((x,x+1)\\)</span>、<span class=\"math inline\">\\((x+1,x+2)\\)</span> 三个位置创建 / 删除的逆序对。</p>\n<p>手玩发现操作给出的<strong>交换</strong>和目的为复原的<strong>交换</strong>都有可能带来新的逆序对。考虑势能分析。</p>\n<p>操作给出的<strong>交换</strong>至多增加一个逆序对（势能），而一次目的为复原的<strong>交换</strong>至少减少一个逆序对（势能）。</p>\n<p>故直接暴力复原范围内逆序对，复杂度 <span class=\"math inline\">\\(O(Q\\log Q)\\)</span>。</p></li>\n</ul>\n<hr />\n<h2 id=\"双向排序\">双向排序</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P8747\" class=\"uri\">https://www.luogu.com.cn/problem/P8747</a></p>\n<blockquote>\n<p>给定排列 <span class=\"math inline\">\\(a_{1\\cdots n}\\)</span>，<strong>初始为 <span class=\"math inline\">\\(1,2,\\cdots,n\\)</span></strong>，维护 <span class=\"math inline\">\\(m\\)</span> 次操作，形如：</p>\n<ul>\n<li><p><code>0 x</code>，将 <span class=\"math inline\">\\(a_{1\\cdots x}\\)</span> 按降序排列。</p></li>\n<li><p><code>1 x</code>，将 <span class=\"math inline\">\\(a_{x\\cdots n}\\)</span> 按升序排列。</p></li>\n</ul>\n<p>输出操作完成后的序列。</p>\n<p><span class=\"math inline\">\\(n,m\\le 2\\times 10^5\\)</span>。</p>\n</blockquote>\n<ul>\n<li><p>发现题目给的限制非常有意思，保证了最终序列一定满足前半截降序，后半截升序。</p></li>\n<li><p>需要发现一个可怕的事实：操作相当于选取分割点 <span class=\"math inline\">\\(pos\\)</span> 左 / 右侧最小的数并挪到对侧。</p>\n<p>维护每个点的 0/1 状态，线段树上二分并区间推平即可。</p></li>\n<li><p>另一个很强的线性做法：只维护 <span class=\"math inline\">\\(pos\\)</span> 左边的点值，那么操作可以看作：</p>\n<p>加入若干个最小的、不存在于左边的点 / 删除若干个存在于左边，且最小的点</p></li>\n<li><p>用栈维护左边从小到大的所有连续段，每次加点暴力合并，删点则暴力删</p>\n<p>发现加点只会增加最多一个连续段，且枚举连续段合并之后会减少对应的势能；删点同理。</p>\n<p>故均摊线性。</p></li>\n</ul>\n",
            "tags": [
                "线段树"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20251104/",
            "url": "https://xsc062.netlify.app/20251104/",
            "title": "杂题选谈",
            "date_published": "2025-11-04T07:01:11.000Z",
            "content_html": "<p>这么爱计数</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a.-图-hdu4903-the-only-survival\">A. 图 / HDU4903 The only survival</h2>\n<p><a href=\"https://vjudge.net/problem/HDU-4903#author=DeepSeek_zh\" class=\"uri\">https://vjudge.net/problem/HDU-4903#author=DeepSeek_zh</a></p>\n<ul>\n<li><p>很容易想到基于按 dis 从小到大枚举的做法</p>\n<p>但是发现算方案就必须要知道每个点的具体 dis，就导致难以 DP，只能搜索，这样复杂度就不太好看。</p></li>\n<li><p>一个显然的观察：<strong>并不关心 <span class=\"math inline\">\\(1,n\\)</span> 以外点的标号</strong>，所以可以把 <span class=\"math inline\">\\(O(n^k)\\)</span> 的暴搜优化到 <span class=\"math inline\">\\(O(\\binom{n+k}k\\cdot (n+k))\\)</span>，然后做多重集排列即可。</p>\n<p>模数非质时的多重集排列：<a href=\"/20231117/#数学\">link</a></p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;graph.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;graph.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, k, L, mod;\n    std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; L &gt;&gt; mod;\n    if (L &lt; k) &#123;\n        std::cout &lt;&lt; 0 &lt;&lt; &#39;\\n&#39;;\n        return 0;\n    &#125;\n    std::vector&lt;std::vector&lt;long long&gt; &gt; C(n + 1, std::vector&lt;long long&gt; (n + 1));\n    C[0][0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        C[i][0] = 1ll;\n        for (int j = 1; j &lt;= i; ++j)\n            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;\n    &#125;\n    std::vector&lt;int&gt; dis(n + 1), s;\n    int res = 0;\n    std::function&lt;void(int, int, long long)&gt; DFS = [&amp;](int x, int d, long long now) &#123;\n        if (x == n) &#123;\n            auto s0 = now, s1 = now;\n            for (int i = 1; i &lt; n; ++i)\n                if (dis[i] &gt;= k)\n                    (s0 *= L) %= mod, (s1 *= L) %= mod;\n                else if (L - (k - dis[i] - 1)) &#123;\n                    (s0 *= L - (k - dis[i] - 1)) %= mod;\n                    (s1 *= L - (k - dis[i] - 1) - 1) %= mod;\n                &#125;\n                else &#123;\n                    s0 = s1 = 0ll;\n                    break;\n                &#125;\n            dis[x] = k;\n            auto u = 1ll;\n            int cnt = n - 2;\n            for (auto i : s)\n                (u *= C[cnt][i]) %= mod, cnt -= i;\n            (res += u * (s0 + mod - s1) % mod) %= mod;\n            return;\n        &#125;\n        for (int i = d; i &lt;= k + 1; ++i) &#123;\n            auto s0 = now, s1 = now;\n            for (int j = 1; j &lt; x; ++j)\n                if (dis[j] &gt;= i)\n                    (s0 *= L) %= mod, (s1 *= L) %= mod;\n                else if (L - (i - dis[j] - 1)) &#123;\n                    (s0 *= L - (i - dis[j] - 1)) %= mod;\n                    (s1 *= L - (i - dis[j] - 1) - 1) %= mod;\n                &#125;\n                else &#123;\n                    s0 = s1 = 0ll;\n                    break;\n                &#125;\n            dis[x] = i;\n            if (dis[x] != dis[x - 1])\n                s.push_back(1);\n            else\n                ++s.back();\n            if (i == k + 1)\n                s1 = 0ll;\n            DFS(x + 1, i, (s0 + mod - s1) % mod);\n            if (dis[x] != dis[x - 1])\n                s.pop_back();\n            else\n                --s.back();\n        &#125;\n        return;\n    &#125;;\n    DFS(2, 1, 1);\n    std::cout &lt;&lt; res % mod &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b.-路线-arc136e-non-coprime-dag\">B. 路线 / ARC136E Non-coprime DAG</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_arc136_e\" class=\"uri\">https://www.luogu.com.cn/problem/AT_arc136_e</a></p>\n<ul>\n<li><p>做过 <a href=\"https://www.luogu.com.cn/problem/CF870F\">CF870F Paths</a> 可以很快反应过来：<span class=\"math inline\">\\(x\\)</span> 和 <span class=\"math inline\">\\(y\\)</span> 是否可以同时被选，取决于它们各自的最小质因子是否能在 <span class=\"math inline\">\\(x,y\\)</span> 之间交汇（或用 <span class=\"math inline\">\\(2\\)</span> 作跳板）。</p>\n<p>接着就发现由于 <span class=\"math inline\">\\(2\\)</span> 间隔出现，此时再分奇偶性就会显得非常合理。</p></li>\n<li><p>两个偶数总是不能同时被选；对于奇数 <span class=\"math inline\">\\(x\\)</span> 和偶数 <span class=\"math inline\">\\(y\\)</span>，要求 <span class=\"math inline\">\\(y\\in [x-f(x)+1,x+f(x)-1]\\)</span>。</p></li>\n<li><p>考察奇数的选取。容易发现，钦定用 <span class=\"math inline\">\\(2\\)</span> 作跳板，则两个奇数 <span class=\"math inline\">\\(x,y(x&lt;y)\\)</span> 能同时被选，当且仅当：</p>\n<ul>\n<li>记 <span class=\"math inline\">\\(f(i)\\)</span> 为 <span class=\"math inline\">\\(i\\)</span> 的最小质因子，则 <span class=\"math inline\">\\(x+f(x)&gt; y-f(y)\\)</span>。</li>\n</ul>\n<p>发现实际上可以认为 <span class=\"math inline\">\\(x\\)</span> 代表区间 <span class=\"math inline\">\\([x-f(x),x+f(x)-1]\\)</span>。那么两个点可以同时被选当且仅当它们代表的区间有交（这样就去掉了 <span class=\"math inline\">\\(x,y\\)</span> 之间的偏序条件）</p>\n<p>这样发现对『代表区间』的定义，在奇数视角和偶数视角下是冲突的，可以发现偶数视角的区间更紧；事实上，应该采用 <span class=\"math inline\">\\([x-f(x)+1,x+f(x)-1]\\)</span> 这个看似充分不必要的定义，因为端点总是奇数，导致 <span class=\"math inline\">\\(x+f(x)&gt; y-f(y)\\)</span> 和 <span class=\"math inline\">\\(x+f(x)-1&lt;y-f(y)+1\\)</span> 不能同时成立。</p></li>\n<li><p>进一步推广结论，容易发现多个奇数可以同时被选，当且仅当它们代表的区间有交。故可以枚举值域中的点，找加权覆盖次数最大值。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; fac(n + 1), l(n + 1), r(n + 1);\n    for (int i = 2; i &lt;= n; ++i) &#123;\n        if (!fac[i]) &#123;\n            fac[i] = i;\n            for (int j = 2 * i; j &lt;= n; j += i)\n                if (!fac[j])\n                   fac[j] = i;\n        &#125;\n        l[i] = std::max(1, i - fac[i] + 1);\n        r[i] = std::min(i + fac[i] - 1, n);\n    &#125;\n    std::vector&lt;int&gt; a(n + 1);\n    std::vector&lt;long long&gt; dif(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        if (i == 1 || i % 2 == 0)\n            continue;\n        dif[l[i]] += a[i];\n        if (r[i] != n)\n            dif[r[i] + 1] -= a[i];\n    &#125;\n    auto res = 0ll;\n    std::partial_sum(dif.begin(), dif.end(), dif.begin());\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        auto now = a[1] + dif[i];\n        if (i % 2 == 0)\n            now += a[i];\n        res = std::max(res, now);\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"a.-列车扫除\">A. 列车扫除</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6708/problem/1\" class=\"uri\">https://www.becoder.com.cn/contest/6708/problem/1</a></p>\n<blockquote>\n<p>绝对聪明的 A, B, C 在一起玩 Nim，有三堆石子 <span class=\"math inline\">\\(c_{1,2,3}\\)</span>，每次可以任选一堆拿走正整数个，不能拿的人扣一分，他的上一个人加一分。</p>\n<p>给定 <span class=\"math inline\">\\(q\\)</span> 次询问，形如：</p>\n<ul>\n<li>现在知道 <span class=\"math inline\">\\(\\forall \\, i=1,2,3,c_i\\in[l_i,r_i]\\)</span>。对于这 <span class=\"math inline\">\\(\\prod_{i=1,2,3}r_i-l_i+1\\)</span> 种可能的情况，对于每个人，求出分数之和。</li>\n</ul>\n<p><span class=\"math inline\">\\(q\\le 10^6,V=10^9\\)</span>。</p>\n</blockquote>\n<ul>\n<li><p>容易发现，胜，平，负三个状态会被分给三个人，且一共只有三种分配方式。</p></li>\n<li><p>当只剩一堆石头时，操作者胜；石头状态为 <span class=\"math inline\">\\((0,1,1)\\)</span> 时，操作者负。</p></li>\n</ul>\n<hr />\n<h2 id=\"b.-换来换去\">B. 换来换去</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6708/problem/2\" class=\"uri\">https://www.becoder.com.cn/contest/6708/problem/2</a></p>\n<blockquote>\n<p>对 <span class=\"math inline\">\\(n\\)</span> 个有标号的球任意分成任意组，组是无顺序的，且要求每组球个数 <span class=\"math inline\">\\(\\ge 2\\)</span>，求方案数，对质数取模。</p>\n<p><span class=\"math inline\">\\(n\\le 10^7\\)</span>。</p>\n</blockquote>\n<ul>\n<li><p>发现这是一个类斯特林数的问题，二项式反演得到答案式为：</p>\n<p><span class=\"math display\">\\[\n\\sum_{i=0}^n (-1)^{n-i}\\binom ni \\sum_{j=0}^i \\begin{Bmatrix} i\\\\ j\\end{Bmatrix}\n\\]</span></p>\n<p>用斯特林数通项展开：</p>\n<p><span class=\"math display\">\\[\n\\sum_{i=0}^n (-1)^{n-i}\\binom ni \\sum_{j=0}^i \\sum_{k=0}^j(-1)^{j-k}\\dfrac {k^i}{(j-k)!\\cdot k!}\n\\]</span></p>\n<p>很容易注意到一个二项式定理的结构，故交换求和顺序：</p>\n<p><span class=\"math display\">\\[\n\\sum_{j=0}^n \\sum_{k=0}^j \\dfrac {(-1)^{j-k}}{(j-k)!\\cdot k!}\\cdot \\sum_{i=j}^n \\binom ni (-1)^{n-i}k^i\n\\]</span></p>\n<p>发现一个很严重的问题在于 <span class=\"math inline\">\\(i\\)</span> 的起始范围是 <span class=\"math inline\">\\(j\\)</span> 而不是 <span class=\"math inline\">\\(0\\)</span>，但如果我们把一开始的式子改写成这样：</p>\n<p><span class=\"math display\">\\[\n\\sum_{i=0}^n (-1)^{n-i}\\binom ni \\sum_{j=0}^n \\begin{Bmatrix} i\\\\ j\\end{Bmatrix}\n\\]</span></p>\n<p>容易发现当 <span class=\"math inline\">\\(j&gt;i\\)</span> 时 <span class=\"math inline\">\\(\\begin{Bmatrix} i\\\\ j\\end{Bmatrix}=0\\)</span>，和原式的值相同，且斯特林数通项对于 <span class=\"math inline\">\\(j&gt;i\\)</span> 也是成立的，故原式等价于</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\n&amp;\\sum_{j=0}^n \\sum_{k=0}^j \\dfrac {(-1)^{j-k}}{(j-k)!\\cdot k!}\\cdot \\sum_{i=0}^n \\binom ni (-1)^{n-i}k^i\\\\\n=&amp;\\sum_{j=0}^n \\sum_{k=0}^j \\dfrac {(-1)^{j-k}}{(j-k)!\\cdot k!}\\cdot (k-1)^n\\\\\n=&amp;\\sum_{k=0}^n \\dfrac {(k-1)^n}{k!}\\cdot \\sum_{j=0}^{n-k} \\dfrac {(-1)^j}{j!}\\\\\n\\end{aligned}\n\\]</span></p>\n<p>后者内部与 <span class=\"math inline\">\\(k\\)</span> 无关，是可前缀和计算的，只需要考虑在 <span class=\"math inline\">\\(O(1)\\)</span> 内求出 <span class=\"math inline\">\\((k-1)^n\\)</span> 的值，筛一下，对于质数（约 <span class=\"math inline\">\\(\\dfrac n{\\ln n}\\)</span> 个）快速幂，合数用积性函数之类即可。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;card.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;card.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, mod;\n        std::cin &gt;&gt; n &gt;&gt; mod;\n        std::vector&lt;int&gt; tag(n + 1), p, pw(n + 1);\n        auto qkp = [&amp;](long long x, int y) &#123;\n            auto res = 1ll;\n            for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n                if (y &amp; 1)\n                    (res *= x) %= mod;\n            return res;\n        &#125;;\n        pw[1] = 1ll;\n        for (int i = 2; i &lt;= n; ++i) &#123;\n            if (!tag[i]) &#123;\n                pw[i] = qkp(i, n);\n                p.push_back(i);\n            &#125;\n            for (auto j : p) &#123;\n                if (i &gt; n / j)\n                    break;\n                tag[i * j] = 1;\n                pw[i * j] = (long long)pw[i] * pw[j] % mod;\n                if (i % j == 0)\n                    break;\n            &#125;\n        &#125;\n        std::vector&lt;int&gt; inv(n + 1), s(n + 1);\n        inv[0] = 1ll;\n        for (int j = 1; j &lt;= n; ++j)\n            inv[j] = (long long)inv[j - 1] * j % mod;\n        inv[n] = qkp(inv[n], mod - 2);\n        for (int j = n - 1; j; --j)\n            inv[j] = (long long)inv[j + 1] * (j + 1) % mod;\n        s[0] = inv[0];\n        for (int j = 1; j &lt;= n; ++j) &#123;\n            if (j &amp; 1)\n                s[j] = s[j - 1] + mod - inv[j];\n            else\n                s[j] = s[j - 1] + inv[j];\n            if (s[j] &gt;= mod)\n                s[j] -= mod;\n        &#125;\n        auto res = (long long)s[n] * ((n &amp; 1) ? mod - 1 : 1);\n        for (int k = 1; k &lt;= n; ++k)\n            res += (long long)pw[k - 1] * inv[k] % mod * s[n - k] % mod;\n        std::cout &lt;&lt; res % mod &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c.-画家\">C. 画家</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6714/problem/3\" class=\"uri\">https://www.becoder.com.cn/contest/6714/problem/3</a></p>\n<ul>\n<li><p>ARC 特供删十字，故时光倒流，转化成在图上删相同颜色的十字 / 行 / 列。</p></li>\n<li><p>令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示合法的 <span class=\"math inline\">\\(i\\)</span> 行 <span class=\"math inline\">\\(j\\)</span> 列地图。发现同颜色的删行 + 删列会和直接删十字算重，</p></li>\n</ul>\n<hr />\n<h2 id=\"b.-灯光秀-cf1545c-aquamoon-and-permutations\">B. 灯光秀 / CF1545C AquaMoon and Permutations</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1545C\" class=\"uri\">https://www.luogu.com.cn/problem/CF1545C</a></p>\n<ul>\n<li><p>第一步需要想到，如果某一列的某个数，只有一个排列有，那么这个排列必须被选入拉丁方；</p>\n<p>用这个必选的排列，可以排除掉一些与之冲突、不能选入拉丁方的排列。</p></li>\n<li></li>\n</ul>\n<hr />\n<h2 id=\"a.-bot-的能量堆\">A. bot 的能量堆</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6731/problem/1\" class=\"uri\">https://www.becoder.com.cn/contest/6731/problem/1</a></p>\n<blockquote>\n<p>⚡<strong>超越一切震慑凡人</strong>⚡</p>\n<p>给定正整数 <span class=\"math inline\">\\(x,y\\)</span>，你可以执行下面三种操作：</p>\n<ol type=\"1\">\n<li>将 <span class=\"math inline\">\\(x,y\\)</span> 同时加 1；</li>\n<li>将 <span class=\"math inline\">\\(x,y\\)</span> 同时减一；</li>\n<li>对于 <span class=\"math inline\">\\(\\gcd(x,y)\\)</span> 的一个质因子 <span class=\"math inline\">\\(p\\)</span>，将 <span class=\"math inline\">\\(x,y\\)</span> 同时除以 <span class=\"math inline\">\\(p\\)</span>。</li>\n</ol>\n<p>问最少花费多少次操作使得 <span class=\"math inline\">\\(\\min(x,y)=1\\)</span>。多测。</p>\n<p><span class=\"math inline\">\\(T\\le 300,1\\le x,y\\le 10^9\\)</span>。</p>\n</blockquote>\n<ul>\n<li><p>不妨先考虑 <span class=\"math inline\">\\(x\\ne y\\)</span> 的情况，发现三种操作都不会使 <span class=\"math inline\">\\(x,y\\)</span> 的相对大小关系改变。故令 <span class=\"math inline\">\\(x&lt;y\\)</span>，考虑让 <span class=\"math inline\">\\(x\\)</span> 变为 1。</p></li>\n<li><p>记 <span class=\"math inline\">\\(d=y-x\\)</span>， 很容易注意到 <span class=\"math inline\">\\(d\\)</span> 的值不会在前两种操作中改变，由辗转相减，<span class=\"math inline\">\\(\\gcd(x,y)=\\gcd(d, x)\\)</span>，即操作三每次选取的 <span class=\"math inline\">\\(p\\)</span> 总是 <span class=\"math inline\">\\(d\\)</span> 的质因子，且总能通过若干次操作 1/2 让 <span class=\"math inline\">\\(p\\)</span> 能够执行。</p>\n<p>每次执行操作 3 后，<span class=\"math inline\">\\(d\\gets d\\div p\\)</span>，每次只需让 <span class=\"math inline\">\\(x\\)</span> 变为 <span class=\"math inline\">\\(\\lfloor \\frac xp\\rfloor\\)</span> 或 <span class=\"math inline\">\\(\\lceil \\frac xp\\rceil\\)</span>。</p>\n<p>直接记搜的话，容易发现状态总数是 V 因数总数。</p></li>\n<li><p>对于 <span class=\"math inline\">\\(x=y\\)</span> 的情况，答案至多为 <span class=\"math inline\">\\(x\\)</span> 的质因子数量。暴搜 + 剪枝非常可过。</p>\n<details>\n<p><summary>有一种神秘的处理方式…</summary></p>\n<pre class=\"cpp\"><code>if (x == y) &#123;\n    auto calc = [&amp;](int x) &#123;\n        int cnt = 0;\n        for (int i = 2; i * i &lt;= x; ++i)\n            for (; x % i == 0; ++cnt, x /= i);\n        return cnt + (x != 1);\n    &#125;;\n    int to = calc(x), res = to;\n    for (int i = std::max(x - to, 1); i &lt;= x + to; ++i)\n        res = std::min(res, calc(i) + std::abs(i - x));\n    std::cout &lt;&lt; x &lt;&lt; &#39;\\n&#39;;\n    continue;\n&#125;</code></pre>\n<p>容易发现这东西没什么道理，反例大概率存在但在小范围内确实难以构造。总之数据没卡到。</p>\n</details></li>\n</ul>\n<hr />\n<h2 id=\"b.-bot-的矩阵\">B. bot 的矩阵</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6731/problem/2\" class=\"uri\">https://www.becoder.com.cn/contest/6731/problem/2</a></p>\n<blockquote>\n<p><strong>⚡带来终结机械降神⚡</strong></p>\n<p>有一个 <span class=\"math inline\">\\(n\\times n\\)</span> 的二维数组，初始只知道 <span class=\"math inline\">\\(m\\)</span> 个位置的数 <span class=\"math inline\">\\(a_{x,y}\\)</span>，以及每行、每列的元素和 <span class=\"math inline\">\\(sx_{1\\cdots n},sy_{1\\cdots n}\\)</span>。</p>\n<p>构造出一个合法的解，每个数在 <span class=\"math inline\">\\([-2^63,2^63)\\)</span> 内。</p>\n<p><span class=\"math inline\">\\(n\\le 2000\\)</span>,<span class=\"math inline\">\\(a_{x,y},sx_i,sy_i\\in [-10^9,10^9]\\)</span>，<span class=\"math inline\">\\(m\\le n^2\\)</span>。</p>\n</blockquote>\n<ul>\n<li><p>听说很容易想到二分图，但实在反应不过来。但在乱填的时候发现，如果出现了『必填』的情况，是一个行列交错的链式反应，这样就很容易想到二分图了</p>\n<p>原理是同时影响行 <span class=\"math inline\">\\(i\\)</span> 列 <span class=\"math inline\">\\(j\\)</span> 的元素只有 <span class=\"math inline\">\\((i, j)\\)</span></p></li>\n<li><p>相当于给一个 <span class=\"math inline\">\\(2n\\)</span> 个点 <span class=\"math inline\">\\(n^2\\)</span> 条边的二分图，其中一些边权是已知的，那么不妨认为这些边被删除了</p>\n<p>同时也是一个 <span class=\"math inline\">\\(n^2\\)</span> 个元，<span class=\"math inline\">\\(2n-1\\)</span> 个方程的方程组（<span class=\"math inline\">\\(sx=sy\\)</span> 会消掉一条方程）；故很多元其实可以直接赋 <span class=\"math inline\">\\(0\\)</span>，只拿 <span class=\"math inline\">\\(2n-1\\)</span> 个元出来解方程。</p></li>\n<li><p>在挖掉已知边的二分图上任意找生成树（森林）就可以满足 <span class=\"math inline\">\\(2n-1\\)</span> 的限制，结合树上高斯消元，从叶子开始解方程即可。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\n#define int long long\n#define nec getchar\nvoid read(int &amp;x) &#123;\n    x = 0;\n    char ch = nec();\n    bool flag = false;\n    for (; ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;; ch = nec())\n        if (ch == &#39;-&#39;)\n            flag = true;\n    for (; ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;; ch = nec())\n        x = x * 10 + ch - &#39;0&#39;;\n    if (flag)\n        x = -x;\n    return;\n&#125;\nsigned main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;matrix3.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    for (read(T); T--; ) &#123;\n        int n, m;\n        read(n), read(m);\n        std::vector&lt;int&gt; sx(n + 1), sy(n + 1);\n        for (int i = 1; i &lt;= n; ++i)\n            read(sx[i]);\n        for (int i = 1; i &lt;= n; ++i)\n            read(sy[i]);\n        std::vector&lt;std::vector&lt;int&gt; &gt; vis(n + 1, std::vector&lt;int&gt; (n + 1));\n        std::vector&lt;std::vector&lt;long long&gt; &gt; a(n + 1, std::vector&lt;long long&gt; (n + 1));\n        std::vector&lt;int&gt; tx(n + 1), ty(n + 1);\n        auto work = [&amp;](int i, int j, int c) &#123;\n            vis[i][j] = 1;\n            ++tx[i], ++ty[j];\n            sx[i] -= c, sy[j] -= c, a[i][j] = c;\n            return;\n        &#125;;\n        for (int x, y, c; m--; ) &#123;\n            read(x), read(y), read(c);\n            work(x, y, c);\n        &#125;\n        if (std::accumulate(sx.begin() + 1, sx.end(), 0ll) != std::accumulate(sy.begin() + 1, sy.end(), 0ll)) &#123;\n            std::cout &lt;&lt; &quot;NoSolution!&quot; &lt;&lt; &#39;\\n&#39;;\n            continue;\n        &#125;\n        std::vector&lt;int&gt; fx(n + 1), fy(n + 1);\n        std::function&lt;bool(void)&gt; check = [&amp;](void) &#123;\n            for (int x = 1; x &lt;= n; ++x)\n                if (!fx[x]) &#123;\n                    if (tx[x] == n) &#123;\n                        if (sx[x] != 0)\n                            return false;\n                        fx[x] = 1;\n                        if (!check())\n                            return false;\n                    &#125;\n                    else if (tx[x] == n - 1) &#123;\n                        for (int y = 1; y &lt;= n; ++y)\n                            if (!vis[x][y]) &#123;\n                                work(x, y, sx[x]);\n                                fx[x] = 1;\n                                if (!check())\n                                    return false;\n                            &#125;\n                    &#125;\n                &#125;\n            for (int y = 1; y &lt;= n; ++y)\n                if (!fy[y]) &#123;\n                    if (ty[y] == n) &#123;\n                        if (sy[y] != 0)\n                            return false;\n                        fy[y] = 1;\n                        if (!check())\n                            return false;\n                    &#125;\n                    else if (ty[y] == n - 1) &#123;\n                        for (int x = 1; x &lt;= n; ++x)\n                            if (!vis[x][y]) &#123;\n                                work(x, y, sy[y]);\n                                fy[y] = 1;\n                                if (!check())\n                                    return false;\n                            &#125;\n                    &#125;\n                &#125;\n            return true;\n        &#125;;\n        if (!check()) &#123;\n            std::cout &lt;&lt; &quot;NoSolution!&quot; &lt;&lt; &#39;\\n&#39;;\n            continue;\n        &#125;\n        std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int op) &#123;\n            if (op == 0) &#123;\n                fx[x] = 1;\n                for (int i = 1; i &lt;= n; ++i)\n                    if (!vis[x][i] &amp;&amp; !fy[i]) &#123;\n                        DFS(i, 1);\n                        work(x, i, sy[i]);\n                    &#125;\n            &#125;\n            else &#123;\n                fy[x] = 1;\n                for (int i = 1; i &lt;= n; ++i)\n                    if (!vis[i][x] &amp;&amp; !fx[i]) &#123;\n                        DFS(i, 0);\n                        work(i, x, sx[i]);\n                    &#125;\n            &#125;\n            return;\n        &#125;;\n        for (int i = 1; i &lt;= n; ++i)\n            if (!fx[i])\n                DFS(i, 0);\n        for (int i = 1; i &lt;= n; ++i)\n            if (!fy[i])\n                DFS(i, 1);\n        std::cout &lt;&lt; &quot;Botany!&quot; &lt;&lt; &#39;\\n&#39;;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            for (int j = 1; j &lt;= n; ++j)\n                std::cout &lt;&lt; a[i][j] &lt;&lt; &#39; &#39;;\n            std::cout &lt;&lt; &#39;\\n&#39;;\n        &#125;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"a.-数码串\">A. 数码串</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6736/problem/1\" class=\"uri\">https://www.becoder.com.cn/contest/6736/problem/1</a></p>\n<blockquote>\n<p>给定一个长度为 <span class=\"math inline\">\\(n\\)</span> 的数字串，现在需要给它分为若干段，问在所有 <span class=\"math inline\">\\(2^{n-1}\\)</span> 种分段方式中，有多少种满足：</p>\n<ul>\n<li>在任意相邻的两段中，有至少一段，其对应的十进制数是 <span class=\"math inline\">\\(D\\)</span> 的倍数。</li>\n</ul>\n<p>答案对 <span class=\"math inline\">\\(10^9+7\\)</span> 取模。</p>\n<p>多测，<span class=\"math inline\">\\(n\\le 2\\times 10^5,D\\le 10^6,T\\le 100\\)</span>。</p>\n<p><strong>部分分特殊性质</strong>：<span class=\"math inline\">\\(\\gcd(D,10)=1\\)</span>。</p>\n</blockquote>\n<ul>\n<li><p>发现若 <span class=\"math inline\">\\(a_{l\\cdots r}\\)</span> 是 <span class=\"math inline\">\\(D\\)</span> 的倍数，记 <span class=\"math inline\">\\(s_i=s_{i+1}+a_i\\times 10^{n-i}\\)</span>，那么 <span class=\"math inline\">\\(\\dfrac{s_l-s_{r+1}}{10^{n-r}}\\bmod D=0\\)</span></p>\n<p>题目要求，这个转移点和上个转移点，至少有一个满足该式。显然可以类 DP 地做。</p></li>\n<li><p>对于 <span class=\"math inline\">\\(D\\)</span> 与 <span class=\"math inline\">\\(10\\)</span> 互质的情况，原条件等价于 <span class=\"math inline\">\\(s_l\\equiv s_{r+1}\\pmod D\\)</span>，用一个桶记录 DP 值即可</p></li>\n<li><p>记 <span class=\"math inline\">\\(D=2^*\\times 5^?\\times m\\)</span>，发现 <span class=\"math inline\">\\(m\\)</span> 与 <span class=\"math inline\">\\(10\\)</span> 互质，或许可以套用上方的做法</p>\n<p><mark>由于 <span class=\"math inline\">\\(D\\le 10^6 &lt; 2^{20}\\)</span>，对于一个固定的 <span class=\"math inline\">\\(r\\)</span>，所有 <span class=\"math inline\">\\(l\\le r-20\\)</span> 项的 <span class=\"math inline\">\\(a_l\\)</span> 对 <span class=\"math inline\">\\(a_{l\\cdots r}\\bmod (2^*\\times 5^?)\\)</span> 的贡献总是 <span class=\"math inline\">\\(0\\)</span></mark>，故在只考虑 <span class=\"math inline\">\\(2^*\\times 5^?\\)</span> 时， <span class=\"math inline\">\\(l\\le r-20\\)</span> 的可选性和 <span class=\"math inline\">\\(l=r-20\\)</span> 的可选性相同。只需要对于 <span class=\"math inline\">\\(\\bmod m\\)</span> 沿用桶做法即可。</p>\n<p>对于 <span class=\"math inline\">\\(l\\ge r-20\\)</span>，暴力即可，复杂度 <span class=\"math inline\">\\(O(T(n+D))\\)</span>。</p></li>\n</ul>\n<details>\n<p>注意 <span class=\"math inline\">\\(s_l-s_{r+1}\\)</span> 里的 <span class=\"math inline\">\\(r+1\\)</span>，调成鸲了</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;digit.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;digit.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;./test/20251113/digit/ex_digit1.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    std::vector&lt;std::array&lt;long long, 2&gt; &gt; c(1e6);\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        std::string a;\n        int d, n, m, p;\n        std::cin &gt;&gt; a &gt;&gt; d, n = (int)a.length();\n        a = &quot;#&quot; + a;\n        std::vector&lt;std::vector&lt;long long&gt; &gt; f(n + 1, std::vector&lt;long long&gt; (2));\n        f[0][0] = 1ll;\n        m = d;\n        for (; m % 2 == 0; m /= 2);\n        for (; m % 5 == 0; m /= 5);\n        p = d / m;\n        for (int i = 0; i &lt; m; ++i)\n            c[i][0] = c[i][1] = 0ll;\n        std::vector&lt;int&gt; s(n + 2);\n        for (int i = n, k = 1; i; --i, (k *= 10) %= m)\n            s[i] = (s[i + 1] + (a[i] - &#39;0&#39;) * k) % m;\n        auto s0 = 0ll;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            int now = 0;\n            for (int j = i, k = 1; j &gt; i - 20 &amp;&amp; j; --j, (k *= 10) %= d) &#123;\n                (now += (a[j] - &#39;0&#39;) * k) %= d;\n                if (now == 0)\n                    (f[i][0] += f[j - 1][0] + f[j - 1][1]) %= mod;\n                else\n                    (f[i][1] += f[j - 1][0]) %= mod;\n            &#125;\n            if (i &gt; 20) &#123;\n                (c[s[i - 20]][0] += f[i - 21][0]) %= mod;\n                (c[s[i - 20]][1] += f[i - 21][1]) %= mod;\n                (s0 += f[i - 21][0]) %= mod;\n                int now = 0;\n                for (int j = i, k = 1; j &gt;= i - 20; --j, (k *= 10) %= p)\n                    (now += (a[j] - &#39;0&#39;) * k) %= p;\n                if (now == 0) &#123;\n                    (f[i][0] += c[s[i + 1]][0] + c[s[i + 1]][1]) %= mod;\n                    (f[i][1] += s0 + mod - c[s[i + 1]][0]) %= mod;\n                &#125;\n                else\n                    (f[i][1] += s0) %= mod;\n            &#125;\n        &#125;\n        std::cout &lt;&lt; (f[n][0] + f[n][1]) % mod &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b.-背包\">B. 背包</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6736/problem/2\" class=\"uri\">https://www.becoder.com.cn/contest/6736/problem/2</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(n\\)</span> 种物品，第 <span class=\"math inline\">\\(i(1\\le i\\le n)\\)</span> 种有无穷多个，体积均为 <span class=\"math inline\">\\(v_i\\)</span>、价值均为 <span class=\"math inline\">\\(w_i\\)</span>。给定 <span class=\"math inline\">\\(Q\\)</span> 次询问，形如：</p>\n<ul>\n<li><p>给定一个背包容积 <span class=\"math inline\">\\(m\\)</span>，回答两个问题：</p>\n<ol type=\"1\">\n<li><strong>有序地</strong>选取体积和<strong>恰好</strong>为 <span class=\"math inline\">\\(m\\)</span> 的物品，所能得到的最大价值。如果不存在这样的选取方式，回答 <span class=\"math inline\">\\(-1\\)</span>。</li>\n<li>在上一问的条件下，可能的方案数。两个方案不同，当且仅当选取的物品数不同，或选物序列的某个位置不同。对 <span class=\"math inline\">\\(1092515507\\)</span> 取模，不存在则回答 <span class=\"math inline\">\\(-1\\)</span>。</li>\n</ol></li>\n</ul>\n<p><span class=\"math inline\">\\(n,Q,v_i\\le 100, m,w_i\\le 10^9\\)</span>。</p>\n</blockquote>\n<p>mobai ddxrS</p>\n<ul>\n<li><p>Tip：由于选取是有序的，所以朴素的『枚举物品 + 枚举体积』的 DP 是不可行的，而需要『枚举体积 + 枚举物品』。</p></li>\n<li><p>很容易写出朴素的 DP：令二元组 <span class=\"math inline\">\\((a, b)_{m}\\)</span> 表示总体积 <span class=\"math inline\">\\(m\\)</span> 下的两问答案，则<strong>合并答案</strong>（定义为 <span class=\"math inline\">\\(+\\)</span> 运算）的过程可以写为：</p>\n<p><span class=\"math display\">\\[\n(a_1,b_1)_{m}+(a_2,b_2)_{m}=\\begin{cases}\n(a_1,b_1)_{m}&amp;a_1&gt;a_2\\\\\n(a_1,b_1+b_2)_{m}&amp;a_1=a_2\\\\\n(a_2, b_2)_{m}&amp;\\text{otherwise}\n\\end{cases}\n\\]</span></p></li>\n<li><p>相似地，<strong>状态转移</strong>（定义为 <span class=\"math inline\">\\(\\times\\)</span> 运算）可以写为：</p>\n<p><span class=\"math display\">\\[\n(a_1,b_1)_{m_1}\\times (a_2,b_2)_{m_2}=(a_1+a_2,b_1\\times b_2)_{m_1+m_2}\n\\]</span></p>\n<p>Tips：实际上是借鉴了矩阵乘法的含义进行定义，这样就可以尝试优化。</p></li>\n<li><p>这样就有 <span class=\"math inline\">\\((f,g)_i = \\sum\\limits_{j=1}^n (f,g)_{i-v_j}\\times (w_j,1)_{v_j}\\)</span>。</p></li>\n<li><p>感性理解：显然，在直接背包时，<span class=\"math inline\">\\(+\\)</span> 运算与 <span class=\"math inline\">\\(\\times\\)</span> 运算具有交换律，且 <span class=\"math inline\">\\(\\times\\)</span> 对 <span class=\"math inline\">\\(+\\)</span> 有分配律。</p>\n<p>那么此时广义矩乘具有结合律，可以优化。</p></li>\n<li><p>体积最大为 <span class=\"math inline\">\\(100\\)</span>，考虑开 <span class=\"math inline\">\\(100\\times 100\\)</span> 的矩阵（元素为二元组）维护 <span class=\"math inline\">\\((f,g)_{i-99}\\sim (f,g)_i\\)</span>。考虑直接快速幂，发现复杂度是非常糟糕的 <span class=\"math inline\">\\(O(qv^3\\log m)\\)</span>，非常糟糕。</p>\n<p>初始矩阵是 <span class=\"math inline\">\\(1\\times 100\\)</span> 的，这里的处理方式是预处理每一个 <span class=\"math inline\">\\(2^i\\)</span> 次幂（<span class=\"math inline\">\\(O(v^3\\log m)\\)</span>），每次询问时二进制拆分 <span class=\"math inline\">\\(m\\)</span>，线性地乘过去，就可以把矩阵乘法优化为矩阵乘向量，复杂度降至 <span class=\"math inline\">\\(O(qv^2\\log m)\\)</span>。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconstexpr int N = 100;\nconst long long inf = 1e18;\nconst int mod = 1092515507;\nstruct node &#123;\n    long long f, g;\n    node(): f(-inf), g(0ll) &#123;&#125;\n    node(long long f1, long long g1): f(f1), g(g1) &#123;\n        if (g &gt;= mod)\n            g -= mod;\n        return;\n    &#125;\n    node operator* (const node &amp;q) const &#123;\n        return node(f + q.f, g * q.g % mod);\n    &#125;\n    node operator+ (const node &amp;q) const &#123;\n        if (f &gt; q.f)\n            return *this;\n        else if (f == q.f)\n            return node(f, g + q.g);\n        return q;\n    &#125;\n    node&amp; operator+= (const node &amp;q) &#123;\n        return *this = *this + q;\n    &#125;\n&#125;;\nstruct mat &#123;\n    std::vector&lt;std::vector&lt;node&gt; &gt; a;\n    mat(void): a(N, std::vector&lt;node&gt; (N)) &#123;&#125;\n    std::vector&lt;node&gt;&amp; operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    mat operator* (mat &amp;q) const &#123;\n        mat res;\n        for (int i = 0; i &lt; N; ++i)\n            for (int k = 0; k &lt; N; ++k)\n                for (int j = 0; j &lt; N; ++j) \n                    res[i][j] += a[i][k] * q[k][j];\n        return res;\n    &#125;\n&#125;;\nstruct vec &#123;\n    std::vector&lt;node&gt; a;\n    vec(void): a(N) &#123;&#125;\n    node&amp; operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    vec operator* (mat &amp;q) const &#123;\n        vec res;\n        for (int k = 0; k &lt; N; ++k)\n            for (int j = 0; j &lt; N; ++j)\n                res[j] += a[k] * q[k][j];\n        return res;\n    &#125;\n    vec&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;pack.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;pack.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, q;\n    std::cin &gt;&gt; n &gt;&gt; q;\n    std::vector&lt;int&gt; v(n + 1), w(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; v[i];\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; w[i];\n    std::vector&lt;mat&gt; t(30);\n    for (int j = 0; j &lt; N - 1; ++j)\n        t[0][j + 1][j] += node(0ll, 1ll);\n    for (int i = 1; i &lt;= n; ++i)\n        t[0][N - v[i]][N - 1] += node(w[i], 1ll);\n    for (int i = 1; i &lt; 30; ++i)\n        t[i] = t[i - 1] * t[i - 1];\n    vec init;\n    init[N - 1] = node(0ll, 1ll);\n    for (int m; q--; ) &#123;\n        std::cin &gt;&gt; m;\n        auto res(init);\n        for (int i = 29; ~i; --i)\n            if ((m &gt;&gt; i) &amp; 1)\n                res *= t[i];\n        if (res[N - 1].f &lt;= 0)\n            std::cout &lt;&lt; -1 &lt;&lt; &#39; &#39; &lt;&lt; -1 &lt;&lt; &#39;\\n&#39;;\n        else\n            std::cout &lt;&lt; res[N - 1].f &lt;&lt; &#39; &#39; &lt;&lt; res[N - 1].g &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"a.-关卡设计\">A. 关卡设计</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6742/problem/1\" class=\"uri\">https://www.becoder.com.cn/contest/6742/problem/1</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(n\\times m\\)</span> 的字符地图，其中 <code>S</code> 为起点（有且仅有一个），<code>R</code>，<code>B</code> 为红、蓝宝石（可能有多个），<code>x</code> 为障碍、<code>.</code> 为可通行地块。</p>\n<p>现在需要把尽可能多的 <code>.</code> 变为 <code>x</code>，使得一种原来可以由 <code>S</code> 出发收集到的宝石在修改后的地图中仍能被收集。输出最多可修改的 <code>.</code> 的数量。</p>\n<p><span class=\"math inline\">\\(n\\times m\\le 10^6\\)</span>。</p>\n</blockquote>\n<ul>\n<li><p>一种显然错误的做法：拆点 <span class=\"math inline\">\\((u,0/1/2/3)\\)</span> 分别表示走到 <span class=\"math inline\">\\(u\\)</span> 时的宝石收集状态，跑 01BFS。</p>\n<p>错误的原因：路径会重复走一些边，但它们不能被重复记入代价。</p></li>\n<li><p>结合『重复走一些边』的想法，发现路径一定有一个『分叉点』。枚举这样的分叉点，从 <code>S</code>、所有 <code>R</code>、所有 <code>B</code> 出发分别跑 01BFS。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int dir[][2] = &#123; &#123; 0, -1 &#125;, &#123; 0, 1 &#125;, &#123; -1, 0 &#125;, &#123; 1, 0 &#125; &#125;;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;design.out&quot;, &quot;w&quot;, stdout);\n    std::freopen(&quot;design.in&quot;, &quot;r&quot;, stdin);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, m,  cnt = 0;\n        std::cin &gt;&gt; n &gt;&gt; m;\n        std::vector&lt;std::vector&lt;char&gt; &gt; a(n + 1, std::vector&lt;char&gt; (m + 1));\n        for (int i = 1; i &lt;= n; ++i)\n            for (int j = 1; j &lt;= m; ++j) &#123;\n                std::cin &gt;&gt; a[i][j];\n                cnt += (a[i][j] == &#39;.&#39;);\n            &#125;\n        const int N = n * m;\n        auto id = [&amp;](int i, int j) &#123; return (i - 1) * m + j; &#125;;\n        std::vector&lt;std::vector&lt;int&gt; &gt; dis(3, std::vector&lt;int&gt; (N + 1, N + 1));\n        auto work = [&amp;](std::vector&lt;int&gt; &amp;dis, char S) &#123;\n            std::deque&lt;int&gt; q;\n            std::vector&lt;int&gt; vis(N + 1);\n            for (int i = 1; i &lt;= n; ++i)\n                for (int j = 1; j &lt;= m; ++j)\n                    if (a[i][j] == S) &#123;\n                        dis[id(i, j)] = 0;\n                        q.push_back(id(i, j));\n                    &#125;\n            for (; !q.empty(); ) &#123;\n                int x, y;\n                &#123;\n                    int t = q.front();\n                    q.pop_front();\n                    if (vis[t])\n                        continue;\n                    vis[t] = 1;\n                    x = (t - 1) / m + 1, y = t - (x - 1) * m;\n                &#125;\n                for (auto [fx, fy] : dir) &#123;\n                    int nx = x + fx, ny = y + fy;\n                    if (nx &gt;= 1 &amp;&amp; ny &gt;= 1 &amp;&amp; nx &lt;= n &amp;&amp; ny &lt;= m &amp;&amp; a[nx][ny] != &#39;x&#39;) &#123;\n                        if (a[nx][ny] != &#39;.&#39;) &#123;\n                            if (dis[id(nx, ny)] &gt; dis[id(x, y)]) &#123;\n                                dis[id(nx, ny)] = dis[id(x, y)];\n                                q.push_front(id(nx, ny));\n                            &#125;\n                        &#125;\n                        else if (dis[id(nx, ny)] &gt; dis[id(x, y)] + 1) &#123;\n                            dis[id(nx, ny)] = dis[id(x, y)] + 1;\n                            q.push_back(id(nx, ny));\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;;\n        work(dis[0], &#39;S&#39;), work(dis[1], &#39;R&#39;), work(dis[2], &#39;B&#39;);\n        int mn1 = N + 1, mn2 = N + 1;\n        for (int i = 1; i &lt;= n; ++i)\n            for (int j = 1; j &lt;= m; ++j) &#123;\n                mn1 = std::min(mn1, dis[0][id(i, j)] + std::min(dis[1][id(i, j)], dis[2][id(i, j)]) - (a[i][j] == &#39;.&#39;));\n                mn2 = std::min(mn2, dis[0][id(i, j)] + dis[1][id(i, j)] + dis[2][id(i, j)] - (a[i][j] == &#39;.&#39;) * 2);\n            &#125;\n        if (mn2 != N + 1)\n            std::cout &lt;&lt; cnt - mn2 &lt;&lt; &#39;\\n&#39;;\n        else if (mn1 != N + 1)\n            std::cout &lt;&lt; cnt - mn1 &lt;&lt; &#39;\\n&#39;;\n        else\n            std::cout &lt;&lt; cnt &lt;&lt; &#39;\\n&#39;;\n    &#125;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c.-炼金术\">C. 炼金术</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6742/problem/3\" class=\"uri\">https://www.becoder.com.cn/contest/6742/problem/3</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(A_{1\\cdots n}\\)</span> 和 <span class=\"math inline\">\\(B_{1\\cdots n}\\)</span>，给定 <span class=\"math inline\">\\(m\\)</span> 次操作，形如：</p>\n<ul>\n<li><code>1 l r x</code>，将 <span class=\"math inline\">\\(A_{l\\cdots r}\\)</span> 赋为 <span class=\"math inline\">\\(x\\)</span>。</li>\n<li><code>2 l r</code>，询问 <span class=\"math inline\">\\(\\min\\limits_{i\\in [l, r]}\\left\\{ \\text{lcm}(A_i,B_i)+\\dfrac{\\text{lcm}(A_i,B_i)}{\\gcd(A_i,B_i)} \\right\\}\\)</span> 的值。</li>\n</ul>\n<p><span class=\"math inline\">\\(n,m\\le 5\\times 10^4,V=5\\times 10^4\\)</span>。</p>\n</blockquote>\n<ul>\n<li><p>待求没什么太好的性质，考虑更暴力的解决方式。</p>\n<p>容易想到分块做法，对于整块赋值，容易想到对于每个 <span class=\"math inline\">\\(x\\)</span> 预处理块内答案。如何快速做到这一点？</p>\n<p>一个想法是枚举 gcd 的值 <span class=\"math inline\">\\(p\\)</span>（显然只需枚举 <span class=\"math inline\">\\(x\\)</span> 的因子），计算 <span class=\"math inline\">\\(\\dfrac {b_j\\times x}p+\\dfrac {b_j\\times x}{p^2}\\)</span> 的最小值。</p>\n<p><em>Tip：枚举到的 <span class=\"math inline\">\\(p\\)</span> 可能不是 gcd，但能保证一定能找到答案。</em></p></li>\n<li><p>贪心地，只需对于块内 <span class=\"math inline\">\\(p\\)</span> 的最小倍数计算答案。这一点对于每个 <span class=\"math inline\">\\(b_i\\)</span> 枚举因数即能 <span class=\"math inline\">\\(O(n\\sqrt V)\\)</span> 地预处理（因为有重复元素所以不是 <span class=\"math inline\">\\(O(V\\log V)\\)</span>）、花费 <span class=\"math inline\">\\(O(V\\log n)\\)</span> 的空间存储。</p></li>\n<li><p>对于每个 <span class=\"math inline\">\\(x\\)</span>，复杂度不允许暴力枚举 <span class=\"math inline\">\\(x\\)</span> 的因子；发现 <span class=\"math inline\">\\(x\\)</span> 的因子是 <span class=\"math inline\">\\(x\\)</span> 与『对于所有 <span class=\"math inline\">\\(x\\)</span> 的质因子 <span class=\"math inline\">\\(m\\)</span>，<span class=\"math inline\">\\(\\dfrac xm\\)</span> 的因子』的并。</p>\n<p>考虑一个类 DP 的过程，则 <span class=\"math inline\">\\(f_x\\gets f_{x\\div m}\\times m\\)</span>，再计算 <span class=\"math inline\">\\(x\\)</span> 自身的答案即可。由于 <span class=\"math inline\">\\(\\omega(V)\\)</span> 平均为 <span class=\"math inline\">\\(\\log\\log V\\)</span>，此时预处理复杂度降低至 <span class=\"math inline\">\\(O(n\\sqrt V + V\\log V\\sqrt n)\\)</span>。</p></li>\n<li><p>用一点科技加速 gcd 即可。可选 <span class=\"math inline\">\\(O(1)\\)</span> gcd，或小范围打表 + 大范围暴力跳至小范围。</p></li>\n</ul>\n<details>\n<p>注意待求可能会爆 <code>unsigned int</code>，问就是挂分了。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;alchemy.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;alchemy.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;./test/20251115/alchemy/alchemy4.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    const long long inf = 1e18;\n    const int M = 5000, N = 50000;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(M + 1, std::vector&lt;int&gt; (M + 1));\n    for (int i = 0; i &lt;= M; ++i) &#123;\n        for (int j = 0; j &lt; i; ++j)\n            g[i][j] = g[j][i];\n        g[i][i] = i;\n        for (int j = i + 1; j &lt;= M; ++j)\n            g[i][j] = std::__gcd(i, j);\n    &#125;\n    std::function&lt;int(int, int)&gt; gcd = [&amp;](int x, int y) &#123;\n        if (x &lt;= M &amp;&amp; y &lt;= M)\n            return g[x][y];\n        return y ? gcd(y, x % y) : x;\n    &#125;;\n    std::vector&lt;std::vector&lt;int&gt; &gt; fac(N + 1);\n    for (int i = 2; i &lt;= N; ++i)\n        if (fac[i].empty())\n            for (int j = i; j &lt;= N; j += i)\n                fac[j].push_back(i);\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;long long&gt; a(n + 1), b(n + 1), p(n + 1);\n    auto calc = [&amp;](long long x, long long y) &#123;\n        auto g = gcd(x, y);\n        return x * y / g + x * y / g / g;\n    &#125;;\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; b[i];\n        p[i] = calc(a[i], b[i]);\n    &#125;\n    int siz = sqrt(n), k = (n + siz - 1) / siz;\n    std::vector&lt;long long&gt; u(k + 1, inf);\n    std::vector&lt;int&gt; L(k + 1), R(k + 1), id(n + 1), d(k + 1, -1);\n    std::vector&lt;std::vector&lt;long long&gt; &gt; mn(k + 1, std::vector&lt;long long&gt; (N + 1, inf)), s(k + 1, std::vector&lt;long long&gt; (N + 1));\n    for (int i = 1; i &lt;= k; ++i) &#123;\n        L[i] = R[i - 1] + 1, R[i] = std::min(L[i] + siz - 1, n);\n        for (int j = L[i]; j &lt;= R[i]; ++j) &#123;\n            id[j] = i, u[i] = std::min(u[i], p[j]);\n            for (int k = 1; k * k &lt;= b[j]; ++k)\n                if (b[j] % k == 0) &#123;\n                    mn[i][k] = std::min(mn[i][k], b[j]);\n                    mn[i][b[j] / k] = std::min(mn[i][b[j] / k], b[j]);\n                &#125;\n        &#125;\n        s[i][1] = mn[i][1] * 2;\n        for (int j = 2; j &lt;= N; ++j) &#123;\n            s[i][j] = mn[i][j] + mn[i][j] / j;\n            for (auto k : fac[j])\n                s[i][j] = std::min(s[i][j], s[i][j / k] * k);\n        &#125;\n    &#125;\n    auto pushdown = [&amp;](int id) &#123;\n        if (d[id] != -1) &#123;\n            for (int i = L[id]; i &lt;= R[id]; ++i)\n                p[i] = calc(d[id], b[i]);\n            d[id] = -1;\n        &#125;\n        return;\n    &#125;;\n    auto ADD = [&amp;](int l, int r, int x) &#123;\n        int pl = id[l], pr = id[r];\n        pushdown(pl);\n        if (pl == pr) &#123;\n            for (int i = l; i &lt;= r; ++i)\n                p[i] = calc(x, b[i]);\n            u[pl] = *std::min_element(p.begin() + L[pl], p.begin() + R[pl] + 1);\n            return;\n        &#125;\n        pushdown(pr);\n        for (int i = l; i &lt;= R[pl]; ++i)\n            p[i] = calc(x, b[i]);\n        u[pl] = *std::min_element(p.begin() + L[pl], p.begin() + R[pl] + 1);\n        for (int i = L[pr]; i &lt;= r; ++i)\n            p[i] = calc(x, b[i]);\n        u[pr] = *std::min_element(p.begin() + L[pr], p.begin() + R[pr] + 1);\n        for (int i = pl + 1; i &lt; pr; ++i)\n            d[i] = x, u[i] = s[i][x];\n        return;\n    &#125;;\n    auto ASK = [&amp;](int l, int r) &#123;\n        int pl = id[l], pr = id[r];\n        pushdown(pl);\n        if (pl == pr)\n            return *std::min_element(p.begin() + l, p.begin() + r + 1);\n        pushdown(pr);\n        auto res = std::min(*std::min_element(p.begin() + l, p.begin() + R[pl] + 1), *std::min_element(p.begin() + L[pr], p.begin() + r + 1));\n        if (pl + 1 != pr)\n            res = std::min(res, *std::min_element(u.begin() + pl + 1, u.begin() + pr));\n        return res;\n    &#125;;\n    for (int op, l, r; m--; ) &#123;\n        std::cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;\n        if (op == 1) &#123;\n            int x;\n            std::cin &gt;&gt; x, ADD(l, r, x);\n        &#125;\n        else\n            std::cout &lt;&lt; ASK(l, r) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "二分图",
                "计数",
                "DP 套 DP",
                "搜索"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20251103/",
            "url": "https://xsc062.netlify.app/20251103/",
            "title": "杂题选谈：数数 & 容斥",
            "date_published": "2025-11-03T03:59:00.000Z",
            "content_html": "<p>数数，但是性质题</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a---reversi-2\">A - Reversi 2</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_arc189_a\" class=\"uri\">https://www.luogu.com.cn/problem/AT_arc189_a</a></p>\n<ul>\n<li><p>操作可以看成，任选一个点，找到两侧最近的颜色相异的点，进行推平。</p>\n<p>或，任选一个极长连续段，推平为其两端的颜色。</p></li>\n<li><p>很容易注意到最终序列被分为若干个极长连续段，彼此独立。对于起始序列，容易发现任意区间中的任意操作会减少 2 的不同段数量（故显然最终序列连续段长度应该为奇数，且两端颜色和目标颜色一致）。</p></li>\n<li><p>令 <span class=\"math inline\">\\(f_i\\)</span> 为长度为 <span class=\"math inline\">\\(i\\)</span> 的连续段被推平的方案数（<span class=\"math inline\">\\(i\\bmod2=1\\)</span>），那么有 <span class=\"math inline\">\\(f_i=(i - 2)\\times f_{i-2}\\)</span>。</p></li>\n<li><p>最终方案数应为所有极长段方案的多重集排列乘上它们各自独立方案数之积。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::syns_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1);\n    std::vector&lt;long long&gt; f(n + 1), fac(n + 1), inv(n + 1);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        fac[i] = fac[i - 1] * i % mod;\n    &#125;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[n] = qkp(fac[n], mod - 2);\n    for (int i = n - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    f[1] = 1;\n    for (int i = 3; i &lt;= n; i += 2)\n        f[i] = f[i - 2] * (i - 2) % mod;\n    auto res = 1ll;\n    int L = 1, cnt = 0;\n    for (int i = 1; i &lt;= n; ++i)\n        if (i == n || a[i + 1] != a[i]) &#123;\n            if (a[i] != i % 2 || (i - L + 1) % 2 == 0) &#123;\n                std::cout &lt;&lt; 0 &lt;&lt; &#39;\\n&#39;;\n                return 0;\n            &#125;\n            (res *= f[i - L + 1]) %= mod;\n            (res *= inv[(i - L) / 2]) %= mod;\n            cnt += (i - L) / 2;\n            L = i + 1;\n        &#125;\n    std::cout &lt;&lt; res * fac[cnt] % mod &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---cigar-box\">B - Cigar Box</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_arc112_e\" class=\"uri\">https://www.luogu.com.cn/problem/AT_arc112_e</a></p>\n<ul>\n<li><p>发现一个数的状态只取决于，最后一次以它为主体的操作，及这次操作之后的所有操作</p></li>\n<li><p>进一步地发现，按最后一次操作分类，可以分为，向左（<code>L</code>）、向右（<code>R</code>）、没被操作过（<code>M</code>）三种类型。</p>\n<p>可以很显然地注意到，最终序列一定是 <code>LLLMMMRRR</code> 的形式，其中，仅要求 <code>M</code> 是递增的；现在需要计算有多少长度为 <span class=\"math inline\">\\(m\\)</span> 的操作序列对应所有的 <code>LMR</code> 序列（如果认为所有的 <code>M</code> 始终是不动的可能会更好理解）。</p></li>\n<li><p>发现同种类数间，『最后一次操作』的相对顺序是固定的。进一步会发现这其实是<a href=\"https://oi-wiki.org/math/combinatorics/stirling/\">第二类斯特林数</a>，最后答案为：</p></li>\n</ul>\n<p><span class=\"math display\">\\[\n\\sum_{L,R}\\binom{L+R}{L}\\cdot \\begin{Bmatrix}m\\\\ L+R\\end{Bmatrix}\\cdot 2^{m-L-R}\n\\]</span></p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::syns_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    using arr = std::vector&lt;long long&gt;;\n    arr pw(m + 1), fac(m + 1), inv(m + 1);\n    std::vector&lt;arr&gt; f(m + 1, arr(m + 1));\n    std::vector&lt;int&gt; a(n + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; ok(n + 1, std::vector&lt;int&gt; (n + 1));\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    for (int l = 1; l &lt;= n; ++l)\n        for (int r = l; r &lt;= n; ++r)\n            if (r == l || a[r] &gt; a[r - 1])\n                ok[l][r] = 1;\n            else\n                break;\n    f[1][1] = 1ll, pw[0] = fac[0] = inv[0] = 1ll;\n    for (int i = 2; i &lt;= m; ++i)\n        for (int j = 1; j &lt;= i; ++j)\n            f[i][j] = (f[i - 1][j - 1] + f[i - 1][j] * j) % mod;\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        pw[i] = pw[i - 1] * 2 % mod;\n        fac[i] = fac[i - 1] * i % mod;\n    &#125;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[m] = qkp(fac[m], mod - 2);\n    for (int i = m - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[m] % mod * inv[n - m] % mod;\n    &#125;;\n    auto res = 0ll;\n    for (int L = 0; L &lt;= m &amp;&amp; L &lt;= n; ++L)\n        for (int R = 0; L + R &lt;= m &amp;&amp; L + R &lt;= n; ++R)\n            if (L + 1 &gt; n - R || ok[L + 1][n - R])\n                res += C(L + R, L) * f[m][L + R] % mod * pw[m - L - R] % mod;\n    std::cout &lt;&lt; res % mod &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---swap-characters\">C - Swap Characters</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_arc168_c\" class=\"uri\">https://www.luogu.com.cn/problem/AT_arc168_c</a></p>\n<ul>\n<li><p>考虑值域为 <span class=\"math inline\">\\(0\\)</span> 和 <span class=\"math inline\">\\(1\\)</span> 的情况</p>\n<p>发现这个很唐 <del>好险，AI 差点比我先做出来了</del>，转化成枚举操作次数 <span class=\"math inline\">\\(i\\)</span>，答案是</p>\n<p><span class=\"math display\">\\[\n\\sum_{i\\le\\min(s_0,s_1)}\\binom{s_0}{i}\\cdot\\binom{s_1}{i}\n\\]</span></p></li>\n<li><p>根据这个可以得到启发，发现所谓任意交换可以转化为，每个字母的支出和收入相等，故考虑画个表：</p></li>\n</ul>\n<hr />\n<h2 id=\"a---leq-and-neq-non-equal-neighbours\">A - LEQ and NEQ / Non-equal Neighbours</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_arc115_e\" class=\"uri\">https://www.luogu.com.cn/problem/AT_arc115_e</a> / <a href=\"https://www.luogu.com.cn/problem/CF1591F\" class=\"uri\">https://www.luogu.com.cn/problem/CF1591F</a> / <a href=\"https://www.luogu.com.cn/problem/CF1585F\" class=\"uri\">https://www.luogu.com.cn/problem/CF1585F</a></p>\n<ul>\n<li><p>容斥，钦定有 <span class=\"math inline\">\\(i\\)</span> 对相同元素，那么答案为 <span class=\"math inline\">\\(\\sum\\limits_{i=0}^{n-1} (-1)^{n-1-i} \\cdot g_i\\)</span>，其中 <span class=\"math inline\">\\(g_i\\)</span> 表示至少有 <span class=\"math inline\">\\(i\\)</span> 对相同元素的方案数。</p></li>\n<li><p>考虑 <span class=\"math inline\">\\(g_i\\)</span> 的计算，朴素的做法是二维 DP，令 <span class=\"math inline\">\\(f_{i, j}\\)</span> 表示 DP 到 <span class=\"math inline\">\\(i\\)</span>，已经有了至多 <span class=\"math inline\">\\(j\\)</span> 对不同元素的方案数（发现这样才更好 DP）。发现没啥好的 <span class=\"math inline\">\\(O(n^2)\\)</span> 转移，只能 <span class=\"math inline\">\\(O(n^3)\\)</span>：</p>\n<p><span class=\"math display\">\\[\nf_{i,j}=\\sum_{k&lt;i}f_{k, j-1}\\times \\min\\{A_{k+1\\cdots i}\\}\n\\]</span></p></li>\n<li><p>一个适用于容斥 DP 的 nb 优化：发现系数只取决于 <span class=\"math inline\">\\(j\\)</span> 维的奇偶性，发现转移也只关注奇偶性，故设 <span class=\"math inline\">\\(f_{i,0/1}\\)</span> 减少一维。</p>\n<p>同时，很显然存在一个单调栈优化的结构，这样就可以在 <span class=\"math inline\">\\(O(n)\\)</span> 内完成 DP。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    struct node &#123; int mn; long long c0, c1; &#125;;\n    std::stack&lt;node&gt; st;\n    std::vector&lt;std::array&lt;long long, 2&gt; &gt; f(n + 1);\n    f[0][0] = 1ll, f[0][1] = 0ll;\n    auto s0 = 0x3f3f3f3fll, s1 = 0ll;\n    st.push(&#123; 0x3f3f3f3f, 1ll, 0ll &#125;);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        auto p0 = 0ll, p1 = 0ll;\n        for (; !st.empty(); ) &#123;\n            auto [mn, c0, c1] = st.top();\n            if (mn &lt;= a[i])\n                break;\n            st.pop();\n            p0 += c0, p1 += c1;\n            (s0 += mod - c0 * (mn - a[i]) % mod) %= mod;\n            (s1 += mod - c1 * (mn - a[i]) % mod) %= mod;\n        &#125;\n        st.push(&#123; a[i], p0 % mod, p1 % mod &#125;);\n        f[i][0] = s1, f[i][1] = s0;\n        (s0 += f[i][0] * 0x3f3f3f3f % mod) %= mod;\n        (s1 += f[i][1] * 0x3f3f3f3f % mod) %= mod;\n        st.push(&#123; 0x3f3f3f3f, f[i][0], f[i][1] &#125;);\n    &#125;\n    std::cout &lt;&lt; (f[n][n &amp; 1] + mod - f[n][(n &amp; 1) ^ 1]) % mod &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---unbranched\">B - Unbranched</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_abc180_f\" class=\"uri\">https://www.luogu.com.cn/problem/AT_abc180_f</a></p>\n<ul>\n<li><p>注意到只会有环和链两种情况。发现消耗的点数和边数是不同的，再加上题目有边数限制，令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示消耗了 <span class=\"math inline\">\\(i\\)</span> 个点 <span class=\"math inline\">\\(j\\)</span> 条边时的方案数。</p></li>\n<li><p>转移是显然的：</p>\n<p>对于环的情况，答案为圆排列去掉翻折，即 <span class=\"math inline\">\\(\\dfrac {(k-1)!}2\\)</span>。特别地，二元环的圆排列不存在翻折，故答案为 <span class=\"math inline\">\\(1\\)</span>。</p>\n<p>对于链的情况，去掉翻折即可，答案为 <span class=\"math inline\">\\(\\dfrac {k!}2\\)</span>。</p></li>\n<li><p>去重，参考典型的图计数问题，钦定没被选的点中，标号最小的必须被选，所以会有 <span class=\"math inline\">\\(C(n-(i-k)-1,k-1)\\)</span> 的系数。</p></li>\n<li><p>显然对于最大值恰好为 <span class=\"math inline\">\\(L\\)</span> 的限制可以直接记一个 <code>bool</code> 量在状态里；尊重一下容斥的标题，用 <span class=\"math inline\">\\(L\\)</span> 的答案减去 <span class=\"math inline\">\\(L-1\\)</span> 的答案亦可。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nconst int inv2 = (mod + 1) &gt;&gt; 1;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m, L;\n    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; L;\n    using arr = std::vector&lt;long long&gt;;\n    using brr = std::vector&lt;arr&gt;;\n    using crr = std::vector&lt;brr&gt;;\n    arr fac(n + 1);\n    brr C(n + 1, arr(n + 1));\n    fac[0] = 1ll, C[0][0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        C[i][0] = 1ll;\n        fac[i] = fac[i - 1] * i % mod;\n        for (int j = 1; j &lt;= i; ++j)\n            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;\n    &#125;\n    crr f(n + 1, brr(m + 1, arr(2)));\n    f[0][0][0] = 1ll;\n    auto work = [&amp;](int i, int j, int k, int p1, int p2) &#123;\n        if (k == 1)\n            f[i][j][p2] += f[i - 1][j][p1];\n        else if (k == 2) &#123;\n            if (j &gt;= 2)\n                f[i][j][p2] += f[i - 2][j - 2][p1] * C[n - (i - k) - 1][k - 1] % mod; \n            if (j &gt;= 1)\n                f[i][j][p2] += f[i - 2][j - 1][p1] * C[n - (i - k) - 1][k - 1] % mod;\n        &#125;\n        else &#123;\n            if (j &gt;= k)\n                f[i][j][p2] += f[i - k][j - k][p1] * C[n - (i - k) - 1][k - 1] % mod * fac[k - 1] % mod * inv2 % mod;\n            if (j &gt;= k - 1)\n                f[i][j][p2] += f[i - k][j - k + 1][p1] * C[n - (i - k) - 1][k - 1] % mod * fac[k] % mod * inv2 % mod;\n        &#125;\n        return;\n    &#125;;\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = 0; j &lt;= m; ++j) &#123;\n            for (int k = 1; k &lt;= i &amp;&amp; k &lt;= L; ++k)\n                if (k == L)\n                    work(i, j, k, 0, 1), work(i, j, k, 1, 1);\n                else\n                    work(i, j, k, 0, 0), work(i, j, k, 1, 1);\n            f[i][j][0] %= mod, f[i][j][1] %= mod;\n        &#125;\n    std::cout &lt;&lt; f[n][m][1] &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---局部极小值\">C - 局部极小值</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P3160\" class=\"uri\">https://www.luogu.com.cn/problem/P3160</a></p>\n<ul>\n<li><p>重要性质：一个合法棋盘，<code>X</code> 的数量不会超过八个，故一个想法是只考虑 <code>X</code> 填的数，进而想到容斥</p></li>\n<li><p>钦定至少有某些位置是 <code>X</code> 进行容斥，结合上面的性质发现空棋盘上的合法超集共 1000 多个，故可做，考虑单步钦定状态下的答案。</p>\n<p>令 <span class=\"math inline\">\\(f_{i,S}\\)</span> 表示填了 <span class=\"math inline\">\\(j\\)</span> 个数，目前 <code>X</code> 集合已经填完了 <span class=\"math inline\">\\(S\\)</span> 内元素的方案数。</p></li>\n</ul>\n<hr />\n<h2 id=\"a---数列\">A - 数列</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P7961\" class=\"uri\">https://www.luogu.com.cn/problem/P7961</a></p>\n<ul>\n<li><p>发现比较合理的 DP 方式是，令 <span class=\"math inline\">\\(f_{i,j,k,l}\\)</span> 表示当前正在 DP <span class=\"math inline\">\\(i\\)</span> 这个值，已经填了 <span class=\"math inline\">\\(j\\)</span> 个数，<span class=\"math inline\">\\(2^i\\)</span> 的个数，加上『进位』上来的，一共有 <span class=\"math inline\">\\(k\\)</span> 个，<span class=\"math inline\">\\(2^0\\sim 2^i\\)</span> 总共有 <span class=\"math inline\">\\(l\\)</span> 个 1 的答案。那么有：</p>\n<p><span class=\"math display\">\\[\nf_{i+1,j+c,\\left\\lfloor\\frac k2\\right\\rfloor+c,l+\\left(\\left\\lfloor\\frac k2\\right\\rfloor+c\\right)\\bmod 2}\\gets f_{i,j,k,l}\\times {v_{i + 1}}^c\\times (c!)^{-1}\n\\]</span></p>\n<p>其中 <span class=\"math inline\">\\((c!)^{-1}\\)</span> 为多重集排列。最后乘上 <span class=\"math inline\">\\(n!\\)</span> 即可。</p></li>\n<li><p>最后若 <span class=\"math inline\">\\(l+\\text{ctz}\\left(\\left\\lfloor\\frac k2\\right\\rfloor\\right)\\le K\\)</span> 即可统计 <span class=\"math inline\">\\(f_{m,n,k,l}\\)</span> 的贡献。</p></li>\n<li><p>注意到 <span class=\"math inline\">\\(k\\)</span> 维始终不超过 <span class=\"math inline\">\\(n\\)</span>，故复杂度 <span class=\"math inline\">\\(O(mn^3K)\\)</span>，非常可过。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m, s;\n    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;\n    using arr = std::vector&lt;long long&gt;;\n    using brr = std::vector&lt;arr&gt;;\n    brr v(m + 1, arr(n + 1));\n    for (int i = 0; i &lt;= m; ++i) &#123;\n        v[i][0] = 1ll;\n        std::cin &gt;&gt; v[i][1];\n        for (int j = 2; j &lt;= n; ++j)\n            v[i][j] = v[i][j - 1] * v[i][1] % mod;\n    &#125;\n    arr inv(n + 1);\n    inv[0] = 1ll;\n    auto fac = 1ll;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        (fac *= i) %= mod;\n        inv[i] = qkp(fac, mod - 2);\n    &#125;\n    using crr = std::vector&lt;brr&gt;;\n    std::vector&lt;crr&gt; f(m + 1, crr(n + 1, brr(n + 1, arr(s + 1))));\n    for (int i = 0; i &lt;= n; ++i)\n        f[0][i][i][i &amp; 1] = v[0][i] * inv[i] % mod;\n    for (int i = 0; i &lt; m; ++i)\n      for (int j = 0; j &lt;= n; ++j)\n        for (int k = 0; k &lt;= n; ++k)\n          for (int l = 0; l &lt;= s; ++l) &#123;\n            f[i][j][k][l] %= mod;\n            for (int c = 0; j + c &lt;= n &amp;&amp; k / 2 + c &lt;= n &amp;&amp; l + (k / 2 + c) % 2 &lt;= s; ++c)\n                f[i + 1][j + c][k / 2 + c][l + (k / 2 + c) % 2] += f[i][j][k][l] * v[i + 1][c] % mod * inv[c] % mod;\n          &#125;\n    auto res = 0ll;\n    for (int k = 0; k &lt;= n; ++k)\n        for (int l = 0; l &lt;= s; ++l)\n            if (l + __builtin_popcount(k / 2) &lt;= s)\n                res += f[m][n][k][l] % mod;\n    std::cout &lt;&lt; res % mod * fac % mod &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---vasya-and-array\">B - Vasya and Array</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1093F\" class=\"uri\">https://www.luogu.com.cn/problem/CF1093F</a></p>\n<ul>\n<li><p>发现正着做避免不了记录相同段长度，所以考虑反过来容斥。</p>\n<p>会发现这是一个类似于<a href=\"/20230418/\">两双手</a>的容斥结构。<del>两双手还在输出</del></p></li>\n<li><p>令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示前 <span class=\"math inline\">\\(i\\)</span> 个均合法，且第 <span class=\"math inline\">\\(i\\)</span> 个元素为 <span class=\"math inline\">\\(j\\)</span> 的方案数，考虑什么时候会出现『前 <span class=\"math inline\">\\(i-1\\)</span> 个元素合法，到了第 <span class=\"math inline\">\\(i\\)</span> 个非法』的情况</p>\n<p>发现即当前 <span class=\"math inline\">\\(i\\)</span> 前面有 <span class=\"math inline\">\\(len-1\\)</span> 个相同元素，且第 <span class=\"math inline\">\\(i\\)</span> 个成为第 <span class=\"math inline\">\\(len\\)</span> 个相同元素的情况。</p></li>\n<li><p>显然有转移：</p>\n<p><span class=\"math display\">\\[\nf_{i,j}\\gets \\left(\\sum_l f_{i-1,l}\\right)-\\left(\\sum_{l\\ne j} f_{i-len,l}\\right)\\times [a_{i-len+1\\cdots i} = j\\text{ is available}]\n\\]</span></p>\n<p>记录一下 <span class=\"math inline\">\\(s_i=\\sum\\limits_{j}f_{i,j}\\)</span> 的值即可做到 <span class=\"math inline\">\\(O(nk)\\)</span>。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, k, L;\n    std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; L;\n    std::vector&lt;int&gt; a(n + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; cnt(n + 1, std::vector&lt;int&gt; (k + 1));\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        for (int j = 1; j &lt;= k; ++j)\n            cnt[i][j] = cnt[i - 1][j] + (a[i] == j);\n        cnt[i][0] = cnt[i - 1][0] + (a[i] == -1);\n    &#125;\n    using arr = std::vector&lt;long long&gt;;\n    using brr = std::vector&lt;arr&gt;;\n    arr s(n + 1);\n    brr f(n + 1, arr(k + 1));\n    s[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = 1; j &lt;= k; ++j)\n            if (a[i] == -1 || a[i] == j) &#123;\n                f[i][j] = s[i - 1];\n                if (i &gt;= L &amp;&amp; (cnt[i][j] - cnt[i - L][j]) + (cnt[i][0] - cnt[i - L][0]) == L) &#123;\n                    f[i][j] += mod - (s[i - L] - f[i - L][j]);\n                    if (s[i - L] &lt; f[i - L][j])\n                        f[i][j] -= mod;\n                    if (f[i][j] &gt;= mod)\n                        f[i][j] -= mod;\n                &#125;\n                s[i] += f[i][j];\n                if (s[i] &gt;= mod)\n                    s[i] -= mod;\n            &#125;\n    std::cout &lt;&lt; s[n] &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---road-of-the-king\">C - Road of the King</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_codefestival_2016_final_f\" class=\"uri\">https://www.luogu.com.cn/problem/AT_codefestival_2016_final_f</a></p>\n<ul>\n<li><p>发现最后的图是强连通的，当且仅当<strong>所有点都能走到 1</strong>。</p>\n<p>最开始转化成『所有点都能通过操作序列走到 1』，错麻了 /qd</p></li>\n<li><p>令 <span class=\"math inline\">\\(f_{i,j,k}\\)</span> 表示前 <span class=\"math inline\">\\(i\\)</span> 步，已经使得 <span class=\"math inline\">\\(j\\)</span> 个点能走到 1，当前已经访问过了 <span class=\"math inline\">\\(k\\)</span> 个不能走到 <span class=\"math inline\">\\(1\\)</span> 的点。</p>\n<p>如果再次访问 <span class=\"math inline\">\\(j\\)</span> 个点中的其中一个，那么这 <span class=\"math inline\">\\(k\\)</span> 个点就能走到 1。转移是容易的。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    using arr = std::vector&lt;long long&gt;;\n    using brr = std::vector&lt;arr&gt;;\n    std::vector&lt;brr&gt; f(m + 1, brr(n + 1, arr(n + 1)));\n    f[0][1][0] = 1ll;\n    for (int i = 0; i &lt; m; ++i)\n        for (int j = 1; j &lt;= n; ++j) &#123;\n            for (int k = 0; k + j &lt;= n &amp;&amp; k + j &lt;= i + 1; ++k) &#123;\n                f[i][j][k] %= mod;\n                f[i + 1][j][k] += f[i][j][k] * k % mod;\n                f[i + 1][j + k][0] += f[i][j][k] * j % mod;\n                if (j + k != n)\n                    f[i + 1][j][k + 1] += f[i][j][k] * (n - j - k) % mod;\n            &#125;\n        &#125;\n    std::cout &lt;&lt; f[m][n][0] % mod &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d---チーム分け\">D - チーム分け</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_mujin_pc_2018_f\" class=\"uri\">https://www.luogu.com.cn/problem/AT_mujin_pc_2018_f</a></p>\n<ul>\n<li><p>很容易得到一个 <span class=\"math inline\">\\(O(n^3)\\)</span> 的做法：给 <span class=\"math inline\">\\(a\\)</span> 排序，从大到小选每个组的『限制者』。</p>\n<p><span class=\"math inline\">\\(f_{i,j}\\)</span> 表示选到 <span class=\"math inline\">\\(i\\)</span>，还剩 <span class=\"math inline\">\\(j\\)</span> 个 <span class=\"math inline\">\\(\\ge a_i\\)</span> 的人没有分组，则：</p>\n<p><span class=\"math display\">\\[\nf_{i-1,j+1-k}\\gets f_{i,j}\\quad(1\\le k\\le a_i)\\\\\nf_{i-1,j+1}\\gets f_{i,j}\n\\]</span></p></li>\n<li><p>后面这个优化还是很难想的…… 主要是要注意到，可以不必在某个 <span class=\"math inline\">\\(a_i\\)</span> 处钦定其为『限制者』；而是在某个 <span class=\"math inline\">\\(i\\)</span> 处，给『未分组』的人分大小为 <span class=\"math inline\">\\(i\\)</span> 的组，而不关心具体谁是限制者，甚至不关心限制者的 <span class=\"math inline\">\\(a\\)</span> 值。</p>\n<p>记 <span class=\"math inline\">\\(c_i\\)</span> 表示 <span class=\"math inline\">\\(i\\)</span> 处有几个 <span class=\"math inline\">\\(a\\)</span>，做多重集组合。仍然记录未分组人数 <span class=\"math inline\">\\(j\\)</span>，那么一个固定的 <span class=\"math inline\">\\(j\\)</span> 能贡献的大小为 <span class=\"math inline\">\\(i\\)</span> 的组满足调和级数，枚举组数 <span class=\"math inline\">\\(k\\)</span>，有：</p>\n<p><span class=\"math display\">\\[\nf_{i-1,j+c_i-k\\cdot i}\\gets f_{i+1,j}\\times \\binom{j+c_i}{i\\cdot k}\\times \\frac{(i\\cdot k)!}{(i!)^k\\times k!}\\quad\\left(k\\le \\frac{j+c_i}i\\right)\n\\]</span></p>\n<p><strong>一定要注意分母里的 <span class=\"math inline\">\\(k!\\)</span> 的含义（消序）！组是无序的。</strong></p></li>\n<li><p>复杂度 <span class=\"math inline\">\\(O(n^2\\log n)\\)</span>。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; c(n + 1);\n    for (int i = 1, x; i &lt;= n; ++i)\n        std::cin &gt;&gt; x, ++c[x];\n    using arr = std::vector&lt;long long&gt;;\n    using brr = std::vector&lt;arr&gt;;\n    brr C(n + 1, arr(n + 1));\n    C[0][0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        C[i][0] = 1ll;\n        for (int j = 1; j &lt;= i; ++j)\n            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;\n    &#125;\n    arr fac(n + 1);\n    fac[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    brr pw(n + 1, arr(n + 1));\n    for (int i = 0; i &lt;= n; ++i) &#123;\n        pw[i][0] = 1ll, pw[i][1] = qkp(fac[i], mod - 2);\n        for (int j = 2; j &lt;= n; ++j)\n            pw[i][j] = pw[i][j - 1] * pw[i][1] % mod;\n    &#125;\n    brr f(n + 2, arr(n + 1));\n    f[n + 1][0] = 1ll;\n    for (int i = n; i; --i)\n        for (int j = 0; j + c[i] &lt;= n; ++j)\n            for (int k = 0, l = (j + c[i]) / i; k &lt;= l; ++k)\n                (f[i][j + c[i] - k * i] += f[i + 1][j] * C[j + c[i]][i * k] % mod * fac[i * k] % mod * pw[i][k] % mod * pw[k][1] % mod) %= mod;\n    std::cout &lt;&lt; f[1][0] &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"e---random-isolation\">E - Random Isolation</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_arc165_e\" class=\"uri\">https://www.luogu.com.cn/problem/AT_arc165_e</a></p>\n<ul>\n<li><p>发现期望可以拆贡献，每个局面下，每个大小 <span class=\"math inline\">\\(&gt;K\\)</span> 的连通块恰好贡献 1 次操作次数。</p>\n<p>这里提一下，一开始有这样的想法：每个存在 <span class=\"math inline\">\\(&gt;K\\)</span> 连通块的局面都可以操作 1 次，所以一个局面有 1 的贡献；这是否和上面得到的结论矛盾？</p>\n<p>答案是，统计局面的方案数权值和连通块的方案数权值是不一样的，但总和是一样的。且局面没什么好的统计方法，故统计连通块。</p></li>\n<li><p>令 <span class=\"math inline\">\\(f_{x,i,j}\\)</span> 表示 <span class=\"math inline\">\\(x\\)</span> 为根，子树内选了大小为 <span class=\"math inline\">\\(i\\)</span> 的连通块，一共需要删除 <span class=\"math inline\">\\(j\\)</span> 个点。那么相当于要求这 <span class=\"math inline\">\\(j\\)</span> 个点的删除时间早于 <span class=\"math inline\">\\(i\\)</span> 内所有点。树上背包统计方案数，每个点处计算权值与贡献即可。</p></li>\n<li><p>最后算权值的时候，把操作序列看成后几项无效的排列，那么要求这 <span class=\"math inline\">\\(j\\)</span> 个点的操作序列需要在所有 <span class=\"math inline\">\\(i\\)</span> 个点的前面</p>\n<p>可以猜到一个答案：<span class=\"math inline\">\\(\\dfrac {i!\\times j!}{(i+j)!}\\)</span>。</p>\n<p>但仔细想来并站不住脚：每个连通块的后几项在实际操作序列里是不存在的，整个操作序列的长短甚至都是未知的，好像没什么道理。</p>\n<p>问了一圈没人说出来个靠谱的证明。算了。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    using arr = std::vector&lt;long long&gt;;\n    using brr = std::vector&lt;arr&gt;;\n    brr C(n + 1, arr(n + 1));\n    for (int i = 0; i &lt;= n; ++i) &#123;\n        C[i][0] = 1ll;\n        for (int j = 1; j &lt;= i; ++j)\n            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;\n    &#125;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    arr fac(n + 1), inv(n + 1);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        fac[i] = fac[i - 1] * i % mod;\n        inv[i] = qkp(fac[i], mod - 2);\n    &#125;\n    std::vector&lt;int&gt; siz(n + 1);\n    brr h(n + 1, arr(n + 1));\n    std::vector&lt;brr&gt; f(n + 1, brr(n + 1, arr(n + 1)));\n    auto res = 0ll;\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        f[x][1][(int)g[x].size()] = 1ll;\n        siz[x] = 1;\n        for (auto i : g[x])\n            if (i != fa) &#123;\n                DFS(i, x);\n                h = f[x];\n                for (int j = siz[x]; j; --j)\n                  for (int a = 0; a &lt; n; ++a)\n                    if (f[x][j][a + 1])\n                      for (int k = siz[i]; ~k; --k)\n                        for (int b = 0; a + b &lt; n; ++b)\n                          f[x][j + k][a + b] += h[j][a + 1] * f[i][k][b + 1] % mod;\n                siz[x] += siz[i];\n            &#125;\n        for (int i = 1; i &lt;= siz[x]; ++i)\n            for (int j = 0; j &lt;= n; ++j)\n                f[x][i][j] %= mod;\n        for (int i = k + 1; i &lt;= siz[x]; ++i)\n            for (int j = 0; i + j &lt;= n; ++j)\n                res += f[x][i][j] * fac[i] % mod * fac[j] % mod * inv[i + j] % mod;\n        res %= mod;\n        return;\n    &#125;;\n    DFS(1, -1);\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"a---染色问题\">A - 染色问题</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P6076\" class=\"uri\">https://www.luogu.com.cn/problem/P6076</a></p>\n<ul>\n<li><p>题述转化成：恰好 <span class=\"math inline\">\\(n\\)</span> 行，恰好 <span class=\"math inline\">\\(m\\)</span> 列，恰好 <span class=\"math inline\">\\(c\\)</span> 种颜色即可容斥</p></li>\n<li><p>将无色视为一个不参与容斥的颜色，容易写出答案式：</p>\n<p><span class=\"math display\">\\[\n\\sum_{i=0}^{n}\\sum_{j=0}^{m}\\sum_{k=0}^{c} (-1)^{i+j+k}\\times \\binom ni\\times \\binom mj\\times \\binom ck\\times (c-k+1)^{(n-i)(m-j)}\n\\]</span></p></li>\n<li><p>预处理幂次即可。复杂度 <span class=\"math inline\">\\(O(nmc)\\)</span>。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m, c;\n    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; c;\n    std::vector&lt;long long&gt; fac(n * m + 1), inv(n * m + 1);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= n * m; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[n * m] = qkp(fac[n * m], mod - 2);\n    for (int i = n * m - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto C = [&amp;](int n, int m) &#123;\n        if (n &lt; m || m &lt; 0)\n            return 0ll;\n        return fac[n] * inv[m] % mod * inv[n - m] % mod;\n    &#125;;\n    std::vector&lt;std::vector&lt;long long&gt; &gt; pw(c + 2, std::vector&lt;long long&gt; (n * m + 1));\n    for (int i = 1; i &lt;= c + 1; ++i) &#123;\n        pw[i][0] = 1ll;\n        for (int j = 1; j &lt;= n * m; ++j)\n            pw[i][j] = pw[i][j - 1] * i % mod;\n    &#125;\n    auto res = 0ll;\n    for (int i = 0; i &lt;= n; ++i)\n        for (int j = 0; j &lt;= m; ++j)\n            for (int k = 0; k &lt;= c; ++k) &#123;\n                int op = ((i + j + k) &amp; 1) ? mod - 1 : 1;\n                res += op * C(n, i) % mod * C(m, j) % mod * C(c, k) % mod * pw[c - k + 1][(n - i) * (m - j)] % mod;\n            &#125;\n    std::cout &lt;&lt; res % mod &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---painting-the-wall\">B - Painting The Wall</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF398B\" class=\"uri\">https://www.luogu.com.cn/problem/CF398B</a></p>\n<ul>\n<li><p>观察到初始被标记的行列之间等价，相似地，初始未被标记的行列之间等价。故可以粗暴地塞到状态里。</p></li>\n<li><p>参照 <a href=\"/20240111/\">Game with Probability Problem</a> 中解决自转移的思路，考虑解方程。</p>\n<p>设 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示剩余 <span class=\"math inline\">\\(i\\)</span> 行 <span class=\"math inline\">\\(j\\)</span> 列时的期望操作数，列出 DP 式：</p>\n<p><span class=\"math display\">\\[\nf_{i,j}\n\\]</span></p></li>\n</ul>\n",
            "tags": [
                "计数",
                "容斥",
                "二项式反演"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20251029/",
            "url": "https://xsc062.netlify.app/20251029/",
            "title": "学习笔记：CDQ 分治",
            "date_published": "2025-10-29T07:36:06.000Z",
            "content_html": "<p>日常不理解算法本质</p>\n<span id=\"more\"></span>\n<hr />\n<p>周末给 afewdgre 讲题，偶遇简单时间轴问题，拼尽全力勉强战胜</p>\n<h2 id=\"何为时间轴\">何为时间轴</h2>\n<ul>\n<li><p>特点：单向。</p>\n<p>前面的修改会影响后面的查询；反过来，后面的修改不会影响前面的查询。</p></li>\n<li><p>在大部分 DS 题目中，顺序操作是满足这个条件的。考虑不存在明显操作时间轴的问题，通常处理方式是扫描线：即用坐标轴当时间轴，这样做的前提条件也是『前面的修改影响后面的查询，但后面的修改不影响前面的查询』。这里拿给 afewdgre 讲的矩形面积并举例。</p>\n<p>矩形面积并中，把一段 <span class=\"math inline\">\\(x\\)</span> 坐标上，每个 <span class=\"math inline\">\\(y\\)</span> 上矩形存在的状态转化成『某个时刻，一段 <span class=\"math inline\">\\(y\\)</span> 是否被覆盖』，矩形的增删则用差分的方式维护。</p></li>\n</ul>\n<hr />\n<h2 id=\"cdq-分治\">CDQ 分治</h2>\n<ul>\n<li><p>在需求时间轴的需求上，额外要求：</p>\n<p>修改之间无依赖，或者说，<strong>单次修改对询问的影响是可求的。</strong></p></li>\n<li><p>这样就可以分治。大部分分治的基本目标都是，使相同的计算不用被多次进行。</p></li>\n<li><p>每层 CDQ 会统计每个 <span class=\"math inline\">\\([l,mid]\\)</span> 的修改对 <span class=\"math inline\">\\([mid+1,r]\\)</span> 询问的影响。</p></li>\n</ul>\n<p>好像讲完了？</p>\n",
            "tags": [
                "CDQ 分治"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20251028/",
            "url": "https://xsc062.netlify.app/20251028/",
            "title": "杂题选谈",
            "date_published": "2025-10-28T09:06:42.000Z",
            "content_html": "<p>模拟赛的密度正在威胁其他文章的生存环境。</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a.-排序\">A. 排序</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P14352\" class=\"uri\">https://www.luogu.com.cn/problem/P14352</a></p>\n<blockquote>\n<p>对于一个长度为 <span class=\"math inline\">\\(n\\)</span> 的排列 <span class=\"math inline\">\\(p\\)</span>，定义一轮冒泡：</p>\n<pre class=\"python\"><code>for i in range(1, n):\n    if p[i] &gt; p[i + 1]:\n        swap(p[i], p[i + 1])</code></pre>\n<p>给定 <span class=\"math inline\">\\(n,k\\)</span>，问在所有长度为 <span class=\"math inline\">\\(n\\)</span> 的排列中，可以在 <span class=\"math inline\">\\(k\\)</span> 轮冒泡后单增的排列数量。对 <span class=\"math inline\">\\(998244353\\)</span> 取模。</p>\n<p><span class=\"math inline\">\\(n\\le 10^{18},k\\le 2\\times 10^7\\)</span>。</p>\n</blockquote>\n<ul>\n<li><p>反序表。令 <span class=\"math inline\">\\(a_i\\)</span> 表示 <span class=\"math inline\">\\(i\\)</span> 结尾的逆序对数，那么限制相当于说 <span class=\"math inline\">\\(\\max\\{a\\}\\le k\\)</span>。</p></li>\n<li><p>也即限制一个元素之前大于之的元素数不超过 <span class=\"math inline\">\\(k\\)</span>，可以直接计数。想象把 <span class=\"math inline\">\\(1\\sim n\\)</span> 依次填入排列的过程：</p>\n<ul>\n<li><p>对于 <span class=\"math inline\">\\(1\\sim n-k\\)</span>，只能填在剩余空位的左 <span class=\"math inline\">\\(k+1\\)</span> 个（因为填完它后，剩下的空位都比它大）；</p></li>\n<li><p>对于 <span class=\"math inline\">\\(n-k+1\\sim n\\)</span>，可以填在剩余任意一个空位。</p></li>\n</ul>\n<p>故答案为 <span class=\"math inline\">\\((k+1)^{n-k}\\cdot k!\\)</span>。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;sorting.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;sorting.out&quot;, &quot;w&quot;, stdout);\n    auto stime = std::chrono::steady_clock::now();\n    long long n;\n    int k;\n    std::cin &gt;&gt; n &gt;&gt; k, k = std::min((long long)k, n);\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    auto res = qkp(k + 1, (n - k) % (mod - 1));\n    for (int i = 1; i &lt;= k; ++i)\n        (res *= i) %= mod;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt;(std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s \\n&quot;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b.-重排\">B. 重排</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P14353\" class=\"uri\">https://www.luogu.com.cn/problem/P14353</a></p>\n<blockquote>\n<p>给定一个初始为空的数组 <span class=\"math inline\">\\(a\\)</span>，再给出 <span class=\"math inline\">\\(n\\)</span> 次加数操作，每次加数后输出：</p>\n<p>任意排列 <span class=\"math inline\">\\(a\\)</span>，得到的 <span class=\"math inline\">\\(\\sum\\limits_{i=2}^n |a_{i+1}-a_{i}|\\)</span> 的最大值。</p>\n<p><span class=\"math inline\">\\(n\\le 3\\times 10^6\\)</span>。</p>\n</blockquote>\n<ul>\n<li><p>显然从小到大排列，答案是后 <span class=\"math inline\">\\(\\left\\lfloor \\dfrac n2\\right\\rfloor\\)</span> 个数的和减去前 <span class=\"math inline\">\\(\\left\\lfloor \\dfrac n2\\right\\rfloor\\)</span> 的和的差的二倍，再减去位于中间 2 / 3 个数中，相邻两个差的最小值。</p>\n<p>这家伙在说什么呢.jpg</p></li>\n<li><p>用大根堆 + 小根堆维护即可，因为 pbds 过不去</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;rearrange.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;rearrange.out&quot;, &quot;w&quot;, stdout);\n    auto stime = std::chrono::steady_clock::now();\n    int n, T;\n    std::cin &gt;&gt; n &gt;&gt; T;\n    auto res = 0ll, la = 0ll, sL = 0ll, sR = 0ll;\n    std::priority_queue&lt;int&gt; L;\n    std::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt; &gt; R;\n    for (int i = 1, mid = 0; i &lt;= n; ++i) &#123;\n        long long x;\n        std::cin &gt;&gt; x;\n        int b =  T ? x ^ la : x;\n        if (i == 1)\n            mid = b, la = 0ll;\n        else if (i &amp; 1) &#123;\n            if (b &lt; L.top()) &#123;\n                mid = L.top(), sL -= mid;\n                L.pop();\n                sL += b, L.push(b);\n            &#125;\n            else if (b &gt; R.top()) &#123;\n                mid = R.top(), sR -= mid;\n                R.pop();\n                sR += b, R.push(b);\n            &#125;\n            else\n                mid = b;\n            la = 2 * (sR - sL) - std::min(R.top() - mid, mid - L.top());\n        &#125;\n        else &#123;\n            if (b &lt;= mid) &#123;\n                sL += b, sR += mid;\n                L.push(b), R.push(mid);\n            &#125;\n            else &#123;\n                sL += mid, sR += b;\n                L.push(mid), R.push(b);\n            &#125;\n            la = 2 * (sR - sL) - (R.top() - L.top());\n        &#125;\n        res ^= la;\n    &#125;\n    printf(&quot;%lld\\n&quot;, res);\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt;(std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s \\n&quot;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c.-整式比较-qoj10506.-waga\">C. 整式比较 / qoj#10506. Waga</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6685/problem/3\" class=\"uri\">https://www.becoder.com.cn/contest/6685/problem/3</a> / <a href=\"https://qoj.ac/problem/10506\" class=\"uri\">https://qoj.ac/problem/10506</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(a_{1\\cdots n}\\)</span>，和一个称，如下操作称为一次『称重』：</p>\n<ul>\n<li>选中 <span class=\"math inline\">\\(a\\)</span> 的一个子集，输入给称。记它们的和为 <span class=\"math inline\">\\(s\\)</span>，那么称会返回 <span class=\"math inline\">\\(\\min(k,\\left\\lfloor \\dfrac sc \\right\\rfloor)\\)</span>，其中，<span class=\"math inline\">\\(c\\)</span> 为给定常数。</li>\n</ul>\n<p>现在对于每个无序对 <span class=\"math inline\">\\((i,j)\\)</span>（<span class=\"math inline\">\\(i\\ne j\\)</span>），你需要判断：</p>\n<ul>\n<li>在已知 <span class=\"math inline\">\\(a\\)</span> 中除 <span class=\"math inline\">\\(a_i,a_j\\)</span> 外所有元素值，且 <span class=\"math inline\">\\(a_i,a_j\\)</span> 数值未知的前提下，是否可以通过若干次称重确定 <span class=\"math inline\">\\(a_i,a_j\\)</span> 的大小关系。</li>\n</ul>\n<p><span class=\"math inline\">\\(n,c\\le 8000,k\\le 10^5,1\\le a_i&lt; kc\\)</span>。</p>\n</blockquote>\n<ul>\n<li><p>显然，<span class=\"math inline\">\\(a_i\\)</span> 和 <span class=\"math inline\">\\(a_j\\)</span> 能区分，当且仅当 <span class=\"math inline\">\\(\\left\\lfloor\\dfrac {a_i}c\\right\\rfloor\\ne \\left\\lfloor\\dfrac {a_j}c\\right\\rfloor\\)</span>，或者存在一个其他元素的子集 <span class=\"math inline\">\\(s\\)</span>，使得 <span class=\"math inline\">\\(\\left\\lfloor\\dfrac {a_i+s}c\\right\\rfloor\\ne \\left\\lfloor\\dfrac {a_j + s}c\\right\\rfloor\\)</span>。</p>\n<p>反过来，如果 <span class=\"math inline\">\\(a_i\\)</span> 和 <span class=\"math inline\">\\(a_j\\)</span> 不能区分，一个前提是 <span class=\"math inline\">\\(\\left\\lfloor\\dfrac {a_i}c\\right\\rfloor =\\left\\lfloor\\dfrac {a_j}c\\right\\rfloor\\)</span>。</p></li>\n<li><p>下意识猜要排序，排序后打表发现使 <span class=\"math inline\">\\(i\\)</span> 不合法的 <span class=\"math inline\">\\(j\\)</span> 总是连续的。</p>\n<details>\n<p><summary>证明</summary></p>\n<ol type=\"1\">\n<li><p>需要证：对于 <span class=\"math inline\">\\(x&lt;y&lt;z\\)</span>，若 <span class=\"math inline\">\\(x,y\\)</span> 不可区分，且 <span class=\"math inline\">\\(y,z\\)</span> 不可区分，那么 <span class=\"math inline\">\\(x,z\\)</span> 不可区分。</p>\n<p>记 <span class=\"math inline\">\\(\\left\\lfloor\\dfrac {x}c\\right\\rfloor=\\left\\lfloor\\dfrac {y}c\\right\\rfloor=\\left\\lfloor\\dfrac {z}c\\right\\rfloor=w\\)</span>，不存在 <span class=\"math inline\">\\(s\\le c\\cdot (k-w)\\)</span>，使得 <span class=\"math inline\">\\(y\\)</span> 可以进位但 <span class=\"math inline\">\\(x\\)</span> 不可，也不存在这样的 <span class=\"math inline\">\\(s\\)</span> 使得 <span class=\"math inline\">\\(z\\)</span> 可以进位但 <span class=\"math inline\">\\(y\\)</span> 不可。</p>\n<p>合并不等式容易得到不存在这样的 <span class=\"math inline\">\\(x\\)</span> 使得 <span class=\"math inline\">\\(z\\)</span> 可以进位但 <span class=\"math inline\">\\(x\\)</span> 不可。</p></li>\n<li><p>需要证：对于 <span class=\"math inline\">\\(x&lt;y&lt;z\\)</span>，若 <span class=\"math inline\">\\(x,y\\)</span> 可区分或 <span class=\"math inline\">\\(y,z\\)</span> 可区分，则 <span class=\"math inline\">\\(x,z\\)</span> 可区分。</p>\n<p>调整法易得。</p></li>\n</ol>\n</details></li>\n<li><p>故发现只需要讨论相邻两个元素是否可区分。需要知道所有可能的子集和用于 check，可以用分治预处理『只有某相邻两个元素不选』时的前后缀背包数组（到达某个余数时需要的最小整倍数），就可以 <span class=\"math inline\">\\(O(nc\\log n)\\)</span> 解决问题。</p>\n<p>考虑在做什么：删点在 <span class=\"math inline\">\\([l,mid]\\)</span>，那么 <span class=\"math inline\">\\([mid+1,r]\\)</span> 的 DP 数组不会受到影响；删点在 <span class=\"math inline\">\\([mid + 1, r]\\)</span>，那么 <span class=\"math inline\">\\([l,mid]\\)</span> 的 DP 数组不会受到影响。背包的物品是无顺序的，所以有正确性。</p>\n<p>也就是说大部分信息是可继承的。<em>为什么题解管这个叫 CDQ？是因为普通分治总会被叫 CDQ 吗？</em></p>\n<p>做一个类似 01 背包滚动数组的东西，维护每个点前 / 后可以凑出来的背包值，在最后下传到单点时统计答案即可。</p></li>\n</ul>\n<details>\n<p>相邻两个的处理略显烧脑，但意外地简洁。</p>\n<p><code>&gt;=</code> 不要写成除，不然会慢成唐诗</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 8e3 + 5;\nchar nec(void) &#123;\n    static char buf[1 &lt;&lt; 20], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, 1 &lt;&lt; 20, stdin);\n        p = buf;\n    &#125;\n    return *p++;\n&#125;\nint read(void) &#123;\n    auto x = 0ll;\n    char t = nec();\n    for (; t &lt; &#39;0&#39; || t &gt; &#39;9&#39;; t = nec());\n    for (; t &gt;= &#39;0&#39; &amp;&amp; t &lt;= &#39;9&#39;; t = nec())\n        x = x * 10 + t - &#39;0&#39;;\n    return x;\n&#125;\nint ok[maxn], m, k;\nstd::pair&lt;int, int&gt; a[maxn];\nvoid calc(int l, int r, const std::vector&lt;int&gt; f) &#123;\n    if (l &gt; r)\n        return;\n    if (l == r) &#123;\n        if (a[l].first == a[l + 1].first)\n            ok[l] = 1;\n        else if (a[l].first / m == a[l + 1].first / m)\n            ok[l] = (*std::min_element(f.begin() + m - a[l + 1].first % m, f.begin() + m - a[l].first % m) + a[l].first / m &gt;= k);\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    auto g = f;\n    for (int i = mid + 2; i &lt;= r + 1; ++i) &#123;\n        auto h = g;\n        for (int j = 0, k; j &lt; m; ++j) &#123;\n            k = (j + m - a[i].first % m) % m;\n            h[j] = std::min(h[j], g[k] + a[i].first / m + (k + a[i].first % m &gt;= m));\n        &#125;\n        h.swap(g);\n    &#125;\n    calc(l, mid, g);\n    g = f;\n    for (int i = l; i &lt;= mid; ++i) &#123;\n        auto h = g;\n        for (int j = 0, k; j &lt; m; ++j) &#123;\n            k = (j + m - a[i].first % m) % m;\n            h[j] = std::min(h[j], g[k] + a[i].first / m + (k + a[i].first % m &gt;= m));\n        &#125;\n        h.swap(g);\n    &#125;\n    calc(mid + 1, r, g);\n    return;\n&#125;;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;intcmp.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;intcmp.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n = read();\n    m = read(), k = read();\n    for (int i = 1; i &lt;= n; ++i)\n        a[i].first = read(), a[i].second = i;\n    std::sort(a + 1, a + n + 1);\n    std::vector&lt;int&gt; f(m, 0x3f3f3f3f);\n    f[0] = 0;\n    calc(1, n - 1, f);\n    std::vector&lt;int&gt; resL(n + 1), resR(n + 1);\n    int now = 0;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        resR[a[i].second] = i - 1 - now;\n        if (i != n &amp;&amp; ok[i])\n            ++now;\n        else\n            now = 0;\n    &#125;\n    now = 0;\n    for (int i = n; i; --i) &#123;\n        resL[a[i].second] = n - i - now;\n        if (ok[i - 1])\n            ++now;\n        else\n            now = 0;\n    &#125;\n    for (int i = 1; i &lt;= n; ++i)\n        printf(&quot;%d %d \\n&quot;, resL[i], resR[i]);\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b.-字符串转换\">B. 字符串转换</h2>\n<p><a href=\"https://www.becoder.com.cn/problem/52055\" class=\"uri\">https://www.becoder.com.cn/problem/52055</a></p>\n<blockquote>\n<p>给定等长 01 串 <span class=\"math inline\">\\(S,T\\)</span>，维护 <span class=\"math inline\">\\(Q\\)</span> 次操作：</p>\n<ul>\n<li>修改：Flip <span class=\"math inline\">\\(S\\)</span> 的某个字符。</li>\n<li>修改：Flip <span class=\"math inline\">\\(T\\)</span> 的某个字符。</li>\n</ul>\n<p>每次操作后，问 <span class=\"math inline\">\\(S\\)</span> 能否通过若干次下列操作变为 <span class=\"math inline\">\\(T\\)</span>：</p>\n<ul>\n<li>选择 <span class=\"math inline\">\\(S\\)</span> 中的一个 <code>00</code>，变为 <code>10</code>。</li>\n<li>选择 <span class=\"math inline\">\\(S\\)</span> 中的一个 <code>11</code>，变为 <code>01</code>。</li>\n</ul>\n<p><span class=\"math inline\">\\(|S|,Q\\le 3\\times 10^5\\)</span>。</p>\n</blockquote>\n<ul>\n<li><p>连续 00 / 11 操作，考虑奇数位取反。取反之后发现原操作等价于 <span class=\"math inline\">\\(a_i\\gets a_{i+1}\\)</span>。</p></li>\n<li><p>这个操作只会使连续段的数量减少，故要求每一个后缀，<span class=\"math inline\">\\(S\\)</span> 的连续段个数不少于 <span class=\"math inline\">\\(T\\)</span> 的连续段个数，而且二者结尾相同。</p>\n<p>线段树维护即可。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 3e5 + 5;\nstruct &#123; int l, r, mn, d; &#125; t[maxn &lt;&lt; 2];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    t[p].mn = t[p].d = 0;\n    if (l == r)\n        return;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    return;\n&#125;\nvoid pushdown(int p) &#123;\n    if (t[p].d) &#123;\n        t[lt].mn += t[p].d, t[lt].d += t[p].d;\n        t[rt].mn += t[p].d, t[rt].d += t[p].d;\n        t[p].d = 0;\n    &#125;\n    return;\n&#125;\nvoid add(int p, int l, int r, int v) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        t[p].mn += v, t[p].d += v;\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid)\n        add(lt, l, r, v);\n    if (r &gt; mid)\n        add(rt, l, r, v);\n    t[p].mn = std::min(t[lt].mn, t[rt].mn);\n    return;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;string.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;string.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, q;\n        std::cin &gt;&gt; n &gt;&gt; q;\n        std::vector&lt;int&gt; a(n + 1), b(n + 1);\n        bld(1, 1, n);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            char t;\n            std::cin &gt;&gt; t, a[i] = (t == &#39;B&#39;);\n            if (i &amp; 1)\n                a[i] ^= 1;\n        &#125;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            char t;\n            std::cin &gt;&gt; t, b[i] = (t == &#39;B&#39;);\n            if (i &amp; 1)\n                b[i] ^= 1;\n        &#125;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            int v = 0;\n            v += (i == n || a[i] != a[i + 1]);\n            v -= (i == n || b[i] != b[i + 1]);\n            if (v)\n                add(1, 1, i, v);\n        &#125;\n        for (char op; q--; ) &#123;\n            int i;\n            std::cin &gt;&gt; op &gt;&gt; i;\n            if (op == &#39;X&#39;) &#123;\n                int v = 0, v1 = 0;\n                v -= (i == n || a[i] != a[i + 1]);\n                v1 -= (i != 1 &amp;&amp; a[i] != a[i - 1]);\n                a[i] ^= 1;\n                v += (i == n || a[i] != a[i + 1]);\n                v1 += (i != 1 &amp;&amp; a[i] != a[i - 1]);\n                if (v)\n                    add(1, 1, i, v);\n                if (v1)\n                    add(1, 1, i - 1, v1);\n            &#125;\n            else &#123;\n                int v = 0, v1 = 0;\n                v += (i == n || b[i] != b[i + 1]);\n                v1 += (i != 1 &amp;&amp; b[i] != b[i - 1]);\n                b[i] ^= 1;\n                v -= (i == n || b[i] != b[i + 1]);\n                v1 -= (i != 1 &amp;&amp; b[i] != b[i - 1]);\n                if (v)\n                    add(1, 1, i, v);\n                if (v1)\n                    add(1, 1, i - 1, v1);\n            &#125;\n            std::cout &lt;&lt; ((a[n] == b[n] &amp;&amp; t[1].mn &gt;= 0) ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; &#39;\\n&#39;;\n        &#125;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c.-监控\">C. 监控</h2>\n<p><a href=\"https://www.becoder.com.cn/problem/52057\" class=\"uri\">https://www.becoder.com.cn/problem/52057</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(n\\)</span> 个怪，每个怪有 <span class=\"math inline\">\\(B_i\\)</span> 滴血，也就是说每个怪能被打 <span class=\"math inline\">\\(\\le B_i\\)</span> 次。</p>\n<p>要求每个怪必须被打 <span class=\"math inline\">\\(\\ge A_i\\)</span> 次，并认为被打恰好 <span class=\"math inline\">\\(A_i\\)</span> 次时这个怪是好的。</p>\n<p>对于每个 <span class=\"math inline\">\\(1\\le x\\le \\sum B_i\\)</span>，求：在攻击次数只能为 <span class=\"math inline\">\\(x\\)</span> 的倍数的前提下，不好的怪的最小值。你只需要输出答案的和。</p>\n<p><span class=\"math inline\">\\(N\\le 10^5,1\\le A_i&lt; B_i\\le 10^5\\)</span>。</p>\n</blockquote>\n<ul>\n<li><p>记 <span class=\"math inline\">\\(c_i=B_i-A_i\\)</span>，把 <span class=\"math inline\">\\(c_i\\)</span> 降序排列，记 <span class=\"math inline\">\\(s=\\sum A_i\\)</span>，那么一个 <span class=\"math inline\">\\(x\\)</span> 的答案为：</p>\n<p><span class=\"math display\">\\[\n\\min\\left\\{i\\mid{\\left\\lceil \\frac{s}x \\right\\rceil\\cdot x - s\\ge c_i}\\right\\}\n\\]</span></p></li>\n<li><p>容易想到整除分块，枚举 <span class=\"math inline\">\\(\\left\\lceil \\dfrac{s}x \\right\\rceil\\)</span> 的值 <span class=\"math inline\">\\(k\\)</span>，那么相当于想要找到 <span class=\"math inline\">\\([L_i,R_i]\\)</span> 中的每个 <span class=\"math inline\">\\(x\\)</span>，<span class=\"math inline\">\\(x\\cdot k-s\\)</span> 会落在哪个 <span class=\"math inline\">\\(c\\)</span> 的管辖范围里。</p>\n<p>不妨记 <span class=\"math inline\">\\(c_i\\)</span> 的管辖范围为 <span class=\"math inline\">\\([cL_i,cR_i]\\)</span>，那么转化为 <span class=\"math inline\">\\(x\\cdot k-s\\in [cL_i,cR_i]\\)</span>，枚举 <span class=\"math inline\">\\(c\\)</span> 解不等式即可。</p></li>\n<li><p>但发现一个严重的问题：外层整除分块复杂度是 <span class=\"math inline\">\\(\\sqrt(s)\\)</span> 的，最劣 <span class=\"math inline\">\\(10^5\\)</span> 级别，很坏了。</p>\n<p>发现枚举商数劣的原因是使 <span class=\"math inline\">\\(\\left\\lceil \\dfrac{s}x \\right\\rceil\\)</span> 很大的 <span class=\"math inline\">\\(x\\)</span> 并不多，却占用了很多枚举次数</p>\n<p>如果做经典的整除分块同样会发现到后期块内元素远远少于 <span class=\"math inline\">\\(n\\)</span>，却要花费 <span class=\"math inline\">\\(n\\)</span> 次操作来处理它们。所以对于这部分数我们直接朴素二分。</p></li>\n<li><p>取阈值为 1500 即可。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int B = 1500;\nconst long long inf = 1e18;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;long long&gt; c(n + 1);\n    auto sa = 0ll, sb = 0ll;\n    for (int i = 1, a, b; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a &gt;&gt; b;\n        sa += a, sb += b, c[i] = b - a;\n    &#125;\n    std::sort(c.begin() + 1, c.end(), std::greater&lt;int&gt; ());\n    std::partial_sum(c.begin() + 1, c.end(), c.begin() + 1);\n    auto L = sb + 1;\n    std::stack&lt;std::pair&lt;long long, int&gt; &gt; st;\n    for (int k = 1; k &lt;= 1500; ++k) &#123;\n        auto l = (sa + k - 1) / k, r = L - 1;\n        if (l &gt; r)\n            continue;\n        L = l;\n        st.emplace(r, n + 1);\n        for (int i = n; ~i; --i)\n            st.emplace(std::min(r, (c[i] + sa) / k), i);\n    &#125;\n    for (int i = L - 1; i; --i)\n        st.emplace(i, std::lower_bound(c.begin(), c.end(), ((sa + i - 1) / i) * i - sa) - c.begin());\n    auto res = 0ll;\n    for (auto l = 1ll; !st.empty(); ) &#123;\n        auto [r, v] = st.top();\n        st.pop();\n        if (l &gt; r)\n            continue;\n        if (v == n + 1)\n            v = 0;\n        res += (r - l + 1) * v;\n        l = r + 1;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"g---range-set-modifying-query\">G - Range Set Modifying Query</h2>\n<p><a href=\"https://atcoder.jp/contests/abc430/tasks/abc430_g\" class=\"uri\">https://atcoder.jp/contests/abc430/tasks/abc430_g</a></p>\n<ul>\n<li><p>发现开 60 个线段树非常合理</p></li>\n<li><p>接着发现是 beats 板子题。看似需要三只 log，其实只有两只。</p></li>\n<li><p>参见 abc426，最近 abc 都喜欢 beats 板子题吗？</p></li>\n</ul>\n",
            "tags": [
                "分治",
                "分块",
                "背包"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20251023/",
            "url": "https://xsc062.netlify.app/20251023/",
            "title": "杂题选谈：图论思维题",
            "date_published": "2025-10-23T03:32:05.000Z",
            "content_html": "<p>人类智慧题</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a---train-splitting\">A - Train Splitting</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1776F\" class=\"uri\">https://www.luogu.com.cn/problem/CF1776F</a></p>\n<ul>\n<li><p>神秘构造题，猜 <span class=\"math inline\">\\(k=2\\)</span> 一定能构造</p></li>\n<li><p>考虑直接从图上抠一个点下来，与之相关的边全部染成 1，剩下的染成 2</p></li>\n<li><p>发现如果恰好选中了菊花的根就不行</p>\n<p>需要找到一个度数不为 <span class=\"math inline\">\\(n-1\\)</span> 的点。完全图的话，从菊花的根上抠一条当颜色 3 即可。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, m;\n        std::cin &gt;&gt; n &gt;&gt; m;\n        std::vector&lt;int&gt; deg(n + 1);\n        std::vector&lt;std::pair&lt;int, int&gt; &gt; e(m + 1);\n        int pos = -1;\n        for (int i = 1; i &lt;= m; ++i) &#123;\n            std::cin &gt;&gt; e[i].first &gt;&gt; e[i].second;\n            ++deg[e[i].first], ++deg[e[i].second];\n        &#125;\n        for (int i = 1; i &lt;= n; ++i)\n            if (deg[i] != n - 1) &#123;\n                pos = i;\n                break;\n            &#125;\n        if (pos != -1) &#123;\n            std::cout &lt;&lt; 2 &lt;&lt; &#39;\\n&#39;;\n            for (int i = 1; i &lt;= m; ++i)\n                if (e[i].first == pos || e[i].second == pos)\n                    std::cout &lt;&lt; 1 &lt;&lt; &#39; &#39;;\n                else\n                    std::cout &lt;&lt; 2 &lt;&lt; &#39; &#39;;\n            std::cout &lt;&lt; &#39;\\n&#39;;\n        &#125;\n        else &#123;\n            std::cout &lt;&lt; 3 &lt;&lt; &#39;\\n&#39;;\n            pos = 1;\n            bool flag = true;\n            for (int i = 1; i &lt;= m; ++i)\n                if (e[i].first == pos || e[i].second == pos) &#123;\n                    if (flag)\n                        std::cout &lt;&lt; 3 &lt;&lt; &#39; &#39;, flag = false;\n                    else\n                        std::cout &lt;&lt; 1 &lt;&lt; &#39; &#39;;\n                &#125;\n                else\n                    std::cout &lt;&lt; 2 &lt;&lt; &#39; &#39;;\n        &#125;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---graph-partition\">B - Graph Partition</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_agc039_b\" class=\"uri\">https://www.luogu.com.cn/problem/AT_agc039_b</a></p>\n<ul>\n<li>考虑二分图染色什么时候不行，即有奇环时</li>\n<li>考虑有多少种颜色时能染奇环，发现都不行，故二分图染色即可判定。</li>\n<li><p>真的只有绿吗？观察样例，猜测答案为图的直径。考虑构造：</p>\n<p>枚举每个点并钦定其为唯一一个 <span class=\"math inline\">\\(1\\)</span>，然后依次向下染色。显然最后构造出来的是合法的。最大为直径长度 + 1。</p>\n<p>也可以从差分约束的角度理解，但无甚必要。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1), g1(n + 1, std::vector&lt;int&gt; (n + 1, 0x3f3f3f3f));\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        g1[i][i] = 0;\n        for (int j = 1; j &lt;= n; ++j) &#123;\n            char t;\n            std::cin &gt;&gt; t;\n            if (t == &#39;1&#39;)\n                g[i].push_back(j), g1[i][j] = 1;\n        &#125;\n    &#125;\n    std::vector&lt;int&gt; col(n + 1);\n    std::function&lt;bool(int, int)&gt; DFS = [&amp;](int x, int now) &#123;\n        col[x] = now;\n        for (auto i : g[x])\n            if (!col[i]) &#123;\n                if (!DFS(i, 3 - now))\n                    return false;\n            &#125;\n            else if (col[i] == now)\n                return false;\n        return true;\n    &#125;;\n    if (!DFS(1, 1))\n        std::cout &lt;&lt; -1 &lt;&lt; &#39;\\n&#39;;\n    else &#123;\n        for (int k = 1; k &lt;= n; ++k)\n            for (int i = 1; i &lt;= n; ++i)\n                for (int j = 1; j &lt;= n; ++j)\n                    g1[i][j] = std::min(g1[i][j], g1[i][k] + g1[k][j]);\n        int mx = 0;\n        for (int i = 1; i &lt;= n; ++i)\n            for (int j = 1; j &lt;= n; ++j)\n                mx = std::max(mx, g1[i][j] + 1);\n        std::cout &lt;&lt; mx &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---strange-housing\">C - Strange Housing</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1470D\" class=\"uri\">https://www.luogu.com.cn/problem/CF1470D</a></p>\n<ul>\n<li>第一反应是随便找一个生成树然后二分图染色，但是发现有当且仅当奇环时行为不太正确</li>\n<li>考虑打个补丁，抛弃二分图染色的想法，不断尝试染成黑色，如果染了下一个点会出现黑黑边，那就不染它，对得比较显然。</li>\n<li>当且仅当不连通时无解。</li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, m;\n        std::cin &gt;&gt; n &gt;&gt; m;\n        std::vector&lt;int&gt; f(n + 1);\n        std::iota(f.begin() + 1, f.end(), 1);\n        std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;\n            return x == f[x] ? x : f[x] = find(f[x]);\n        &#125;;\n        std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1), g1(n + 1);\n        int cnt = 0;\n        for (int x, y; m--; ) &#123;\n            std::cin &gt;&gt; x &gt;&gt; y;\n            g1[x].push_back(y), g1[y].push_back(x);\n            if (find(x) != find(y)) &#123;\n                f[find(x)] = find(y);\n                ++cnt, g[x].push_back(y), g[y].push_back(x);\n            &#125;\n        &#125;\n        if (cnt != n - 1) &#123;\n            std::cout &lt;&lt; &quot;NO\\n&quot;;\n            continue;\n        &#125;\n        std::vector&lt;int&gt; col(n + 1);\n        std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n            for (auto i : g[x])\n                if (i != fa) &#123;\n                    bool flag = true;\n                    for (auto j : g1[i])\n                        if (col[j] == 2) &#123;\n                            flag = false;\n                            break;\n                        &#125;\n                    if (flag)\n                        col[i] = 2;\n                    else\n                        col[i] = 1;\n                    DFS(i, x);\n                &#125;\n            return;\n        &#125;;\n        col[1] = 2, DFS(1, -1);\n        std::vector&lt;int&gt; res;\n        for (int i = 1; i &lt;= n; ++i)\n            if (col[i] == 2)\n                res.push_back(i);\n        std::cout &lt;&lt; &quot;YES\\n&quot; &lt;&lt; (int)res.size() &lt;&lt; &#39;\\n&#39;;\n        for (auto i : res)\n            std::cout &lt;&lt; i &lt;&lt; &#39; &#39;;\n        std::cout &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d---defender-of-childhood-dreams\">D - Defender of Childhood Dreams</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1583F\" class=\"uri\">https://www.luogu.com.cn/problem/CF1583F</a></p>\n<ul>\n<li><p>考虑把每连续 <span class=\"math inline\">\\(k\\)</span> 个点分为一个一级组，每个一级组内全部连 <span class=\"math inline\">\\(1\\)</span> 边。显然组内边最长不超过 <span class=\"math inline\">\\(k-1\\)</span>。</p></li>\n<li><p>接着把每连续 <span class=\"math inline\">\\(k\\)</span> 个一级组分为一个二级组，二级组内空闲边全部涂成颜色 <span class=\"math inline\">\\(2\\)</span>。</p>\n<p>此时 <span class=\"math inline\">\\(a&lt;b\\)</span> 的条件就会派上用场：每个一级组的值域是没有交的，一级组之间的边都是同一个朝向。</p>\n<p>这样就保证由颜色为 <span class=\"math inline\">\\(2\\)</span> 的边构成的连链来自不同的一级组，长度最多为 <span class=\"math inline\">\\(k-1\\)</span>。</p></li>\n<li><p>依次类推，<span class=\"math inline\">\\(i\\)</span> 级组是大小为 <span class=\"math inline\">\\(k^i\\)</span> 的团，故 <span class=\"math inline\">\\(i\\)</span> 最大为 <span class=\"math inline\">\\(\\left\\lceil \\log_kn\\right\\rceil\\)</span>。</p></li>\n<li><p>按上述流程构造，即可 <span class=\"math inline\">\\(O(n^2)\\)</span> 完成。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    using arr = std::vector&lt;int&gt;;\n    using brr = std::vector&lt;arr&gt;;\n    brr pos;\n    for (int i = 1; i &lt;= n; ++i)\n        pos.push_back(&#123; i &#125;);\n    brr g(n + 1, arr(n + 1));\n    std::function&lt;void(brr&amp;, int)&gt; calc = [&amp;](brr &amp;pos, int now) &#123;\n        if ((int)pos.size() == 1) &#123;\n            std::cout &lt;&lt; now &lt;&lt; &#39;\\n&#39;;\n            for (int i = 1; i &lt;= n; ++i)\n                for (int j = i + 1; j &lt;= n; ++j)\n                    std::cout &lt;&lt; g[i][j] &lt;&lt; &#39; &#39;;\n            std::cout &lt;&lt; &#39;\\n&#39;;\n            return;\n        &#125;\n        brr p;\n        ++now;\n        for (int i = 0; i &lt; (int)pos.size(); i += k) &#123;\n            p.emplace_back();\n            for (int j = i; j &lt; i + k &amp;&amp; j &lt; (int)pos.size(); ++j) &#123;\n                for (auto a : p.back())\n                    for (auto b : pos[j])\n                        g[a][b] = now;\n                for (auto b : pos[j])\n                    p.back().push_back(b);\n            &#125;\n        &#125;\n        calc(p, now);\n        return;\n    &#125;;\n    calc(pos, 0);\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"e---edge-split\">E - Edge Split</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1726D\" class=\"uri\">https://www.luogu.com.cn/problem/CF1726D</a></p>\n<ul>\n<li>题意有些许歧义，『红色连通块』其实是指删掉蓝边之后的连通块。考虑到 <span class=\"math inline\">\\(m\\le n+2\\)</span> 而不是更多，考虑直接分讨。</li>\n<li>考虑树的情况，对于任意颜色，删一条边就会带来 <span class=\"math inline\">\\(1\\)</span> 个连通块的代价，随便染色即可。</li>\n<li><p>考虑基环树的情况，发现如果环上有某个颜色，那么钦定这个颜色第一次删边删的是环边，就会发现第一次删边不会有代价，故强制环上有两种颜色即可。</p>\n<p>考虑 <span class=\"math inline\">\\(m=n+1\\)</span> 的情况，环可能有下面三种形态：</p>\n<p><img src=\"image.png\" /></p>\n<p>对于第一、二种，保证两个环上都有两种颜色即可，第三种乍一看有点复杂，其实还是一样的，保证两个环都有两种颜色即可，这样三个环显然都会有两种颜色。站在不饱和度的角度，第三个环其实是无意义的。</p></li>\n<li><p>由此类推 <span class=\"math inline\">\\(m=n+2\\)</span> 的情况，发现只需要在并查集连边时令树边为蓝，反祖边为红即可。发现这样会且仅会在第一组样例的情况出问题：</p>\n<figure>\n<img src=\"image-1.png\" alt=\"如果中间的三角形在最后输入就不能得到最优解\" /><figcaption>如果中间的三角形在最后输入就不能得到最优解</figcaption>\n</figure>\n<p>怎么处理这个问题呢，我们使用人类智慧，发现这种情况最后三条红边构成三角形，我们只要发现构造出来的解是这样的三角形，由于造成这一点的顺序很苛刻，故一直 <code>random_shuffle</code> 输入，继续构造直到合法即可。</p>\n<p>（？怎么最优解全是这么做的，我还以为只有我一个人会乱搞。）</p></li>\n<li><p>当不饱和度为 4 的时候就会出现这种结构：</p>\n<p><img src=\"image-2.png\" /></p>\n<p>此时按照刚刚的方法就一定构造不出合法解了。这或许也是 <span class=\"math inline\">\\(m\\le n+2\\)</span> 的原因。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    std::mt19937 rand(0xabcdef);\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, m;\n        std::cin &gt;&gt; n &gt;&gt; m;\n        std::vector&lt;int&gt; res(m + 1);\n        std::vector&lt;std::tuple&lt;int, int, int&gt; &gt; e(m + 1);\n        for (int i = 1, x, y; i &lt;= m; ++i) &#123;\n            std::cin &gt;&gt; x &gt;&gt; y;\n            e[i] = &#123; x, y, i &#125;;\n        &#125;\n        auto work = [&amp;](std::vector&lt;std::tuple&lt;int, int, int&gt; &gt; &amp;e) &#123;\n            std::vector&lt;int&gt; f(n + 1);\n            std::iota(f.begin() + 1, f.end(), 1);\n            std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;\n                return x == f[x] ? x : f[x] = find(f[x]);\n            &#125;;\n            std::set&lt;int&gt; t;\n            for (int i = 1; i &lt;= m; ++i) &#123;\n                auto [x, y, id] = e[i];\n                if (find(x) == find(y)) &#123;\n                    t.insert(x), t.insert(y);\n                    res[id] = 1;\n                &#125;\n                else &#123;\n                    res[id] = 0;\n                    f[find(x)] = find(y);\n                &#125;\n            &#125;\n            return (int)t.size() != 3;\n        &#125;;\n        for (; !work(e); std::shuffle(e.begin() + 1, e.end(), rand));\n        for (int i = 1; i &lt;= m; ++i)\n            std::cout &lt;&lt; res[i];\n        std::cout &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"f---fair-share\">F - Fair Share</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1634E\" class=\"uri\">https://www.luogu.com.cn/problem/CF1634E</a></p>\n<p>原来 <span class=\"math inline\">\\(L=R\\)</span> 是说两个可重集相等 不是说和相等</p>\n<ul>\n<li><p>考虑把所有元素排得整齐一点：同一组的在同一行，同一值的在同一列（显然这就要求每列元素个数为偶）。这样要求就转化为：分组，并满足每行每组各占一半、每列每组各占一半。</p></li>\n<li><p>参考 <a href=\"https://vjudge.net/problem/OpenJ_POJ-C19A\">Ball</a>，用连边可以体现二选一的操作，发现其实二选一就是一选二分之一，故在行列中连边，按照 <span class=\"math inline\">\\((1,2)\\)</span>，<span class=\"math inline\">\\((3,4)\\)</span> 这样连边，就可以满足一选二分之一。</p>\n<p>因为元素可重，所以一行一列可能会有多个元素，这不太好；实际实现时，不妨记输入的第 <span class=\"math inline\">\\(i\\)</span> 个数组第 <span class=\"math inline\">\\(j\\)</span> 个元素为 <span class=\"math inline\">\\(a_{i,j}\\)</span>，实际上连的是 <span class=\"math inline\">\\((a_{i,j},a_{i,j\\oplus 1})\\)</span>；记值为 <span class=\"math inline\">\\(i\\)</span> 的第 <span class=\"math inline\">\\(j\\)</span> 个元素为 <span class=\"math inline\">\\(b_{i,j}\\)</span>，实际上连的是 <span class=\"math inline\">\\((b_{i,j},b_{i,j\\oplus 1})\\)</span>。</p></li>\n<li><p>还是参照 Ball 中二分图的观点，发现这个图很能二分图染色。如果这个解法是足够优的，我们当然希望不包含奇环。由于一个点在 <span class=\"math inline\">\\(a\\)</span> 中至多被连一条边，在 <span class=\"math inline\">\\(b\\)</span> 中也至多被连一条边，所以一条路径一定是 a b 交错的，由此证毕。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, tot = 0, N = 0;\n    std::cin &gt;&gt; n;\n    std::unordered_map&lt;int, int&gt; tab;\n    std::vector&lt;std::vector&lt;int&gt; &gt; a(n + 1), b(1);\n    for (int i = 1, m; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; m;\n        for (int x; m--; ) &#123;\n            std::cin &gt;&gt; x, ++N;\n            if (!tab.count(x))\n                tab[x] = ++tot, b.emplace_back();\n            a[i].push_back(N);\n            b[tab[x]].push_back(N);\n        &#125;\n    &#125;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(N + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = 0; j &lt; (int)a[i].size(); ++j)\n            g[a[i][j]].push_back(a[i][j ^ 1]);\n    for (int i = 1; i &lt;= tot; ++i) &#123;\n        if ((int)b[i].size() &amp; 1) &#123;\n            std::cout &lt;&lt; &quot;NO\\n&quot;;\n            return 0;\n        &#125;\n        for (int j = 0; j &lt; (int)b[i].size(); ++j)\n            g[b[i][j]].push_back(b[i][j ^ 1]);\n    &#125;\n    std::cout &lt;&lt; &quot;YES\\n&quot;;\n    std::vector&lt;int&gt; col(N + 1);\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int now) &#123;\n        col[x] = now;\n        for (auto i : g[x])\n            if (!col[i])\n                DFS(i, 3 - now);\n            else\n                assert(col[i] != col[x]);\n        return;\n    &#125;;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (auto j : a[i]) &#123;\n            if (!col[j])\n                DFS(j, 1);\n            std::cout &lt;&lt; (col[j] == 1 ? &#39;L&#39; : &#39;R&#39;);\n        &#125;\n        std::cout &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"g---lenient-vertex-cover\">G - Lenient Vertex Cover</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1680F\" class=\"uri\">https://www.luogu.com.cn/problem/CF1680F</a></p>\n<ul>\n<li><p>对于边不被完全覆盖的限制把问题转换成了一个近似二分图染色的形态，一个朴素的做法是枚举这样的边并染色，但似乎没什么优化前途，考虑更加二分图的做法。</p></li>\n<li><p>从非法的角度考虑，相当于是问能不能抠掉 <span class=\"math inline\">\\(\\le 1\\)</span> 条边使图变为二分图。显然这条边（如果存在）在奇环上且是所有奇环的交。</p>\n<p><strong>从合法的角度考虑</strong>，因为不是真的删边，而是相当于把所在的所有环长度 <span class=\"math inline\">\\(-1\\)</span>，所以这条边不能被任何一个偶环包含。</p></li>\n<li><p>容易想到找生成树，标记偶环边并统计奇环。但显然没办法标记到所有偶环边，也没办法统计到所有奇环：</p>\n<p><img src=\"image-3.png\" /></p>\n<details>\n<p><summary>实际上这个做法可以证明是正确的，因为有一个前提：<strong>非树边总是可以和树边成环</strong>。</summary></p>\n<p>考虑两个疑点：</p>\n<ol type=\"1\">\n<li><p>无法标记到所有偶环：当且仅当存在偶环需要 <span class=\"math inline\">\\(\\ge 2\\)</span> 条非树边参与形成。需要证明这样的偶环上的树边不会被选中。</p>\n<p>单看这个环上的树边，形成 <span class=\"math inline\">\\(\\ge 2\\)</span> 个条分立的链。考虑它们在树上是怎么连通的：</p>\n<ul>\n<li><p>中间相隔奇数条树边。那么会被另一条非树边标记为偶环。</p></li>\n<li><p>中间相隔偶数条树边。那么这两条链一定不会被认定为可选的奇环边，因为一条非树边 + 这偶数条边会形成一个新的、与当前偶环分立的奇环。</p>\n<p><img src=\"image-4.png\" /></p></li>\n</ul></li>\n<li><p>无法判定到所有奇环：当且仅当存在奇环需要 <span class=\"math inline\">\\(\\ge 2\\)</span> 条非树边参与形成。需要证明被选中的边被包含在这样的奇环中。</p>\n<p>相似地，单看这个环上的树边，形成 <span class=\"math inline\">\\(\\ge 2\\)</span> 个条分立的链。考虑它们在树上是怎么连通的：</p>\n<ul>\n<li><p>中间相隔偶数条树边。上帝视角下共两个奇环，且公共边为这个奇环中除了另一条非树边以外的所有边。</p>\n<p>实际上的行为也是正确的，另一条非树边参与形成并标记一个偶环，当前非树边形成并标记一个奇环。</p></li>\n<li><p>中间相隔奇数条树边。那么会被另一条非树边标记为偶环，当前奇环中唯一可选的边为当前非树边。</p>\n<p>实际行为也是正确的。比较显然。</p></li>\n</ul>\n<p><img src=\"image-5.png\" /></p></li>\n</ol>\n</details>\n<p>故树上差分维护即可。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, m;\n        std::cin &gt;&gt; n &gt;&gt; m;\n        std::vector&lt;std::pair&lt;int, int&gt; &gt; e;\n        std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1), g1(n + 1);\n        for (int i = 1, x, y; i &lt;= m; ++i) &#123;\n            std::cin &gt;&gt; x &gt;&gt; y;\n            e.emplace_back(x, y);\n            g1[x].push_back(y), g1[y].push_back(x);\n        &#125;\n        std::vector&lt;int&gt; col(n + 1);\n        std::function&lt;bool(int, int)&gt; DFS = [&amp;](int x, int now) &#123;\n            col[x] = now;\n            for (auto i : g1[x])\n                if (!col[i]) &#123;\n                    if (!DFS(i, 3 - now))\n                        return false;\n                &#125;\n                else if (col[i] == now)\n                    return false;\n            return true;\n        &#125;;\n        if (DFS(1, 1)) &#123;\n            std::cout &lt;&lt; &quot;YES\\n&quot;;\n            for (int i = 1; i &lt;= n; ++i)\n                std::cout &lt;&lt; col[i] - 1;\n            std::cout &lt;&lt; &#39;\\n&#39;;\n            continue;\n        &#125;\n        std::vector&lt;int&gt; f(n + 1);\n        std::iota(f.begin() + 1, f.end(), 1);\n        std::vector&lt;std::pair&lt;int, int&gt; &gt; r;\n        std::function&lt;int(int)&gt; find = [&amp;](int x) &#123; return x == f[x] ? x : f[x] = find(f[x]); &#125;;\n        for (auto [u, v] : e)\n            if (find(u) != find(v)) &#123;\n                f[find(u)] = find(v);\n                // printf(&quot;%d %d \\n&quot;, u, v);\n                g[u].push_back(v), g[v].push_back(u);\n            &#125;\n            else\n                r.emplace_back(u, v);\n        std::vector&lt;int&gt; dep(n + 1), son(n + 1), siz(n + 1), fa(n + 1);\n        std::function&lt;void(int)&gt; DFS1 = [&amp;](int x) &#123;\n            siz[x] = 1;\n            for (auto i : g[x])\n                if (i != fa[x]) &#123;\n                    dep[i] = dep[x] + 1;\n                    fa[i] = x, DFS1(i);\n                    siz[x] += siz[i];\n                    if (siz[i] &gt; siz[son[x]])\n                        son[x] = i;\n                &#125;\n            return;\n        &#125;;\n        dep[1] = 1, DFS1(1);\n        std::vector&lt;int&gt; top(n + 1);\n        DFS1 = [&amp;](int x) &#123;\n            if (son[x])\n                top[son[x]] = top[x], DFS1(son[x]);\n            for (auto i : g[x])\n                if (i != fa[x] &amp;&amp; i != son[x])\n                    top[i] = i, DFS1(i);\n            return;\n        &#125;;\n        top[1] = 1, DFS1(1);\n        auto askLCA = [&amp;](int x, int y) &#123;\n            for (; top[x] != top[y]; x = fa[top[x]])\n                if (dep[top[x]] &lt; dep[top[y]])\n                    std::swap(x, y);\n            return dep[x] &lt; dep[y] ? x : y;\n        &#125;;\n        int cnt = 0;\n        std::pair&lt;int, int&gt; res;\n        std::vector&lt;int&gt; tag(n + 1), s(n + 1);\n        for (auto [u, v] : r) &#123;\n            int fa = askLCA(u, v), dis = dep[u] + dep[v] - 2 * dep[fa];\n            if (dis &amp; 1)\n                ++tag[u], ++tag[v], tag[fa] -= 2;\n            else &#123;\n                res = &#123; 0, 0 &#125;;\n                ++cnt, ++s[u], ++s[v], s[fa] -= 2;\n                if (cnt == 1)\n                    res = &#123; u, v &#125;;\n            &#125;\n        &#125;\n        DFS1 = [&amp;](int x) &#123;\n            for (auto i : g[x])\n                if (i != fa[x]) &#123;\n                    DFS1(i);\n                    tag[x] += tag[i], s[x] += s[i];\n                &#125;\n            if (!tag[x] &amp;&amp; s[x] == cnt &amp;&amp; x != 1)\n                res = &#123; fa[x], x &#125;;\n            return;\n        &#125;;\n        DFS1(1);\n        // printf(&quot;# %d %d \\n&quot;, res.first, res.second);\n        if (res.first) &#123;\n            std::cout &lt;&lt; &quot;YES\\n&quot;;\n            std::fill(col.begin() + 1, col.end(), 0);\n            std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int now) &#123;\n                col[x] = now;\n                for (auto i : g1[x])\n                    if (!col[i])\n                        DFS(i, 3 - now);\n                return;\n            &#125;;\n            col[res.first] = col[res.second] = 2;\n            DFS(res.first, 2), DFS(res.second, 2);\n            for (int i = 1; i &lt;= n; ++i)\n                std::cout &lt;&lt; col[i] - 1;\n            std::cout &lt;&lt; &#39;\\n&#39;;\n        &#125;\n        else\n            std::cout &lt;&lt; &quot;NO\\n&quot;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"h---four-coloring\">H - Four Coloring</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_code_festival_2017_quala_d\" class=\"uri\">https://www.luogu.com.cn/problem/AT_code_festival_2017_quala_d</a></p>\n<ul>\n<li><p>参见<a href=\"/20231117/#杂项\">切比雪夫距离</a>，则问题转化为，任意点为中心的边长为 <span class=\"math inline\">\\(2d+1\\)</span> 的正方形的边不能和这个点同色</p></li>\n<li><p>直接按照 <span class=\"math inline\">\\(d\\times d\\)</span> 进行划分即可。注意负数除法会影响正确性，故平移到正数即可。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m, d;\n    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; d;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = n + 1; j &lt;= n + m; ++j) &#123;\n            int x = (i + j) / d, y = (j - i) / d;\n            if (x % 2 == 0 &amp;&amp; y % 2 == 0)\n                std::cout &lt;&lt; &#39;R&#39;;\n            else if (x % 2 == 0)\n                std::cout &lt;&lt; &#39;Y&#39;;\n            else if (y % 2 == 0)\n                std::cout &lt;&lt; &#39;G&#39;;\n            else\n                std::cout &lt;&lt; &#39;B&#39;;\n        &#125;\n        std::cout &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"i---diverse-coloring\">I - Diverse Coloring</h2>\n<p><a href=\"https://vjudge.net/contest/759882#problem/I\" class=\"uri\">https://vjudge.net/contest/759882#problem/I</a></p>\n<ul>\n<li>可以很简单地猜到答案为 <span class=\"math inline\">\\(n\\bmod 2\\)</span>，且唯一的例外是样例中 <span class=\"math inline\">\\(n=4\\)</span> 的菊花；</li>\n<li><p>很难理解怎么想到构造方法的：从根节点开始 DFS，先向下递归处理儿子，如果儿子传上来未配对的点则与之配对，否则上传自己。</p>\n<p>这样做之后，除了根可能为孤岛之外，树会被分为若干个大小为 2 或 3 的连通块，此时的染色策略就很明显了。</p>\n<blockquote>\n<p>1 的连通块的存在价值是保证每个点在包含其的连通块内都能解决掉限制，大小 <span class=\"math inline\">\\(=3\\)</span> 的连通块是为了提供 <span class=\"math inline\">\\(1\\)</span> 或 <span class=\"math inline\">\\(-1\\)</span> 的代价用于调整。</p>\n</blockquote></li>\n<li><p>对于孤岛根，一个很好的性质是其儿子所在连通块一定是下面的两层，故大力讨论前三层形态（实际上是前五层）：</p>\n<details>\n<p><summary>神秘枚举</summary></p>\n<p><img src=\"image-6.png\" /></p>\n</details>\n<p>分讨即可。似乎并不用分这么多类，但是实现难度并不高。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n;\n        std::cin &gt;&gt; n;\n        std::vector&lt;int&gt; deg(n + 1);\n        std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n        for (int i = 2, fa; i &lt;= n; ++i) &#123;\n            std::cin &gt;&gt; fa;\n            ++deg[fa], ++deg[i];\n            g[fa].push_back(i);\n            if (i == 4 &amp;&amp; *std::max_element(deg.begin() + 1, deg.begin() + 5) == 3)\n                std::cout &lt;&lt; 2 &lt;&lt; &#39;\\n&#39;;\n            else\n                std::cout &lt;&lt; i % 2 &lt;&lt; &#39;\\n&#39;;\n        &#125;\n        std::vector&lt;int&gt; siz(n + 1);\n        std::vector&lt;std::pair&lt;int, int&gt; &gt; p2;\n        std::vector&lt;std::tuple&lt;int, int, int&gt; &gt; p3;\n        std::function&lt;int(int)&gt; DFS = [&amp;](int x) &#123;\n            std::vector&lt;int&gt; p;\n            p.push_back(x);\n            for (auto i : g[x])\n                if (DFS(i) == 1)\n                    p.push_back(i);\n            if ((int)p.size() == 2)\n                p2.emplace_back(p[0], p[1]);\n            else if ((int)p.size() == 3)\n                p3.emplace_back(p[0], p[1], p[2]);\n            siz[x] = (int)p.size();\n            return siz[x];\n        &#125;;\n        std::vector&lt;int&gt; col(n + 1);\n        auto work = [&amp;](int now) &#123;\n            for (auto [x, y] : p2)\n                if (!col[x] &amp;&amp; !col[y])\n                    col[x] = 1;\n            for (auto [x, y, z] : p3)\n                if (!col[x] &amp;&amp; !col[y] &amp;&amp; !col[z]) &#123;\n                    if (now &gt;= 0)\n                        col[x] = 1, --now;\n                    else\n                        col[y] = col[z] = 1, ++now;\n                &#125;\n            for (int i = 1; i &lt;= n; ++i)\n                std::cout &lt;&lt; (col[i] ? &#39;b&#39; : &#39;w&#39;);\n            std::cout &lt;&lt; &#39;\\n&#39;;\n            return;\n        &#125;;\n        DFS(1);\n        int now = 0;\n        if (siz[1] == 1) &#123;\n            if ((int)g[1].size() == 1) &#123;\n                int p2 = g[1][0];\n                if (siz[p2] == 2)\n                    col[p2] = 1, now = -1;\n                else if (n == 4)\n                    col[p2] = 1, now = -1;\n                else &#123;\n                    int p3 = g[g[p2][0]].empty() ? g[p2][1] : g[p2][0], p5 = g[p3][0];\n                    col[p2] = col[p3] = 1;\n                    if (siz[p5] == 2) &#123;\n                        int p6 = siz[g[p5][0]] == 1 ? g[p5][0] : g[p5][1];\n                        col[p6] = 1, now = 0;\n                    &#125;\n                    else &#123;\n                        int p6 = g[p5][0], p7 = g[p5][1];\n                        col[p6] = col[p7] = 1, now = 1;\n                    &#125;\n                &#125;\n            &#125;\n            else &#123;\n                int p2 = g[1][0], p3 = g[1][1];\n                if (siz[p2] &gt; siz[p3])\n                    std::swap(p2, p3);\n                if (siz[p2] == 2 &amp;&amp; siz[p3] == 2)\n                    col[p2] = col[p3] = 1, now = -1;\n                else if (siz[p2] == 2 &amp;&amp; siz[p3] == 3) &#123;\n                    int p4 = siz[g[p2][0]] == 1 ? g[p2][0] : g[p2][1];\n                    col[1] = col[p3] = col[p4] = 1, now = 0;\n                &#125;\n                else &#123;\n                    int p4 = g[p2][0], p5 = g[p2][1];\n                    col[1] = col[p3] = col[p4] = col[p5] = 1, now = 1;\n                &#125;\n            &#125;\n        &#125;\n        work(now);\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"j---graph-coloring\">J - Graph Coloring</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF662B\" class=\"uri\">https://www.luogu.com.cn/problem/CF662B</a></p>\n<ul>\n<li><p>首先需要意识到，翻奇数次 / 偶数次可以归到翻 / 不翻的范畴里。</p></li>\n<li><p>不妨枚举最后所有边颜色，那么就可以限定每条边的两端点翻转情况，发现这是并查集，但怎么求最小？难道要 2-SAT 吗？</p></li>\n<li><p>发现最终的并查集一定是两两对应的，对应每一对，取最小开销者即可。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;std::tuple&lt;int, int, int&gt; &gt; e;\n    for (int i = 1, x, y; i &lt;= m; ++i) &#123;\n        char t;\n        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; t;\n        e.emplace_back(x, y, t == &#39;R&#39;);\n    &#125;\n    std::vector&lt;int&gt; res1, res2;\n    auto calc = [&amp;](std::vector&lt;int&gt; &amp;res) &#123;\n        std::vector&lt;int&gt; f(2 * n + 1), siz(2 * n + 1);\n        std::iota(f.begin() + 1, f.end(), 1);\n        std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;\n            return x == f[x] ? x : f[x] = find(f[x]);\n        &#125;;\n        auto merge = [&amp;](int x, int y) &#123;\n            f[find(x)] = find(y);\n            return;\n        &#125;;\n        for (auto [x, y, w] : e)\n            if (w)\n                merge(x, y), merge(x + n, y + n);\n            else\n                merge(x, y + n), merge(x + n, y);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            ++siz[find(i)];\n            if (find(i) == find(n + i))\n                return false;\n        &#125;\n        std::vector&lt;int&gt; tag(2 * n + 1);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            if (!tag[find(i)]) &#123;\n                tag[find(i)] = tag[find(i + n)] = 1;\n                if (siz[find(i)] &lt;= siz[find(i + n)])\n                    ++tag[find(i)];\n                else\n                    ++tag[find(i + n)];\n            &#125;\n            if (tag[find(i)] == 2)\n                res.push_back(i);\n        &#125;\n        return true;\n    &#125;;\n    auto flag1 = calc(res1);\n    for (auto &amp;[x, y, w] : e)\n        w ^= 1;\n    auto flag2 = calc(res2);\n    if (!flag1 &amp;&amp; !flag2)\n        std::cout &lt;&lt; -1 &lt;&lt; &#39;\\n&#39;;\n    else if (!flag2 || (flag1 &amp;&amp; res1.size() &lt; res2.size())) &#123;\n        std::cout &lt;&lt; (int)res1.size() &lt;&lt; &#39;\\n&#39;;\n        for (auto i : res1)\n            std::cout &lt;&lt; i &lt;&lt; &#39; &#39;;\n        std::cout &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    else &#123;\n        std::cout &lt;&lt; (int)res2.size() &lt;&lt; &#39;\\n&#39;;\n        for (auto i : res2)\n            std::cout &lt;&lt; i &lt;&lt; &#39; &#39;;\n        std::cout &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "并查集",
                "二分图",
                "构造",
                "思维",
                "随机化"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20251020/",
            "url": "https://xsc062.netlify.app/20251020/",
            "title": "杂题选谈：生成树",
            "date_published": "2025-10-20T09:10:11.000Z",
            "content_html": "<p>mst，怎么还有 mst related</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a---st-spanning-tree\">A - st-Spanning Tree</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF723F\" class=\"uri\">https://www.luogu.com.cn/problem/CF723F</a></p>\n<ul>\n<li>看起来形似最小度限制生成树，但没有边权导致失去了凸性，wqs 二分不再可行。</li>\n<li>这也启示我们放弃 mst 算法，重新回到连通性看待本题。即尝试在不影响连通性的前提下，让 <span class=\"math inline\">\\(s,t\\)</span> 在原图上的度数减少到对应值。</li>\n<li><p>发现 <span class=\"math inline\">\\(s,t\\)</span> 的决策会相互影响：</p>\n<p><img src=\"image.png\" /></p>\n<p>好消息是有且仅有这两种情况会干扰决策。胡乱贪心即可。</p></li>\n<li><p>考虑忽略与 <span class=\"math inline\">\\(s,t\\)</span> 有关的边跑一遍 DFS，得到若干连通块，显然它们会分为只与 <span class=\"math inline\">\\(s,t\\)</span> 中一者有关 / 与二者都有关两类。</p>\n<ul>\n<li>连通块内部：建 DFS 树即可。</li>\n<li><strong>先</strong>处理对于只与 <span class=\"math inline\">\\(s,t\\)</span> 中的一个有关的连通块：将其与对应 <span class=\"math inline\">\\(s,t\\)</span> 相连。</li>\n<li><strong>再</strong>处理对于与二者都有关的连通块：若 <span class=\"math inline\">\\((s, t)\\)</span> 不连通，则先找一个把 <span class=\"math inline\">\\(s\\)</span> 和 <span class=\"math inline\">\\(t\\)</span> 连通起来；剩下的看看哪个能连就连哪个。</li>\n<li><strong>最后</strong>看看是否存在边 <span class=\"math inline\">\\((s, t)\\)</span> 且不存在上一种情况（也就是 <span class=\"math inline\">\\(s,t\\)</span> 不连通），如果满足就连起来。</li>\n</ul></li>\n<li><p>为什么是这个连边顺序呢，发现 <span class=\"math inline\">\\((s,t)\\)</span> 会用一条边消耗两次度数，故放在最后；其他两者先解决更严格的一者。故有。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1), ps(n + 1), pt(n + 1);\n    for (int x, y; m--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    int s, t, ds, dt;\n    std::cin &gt;&gt; s &gt;&gt; t &gt;&gt; ds &gt;&gt; dt;\n    std::vector&lt;int&gt; col(n + 1);\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; res;\n    int now = 0;\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        col[x] = now;\n        for (auto i : g[x])\n            if (i == s)\n                ps[now].push_back(x);\n            else if (i == t)\n                pt[now].push_back(x);\n            else if (!col[i])\n                res.emplace_back(x, i), DFS(i);\n        return;\n    &#125;;\n    for (int i = 1; i &lt;= n; ++i)\n        if (i != s &amp;&amp; i != t &amp;&amp; !col[i])\n            ++now, DFS(i);\n    for (int i = 1; i &lt;= now; ++i)\n        if (!ps[i].empty() &amp;&amp; !pt[i].empty());\n        else if (!ps[i].empty())\n            res.emplace_back(ps[i].back(), s), --ds;\n        else\n            res.emplace_back(pt[i].back(), t), --dt;\n    if (ds &lt;= 0 || dt &lt;= 0) &#123;\n        std::cout &lt;&lt; &quot;No&quot; &lt;&lt; &#39;\\n&#39;;\n        return 0;\n    &#125;\n    bool flag = false;\n    for (int i = 1; i &lt;= now; ++i)\n        if (!ps[i].empty() &amp;&amp; !pt[i].empty()) &#123;\n            if (flag == false) &#123;\n                res.emplace_back(ps[i].back(), s), --ds;\n                res.emplace_back(pt[i].back(), t), --dt;\n                flag = true;\n            &#125;\n            else if (ds)\n                res.emplace_back(ps[i].back(), s), --ds;\n            else if (dt)\n                res.emplace_back(pt[i].back(), t), --dt;\n            else &#123;\n                std::cout &lt;&lt; &quot;No&quot; &lt;&lt; &#39;\\n&#39;;\n                return 0;\n            &#125;\n        &#125;\n    if (flag == false)\n        for (auto i : g[s])\n            if (i == t) &#123;\n                res.emplace_back(s, t);\n                --ds, --dt, flag = true;\n            &#125;\n    if (flag == false) &#123;\n        std::cout &lt;&lt; &quot;No&quot; &lt;&lt; &#39;\\n&#39;;\n        return 0;\n    &#125;\n    assert((int)res.size() == n - 1);\n    std::cout &lt;&lt; &quot;Yes&quot; &lt;&lt; &#39;\\n&#39;;\n    for (auto [u, v] : res)\n        std::cout &lt;&lt; u &lt;&lt; &#39; &#39; &lt;&lt; v &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---0-1-mst\">B - 0-1 MST</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1242B\" class=\"uri\">https://www.luogu.com.cn/problem/CF1242B</a></p>\n<ul>\n<li>发现实际上是在问删掉这 <span class=\"math inline\">\\(m\\)</span> 条边后还剩多少个连通块。</li>\n<li><p>容易发现删的边相对来说比较少，或者说在 <span class=\"math inline\">\\(10^5\\)</span> 这个限制下很难分成很多个很大的连通块。</p>\n<p>正解利用了鸽巢原理证明这个事情：相当于把 <span class=\"math inline\">\\(m\\)</span> 次删边分配给 <span class=\"math inline\">\\(n\\)</span> 个点，那么至少存在一个点，被删掉的边不超过 <span class=\"math inline\">\\(\\left\\lfloor \\frac mn\\right\\rfloor\\)</span> 条。那么这个点带领的菊花形成了一个大小至少为 <span class=\"math inline\">\\(n-\\left\\lfloor \\frac mn\\right\\rfloor\\)</span> 的连通子图。</p></li>\n<li>剩余的 <span class=\"math inline\">\\(\\left\\lfloor \\frac mn\\right\\rfloor\\)</span> 个点，目测不是很大，事实上又是神秘不等式：<span class=\"math inline\">\\(\\left\\lfloor \\frac mn\\right\\rfloor^2&lt;n\\times \\left\\lfloor \\frac mn\\right\\rfloor=m\\)</span>。可以暴力枚举点对查看是否有边。</li>\n<li><p>对于菊花上可能的其他连边，仍然神秘不等式，<span class=\"math inline\">\\(\\left\\lfloor \\frac mn\\right\\rfloor\\times (n-\\left\\lfloor \\frac mn\\right\\rfloor)=\\left\\lfloor \\frac mn\\right\\rfloor\\times n-\\left\\lfloor \\frac mn\\right\\rfloor^2&lt;\\left\\lfloor \\frac mn\\right\\rfloor\\times n=m\\)</span>，仍然暴力枚举即可。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;int&gt; f(n + 1);\n    std::iota(f.begin() + 1, f.end(), 1);\n    std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;\n        return x == f[x] ? x : f[x] = find(f[x]);\n    &#125;;\n    auto merge = [&amp;](int x, int y) &#123;\n        if (find(x) == find(y))\n            return false;\n        f[find(x)] = find(y);\n        return true;\n    &#125;;\n    std::vector&lt;int&gt; deg(n + 1, n - 1);\n    std::set&lt;std::pair&lt;int, int&gt; &gt; t;\n    for (int u, v; m--; ) &#123;\n        std::cin &gt;&gt; u &gt;&gt; v;\n        t.emplace(std::min(u, v), std::max(u, v)), --deg[u], --deg[v];\n    &#125;\n    int u = std::max_element(deg.begin() + 1, deg.end()) - deg.begin();\n    std::vector&lt;int&gt; p1, p2;\n    for (int i = 1; i &lt;= n; ++i)\n        if (i == u || !t.count(&#123; std::min(u, i), std::max(u, i) &#125;))\n            p1.push_back(i), merge(u, i);\n        else\n            p2.push_back(i);\n    int cnt = 1 + (int)p2.size();\n    for (int i = 0; i &lt; (int)p2.size(); ++i) &#123;\n        for (int j = 0; j &lt; i; ++j)\n            if (!t.count(&#123; std::min(p2[i], p2[j]), std::max(p2[i], p2[j]) &#125;))\n                cnt -= merge(p2[i], p2[j]);\n        for (int j = 0; j &lt; (int)p1.size(); ++j)\n            if (!t.count(&#123; std::min(p2[i], p1[j]), std::max(p2[i], p1[j]) &#125;))\n                cnt -= merge(p2[i], p1[j]);\n    &#125;\n    std::cout &lt;&lt; cnt - 1 &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---magic-matrix\">C - Magic Matrix</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF632F\" class=\"uri\">https://www.luogu.com.cn/problem/CF632F</a></p>\n<ul>\n<li><p>神秘不等式。若边 <span class=\"math inline\">\\(A,B,C\\)</span> 组成三元环，显然有 <span class=\"math inline\">\\(A\\le \\max(A,B,C)\\)</span>。考虑 <span class=\"math inline\">\\(B\\)</span> 参与形成的另一个三元环 <span class=\"math inline\">\\(B,D,E\\)</span>，那么显然有 <span class=\"math inline\">\\(A\\le \\max(A,C,D,E)\\)</span>，（需要注意到此时仍是一个环，很容易证明），etc.</p></li>\n<li><p>更可视化地叙述，令 <span class=\"math inline\">\\((x,y)\\)</span> 为边 <span class=\"math inline\">\\(A\\)</span> 的两端，则 <span class=\"math inline\">\\(A\\)</span> 参与构成的所有简单环，<span class=\"math inline\">\\(A\\)</span> 不大于环上边权最大值。反过来，若存在一个路径最大值小于 <span class=\"math inline\">\\(A\\)</span> 则判定失败。故 Kruskal 乱 check 一下即可，复杂度 <span class=\"math inline\">\\(O(n^2\\log n)\\)</span>。</p>\n<p>谁家好人写 <span class=\"math inline\">\\(O(n^2\\log n^2)\\)</span> 的？咋看咋不对劲，好在发现问题，保住了高中生的名头。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::vector&lt;int&gt; &gt; a(n + 1, std::vector&lt;int&gt; (n + 1));\n    auto nosol = [&amp;](void) &#123;\n        std::cout &lt;&lt; &quot;NOT MAGIC\\n&quot;;\n        exit(0);\n        return;\n    &#125;;\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = 1; j &lt;= n; ++j)\n            std::cin &gt;&gt; a[i][j];\n    std::vector&lt;int&gt; l(1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        if (a[i][i] != 0)\n            nosol();\n        for (int j = 1; j &lt; i; ++j) &#123;\n            l.push_back(a[i][j]);\n            if (a[i][j] != a[j][i])\n                nosol();\n        &#125;\n    &#125;\n    std::sort(l.begin() + 1, l.end());\n    l.erase(std::unique(l.begin() + 1, l.end()), l.end());\n    int m = (int)l.size() - 1;\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; e(m + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = 1; j &lt; i; ++j) &#123;\n            a[i][j] = std::lower_bound(l.begin() + 1, l.end(), a[i][j]) - l.begin();\n            e[a[i][j]].emplace_back(i, j);\n        &#125;\n    std::vector&lt;int&gt; f(n + 1);\n    std::iota(f.begin() + 1, f.end(), 1);\n    std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;\n        return x == f[x] ? x : f[x] = find(f[x]);\n    &#125;;\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        for (auto [u, v] : e[i])\n            if (find(u) == find(v))\n                nosol();\n        for (auto [u, v] : e[i])\n            if (find(u) != find(v))\n                f[find(u)] = find(v);\n    &#125;\n    std::cout &lt;&lt; &quot;MAGIC\\n&quot;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"k---jumbled-trees\">K - Jumbled Trees</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1773J\" class=\"uri\">https://www.luogu.com.cn/problem/CF1773J</a></p>\n",
            "tags": [
                "最小生成树"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20251019/",
            "url": "https://xsc062.netlify.app/20251019/",
            "title": "杂题选谈",
            "date_published": "2025-10-19T06:17:38.000Z",
            "content_html": "<p>模拟赛 and so on</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"cf1923f-shrink-reverse\">CF1923F Shrink-Reverse</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1923F\" class=\"uri\">https://www.luogu.com.cn/problem/CF1923F</a></p>\n<p>需要想到贪心策略，但正确的策略并没有<strong>那么</strong>显然。</p>\n<ul>\n<li><p>观察样例可以大胆猜测，<code>SHRINK_REVERSE</code> 只会用最多一次。尝试理解这一点：</p>\n<ul>\n<li>只考虑 <code>SHRINK</code>，那么发现只有最后一次 <code>SHRINK</code> 是有效的。</li>\n<li>只考虑 <code>REVERSE</code>，那么只需要将两次 <code>REVERSE</code> 中间的 <code>SWAP</code> 进行翻转，并删除这两次 <code>REVERSE</code>，就可以达到相同的作用。</li>\n</ul>\n<p>综上，只需要保留最后一次 <code>SHRINK_REVERSE</code>，剩下的可以通过翻转对应的 <code>SWAP</code> 操作达到相同的效果，节省操作次数。且显然这次 <code>SHRINK_REVERSE</code> 应该放在操作序列的末尾。</p></li>\n<li><p>因此，只需要讨论不 <code>SHRINK_REVERSE</code>、在最后 <code>SHRINK_REVERSE</code> 两种情况。</p>\n<p>对于不 <code>SHRINK_REVERSE</code> 的情况，直接贪心即可。</p></li>\n<li><p>对于最后再 <code>SHRINK_REVERSE</code> 的情况，不妨先 <code>REVERSE</code>，考虑找到 <code>SHRINK</code> 后对应的原始字符串上的区间。</p>\n<p>也即考虑找到一个最短的子串，使得能够通过 <span class=\"math inline\">\\(k-1\\)</span> 次 <code>SWAP</code> 把子串外的 <span class=\"math inline\">\\(1\\)</span> 全部换到子串内。</p></li>\n<li><p>问题具有一定的单调性，故可以双指针对于每个 <span class=\"math inline\">\\(l\\)</span> 找到最小的 <span class=\"math inline\">\\(r\\)</span>。接下来仍然可以贪心最小化答案。</p>\n<p>很容易说明区间长最短的才能竞争最优：要么 <span class=\"math inline\">\\(l\\)</span> 初始为 <span class=\"math inline\">\\(1\\)</span>，要么区间长就是 <span class=\"math inline\">\\(1\\)</span> 总数；</p>\n<p>很容易说明相同长度的参与竞争的区间，字典序最小的最优。</p></li>\n<li><p>故接下来需要比较这 <span class=\"math inline\">\\(O(n)\\)</span> 个长度相同的答案区间的字典序。SA 即可。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, k;\n    std::string s, res1, res2;\n    std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; s, s = &#39;#&#39; + s;\n    res1 = s;\n    for (int i = 1, j = n, l = 1; l &lt;= k &amp;&amp; i &lt; j; ++i, --j, ++l) &#123;\n        for (; i &lt; j &amp;&amp; res1[i] != &#39;1&#39;; ++i);\n        for (; i &lt; j &amp;&amp; res1[j] != &#39;0&#39;; --j);\n        if (i &lt; j)\n            std::swap(res1[i], res1[j]);\n    &#125;\n    for (int i = 1; i &lt;= n; ++i)\n        if (res1[i] == &#39;1&#39;) &#123;\n            res1 = &#39;#&#39; + res1.substr(i, n - i + 1);\n            break;\n        &#125;\n    std::reverse(s.begin() + 1, s.end());\n    std::vector&lt;int&gt; pos;\n    const int s1 = std::count(s.begin() + 1, s.end(), &#39;1&#39;);\n    int len = n;\n    for (int l = 1, r = 0, c1 = 0, c0 = 0; l &lt;= n; ++l) &#123;\n        for (; r &lt; n &amp;&amp; (c0 &lt; s1 - c1 || s1 - c1 &gt; k - 1); )\n            if (s[++r] == &#39;1&#39;) ++c1;\n            else ++c0;\n        if (c0 &gt;= s1 - c1 &amp;&amp; s1 - c1 &lt;= k - 1) &#123;\n            if (r - l + 1 &lt; len)\n                len = r - l + 1, pos.clear();\n            if (r - l + 1 == len)\n                pos.push_back(l);\n        &#125;\n        if (s[l] == &#39;1&#39;) --c1;\n        else --c0;\n    &#125;\n    std::vector&lt;int&gt; sa(n + 1), rk(2 * n + 1);\n    &#123;\n        int m = 128;\n        std::vector&lt;int&gt; c(std::max(n, m) + 1), id, la(2 * n + 1);\n        std::copy(s.begin() + 1, s.end(), rk.begin() + 1);\n        for (int i = 1; i &lt;= n; ++i)\n            ++c[rk[i]];\n        std::partial_sum(c.begin() + 1, c.begin() + m + 1, c.begin() + 1);\n        for (int i = n; i; --i)\n            sa[c[rk[i]]--] = i;\n        for (int w = 1, p; ; w &lt;&lt;= 1, m = p) &#123;\n            id.clear(), id.push_back(-1);\n            for (int i = n - w + 1; i &lt;= n; ++i)\n                id.push_back(i);\n            for (int i = 1; i &lt;= n; ++i)\n                if (sa[i] &gt; w)\n                    id.push_back(sa[i] - w);\n            std::fill(c.begin() + 1, c.begin() + m + 1, 0);\n            for (int i = 1; i &lt;= n; ++i)\n                ++c[rk[i]];\n            std::partial_sum(c.begin() + 1, c.begin() + m + 1, c.begin() + 1);\n            for (int i = n; i; --i)\n                sa[c[rk[id[i]]]--] = id[i];\n            p = 0;\n            std::copy(rk.begin() + 1, rk.end(), la.begin() + 1);\n            for (int i = 1; i &lt;= n; ++i)\n                if (i != 1 &amp;&amp; la[sa[i]] == la[sa[i - 1]] &amp;&amp; la[sa[i] + w] == la[sa[i - 1] + w])\n                    rk[sa[i]] = p;\n                else\n                    rk[sa[i]] = ++p;\n            if (p == n)\n                break;\n        &#125;\n    &#125;\n    int id = 0;\n    for (auto i : pos)\n        if (id == 0 || rk[i] &lt; rk[id])\n            id = i;\n    if (id == 0)\n        assert(len == n), id = 1;\n    res2 = &#39;#&#39; + s.substr(id, len);\n    int tot = s1 - std::count(res2.begin() + 1, res2.end(), &#39;1&#39;);\n    for (int i = len; tot--; --i) &#123;\n        for (; res2[i] != &#39;0&#39;; --i);\n        res2[i] = &#39;1&#39;;\n    &#125;\n    if (res1.length() == res2.length())\n        s = std::min(res1, res2);\n    else if (res1.length() &lt; res2.length())\n        s = res1;\n    else\n        s = res2;\n    auto res = 0ll;\n    for (int i = 1; i &lt; (int)s.size(); ++i)\n        res = (res * 2 + s[i] - &#39;0&#39;) % mod;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"cf1859f-teleportation-in-byteland\">CF1859F Teleportation in Byteland</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1859F\" class=\"uri\">https://www.luogu.com.cn/problem/CF1859F</a></p>\n<ul>\n<li><p>题设让树自然呈现一个分层图的结构。贪心地，最优的路径一定为 <span class=\"math inline\">\\(a_i\\to u\\)</span>，（在 <span class=\"math inline\">\\(u\\)</span> 学习若干次），<span class=\"math inline\">\\(u\\to b_i\\)</span>。</p>\n<p>枚举一个学习次数 <span class=\"math inline\">\\(k\\)</span>（显然 <span class=\"math inline\">\\(k\\)</span> 不会超过 <span class=\"math inline\">\\(\\left\\lceil\\log_2n\\right\\rceil\\)</span>），并令 <span class=\"math inline\">\\(d_k(u,v)\\)</span> 表示在学习 <span class=\"math inline\">\\(k\\)</span> 次后的分层图上 <span class=\"math inline\">\\(u\\)</span> 与 <span class=\"math inline\">\\(v\\)</span> 的距离。最后的答案可以表示为 <span class=\"math inline\">\\(\\min\\limits_{u,k}\\{d_0(a_i,u)+d_k(u,b_i)+k\\cdot T\\}\\)</span>。</p></li>\n<li><p>现在希望能够快速地找到，对于一个固定的 <span class=\"math inline\">\\(k\\)</span>，使答案最小的 <span class=\"math inline\">\\(u\\)</span>。询问与路径相关，所以期望一种能和路径挂钩的答案表示方法（似乎是经典 trick）。容易想到链 <span class=\"math inline\">\\((a_i,b_i)\\)</span> 上离 <span class=\"math inline\">\\(u\\)</span> 最近的点 <span class=\"math inline\">\\(v\\)</span>，答案可以改写成：</p>\n<p><span class=\"math display\">\\[\n\\min\\limits_{u,v}\\{d_0(a_i,v)+d_k(v,b_i)+d_0(v,u)+d_k(u,v)\\}+k\\cdot T\n\\]</span></p>\n<p>其中，<span class=\"math inline\">\\(d_0(v,u)+d_k(u,v)\\)</span> 与具体的 <span class=\"math inline\">\\(a,b\\)</span> 无关，可以用一次多源 Dij 预处理出每个 <span class=\"math inline\">\\(v\\)</span> 的答案（记为 <span class=\"math inline\">\\(s_k(v)\\)</span>）（需要注意到 <span class=\"math inline\">\\(d_0(v,u)\\)</span> 和 <span class=\"math inline\">\\(d_k(u,v)\\)</span> 可能不同时取最小，可以用 <span class=\"math inline\">\\(w_0+w_k\\)</span> 作边权）；<span class=\"math inline\">\\(d_0(a_i,v)+d_k(v,b_i)\\)</span> 则可以通过讨论 LCA 直接用深度表示，求出最值。</p></li>\n<li><p>记 <span class=\"math inline\">\\(fa=\\text{LCA}(a_i,b_i)\\)</span>，当 <span class=\"math inline\">\\(v\\)</span> 在 <span class=\"math inline\">\\(fa\\to a_i\\)</span> 上时，答案为：</p>\n<p><span class=\"math display\">\\[\n(dep_k(v)+s_k(v)-dep_0(v))+(dep_k(b_i)-2dep_k(fa)+dep_0(a_i)+k\\cdot T)\n\\]</span></p>\n<p>当 <span class=\"math inline\">\\(v\\)</span> 在 <span class=\"math inline\">\\(fa\\to b_i\\)</span> 上时，答案为：</p>\n<p><span class=\"math display\">\\[\n(dep_0(v)+s_k(v)-dep_k(v))+(dep_0(a_i)-2dep_0(fa)+dep_k(b_i)+k\\cdot T)\n\\]</span></p>\n<p>维护链上 <span class=\"math inline\">\\(dep_k(v)+s_k(v)-dep_0(v)\\)</span> 和 <span class=\"math inline\">\\(dep_0(v)+s_k(v)-dep_k(v)\\)</span> 的最小值即可。</p></li>\n<li>由于是完全静态的树上路径问题，可以用倍增完成。注意考虑学 <span class=\"math inline\">\\(0\\)</span> 次的情况。复杂度 <span class=\"math inline\">\\(O(n\\log^2 n)\\)</span>。</li>\n<li><p>咦你怎么 MLE 了？只需要把所有询问离线下来，每个 <span class=\"math inline\">\\(k\\)</span> 就可以共用数组了。</p>\n<p>看到 Limury 的做法是树剖 + st 表，薄纱所有人。Rosmist 树剖 + bit 三只 log 也薄纱倍增做法，我怎么会做这样的梦。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e5 + 5;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, t;\n        std::cin &gt;&gt; n &gt;&gt; t;\n        std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(n + 1);\n        for (int i = 1, x, y, w; i &lt; n; ++i) &#123;\n            std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;\n            g[x].emplace_back(y, w), g[y].emplace_back(x, w);\n        &#125;\n        std::vector&lt;int&gt; tag(n + 1);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            char t;\n            std::cin &gt;&gt; t, tag[i] = t - &#39;0&#39;;\n        &#125;\n        auto fun = [&amp;](int w, int k) &#123;\n            return (w + (1 &lt;&lt; k) - 1) &gt;&gt; k;\n        &#125;;\n        std::vector&lt;long long&gt; s(n + 1);\n        std::vector&lt;int&gt; dep(n + 1), vis(n + 1);\n        std::vector&lt;std::array&lt;int, 17&gt; &gt; fa(n + 1);\n        std::vector&lt;std::array&lt;long long, 17&gt; &gt; f1(n + 1), f2(n + 1);\n        std::vector&lt;std::vector&lt;long long&gt; &gt; dis(2, std::vector&lt;long long&gt; (n + 1));\n        std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n            for (auto [i, w] : g[x])\n                if (i != fa[x][0]) &#123;\n                    dep[i] = dep[x] + 1;\n                    dis[0][i] = dis[0][x] + w;\n                    fa[i][0] = x;\n                    for (int j = 1; j &lt; 17; ++j)\n                        fa[i][j] = fa[fa[i][j - 1]][j - 1];\n                    DFS(i);\n                &#125;\n            return;\n        &#125;;\n        dep[1] = 1, DFS(1);\n        auto getLCA = [&amp;](int x, int y) &#123;\n            if (dep[x] &lt; dep[y])\n                std::swap(x, y);\n            for (int i = 16; ~i; --i)\n                if (dep[fa[x][i]] &gt;= dep[y])\n                    x = fa[x][i];\n            if (x == y)\n                return x;\n            for (int i = 16; ~i; --i)\n                if (fa[x][i] != fa[y][i])\n                    x = fa[x][i], y = fa[y][i];\n            return fa[x][0];\n        &#125;;\n        int m;\n        std::cin &gt;&gt; m;\n        std::vector&lt;long long&gt; res(m + 1);\n        std::vector&lt;std::pair&lt;int, int&gt; &gt; q(m + 1);\n        for (int i = 1, u, v; i &lt;= m; ++i) &#123;\n            std::cin &gt;&gt; u &gt;&gt; v;\n            res[i] = dis[0][u] + dis[0][v] - 2 * dis[0][getLCA(u, v)];;\n            q[i] = &#123; u, v &#125;;\n        &#125;\n        for (int j = 0; j &lt; 17; ++j)\n            f1[0][j] = f2[0][j] = 1e18;\n        for (int k = 1; k &lt;= 20; ++k) &#123;\n            &#123;\n                std::priority_queue&lt;std::pair&lt;long long, int&gt; &gt; q;\n                for (int i = 1; i &lt;= n; ++i) &#123;\n                    vis[i] = 0;\n                    if (tag[i])\n                        s[i] = 0ll, q.emplace(0ll, i);\n                    else\n                        s[i] = 1e18;\n                &#125;\n                for (; !q.empty(); ) &#123;\n                    int x = q.top().second;\n                    q.pop();\n                    if (vis[x])\n                        continue;\n                    vis[x] = 1;\n                    for (auto [v, w] : g[x])\n                        if (s[v] &gt; s[x] + fun(w, k) + w) &#123;\n                            s[v] = s[x] + fun(w, k) + w;\n                            q.emplace(-s[v], v);\n                        &#125;\n                &#125;\n            &#125;\n            DFS = [&amp;](int x) &#123;\n                for (auto [i, w] : g[x])\n                    if (i != fa[x][0]) &#123;\n                        dis[1][i] = dis[1][x] + fun(w, k);\n                        f1[i][0] = dis[1][i] + s[i] - dis[0][i];\n                        f2[i][0] = dis[0][i] + s[i] - dis[1][i];\n                        for (int j = 1; j &lt; 17; ++j) &#123;\n                            f1[i][j] = std::min(f1[i][j - 1], f1[fa[i][j - 1]][j - 1]);\n                            f2[i][j] = std::min(f2[i][j - 1], f2[fa[i][j - 1]][j - 1]);\n                        &#125;\n                        DFS(i);\n                    &#125;\n                return;\n            &#125;;\n            DFS(1);\n            for (int i = 1; i &lt;= m; ++i) &#123;\n                auto [u, v] = q[i];\n                int x = u, y = v;\n                long long s1 = 1e18, s2 = 1e18;\n                if (dep[x] &gt; dep[y]) &#123;\n                    for (int i = 16; ~i; --i)\n                        if (dep[fa[x][i]] &gt;= dep[y]) &#123;\n                            s1 = std::min(s1, f1[x][i]);\n                            x = fa[x][i];\n                        &#125;\n                &#125;\n                else &#123;\n                    for (int i = 16; ~i; --i)\n                        if (dep[fa[y][i]] &gt;= dep[x]) &#123;\n                            s2 = std::min(s2, f2[y][i]);\n                            y = fa[y][i];\n                        &#125;\n                &#125;\n                if (x != y) &#123;\n                    for (int i = 16; ~i; --i)\n                        if (fa[x][i] != fa[y][i]) &#123;\n                            s1 = std::min(s1, f1[x][i]);\n                            s2 = std::min(s2, f2[y][i]);\n                            x = fa[x][i], y = fa[y][i];\n                        &#125;\n                    s1 = std::min(s1, f1[x][0]);\n                    s2 = std::min(s2, f2[y][0]);\n                    x = fa[x][0];\n                &#125;\n                s1 = std::min(s1, dis[1][x] + s[x] - dis[0][x]);\n                s2 = std::min(s2, dis[0][x] + s[x] - dis[1][x]);\n                res[i] = std::min(res[i], k * t + dis[0][u] + dis[1][v] + std::min(s1 - 2 * dis[1][x], s2 - 2 * dis[0][x]));\n            &#125;\n        &#125;\n        for (int i = 1; i &lt;= m; ++i)\n            std::cout &lt;&lt; res[i] &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"cf1556g-gates-to-another-world\">CF1556G Gates to Another World</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1556G\" class=\"uri\">https://www.luogu.com.cn/problem/CF1556G</a></p>\n<ul>\n<li><p>快速做出来需要一定运气，需要把点顺序排布而不是像题目一样画晶胞（。）手玩一下 <span class=\"math inline\">\\(n=4\\)</span> 时的情况：</p>\n<p><img src=\"image.png\" /></p>\n<p>看到两个相邻点间连的边就应激想到线段树了，事实上把不同层的边提起来发现就是线段树的结构。</p>\n<details>\n<p><summary>为什么这个图这么大（没啥用故折起来了）</summary></p>\n<p>tip：实际上那些相邻 / 相反的尖尖是重合的，为了好看一点故错开。</p>\n<p><img src=\"image-1.png\" /></p>\n</details>\n<p>发现形成一个<strong>相邻子树对位连边</strong>的结构。这里线段树其实只有底层点是有意义的，其他点只起结构辅助作用。</p>\n<p>实际上，对于两个有连边的点，它们『LCA』的高度是被 flip 的位。</p></li>\n<li><p>很容易注意到一个线段树子树内的底层点是连通的，这一点也很容易递归地证明。</p>\n<p>考虑动态开点线段树优化建图，对于动态开点出来的叶子（注意不是底层点），容易发现在题目限制下每个叶子内部都没有点被删除，是连通的（那么此时不妨认为叶子就代表了这个连通块）。</p>\n<p>故将某个点进行连边时，并不要求找到对位的那个点（不一定存在），和走到头的叶子连边就可以达到相同的连通效果。这样就把底层点之间的连边转化为了<strong>叶子间</strong>的连边。</p></li>\n<li><p>不妨先时光倒流 + 预处理出每个叶子最后（最早）存在的时间戳，考虑暴力连出来这些叶子间的边（对于每个点，将对位的叶子连边）并计算出边最后（最早）存在的时间戳。</p>\n<p>发现暴力对位连边这个操作，是形似线段树合并但比线段树合并更劣的东西。咋分析复杂度。</p>\n<p>边是双向的，考虑更深的叶子的贡献。那么其枚举 lca + flip 对应位（不存在则取路径上的叶子），一共会有 <span class=\"math inline\">\\(O(n)\\)</span> 次连边。共有 <span class=\"math inline\">\\(O(nm)\\)</span> 个叶子，摊下来暴力连边复杂度为 <span class=\"math inline\">\\(O(n^2m)\\)</span>。</p></li>\n</ul>\n<details>\n<p>空间很卡…… 不要把离线的加边数组开成 <code>long long</code> 了。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 32e5 + 5;\nusing ll = long long;\nstruct &#123; int l, r, d; &#125; t[maxn];\nint tot;\n#define lt t[p].l\n#define rt t[p].r\n#define leaf(p) (!t[p].l &amp;&amp; !t[p].r)\nint newnode(void) &#123;\n    ++tot, t[tot].l = t[tot].r = t[tot].d = 0;\n    return tot;\n&#125;\nvoid pushdown(int p) &#123;\n    if (t[p].d) &#123;\n        if (!lt)\n            lt = newnode();\n        if (!rt)\n            rt = newnode();\n        t[lt].d = t[rt].d = t[p].d;\n        t[p].d = 0;\n    &#125;\n    return;\n&#125;\nvoid upd(int &amp;p, ll l, ll r, ll ql, ll qr, int v) &#123;\n    if (!p)\n        p = newnode();\n    if (ql &lt;= l &amp;&amp; r &lt;= qr) &#123;\n        t[p].d = v;\n        return;\n    &#125;\n    pushdown(p);\n    auto mid = (l + r) &gt;&gt; 1;\n    if (ql &lt;= mid)\n        upd(lt, l, mid, ql, qr, v);\n    if (qr &gt; mid)\n        upd(rt, mid + 1, r, ql, qr, v);\n    return;\n&#125;\nint ask(int p, ll l, ll r, ll x) &#123;\n    if (leaf(p))\n        return p;\n    ll mid = (l + r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        return ask(lt, l, mid, x);\n    return ask(rt, mid + 1, r, x);\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m, rt = newnode();\n    std::cin &gt;&gt; n &gt;&gt; m;\n    t[rt].d = m + 1;\n    const auto N = (1ll &lt;&lt; n) - 1;\n    struct query &#123; int op; ll s, t; &#125;;\n    std::vector&lt;query&gt; q(m + 1);\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        std::string op;\n        std::cin &gt;&gt; op;\n        q[i].op = (op == &quot;ask&quot;) + 1;\n        std::cin &gt;&gt; q[i].s &gt;&gt; q[i].t;\n        if (q[i].op == 1)\n            upd(rt, 0ll, N, q[i].s, q[i].t, i);\n    &#125;\n    std::vector&lt;int&gt; f(tot + 1);\n    std::iota(f.begin() + 1, f.end(), 1);\n    std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;\n        return x == f[x] ? x : f[x] = find(f[x]);\n    &#125;;\n    auto merge = [&amp;](int x, int y) &#123;\n        f[find(x)] = find(y);\n        return;\n    &#125;;\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; u(m + 2);\n    std::function&lt;void(int, int)&gt; link = [&amp;](int p, int q) &#123;\n        if (leaf(p) &amp;&amp; leaf(q)) &#123;\n            u[std::min(t[p].d, t[q].d)].emplace_back(p, q);\n            return;\n        &#125;\n        else if (leaf(p))\n            link(p, t[q].l), link(p, t[q].r);\n        else if (leaf(q))\n            link(t[p].l, q), link(t[p].r, q);\n        else\n            link(t[p].l, t[q].l), link(t[p].r, t[q].r);\n        return;\n    &#125;;\n    for (int i = 1; i &lt;= tot; ++i)\n        if (t[i].l &amp;&amp; t[i].r)\n            link(t[i].l, t[i].r);\n    for (auto [p, q] : u[m + 1])\n        merge(p, q);\n    std::vector&lt;int&gt; res;\n    for (int i = m; i; --i)\n        if (q[i].op == 2)\n            res.push_back(find(ask(rt, 0, N, q[i].s)) == find(ask(rt, 0, N, q[i].t)));\n        else\n            for (auto [p, q] : u[i])\n                merge(p, q);\n    for (; !res.empty(); res.pop_back())\n        std::cout &lt;&lt; res.back() &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c.-小-z-爱优化\">C. 小 Z 爱优化</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6662/problem/3\" class=\"uri\">https://www.becoder.com.cn/contest/6662/problem/3</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(a_{1\\sim n}\\)</span>，将其分为若干连续段，满足每段长度为 <span class=\"math inline\">\\(1\\)</span> 或 <span class=\"math inline\">\\(2\\)</span>，定义一段的权值为元素之和，最小化段权值的极差并输出之。</p>\n<p><span class=\"math inline\">\\(n\\le 2\\times 10^5,V=10^9\\)</span>。</p>\n</blockquote>\n<ul>\n<li><p>令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示这一段以 <span class=\"math inline\">\\(i\\)</span> 结尾，最小值为 <span class=\"math inline\">\\(j\\)</span> 时的最大值。把最小值当状态是自然的想法，实际似乎差不多（。）得到（<strong>不重要</strong>）：</p>\n<p><span class=\"math display\">\\[\nf_{i,a_i}\\gets f_{i-1,j},j\\ge a_i\\\\\nf_{i,a_i+a_{i-1}}\\gets f_{i-2,j},j\\ge a_i+a_{i-1}\\\\\nf_{i,j}\\gets \\max(f_{i-1,j},a_i) ,j\\le a_i\\\\\nf_{i,j}\\gets \\max(f_{i-2,j},a_i+a_{i-1}) ,j\\le a_i\n\\]</span></p></li>\n<li><p>这个状态很矩阵，可以考虑下标分奇偶性继承，用线段树优化，矩阵作为元素；然而同时涉及两个维度，尤其是第一维的变化，实在是答辩啊！</p>\n<details>\n<p><summary>By the way，广义矩乘的结合律？</summary></p>\n<p>对于一个 <span class=\"math inline\">\\(\\oplus-\\otimes\\)</span> 矩阵（内层为 <span class=\"math inline\">\\(\\otimes\\)</span>，外层为 <span class=\"math inline\">\\(\\oplus\\)</span>），其有结合律当且仅当同时满足：</p>\n<ol type=\"1\">\n<li><span class=\"math inline\">\\(\\oplus\\)</span> 有交换律；</li>\n<li><span class=\"math inline\">\\(\\otimes\\)</span> 有结合律；</li>\n<li><span class=\"math inline\">\\(\\otimes\\)</span> 对 <span class=\"math inline\">\\(\\oplus\\)</span> 有分配律。</li>\n</ol>\n<figure>\n<img src=\"image-2.png\" alt=\"来自 qkhm 关于广义矩阵乘法常见误区的一点纠正\" /><figcaption>来自 qkhm <a href=\"https://www.cnblogs.com/qkhm/p/19055513/ddp\">关于广义矩阵乘法常见误区的一点纠正</a></figcaption>\n</figure>\n</details>\n<p>发现第二维其实不会怎么变，或者说第二维其实起的是一个<strong>限制</strong>性的作用，可以考虑把第二维放到外层循环，相当于枚举<strong>限制</strong>。我们知道上面的做法可以很快地优化，所以拿出去了之后大概也能做。</p></li>\n<li><p>若限制当前最小值不能小于 <span class=\"math inline\">\\(j\\)</span>，那么有：</p>\n<p><span class=\"math display\">\\[\nf_i\\gets \\max(f_{i-1},a_i),a_j\\ge j\\\\\nf_i\\gets \\max(f_{i-2},a_i+a_{i-1}),a_i+a_{i-1}\\ge j\n\\]</span></p>\n<p>发现这就很显然是一个 DDP 的形式了，每次 <span class=\"math inline\">\\(j\\)</span> 改变时，只需要改动对应位置的矩阵（即是否能进行转移），总修改次数是 <span class=\"math inline\">\\(O(n)\\)</span> 的。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 2e5 + 5;\nconst int inf = 0x7fffffff;\nusing mat = std::array&lt;std::array&lt;int, 2&gt;, 2&gt;;\nint m[maxn][2][2];\nvoid mul(mat &amp;res, mat &amp;p, mat &amp;q) &#123;\n    res[0][0] = std::min(std::max(p[0][0], q[0][0]), std::max(p[0][1], q[1][0]));\n    res[0][1] = std::min(std::max(p[0][0], q[0][1]), std::max(p[0][1], q[1][1]));\n    res[1][0] = std::min(std::max(p[1][0], q[0][0]), std::max(p[1][1], q[1][0]));\n    res[1][1] = std::min(std::max(p[1][0], q[0][1]), std::max(p[1][1], q[1][1]));\n    return;\n&#125;\nstruct &#123;\n    int l, r;\n    mat u;\n&#125; t[maxn &lt;&lt; 2];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        t[p].u[0][0] = m[l][0][0];\n        t[p].u[0][1] = m[l][0][1];\n        t[p].u[1][0] = m[l][1][0];\n        t[p].u[1][1] = m[l][1][1];\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    mul(t[p].u, t[lt].u, t[rt].u);\n    return;\n&#125;\nvoid upd(int p, int x) &#123;\n    if (t[p].l == t[p].r) &#123;\n        t[p].u[0][1] = m[x][0][1];\n        t[p].u[1][1] = m[x][1][1];\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        upd(lt, x);\n    else\n        upd(rt, x);\n    mul(t[p].u, t[lt].u, t[rt].u);\n    return;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;opti.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;opti.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;./test/20251021/opti/1.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n;\n        std::cin &gt;&gt; n;\n        std::vector&lt;int&gt; a(n + 1), b(n + 1), l(1);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            std::cin &gt;&gt; a[i];\n            l.push_back(a[i]);\n            if (i &gt; 1)\n                b[i] = a[i] + a[i - 1], l.push_back(b[i]);\n        &#125;\n        std::sort(l.begin() + 1, l.end());\n        l.erase(std::unique(l.begin() + 1, l.end()), l.end());\n        int m = (int)l.size() - 1;\n        std::vector&lt;std::vector&lt;int&gt; &gt; ida(m + 1), idb(m + 1);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            a[i] = std::lower_bound(l.begin() + 1, l.end(), a[i]) - l.begin();\n            ::m[i][1][1] = a[i], ida[a[i]].push_back(i);\n            if (i &gt; 1) &#123;\n                b[i] = std::lower_bound(l.begin() + 1, l.end(), b[i]) - l.begin();\n                ::m[i][0][1] = b[i], idb[b[i]].push_back(i);\n            &#125;\n            else\n                ::m[i][0][1] = inf;\n            ::m[i][0][0] = inf, ::m[i][1][0] = 0;\n        &#125;\n        bld(1, 1, n);\n        auto res = inf;\n        for (int i = 1; i &lt;= m; ++i) &#123;\n            if (std::min(t[1].u[0][1], t[1].u[1][1]) != inf)\n                res = std::min(res, l[std::min(t[1].u[0][1], t[1].u[1][1])] - l[i]);\n            for (auto j : ida[i])\n                ::m[j][1][1] = inf, upd(1, j);\n            for (auto j : idb[i])\n                ::m[j][0][1] = inf, upd(1, j);\n        &#125;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt;(std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s \\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d.-小-z-爱考试\">D. 小 Z 爱考试</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6662/problem/4\" class=\"uri\">https://www.becoder.com.cn/contest/6662/problem/4</a></p>\n<blockquote>\n<p>给定一个大小为 <span class=\"math inline\">\\(n\\)</span> 的内向基环树森林，每个点 <span class=\"math inline\">\\(u\\)</span> 上附有点权 <span class=\"math inline\">\\(a_u\\)</span>、收益 <span class=\"math inline\">\\(w_u\\)</span> 和一个进程，内容为：</p>\n<ul>\n<li>若 <span class=\"math inline\">\\(u\\)</span> 指向的结点 <span class=\"math inline\">\\(fa\\)</span> 满足 <span class=\"math inline\">\\(a_{fa}&gt;a_u\\)</span>，则令 <span class=\"math inline\">\\(a_u\\gets a_u+w_u\\)</span>。</li>\n</ul>\n<p>给定 <span class=\"math inline\">\\(m\\)</span> 次操作，形如：</p>\n<ul>\n<li>单点修改 <span class=\"math inline\">\\(a_u,w_u\\)</span>。</li>\n<li>给定一个 <span class=\"math inline\">\\(u\\)</span>，输出：在 <span class=\"math inline\">\\(n!\\)</span> 种进程的执行序列中，<span class=\"math inline\">\\(a_u\\)</span> 最终值的期望。</li>\n</ul>\n<p><span class=\"math inline\">\\(n,m\\le 2\\times 10^5\\)</span>。<strong>保证每个点的入度 <span class=\"math inline\">\\(\\le 3\\)</span></strong>。</p>\n</blockquote>\n<ul>\n<li><p>可以感受到操作的『后效性』是非常弱的，进一步感受到点可以粗暴地分为三种类型：</p>\n<ol type=\"1\">\n<li><span class=\"math inline\">\\(a_{fa}&gt;a_x\\)</span> 的；</li>\n<li><span class=\"math inline\">\\(a_{fa}+w_{fa} \\le a_x\\)</span> 的；</li>\n<li><span class=\"math inline\">\\(a_{fa}\\le a_x&lt;a_{fa} + w_{fa}\\)</span> 的；</li>\n</ol>\n<p>点的类型是无依赖，可直接求的。显然，若 <span class=\"math inline\">\\(u\\)</span> 最终想取到 <span class=\"math inline\">\\(a_u+w_u\\)</span>，相当于走一条 <span class=\"math inline\">\\(u\\)</span> 开头，经过若干 3 类点，在 1 类点结尾的路径（这显然是确定的），假设路径包含 <span class=\"math inline\">\\(len\\)</span> 个点，答案为 <span class=\"math inline\">\\(\\dfrac {(n-len)!\\cdot C_{n}^{len}}{n!}=\\dfrac 1{len!}\\)</span>。</p>\n<p>换句话说，<span class=\"math inline\">\\(u\\)</span> 取不到 <span class=\"math inline\">\\(a_u+w_u\\)</span>，当且仅当路径上在出现 1 类点前出现了 2 类点或 3 类点的环（基环）。</p></li>\n<li><p>考虑静态的情况，先处理所有基环：若只存在 3 类点，则标记全部非法；否则，任选一个 1 类点或者 2 类点开头，就可以 DP 出环上的 <span class=\"math inline\">\\(len\\)</span>。</p>\n<p>对于所有树，直接大力 DP 即可。</p></li>\n<li><p>接着考虑带修的情况，修改相当于改变点及其后继的状态（原来入度限制是拿来做这个的）。</p>\n<p>发现没啥办法很好地做这个类 DDP 的问题。考虑到一场比赛不应该出现两道 DDP，故如果灵感迸发可能会想到干脆放弃预处理的想法，上重链，线段树维护区间 1 类点或 2 类点深度 max，即可做到两只 log。</p>\n<p>如果发现树上没有这样的点，在环上也可以类似地找到第一个 1 类点或 2 类点。</p></li>\n</ul>\n<details>\n<p>感觉写复杂了，瞻仰了一下别人的代码又感觉流程上没什么区别</p>\n<p>喜提最长代码，喜提最优解</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nconst int maxn = 6e5 + 5;\nstruct &#123;\n    int l, r, lc, rc, u1, u2;\n&#125; t[maxn &lt;&lt; 2];\n#define lt t[p].lc\n#define rt t[p].rc\nint tot;\nint ty[maxn], dep[maxn];\nvoid bld(int &amp;p, int l, int r) &#123;\n    p = ++tot;\n    t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        t[p].u1 = t[p].u2 = 0;\n        if (ty[l] == 1)\n            t[p].u1 = dep[l];\n        else if (ty[l] == 2)\n            t[p].u2 = dep[l];\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    t[p].u1 = std::max(t[lt].u1, t[rt].u1);\n    t[p].u2 = std::max(t[lt].u2, t[rt].u2);\n    return;\n&#125;\nvoid upd(int p, int x) &#123;\n    if (t[p].l == t[p].r) &#123;\n        t[p].u1 = t[p].u2 = 0;\n        if (ty[x] == 1)\n            t[p].u1 = dep[x];\n        else if (ty[x] == 2)\n            t[p].u2 = dep[x];\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        upd(lt, x);\n    else\n        upd(rt, x);\n    t[p].u1 = std::max(t[lt].u1, t[rt].u1);\n    t[p].u2 = std::max(t[lt].u2, t[rt].u2);\n    return;\n&#125;\nstd::pair&lt;int, int&gt; ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return std::make_pair(t[p].u1, t[p].u2);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    std::pair&lt;int, int&gt; res(0, 0);\n    if (l &lt;= mid)\n        res = ask(lt, l, r);\n    if (r &gt; mid) &#123;\n        auto s(ask(rt, l, r));\n        res.first = std::max(res.first, s.first);\n        res.second = std::max(res.second, s.second);\n    &#125;\n    return res;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;exam.out&quot;, &quot;w&quot;, stdout);\n    std::freopen(&quot;exam.in&quot;, &quot;r&quot;, stdin);\n#else\n    std::freopen(&quot;./test/20251021/exam/3.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, m;\n        std::cin &gt;&gt; n &gt;&gt; m;\n        std::vector&lt;int&gt; f(n + 1);\n        std::iota(f.begin() + 1, f.end(), 1);\n        std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;\n            return x == f[x] ? x : f[x] = find(f[x]);\n        &#125;;\n        auto merge = [&amp;](int x, int y) &#123;\n            f[find(x)] = find(y);\n            return;\n        &#125;;\n        std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);\n        fac[0] = inv[0] = 1ll;\n        for (int i = 1; i &lt;= n; ++i)\n            fac[i] = fac[i - 1] * i % mod;\n        auto qkp = [&amp;](long long x, int y) &#123;\n            auto res = 1ll;\n            for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n                if (y &amp; 1)\n                    (res *= x) %= mod;\n            return res;\n        &#125;;\n        inv[n] = qkp(fac[n], mod - 2);\n        for (int i = n - 1; i; --i)\n            inv[i] = inv[i + 1] * (i + 1) % mod;\n        std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n        std::vector&lt;int&gt; a(n + 1), w(n + 1), to(n + 1), col(2 * n + 1);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            std::cin &gt;&gt; a[i] &gt;&gt; to[i] &gt;&gt; w[i];\n            merge(i, to[i]);\n            g[to[i]].push_back(i);\n        &#125;\n        int now = 0, tot = n;\n        std::vector&lt;int&gt; tab(n + 1), tad(n + 1), vis(n + 1), L(2 * n + 1), R(2 * n + 1);\n        auto getty = [&amp;](int x) &#123;\n            if (a[to[x]] &gt; a[x])\n                return 1;\n            if (a[to[x]] + w[to[x]] &lt;= a[x])\n                return 2;\n            return 3;\n        &#125;;\n        for (int i = 1; i &lt;= n; ++i)\n            if (f[i] == i) &#123;\n                std::vector&lt;int&gt; vis(n + 1), t(1);\n                std::stack&lt;int&gt; st;\n                for (int x = i; ; ) &#123;\n                    st.push(x);\n                    if (!vis[to[x]])\n                        vis[to[x]] = 1, x = to[x];\n                    else &#123;\n                        for (;;) &#123;\n                            t.push_back(st.top());\n                            if (st.top() == to[x])\n                                break;\n                            st.pop();\n                        &#125;\n                        break;\n                    &#125;\n                &#125;\n                int k = (int)t.size() - 1;\n                std::reverse(t.begin() + 1, t.end());\n                t.resize(2 * k + 1);\n                L[++tot] = now + 1;\n                for (int i = 1; i &lt;= k; ++i) &#123;\n                    tab[t[i]] = ++now;\n                    col[t[i]] = tot;\n                    ::dep[tab[t[i]]] = 2 * k - i + 1;\n                    ::ty[tab[t[i]]] = getty(t[i]);\n                &#125;\n                for (int i = k + 1; i &lt;= 2 * k; ++i) &#123;\n                    t[i] = t[i - k];\n                    tad[t[i]] = ++now;\n                    ::dep[tad[t[i]]] = 2 * k - i + 1;\n                    ::ty[tad[t[i]]] = getty(t[i]);\n                &#125;\n                R[tot] = now;\n            &#125;\n        std::vector&lt;int&gt; fa(n + 1), siz(n + 1), son(n + 1), dep(n + 1);\n        std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n            siz[x] = 1;\n            for (auto i : g[x])\n                if (!tab[i]) &#123;\n                    dep[i] = dep[x] + 1;\n                    fa[i] = x, DFS(i);\n                    siz[x] += siz[i];\n                    if (siz[i] &gt; siz[son[x]])\n                        son[x] = i;\n                &#125;\n            return;\n        &#125;;\n        for (int i = 1; i &lt;= n; ++i)\n            if (tab[i])\n                dep[i] = 1, DFS(i);\n        std::vector&lt;int&gt; rt(2 * n + 1), dfn(n + 1), top(n + 1), bot(n + 1);\n        DFS = [&amp;](int x) &#123;\n            dfn[x] = ++now;\n            ty[dfn[x]] = getty(x);\n            ::dep[dfn[x]] = dep[x];\n            bot[top[x]] = x;\n            if (son[x])\n                top[son[x]] = top[x], DFS(son[x]);\n            for (auto i : g[x])\n                if (i != son[x] &amp;&amp; !tab[i])\n                    top[i] = i, DFS(i);\n            if (x == top[x])\n                bld(rt[x], dfn[x], dfn[bot[x]]);\n            return;\n        &#125;;\n        for (int i = 1; i &lt;= n; ++i)\n            if (tab[i])\n                top[i] = i, DFS(i);\n        for (int i = n + 1; i &lt;= tot; ++i)\n            bld(rt[i], L[i], R[i]);\n        auto work = [&amp;](int x) &#123;\n            ty[dfn[x]] = getty(x);\n            upd(rt[top[x]], dfn[x]);\n            if (tab[x]) &#123;\n                ty[tab[x]] = ty[tad[x]] = getty(x);\n                upd(rt[col[x]], tab[x]), upd(rt[col[x]], tad[x]);\n            &#125;\n            return;\n        &#125;;\n        for (int op; m--; ) &#123;\n            std::cin &gt;&gt; op;\n            if (op == 1) &#123;\n                int x;\n                std::cin &gt;&gt; x, std::cin &gt;&gt; a[x];\n                work(x);\n                for (auto i : g[x])\n                    work(i);\n            &#125;\n            else if (op == 2) &#123;\n                int x;\n                std::cin &gt;&gt; x, std::cin &gt;&gt; w[x];\n                work(x);\n                for (auto i : g[x])\n                    work(i);\n            &#125;\n            else &#123;\n                int x;\n                std::cin &gt;&gt; x;\n                auto calc = [&amp;](int x) &#123;\n                    int len = 0, toq = 0;\n                    for (; x; x = fa[top[x]]) &#123;\n                        auto [u1, u2] = ask(rt[top[x]], dfn[top[x]], dfn[x]);\n                        if (u1 &gt; u2)\n                            return len + dep[x] - u1 + 1;\n                        if (u2 &gt; u1)\n                            return -1;\n                        len += dep[x] - dep[fa[top[x]]], toq = top[x];\n                    &#125;\n                    auto [u1, u2] = ask(rt[col[toq]], tab[toq], R[col[toq]]);\n                    if (u1 &gt; u2)\n                        return len + ::dep[tab[toq]] - u1;\n                    return -1;\n                &#125;;\n                auto t(calc(x));\n                if (t == -1)\n                    std::cout &lt;&lt; a[x] &lt;&lt; &#39;\\n&#39;;\n                else &#123;\n                    // std::cout &lt;&lt; &quot;len = &quot; &lt;&lt; t &lt;&lt; &#39;\\n&#39;;\n                    std::cout &lt;&lt; ((a[x] + w[x]) * inv[t] % mod + (1ll + mod - inv[t]) % mod * a[x] % mod) % mod &lt;&lt; &#39;\\n&#39;;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b.-炒鱿鱼\">B. 炒鱿鱼</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6666/problem/2\" class=\"uri\">https://www.becoder.com.cn/contest/6666/problem/2</a></p>\n<blockquote>\n<p>现在有一个栈。在接下来的 <span class=\"math inline\">\\(n\\)</span> 个时刻，每个时刻会发生一次事件，形如：</p>\n<ul>\n<li>删除栈顶的 <span class=\"math inline\">\\(a_i\\)</span> 个元素，然后向栈顶加入 <span class=\"math inline\">\\(b_i\\)</span> 个元素。</li>\n</ul>\n<p>现在每个时刻都让一个人去执行事件，需要满足每个元素，加入它的和删除它的不能是同一个人。问最少需要多少个人才能实现这一点。输出方案。有 SPJ。</p>\n<p><span class=\"math inline\">\\(n\\le 10^5,V=10^9\\)</span>。</p>\n</blockquote>\n<ul>\n<li>可以猜到答案只会为 1 2 3，尝试从图染色的角度考虑这个问题（<strong>怎么想到这一点？</strong>）。</li>\n<li>一个元素在哪个时刻被加入 / 删除是固定的，故如果两天有冲突，可以考虑直接连边。考虑模拟，能够线性地求出来所有冲突关系，故边数是 <span class=\"math inline\">\\(O(n)\\)</span> 的。</li>\n<li><p>由于这个栈的结构，发现不存在交错的边，或者说不同时存在 <span class=\"math inline\">\\((x_1,y_1)\\)</span> 和 <span class=\"math inline\">\\((x_2,y_2)\\)</span>，使得 <span class=\"math inline\">\\(x_1&lt;x_2&lt;y_1&lt;y_2\\)</span>。考虑构造解：</p>\n<p>首先对于 <span class=\"math inline\">\\(1,n\\)</span> 任意涂色，忽略 <span class=\"math inline\">\\((1,n)\\)</span> 这条边（如果有），显然可以找到一个 <span class=\"math inline\">\\(mid\\)</span> 使得没有边跨过之，给其赋一个合法的颜色，接着就可以分治构造。</p>\n<p>感觉这种构造不算太显然，只能算是能想到（实际上并没有）。</p>\n<p>具体分治，由于性质比较好，直接取左端点对应范围内最远的边即可。</p></li>\n<li><p>需要注意上述构造方案能保证可以构造出 <span class=\"math inline\">\\(k=3\\)</span> 的解，但不能保证是最优的（即不能保证 <span class=\"math inline\">\\(k=1\\)</span> 或 <span class=\"math inline\">\\(k=2\\)</span> 也能构造出对应的解），故需要特判没有边 + 二分图两种情况。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;fire.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;fire.out&quot;, &quot;w&quot;, stdout);\n#else\n    // std::freopen(&quot;./test/20251022/fire/fire2.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i].first &gt;&gt; a[i].second;\n    bool flag = true;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1), g1(n + 1);\n    std::stack&lt;std::pair&lt;int, int&gt; &gt; st;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = 0; j &lt; a[i].first; ) &#123;\n            g[st.top().second].push_back(i);\n            g1[st.top().second].push_back(i);\n            g1[i].push_back(st.top().second);\n            flag = false;\n            int to = std::min(st.top().first, a[i].first - j);\n            j += to, st.top().first -= to;\n            if (st.top().first == 0)\n                st.pop();\n        &#125;\n        if (a[i].second)\n            st.emplace(a[i].second, i);\n    &#125;\n    if (flag == true) &#123;\n        std::cout &lt;&lt; 1 &lt;&lt; &#39;\\n&#39;;\n        for (int i = 1; i &lt;= n; ++i)\n            std::cout &lt;&lt; 1 &lt;&lt; &#39; &#39;;\n        std::cout &lt;&lt; &#39;\\n&#39;;\n        return 0;\n    &#125;\n    std::vector&lt;int&gt; col(n + 1);\n    std::function&lt;bool(int, int)&gt; DFS = [&amp;](int x, int now) &#123;\n        col[x] = now;\n        for (auto i : g1[x])\n            if (!col[i]) &#123;\n                if (!DFS(i, 3 - now))\n                    return false;\n            &#125;\n            else if (col[i] == now)\n                return false;\n        return true;\n    &#125;;\n    for (int i = 1; i &lt;= n; ++i)\n        if (!col[i] &amp;&amp; !DFS(i, 1))\n            goto nosol;\n    std::cout &lt;&lt; 2 &lt;&lt; &#39;\\n&#39;;\n    for (int i = 1; i &lt;= n; ++i)\n        std::cout &lt;&lt; col[i] &lt;&lt; &#39; &#39;;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n    return 0;\nnosol: ;\n    col[1] = 1, col[n] = 2;\n    std::function&lt;void(int, int)&gt; calc = [&amp;](int l, int r) &#123;\n        if (r - l + 1 &lt;= 2)\n            return;\n        if (!g[l].empty() &amp;&amp; g[l].back() == r)\n            g[l].pop_back();\n        int pos = g[l].empty() ? l + 1 : g[l].back();\n        col[pos] = 6 - col[l] - col[r];\n        calc(l, pos), calc(pos, r);\n        return;\n    &#125;;\n    calc(1, n);\n    std::cout &lt;&lt; 3 &lt;&lt; &#39;\\n&#39;;\n    for (int i = 1; i &lt;= n; ++i)\n        std::cout &lt;&lt; col[i] &lt;&lt; &#39; &#39;;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c.-适格者\">C. 适格者</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6666/problem/3\" class=\"uri\">https://www.becoder.com.cn/contest/6666/problem/3</a></p>\n<blockquote>\n<p>给定长度为 <span class=\"math inline\">\\(2^n\\)</span> 的数组 <span class=\"math inline\">\\(a_{0,\\cdots,2^n-1}\\)</span>，维护 <span class=\"math inline\">\\(q\\)</span> 次操作：</p>\n<ul>\n<li>修改：单点加；</li>\n<li>修改：高维前缀加；</li>\n<li>修改：高维后缀加；</li>\n<li>询问：高维前缀和，对 <span class=\"math inline\">\\(998244353\\)</span> 取模；</li>\n</ul>\n<p><span class=\"math inline\">\\(n\\le 20,q\\le 10^5\\)</span>。</p>\n</blockquote>\n<ul>\n<li>单点加 + 高维前缀和会反应出 <a href=\"/20250907/#e---subset-product-problem\">ARC205E</a> 的 trick</li>\n<li><p>考虑怎么做后缀加，会反应过来和 <a href=\"/20251010/#区间修改区间查询\">bit 的区间修改</a> 有一致性，修改相当于单点修改差分数组。考虑类似的推导：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\n\\sum_{s\\subseteq S}a_s&amp;=\\sum_{s\\subseteq S} \\sum_{i\\subseteq s} d_i\\\\\n&amp;=\\sum_{i\\subseteq S} 2^{|S|-|i|}\\times d_i\n\\end{aligned}\n\\]</span></p>\n<p>故维护 <span class=\"math inline\">\\(2^{-|i|}\\cdot d_i\\)</span> 即可（原来取模是拿来搞这个的）。类似地可以推导前缀加：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\n\\sum_{s\\subseteq S}a_s&amp;=\\sum_{s\\subseteq S} \\sum_{i\\supseteq s} d_i\\\\\n&amp;=\\sum_{i\\subseteq S} 2^{|S \\text{ bitand } i|}\\times d_i\n\\end{aligned}\n\\]</span></p>\n<p>发现这个 bitand 不太好搞，不过 bitand 是对位的，所以依然可以套在分块上</p>\n<p>同时，因为问的是前缀和，所以单点的 <span class=\"math inline\">\\(S\\text{ bitand } i\\)</span> 其实就是 <span class=\"math inline\">\\(i\\)</span>。这里有点囿于 fmt 的思维定势了，实际上可以直接认为 <span class=\"math inline\">\\(f_{s_1, s_2}\\)</span> 维护的是这个点处的答案，每次更新对 <span class=\"math inline\">\\(f_{s_1,*}\\)</span> 的贡献即可。</p></li>\n</ul>\n<details>\n<p>不知为何很慢</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nconst int inv2 = (mod + 1) &gt;&gt; 1;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;gene.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;gene.out&quot;, &quot;w&quot;, stdout);\n#else\n    // std::freopen(&quot;./test/20251022/gene/gene5.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, q;\n    std::cin &gt;&gt; n &gt;&gt; q;\n    const int N1 = n / 2, N2 = n - N1, lim = 1 &lt;&lt; N2;\n    std::vector&lt;long long&gt; inv(n + 1);\n    inv[0]= 1ll;\n    for (int i = 1; i &lt;= n; ++i)\n        inv[i] = inv[i - 1] * inv2 % mod;\n    std::vector&lt;std::vector&lt;long long&gt; &gt; s(1 &lt;&lt; N1, std::vector&lt;long long&gt; (lim));\n    auto s1(s), s2(s);\n    for (int op, x; q--; ) &#123;\n        std::cin &gt;&gt; op &gt;&gt; x;\n        int X1 = x &gt;&gt; N2, X2 = x &amp; (lim - 1);\n        if (op == 0) &#123;\n            auto res = 0ll, res1 = 0ll, res2 = 0ll;\n            for (int i = 0; i &lt; (1 &lt;&lt; N1); ++i)\n                res2 += (1 &lt;&lt; __builtin_popcount(i &amp; X1)) * s2[i][X2] % mod;\n            for (int i = X1; ; i = X1 &amp; (i - 1)) &#123;\n                res += s[i][X2];\n                res1 += s1[i][X2] * (1 &lt;&lt; __builtin_popcount(x)) % mod;\n                if (i == 0)\n                    break;\n            &#125;\n            std::cout &lt;&lt; (res + res1 + res2) % mod &lt;&lt; &#39;\\n&#39;;\n        &#125;\n        else if (op == 1) &#123;\n            int v;\n            std::cin &gt;&gt; v;\n            int X3 = (lim - 1) ^ X2;\n            for (int i = X3; ; i = X3 &amp; (i - 1)) &#123;\n                (s[X1][(lim - 1) ^ i] += v) %= mod;\n                if (i == 0)\n                    break;\n            &#125;\n        &#125;\n        else if (op == 2) &#123;\n            long long v;\n            std::cin &gt;&gt; v, (v *= inv[__builtin_popcount(x)]) %= mod;\n            int X3 = (lim - 1) ^ X2;\n            for (int i = X3; ; i = X3 &amp; (i - 1)) &#123;\n                (s1[X1][(lim - 1) ^ i] += v) %= mod;\n                if (i == 0)\n                    break;\n            &#125;\n        &#125;\n        else &#123;\n            long long v;\n            std::cin &gt;&gt; v;\n            for (int i = 0; i &lt; lim; ++i)\n                (s2[X1][i] += v * (1 &lt;&lt; __builtin_popcount(i &amp; X2))) %= mod;\n        &#125;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"cf1784c-monsters-hard-version\">CF1784C Monsters (hard version)</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1784C\" class=\"uri\">https://www.luogu.com.cn/problem/CF1784C</a></p>\n<ul>\n<li><p>通过若干次 1 操作，把数列的值域变成包含 1 且连续的，然后执行 2 操作，一定不劣</p></li>\n<li><p>考虑怎么快速维护这个东西，发现只关心初始序列和目标序列（从计算代价的式子可以看出来），故考虑这样一个构造最终序列的方式：</p>\n<ul>\n<li>从前到后遍历值域上的每个空位，找到第一个大于之的元素，并放过来，重复执行直到上述步骤不能执行为止。</li>\n</ul>\n<p>直接考虑一次加点带来的影响似乎非常复杂，但如果时光倒流，发现有贪心策略，直接把最后一次操作挪到这个新的空位即可。</p></li>\n<li><p>电波题！用 set 维护即可。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n;\n        std::cin &gt;&gt; n;\n        std::set&lt;std::pair&lt;int, int&gt; &gt; t;\n        std::vector&lt;long long&gt; res(n + 1);\n        std::vector&lt;int&gt; a(n + 1), to(n + 1), at(n + 1);\n        for (int i = 1; i &lt;= n; ++i)\n            std::cin &gt;&gt; a[i], t.emplace(a[i], i);\n        int now;\n        for (now = 1; ; ++now) &#123;\n            auto p(t.lower_bound(&#123; now, 0 &#125;));\n            if (p == t.end())\n                break;\n            at[now] = p-&gt;second;\n            to[p-&gt;second] = now;\n            res[n] += p-&gt;first - now;\n            t.erase(p);\n        &#125;\n        --now;\n        for (int i = n - 1; i; --i) &#123;\n            res[i] = res[i + 1];\n            if (to[i + 1]) &#123;\n                res[i] -= a[i + 1] - to[i + 1];\n                auto p = t.lower_bound(&#123; to[i + 1], 0 &#125;);\n                if (p != t.end()) &#123;\n                    at[to[i + 1]] = p-&gt;second;\n                    to[p-&gt;second] = to[i + 1];\n                    res[i] += a[p-&gt;second] - to[i + 1];\n                    t.erase(p);\n                &#125;\n                else &#123;\n                    res[i] -= a[at[now]] - to[at[now]];\n                    res[i] += a[at[now]] - to[i + 1];\n                    to[at[now]] = to[i + 1];\n                    at[to[i + 1]] = at[now];\n                    --now;\n                &#125;\n            &#125;\n            else\n                t.erase(&#123; a[i + 1], i + 1 &#125;);\n        &#125;\n        for (int i = 1; i &lt;= n; ++i)\n            std::cout &lt;&lt; res[i] &lt;&lt; &#39; &#39;;\n        std::cout &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"cf891c-envy\">CF891C Envy</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF891C\" class=\"uri\">https://www.luogu.com.cn/problem/CF891C</a></p>\n<p>mobai ddxrS</p>\n<ul>\n<li><p>经典结论：在做完权值 <span class=\"math inline\">\\(&lt;w\\)</span> 的 Kruskal 后，权值 <span class=\"math inline\">\\(=w\\)</span> 的边以任意顺序加入 Kruskal 后，并查集连通性完全一致。</p></li>\n<li><p>Another 经典结论：一条权值为 <span class=\"math inline\">\\(w\\)</span> 的边可以属于 mst，当且仅当在做完权值 <span class=\"math inline\">\\(&lt;w\\)</span> 的 Kruskal 后，这条边加入不形成环。</p></li>\n<li><p>重要事实：把并查集的 <code>merge</code> 操作打乱，连通性不变。</p></li>\n<li><p>结合起来得到这个神秘做法：按照边权做 Kruskal 检验每条边是否可以加入 mst，如果可以则记录合并的两个根，作为<strong>新边</strong>（不带权）。</p>\n<p><mark>重要事实：对于 <span class=\"math inline\">\\(n-1\\)</span> 条<strong>新边</strong>，要么有环，要么形成 mst。</mark></p>\n<p>推广：对于任意条<strong>新边</strong>，要么有环，要么可以通过某种选取其他<strong>新边</strong>的方式形成 mst。</p>\n<p>故 check 给定边的<strong>新边</strong>是否成环即可。算是一个 trick 吗？</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    const int M = 5e5;\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; ne(m + 1);\n    std::vector&lt;std::vector&lt;std::tuple&lt;int, int, int&gt; &gt; &gt; e(M + 1); \n    for (int i = 1, x, y, w; i &lt;= m; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;\n        e[w].emplace_back(x, y, i);\n    &#125;\n    std::vector&lt;int&gt; f(n + 1);\n    std::iota(f.begin() + 1, f.end(), 1);\n    std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;\n        return x == f[x] ? x : f[x] = find(f[x]);\n    &#125;;\n    for (int i = 1; i &lt;= M; ++i) &#123;\n        for (auto [u, v, id] : e[i])\n            ne[id] = &#123; find(u), find(v) &#125;;\n        for (auto [u, v, id] : e[i])\n            f[find(u)] = find(v);\n    &#125;\n    std::iota(f.begin() + 1, f.end(), 1);\n    int q;\n    for (std::cin &gt;&gt; q; q--; ) &#123;\n        int k;\n        std::cin &gt;&gt; k;\n        std::vector&lt;int&gt; pos;\n        bool flag = true;\n        for (int id; k--; ) &#123;\n            std::cin &gt;&gt; id;\n            if (find(ne[id].first) == find(ne[id].second))\n                flag = false;\n            f[find(ne[id].first)] = find(ne[id].second);\n            pos.push_back(ne[id].first);\n            pos.push_back(ne[id].second);\n        &#125;\n        std::cout &lt;&lt; (flag ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; &#39;\\n&#39;;\n        for (auto i : pos)\n            f[i] = i;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c.-山月记\">C. 山月记</h2>\n<p><a href=\"https://www.becoder.com.cn/problem/52034\" class=\"uri\">https://www.becoder.com.cn/problem/52034</a></p>\n<blockquote>\n<p>给定一棵大小为 <span class=\"math inline\">\\(n\\)</span> 的带权无根树 <span class=\"math inline\">\\(T\\)</span>，再给定 <span class=\"math inline\">\\(m\\)</span> 条额外的边，和 <span class=\"math inline\">\\(T\\)</span> 一起形成一个图 <span class=\"math inline\">\\(G\\)</span>。</p>\n<p>定义一个点 <span class=\"math inline\">\\(u\\)</span> 是好的，当且仅当对于<strong>每一个</strong> <span class=\"math inline\">\\(1\\le v\\le n\\)</span>，<strong><span class=\"math inline\">\\(T\\)</span> 上的</strong>简单路径 <span class=\"math inline\">\\((u,v)\\)</span> 都可以被 <span class=\"math inline\">\\(G\\)</span> 的某个 MST <strong>完整</strong>包含。</p>\n<p>输出任意一个好的点。无解输出 <span class=\"math inline\">\\(0\\)</span>。有 SPJ。</p>\n<p><span class=\"math inline\">\\(n,m\\le 10^5\\)</span>，<span class=\"math inline\">\\(w\\le 10^9\\)</span>。</p>\n</blockquote>\n<ul>\n<li><p>参考上一题，朴素做法是 <span class=\"math inline\">\\(O(n^2)\\)</span> 枚举某个 <span class=\"math inline\">\\(x\\)</span> 开头的路径，然后 <span class=\"math inline\">\\(O(len)\\)</span> 地 check；</p>\n<p>注意到这个结构能很好地和 DFS + 回溯结合，用可撤销并查集维护即可在 <span class=\"math inline\">\\(O(n\\log n)\\)</span> 内完成对一个 <span class=\"math inline\">\\(x\\)</span> 所有路径的 check。</p></li>\n<li><p>发现：如果一条路径 <span class=\"math inline\">\\((u,v)\\)</span> 是非法的，进一步所有完整包含 <span class=\"math inline\">\\((u,v)\\)</span> 的路径都是非法的。</p>\n<p><strong>从路径反映到点上</strong>，会发现 <span class=\"math inline\">\\((u,v)\\)</span> 两侧的点都是非法的。下意识考虑不在 <span class=\"math inline\">\\((u,v)\\)</span> 两侧，但在 <span class=\"math inline\">\\((u,v)\\)</span> 之外的点，发现它们仍然有可能合法，只要满足如下情况：</p>\n<p><img src=\"image-3.png\" /></p></li>\n<li><p>也就是说，对于 <span class=\"math inline\">\\(x\\)</span>，如果它出发的所有路径都合法，那么 <span class=\"math inline\">\\(x\\)</span> 自己就是答案；</p>\n<p>如果存在 <span class=\"math inline\">\\(\\ge 2\\)</span> 条非法路径，那么无解；</p>\n<p>否则，存在恰好一条边，在非法边所在的子树中递归求解，发现这很点分治，故可以 <span class=\"math inline\">\\(O(n\\log^2 n)\\)</span> 解决。log 分别来自点分治和撤销并查集。</p></li>\n<li><p>注：这里唐唐的，check 写成点分树子树内 check 了。点分治在这里只起保证递归层数的作用。</p></li>\n</ul>\n<details>\n<p>怎么跑得这么快？推测因为写的是按秩合并。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;./test/20251024/beast/beast1.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, m;\n        std::cin &gt;&gt; n &gt;&gt; m;\n        std::vector&lt;int&gt; l(1);\n        std::vector&lt;std::pair&lt;int, int&gt; &gt; ne(m + 1);\n        std::vector&lt;std::tuple&lt;int, int, int&gt; &gt; se(m + 1);\n        std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(n + 1);\n        std::vector&lt;std::vector&lt;std::tuple&lt;int, int, int&gt; &gt; &gt; e(m + 1); \n        for (int i = 1, x, y, w; i &lt;= m; ++i) &#123;\n            std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;\n            se[i] = &#123; x, y, w &#125;, l.push_back(w);\n            if (i &lt; n)\n                g[x].emplace_back(y, i), g[y].emplace_back(x, i);\n        &#125;\n        std::sort(l.begin() + 1, l.end());\n        l.erase(std::unique(l.begin() + 1, l.end()), l.end());\n        for (int i = 1; i &lt;= m; ++i) &#123;\n            auto [x, y, w] = se[i];\n            w = std::lower_bound(l.begin() + 1, l.end(), w) - l.begin();\n            e[w].emplace_back(x, y, i);\n        &#125;\n        std::vector&lt;int&gt; f(n + 1);\n        std::iota(f.begin() + 1, f.end(), 1);\n        std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;\n            return x == f[x] ? x : f[x] = find(f[x]);\n        &#125;;\n        for (int i = 1; i &lt;= m; ++i) &#123;\n            for (auto [u, v, id] : e[i])\n                ne[id] = &#123; find(u), find(v) &#125;;\n            for (auto [u, v, id] : e[i])\n                f[find(u)] = find(v);\n        &#125;\n        std::vector&lt;int&gt; tag(n + 1), p, siz(n + 1), mx(n + 1);\n        std::function&lt;void(int, int)&gt; DFS1 = [&amp;](int x, int fa) &#123;\n            p.push_back(x);\n            siz[x] = 1, mx[x] = 0;\n            for (auto [i, id] : g[x])\n                if (i != fa &amp;&amp; !tag[i]) &#123;\n                    DFS1(i, x);\n                    siz[x] += siz[i];\n                    mx[x] = std::max(mx[x], siz[i]);\n                &#125;\n            return;\n        &#125;;\n        auto findrt = [&amp;](int x) &#123;\n            p.clear(), DFS1(x, -1);\n            int n = (int)p.size();\n            for (auto i : p)\n                if (mx[i] &lt;= n / 2 &amp;&amp; n - siz[i] &lt;= n / 2)\n                    return i;\n            assert(0);\n            return -1;\n        &#125;;\n        std::vector&lt;int&gt; rank(n + 1);\n        std::stack&lt;std::tuple&lt;int, int, int&gt; &gt; st;\n        find = [&amp;](int x) &#123;\n            return x == f[x] ? x : find(f[x]);\n        &#125;;\n        auto merge = [&amp;](int x, int y) &#123;\n            x = find(x), y = find(y);\n            if (x == y)\n                return true;\n            if (rank[x] &lt;= rank[y])\n                st.emplace(x, y, rank[y]), f[x] = y;\n            else \n                st.emplace(y, x, rank[x]), f[y] = x;\n            if (rank[x] == rank[y])\n                ++rank[y];\n            return false;\n        &#125;;\n        auto undo = [&amp;](void) &#123;\n            assert(!st.empty());\n            auto [x, y, ry] = st.top();\n            st.pop();\n            f[x] = x, rank[y] = ry;\n            return;\n        &#125;;\n        std::function&lt;bool(int, int)&gt; DFS2 = [&amp;](int x, int fa) &#123;\n            for (auto [i, id] : g[x])\n                if (i != fa &amp;&amp; (merge(ne[id].first, ne[id].second) || DFS2(i, x))) &#123;\n                    undo();\n                    return true;\n                &#125;\n            undo();\n            return false;\n        &#125;;\n        std::function&lt;bool(int)&gt; DFS = [&amp;](int x) &#123;\n            x = findrt(x);\n            int to = 0;\n            for (auto [i, id] : g[x])\n                if (merge(ne[id].first, ne[id].second) || DFS2(i, x)) &#123;\n                    if (!to) to = i;\n                    else &#123;\n                        std::cout &lt;&lt; 0 &lt;&lt; &#39;\\n&#39;;\n                        return true;\n                    &#125;\n                &#125;\n            assert(st.empty());\n            tag[x] = 1;\n            if (to) &#123;\n                if (tag[to]) &#123;\n                    std::cout &lt;&lt; 0 &lt;&lt; &#39;\\n&#39;;\n                    return true;\n                &#125;\n                return DFS(to);\n            &#125;\n            std::cout &lt;&lt; x &lt;&lt; &#39;\\n&#39;;\n            return true;\n        &#125;;\n        std::iota(f.begin() + 1, f.end(), 1);\n        assert(DFS(1));\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b.-电报-a.-神灵庙-cf2068d-morse-code\">B. 电报 / A. 神灵庙 / CF2068D Morse Code</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6676/problem/2\" class=\"uri\">https://www.becoder.com.cn/contest/6676/problem/2</a> / <a href=\"https://www.becoder.com.cn/contest/5527/problem/1\" class=\"uri\">https://www.becoder.com.cn/contest/5527/problem/1</a> / <a href=\"https://www.luogu.com.cn/problem/CF2068D\" class=\"uri\">https://www.luogu.com.cn/problem/CF2068D</a></p>\n<blockquote>\n<p>一个无限大的完全二叉树，根节点权值为 <span class=\"math inline\">\\(0\\)</span>，一个点的左儿子权值是这个点的权值 <span class=\"math inline\">\\(+1\\)</span>，右儿子为 <span class=\"math inline\">\\(+2\\)</span>。</p>\n<p>给定 <span class=\"math inline\">\\(c_1,\\cdots, c_n\\)</span>，挑选 <span class=\"math inline\">\\(n\\)</span> 个互不为祖孙的点，最终代价为点权 <span class=\"math inline\">\\(\\times\\)</span> 对应的 <span class=\"math inline\">\\(c\\)</span> 之和。</p>\n</blockquote>\n<ul>\n<li><p>一个基本的观察：权值对应相邻两种值的结点数总是构成类似斐波那契的结构。显然应该把权值和点权逆大小对应。</p>\n<p>朴素 DP：令 <span class=\"math inline\">\\(f_{i,j,a,b}\\)</span> 表示当前枚举到权值 <span class=\"math inline\">\\(i\\)</span>，已经选了 <span class=\"math inline\">\\(j\\)</span> 个点，<span class=\"math inline\">\\(i-1\\)</span>、<span class=\"math inline\">\\(i\\)</span> 分别剩余 <span class=\"math inline\">\\(a,b\\)</span> 个点的最小代价，可以得到 <span class=\"math inline\">\\(n^5\\)</span> 的惊人转移。</p></li>\n<li><p>经典 trick：最后一层循环的枚举是无必要的，可以一个一个转移（类似完全背包）。这样就少了一个 <span class=\"math inline\">\\(n\\)</span>。如果观察到最深取到 1.5 log（斐波那契）能砍成 <span class=\"math inline\">\\(O(n^3\\log n)\\)</span>。</p></li>\n<li><p>接着，发现可以费用提前计算（这里我觉得更像是算贡献），少枚举一个 <span class=\"math inline\">\\(i\\)</span>，这样就是 <span class=\"math inline\">\\(O(n^3)\\)</span> 的了。</p>\n<p>发现没什么实现的头绪。目前有：</p>\n<p><span class=\"math display\">\\[\nf_{j,a,b}\\to f_{j+1,a,b-1}\\\\\nf_{j,a,b}+suf_{j+1}\\to f_{j,b,a+b}\n\\]</span></p>\n<p>以前没有注意到过，其实<strong>枚举顺序是由转移方程决定的</strong>：</p>\n<ul>\n<li>第一种转移中，<span class=\"math inline\">\\(j\\)</span> 是递增的，<span class=\"math inline\">\\(a\\)</span> 水平，<span class=\"math inline\">\\(b\\)</span> 递减；</li>\n<li>第二种转移中，<span class=\"math inline\">\\(j\\)</span> 水平，<span class=\"math inline\">\\(a\\)</span> 无法确定，<span class=\"math inline\">\\(b\\)</span> 不递减；</li>\n</ul>\n<p>可以想到一个转移顺序：正序枚举 <span class=\"math inline\">\\(j\\)</span>，正序枚举 <span class=\"math inline\">\\(b\\)</span>；正序枚举 <span class=\"math inline\">\\(a\\)</span>。</p>\n<p>此时第二种会有点问题，<span class=\"math inline\">\\(j\\)</span> 水平且 <span class=\"math inline\">\\(b\\)</span> 水平时，若 <span class=\"math inline\">\\(a\\)</span> 变小怎么办？发现这要求 <span class=\"math inline\">\\(b&lt;a\\)</span>，则 <span class=\"math inline\">\\(a+b&gt;b\\)</span> 恒成立，<span class=\"math inline\">\\(b\\)</span> 一定不水平。挺牛的这个。</p></li>\n<li><p>卡空间了，滚动一下即可。复杂度 <span class=\"math inline\">\\(O(n^3)\\)</span>。绅士写了神秘玄学<a href=\"https://www.becoder.com.cn/submission/3177578\">做法</a>，瞻仰无果。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;telegram.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;telegram.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; c(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; c[i];\n    std::sort(c.begin() + 1, c.end(), std::greater&lt;int&gt; ());\n    std::partial_sum(c.rbegin(), c.rend(), c.rbegin());\n    using arr = std::vector&lt;int&gt;;\n    using brr = std::vector&lt;arr&gt;;\n    using crr = std::vector&lt;brr&gt;;\n    crr f(2, brr(n + 1, arr(n + 1))), tag(2, brr(n + 1, arr(n + 1, -1)));\n    f[0][1][1] = c[1], tag[0][1][1] = 0;\n    auto upd = [&amp;](int i, int &amp;t, int &amp;x, int y) &#123;\n        if (t == i)\n            x = std::min(x, y);\n        else\n            x = y, t = i;\n        return;\n    &#125;;\n    for (int j = 0, k = 0; j &lt; n; ++j, k ^= 1) &#123;\n        for (int b = 0; b &lt;= n; ++b)\n            for (int a = 0; a &lt;= n; ++a)\n                if (tag[k][b][a] == j) &#123;\n                    if (b)\n                        upd(j + 1, tag[k ^ 1][b - 1][a], f[k ^ 1][b - 1][a], f[k][b][a]);\n                    if (a + b &lt;= n)\n                        upd(j, tag[k][a + b][b], f[k][a + b][b], f[k][b][a] + c[j + 1]);\n                &#125;\n    &#125;\n    auto res = 0x3f3f3f3f;\n    for (int b = 0; b &lt;= n; ++b)\n        for (int a = 0; a &lt;= n; ++a)\n            if (tag[n &amp; 1][b][a] == n)\n                res = std::min(res, f[n &amp; 1][b][a]);\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"coi-2019-tenis\">[COI 2019] TENIS</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P11340\" class=\"uri\">https://www.luogu.com.cn/problem/P11340</a></p>\n<ul>\n<li><p>观察一：<span class=\"math inline\">\\(x\\)</span> 能获胜，当且仅当存在一个 <span class=\"math inline\">\\(y\\)</span>，使得 <span class=\"math inline\">\\(x\\)</span> 能战胜 <span class=\"math inline\">\\(y\\)</span>，且 <span class=\"math inline\">\\(y\\)</span> 能在剩下 <span class=\"math inline\">\\(n-1\\)</span> 个人中获胜。</p>\n<p>发现这是一个递归，或者说链式的关系。</p></li>\n<li><p>观察二：不妨把三个数组视为三条链，那么发现任意一个链首在任意局面总是能获胜。如果一个人能战胜链首，显然这个人能获胜。反过来，若不能通过任何方式战胜链首，显然无法获胜。</p>\n<p>然后就变成连通性问题了。但很容易猜到带删边连通性没什么优化的前途。</p>\n<p><em>只有加边的带修连通性问题：<a href=\"https://www.luogu.com.cn/article/taefjy3d\">整体二分</a></em>。</p></li>\n<li><p>观察三：链首不能被 <span class=\"math inline\">\\(x\\)</span> 战胜，当且仅当存在一个 <span class=\"math inline\">\\(i\\)</span>，三条链的前 <span class=\"math inline\">\\(i\\)</span> 个元素集相同，且 <span class=\"math inline\">\\(x\\)</span> 位于最小的 <span class=\"math inline\">\\(i\\)</span> 之后。</p>\n<p>这个看起来和 <a href=\"https://www.luogu.com.cn/problem/CF526F\">Puuding Monsters</a> / <a href=\"https://www.luogu.com.cn/problem/CF997E\">Good Subsegments</a> 比较像，实际上思路上也有共通之处：<strong>如果合法区间的值域是连续的，可以把条件转化为 min / max 问题。</strong></p>\n<p>考虑先使其<strong>询问区间内值域连续</strong>以套用这样的方法。可以对链 1 重标号为 <span class=\"math inline\">\\(1\\cdots n\\)</span>，维护链 2、3 的答案；也可以维护三个 rank 上的答案。法一实现起来有很多不必要的令人讨厌的地方，故写法二。</p></li>\n<li><p>相当于求一个最小的 <span class=\"math inline\">\\(i\\)</span> 使得链 1、2、3 在 <span class=\"math inline\">\\(i\\)</span> 之前的所有元素 rank 都不能比 <span class=\"math inline\">\\(i\\)</span> 大。主体为 <span class=\"math inline\">\\(i\\)</span> 时，（因为最小这个限制，和依次改动会带来很大的偏移），所以不太好维护；</p>\n<p>但是正确的维护方式很难想到！令 <span class=\"math inline\">\\(f_i,g_i\\)</span> 分别表示链 2、3 的每个 <span class=\"math inline\">\\(1\\le j\\le n\\)</span>，满足 <span class=\"math inline\">\\(\\min(r_{1/2/3,j})\\)</span>、<span class=\"math inline\">\\(\\max(r_{1/2/3,j})= i\\)</span> 的 <span class=\"math inline\">\\(j\\)</span> 的数量。如果二者在 <span class=\"math inline\">\\(i\\)</span> 处的前缀和相等，那么 <span class=\"math inline\">\\(i\\)</span> 就是合法的。</p>\n<blockquote>\n<p>Fractures（新角色）：这是个很常见的 trick。</p>\n<p>Fractures：这个和 Pudding Monsters 哪里像了。是你唐。</p>\n</blockquote>\n<p>维护 <span class=\"math inline\">\\(f_i-g_i\\)</span> 的前缀和；线段树维护区间修改和全局 min 即可。</p></li>\n</ul>\n<details>\n<p>莫名很慢。和 TTpandaS 相比多了一次建树（但不应该有这么大的影响才对）。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e5 + 5;\nstruct &#123; int l, r, mn, at, d; &#125; t[maxn &lt;&lt; 2];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid pushup(int p) &#123;\n    t[p].mn = std::min(t[lt].mn, t[rt].mn);\n    if (t[lt].mn == t[p].mn)\n        t[p].at = t[lt].at;\n    else\n        t[p].at = t[rt].at;\n    return;\n&#125;\nvoid pushdown(int p) &#123;\n    if (t[p].d) &#123;\n        t[lt].d += t[p].d, t[lt].mn += t[p].d;\n        t[rt].d += t[p].d, t[rt].mn += t[p].d;\n        t[p].d = 0;\n    &#125;\n    return;\n&#125;\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        t[p].at = l;\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    pushup(p);\n    return;\n&#125;\nvoid add(int p, int l, int r, int v) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        t[p].d += v, t[p].mn += v;\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid)\n        add(lt, l, r, v);\n    if (r &gt; mid)\n        add(rt, l, r, v);\n    pushup(p);\n    return;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;match.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;match.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, q;\n    std::cin &gt;&gt; n &gt;&gt; q;\n    std::vector&lt;std::vector&lt;int&gt; &gt; p(3, std::vector&lt;int&gt; (n + 1));\n    for (int k = 0; k &lt; 3; ++k)\n        for (int i = 1, x; i &lt;= n; ++i)\n            std::cin &gt;&gt; x, p[k][x] = i;\n    bld(1, 1, n);\n    auto upd = [&amp;](int i, int k) &#123;\n        add(1, std::min(&#123; p[0][i], p[1][i], p[2][i] &#125;), n, k);\n        add(1, std::max(&#123; p[0][i], p[1][i], p[2][i] &#125;), n, -k);\n        return;\n    &#125;;\n    for (int i = 1; i &lt;= n; ++i)\n        upd(i, 1);\n    int now = t[1].at;\n    // printf(&quot;now = %d \\n&quot;, now);\n    for (int op; q--; ) &#123;\n        std::cin &gt;&gt; op;\n        if (op == 1) &#123;\n            int x;\n            std::cin &gt;&gt; x;\n            std::cout &lt;&lt; (std::min(&#123; p[0][x], p[1][x], p[2][x] &#125;) &lt;= now ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; &#39;\\n&#39;;\n        &#125;\n        else &#123;\n            int k, i, j;\n            std::cin &gt;&gt; k &gt;&gt; i &gt;&gt; j, --k;\n            upd(i, -1), upd(j, -1);\n            std::swap(p[k][i], p[k][j]);\n            upd(i, 1), upd(j, 1);\n            now = t[1].at;\n            // printf(&quot;now = %d \\n&quot;, now);\n        &#125;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "线段树",
                "最小生成树",
                "贪心",
                "优化建图",
                "DP 优化",
                "点分治"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20251013/",
            "url": "https://xsc062.netlify.app/20251013/",
            "title": "杂题选谈：生成树 III",
            "date_published": "2025-10-13T02:35:14.000Z",
            "content_html": "<p>mst，以及 mst related</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"boruvka\">Boruvka</h2>\n<ul>\n<li>用途：<span class=\"math inline\">\\(O(m\\log n)\\)</span> 求 mst。</li>\n<li><p>过程：</p>\n<ul>\n<li>考虑和 Kruskal、Prim 类似的孤立点 <span class=\"math inline\">\\(\\to\\)</span> 加边 <span class=\"math inline\">\\(\\to\\)</span> 树。</li>\n<li>每一轮算法，对于当前的每个连通块，找到其连向其它连通块的边中最小的一条，并在这一轮后加入边集（用并查集维护连通块合并）。</li>\n<li>重复执行该算法，最终找到 mst。</li>\n</ul>\n<figure>\n<img src=\"mst-1.apng\" alt=\"图源 OI Wiki\">\n<figcaption>\n图源 OI Wiki\n</figcaption>\n</figure></li>\n<li>复杂度：每一轮中，每个连通块都会被合并一次，故一轮之后现存连通块数量最坏情况下变为原来的一半。也即共执行 <span class=\"math inline\">\\(\\log n\\)</span> 轮。复杂度 <span class=\"math inline\">\\(O(m\\log n)\\)</span>。</li>\n<li><p>优势：对于<strong>特殊边权</strong>的完全图 / 稠密图，边权并不由输入直接给定，而是由顶点计算得到，此时若可以依据性质直接找到连通块的最小边，则复杂度降低至 <span class=\"math inline\">\\(O(n\\log n)\\)</span> 之类非常优秀的级别（注意并查集的 log 和 Boruvka 本身的 log 是平行的）。</p>\n<p>『依据性质找到最小的边』的一个 Bonus：见 KDT + Boruvka 做法的 <a href=\"https://www.luogu.com.cn/problem/P6362\">平面欧几里得最小生成树</a>。</p></li>\n</ul>\n<hr />\n<h2 id=\"a---jumping-around\">A - Jumping Around</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1550F\" class=\"uri\">https://www.luogu.com.cn/problem/CF1550F</a></p>\n<ul>\n<li>本题就是『特殊边权完全图』的体现。定义任意两个点之间的边权为两个点相互跳需要的最小的 <span class=\"math inline\">\\(k=||x_0-x_1|-d|\\)</span>，那么只需求瓶颈路。</li>\n<li><p>做 Boruvka 即可。考虑怎么求某个连通块的最小边，预处理出每个位置（包括空位）前 / 后第一个和自己颜色不同的非空位，每次 check <span class=\"math inline\">\\(i\\pm d\\)</span>：</p>\n<ul>\n<li>若该位置存在和当前位置不同颜色的点：连边。</li>\n<li>否则，若该位置和当前位置颜色相同：转到刚刚求出的前驱、后继，选更小者连边。</li>\n<li>否则该位为空。前驱、后继则转化为上面两种情况。</li>\n</ul></li>\n<li><p>和双指针做法不同，似乎并不支持离散化，只能做到 <span class=\"math inline\">\\(O(V\\log n)\\)</span>。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int V = 1e6;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, q, s, d;\n    std::cin &gt;&gt; n &gt;&gt; q &gt;&gt; s &gt;&gt; d;\n    std::vector&lt;int&gt; a(n + 1), tab(V + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i], tab[a[i]] = i;\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; to(n + 1);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(n + 1);\n    std::vector&lt;int&gt; u(V + 1), pre(V + 1), nex(V + 1), mn(n + 1), f(n + 1), pos;\n    std::iota(f.begin() + 1, f.end(), 1);\n    std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;\n        return x == f[x] ? x : f[x] = find(f[x]);\n    &#125;;\n    for (int tot = n; tot != 1; ) &#123;\n        pos.clear();\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            if (f[i] == i) &#123;\n                mn[i] = 0x3f3f3f3f, to[i] = &#123; 0, 0 &#125;;\n                pos.push_back(i);\n            &#125;\n            u[a[i]] = find(i);\n            if (u[a[i - 1]] == u[a[i]])\n                pre[a[i]] = pre[a[i - 1]];\n            else\n                pre[a[i]] = a[i - 1];\n        &#125;\n        for (int i = 1; i &lt;= V; ++i)\n            if (!u[i])\n                pre[i] = u[i - 1] ? i - 1 : pre[i - 1];\n        nex[a[n]] = V + 1;\n        for (int i = n - 1; i; --i)\n            if (u[a[i + 1]] == u[a[i]])\n                nex[a[i]] = nex[a[i + 1]];\n            else\n                nex[a[i]] = a[i + 1];\n        nex[V] = V + 1;\n        for (int i = V - 1; i; --i)\n            if (!u[i])\n                nex[i] = u[i + 1] ? i + 1 : nex[i + 1];\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            int x = a[i], now = 0x3f3f3f3f, pos = 0;\n            auto upd = [&amp;](int x1) &#123;\n                if (std::abs(std::abs(x - x1) - d) &lt; now)\n                    now = std::abs(std::abs(x - x1) - d), pos = x1;\n                return;\n            &#125;;\n            auto trans = [&amp;](int x1) &#123;\n                if (pre[x1])\n                    upd(pre[x1]);\n                if (nex[x1] != V + 1)\n                    upd(nex[x1]);\n                return;\n            &#125;;\n            std::function&lt;void(int)&gt; work = [&amp;](int x1) &#123;\n                if (u[x1] &amp;&amp; u[x1] != u[x])\n                    upd(x1);\n                else if (u[x1])\n                    trans(x1);\n                else &#123;\n                    if (pre[x1])\n                        work(pre[x1]);\n                    if (nex[x1] != V + 1)\n                        work(nex[x1]);\n                &#125;\n                return;\n            &#125;;\n            work(std::max(1, x - d)), work(std::min(V, x + d));\n            if (now &lt; mn[u[x]])\n                mn[u[x]] = now, to[u[x]] = &#123; i, tab[pos] &#125;;\n        &#125;\n        for (auto i : pos) &#123;\n            int j = u[a[to[i].second]], x = to[i].first, y = to[i].second;\n            if (find(i) != find(j)) &#123;\n                --tot;\n                f[find(i)] = find(j);\n                g[x].emplace_back(y, mn[i]), g[y].emplace_back(x, mn[i]);\n            &#125;\n        &#125;\n    &#125;\n    std::vector&lt;int&gt; res(n + 1);\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        for (auto [i, w] : g[x])\n            if (i != fa) &#123;\n                res[i] = std::max(res[x], w);\n                DFS(i, x);\n            &#125;\n        return;\n    &#125;;\n    DFS(s, -1);\n    for (int x, k; q--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; k;\n        std::cout &lt;&lt; ((res[x] &lt;= k) ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---parametric-mst\">B - Parametric MST</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1656F\" class=\"uri\">https://www.luogu.com.cn/problem/CF1656F</a></p>\n<ul>\n<li>可以猜到能够把答案写出来，但是发现太抽象了以至于不太好模拟。</li>\n<li>首先需要猜到题目给的 <span class=\"math inline\">\\(w\\)</span> 是可以继续化的，注意到 <span class=\"math inline\">\\(a_i\\cdot a_j+t(a_i+a_j)\\)</span> 可以写成 <span class=\"math inline\">\\((a_j+t)\\cdot a_i+t\\cdot a_i\\)</span> 的一次函数形式，一个很重要的思路是放弃模拟 mst 转而<strong>从点出发贪心</strong></li>\n<li><p><span class=\"math inline\">\\(t\\)</span> 会影响的是斜率 <span class=\"math inline\">\\(a_j+t\\)</span>，所以<strong>应该根据 <span class=\"math inline\">\\(a_j+t\\)</span> 的正负情况选择贪心策略</strong>。</p>\n<p>当 <span class=\"math inline\">\\(a_j+t\\le 0\\)</span> 时，使 <span class=\"math inline\">\\(a_j\\)</span> 向 <span class=\"math inline\">\\(a_{\\max}\\)</span> 连边，否则向 <span class=\"math inline\">\\(a_{\\min}\\)</span> 连边。</p>\n<p>这其实是 Boruvka 第一轮的过程；此时只剩至多两个连通块，连边方式也就讨论一下 <span class=\"math inline\">\\(a_1+t\\)</span> 和 <span class=\"math inline\">\\(a_n+t\\)</span> 的正负，然后很显然了。</p></li>\n<li><p>当 <span class=\"math inline\">\\(t\\)</span> 足够小时，所有点都会连向 <span class=\"math inline\">\\(a_{\\max}\\)</span>；反之，当 <span class=\"math inline\">\\(t\\)</span> 足够大时，所有点都会连向 <span class=\"math inline\">\\(a_{\\min}\\)</span>。</p>\n<p>对于第一种情况，mst 的权为 <span class=\"math inline\">\\(a_{\\max}\\cdot (s - a_{\\max}) + t\\cdot ((n-1)\\cdot a_{\\max}+s-a_{\\max})\\)</span>；第二种情况，mst 的权为 <span class=\"math inline\">\\(a_{\\min}\\cdot (s - a_{\\min}) + t\\cdot ((n-1)\\cdot a_{\\min}+s-a_{\\min})\\)</span>，check <span class=\"math inline\">\\(t\\)</span> 的系数即可判 <code>INF</code>。</p></li>\n<li><p>通过上面一种情况，可以注意到 <span class=\"math inline\">\\(t\\in[-a_{\\max},-a_{\\min}]\\)</span>，进一步需要猜到 <span class=\"math inline\">\\(t\\)</span> 取某个 <span class=\"math inline\">\\(-a_i\\)</span>。由于连的边是很已知的，可以发现当 <span class=\"math inline\">\\(t\\)</span> 夹在两个连续的 <span class=\"math inline\">\\(-a\\)</span> 之间时，mst 的连边情况是不变的。</p>\n<p>显然此时 mst 的权是一个关于 <span class=\"math inline\">\\(t\\)</span> 的一次函数，故 check 两端点即可。排序即可快速 check。</p>\n<p>由于此时第二轮 Boruvka 要连的边一定是 <span class=\"math inline\">\\((a_1,a_n)\\)</span>，连上即可。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n;\n        std::cin &gt;&gt; n;\n        std::vector&lt;long long&gt; a(n + 1), s(n + 1);\n        for (int i = 1; i &lt;= n; ++i)\n            std::cin &gt;&gt; a[i];\n        std::sort(a.begin() + 1, a.end());\n        std::partial_sum(a.begin() + 1, a.end(), s.begin() + 1);\n        if ((n - 1) * a[n] + s[n - 1] &lt; 0ll || (n - 1) * a[1] + s[n] - a[1] &gt; 0ll)\n            std::cout &lt;&lt; &quot;INF\\n&quot;;\n        else &#123;\n            long long res = -1e18;\n            for (int i = 1; i &lt;= n; ++i) &#123;\n                auto t = -a[i], sl = s[i] - a[1], sr = s[n - 1] - s[i];\n                res = std::max(res, a[n] * sl + a[1] * sr + t * ((i - 1) * a[n] + (n - 1 - i) * a[1] + sl + sr) + a[1] * a[n] + t * (a[1] + a[n]));\n            &#125;\n            std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n        &#125;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---star-mst\">C - Star MST</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1657E\" class=\"uri\">https://www.luogu.com.cn/problem/CF1657E</a></p>\n<ul>\n<li>模拟 Kruskal 的过程，在边权 <span class=\"math inline\">\\(w\\)</span> 处出现 <span class=\"math inline\">\\((1,x)\\)</span>，那么允许在 <span class=\"math inline\">\\(\\ge w\\)</span> 处出现其他与 <span class=\"math inline\">\\(x\\)</span> 相关的边。</li>\n<li>会有一个比较暴力的想法，设 <span class=\"math inline\">\\(f_{i,j,l}\\)</span> 表示已经分配完边权 <span class=\"math inline\">\\(i\\)</span>，共分配了 <span class=\"math inline\">\\(j\\)</span> 条与 <span class=\"math inline\">\\(1\\)</span> 相关的边，还剩下 <span class=\"math inline\">\\(l\\)</span> 条空闲边可以放，会有一个 <span class=\"math inline\">\\(O(k\\cdot n^4)\\)</span> 的转移。</li>\n<li><p>考虑优化。容易注意到没必要存 <span class=\"math inline\">\\(l\\)</span> 而是可以当场完成分配，但这样就导致 <span class=\"math inline\">\\(i\\)</span> 维的限制转化为『恰好』，需要额外枚举一轮。总之可以得到：</p>\n<p><span class=\"math display\">\\[\nf_{i,j}=\\sum_{d_i=1}^{i}\\sum_{d_j=1}^{j} C_{n-(j-d_j)}^{d_j}\\times f_{i-d_i,j-d_j}\\times (k-i+1)^{C_{d_j}^2+d_j\\times (j-d_j)}\n\\]</span></p>\n<p>此时复杂度为 <span class=\"math inline\">\\(O(k^2n^2\\log k)\\)</span>，依然不够看；注意到交换求和顺序可以前缀和优化，故：</p>\n<p><span class=\"math display\">\\[\nf_{j, i}=\\sum_{d_j=1}^{j} C_{n-(j-d_j)}^{d_j}\\times (k-i+1)^{C_{d_j}^2+d_j\\times (j-d_j)}\\times \\sum_{d_i=1}^{i}f_{j - d_j,i-d_i}\n\\]</span></p>\n<p>复杂度 <span class=\"math inline\">\\(O(kn^2\\log k)\\)</span>。<span class=\"math inline\">\\(\\log\\)</span> 来源于快速幂。当然可以考虑预处理优化掉 log，whatever.</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    std::vector&lt;std::vector&lt;long long&gt; &gt; C(n + 1, std::vector&lt;long long&gt; (n + 1));\n    for (int i = 0; i &lt;= n; ++i) &#123;\n        C[i][0] = 1ll;\n        for (int j = 1; j &lt;= i; ++j)\n            C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod;\n    &#125;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    std::vector&lt;std::vector&lt;long long&gt; &gt; s(n, std::vector&lt;long long&gt; (k + 1));\n    for (int i = 0; i &lt;= k; ++i)\n        s[0][i] = 1ll;\n    for (int j = 1; j &lt; n; ++j)\n        for (int i = 1; i &lt;= k; ++i) &#123;\n            for (int dj = 1; dj &lt;= j; ++dj) \n                s[j][i] += C[n - (j - dj) - 1][dj] * qkp(k - i + 1, (C[dj][2] + dj * (j - dj)) % mod) % mod * s[j - dj][i - 1] % mod;\n            (s[j][i] += s[j][i - 1]) %= mod;\n        &#125;\n    std::cout &lt;&lt; s[n - 1][k] &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d---smooth-sailing-hard-version\">D - Smooth Sailing (Hard Version)</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1920F2\" class=\"uri\">https://www.luogu.com.cn/problem/CF1920F2</a></p>\n<ul>\n<li><p>实在十分熟悉，之前在哪道 CF 题遇到过这个 trick，然而没什么回忆线索，遂放弃</p>\n<p>一个连通块被包围的充要条件：从连通块边缘任意一个点向任意方向发一条射线，<em>垂直</em>经过路径奇数次。</p>\n<p><em>垂直</em>：即切线不切换奇偶状态。</p>\n<p>这个东西其实来源于计算几何，但是我的数学水平只停留在听说过计算几何四个字的水平，故不深究了。</p>\n<p>这种网格图上的图论问题，可以往欧拉定理（<span class=\"math inline\">\\(v-e+f=2\\)</span>），计算几何考虑，</p></li>\n<li><p>怎么在保证这一点的前提下求 mst 呢？答案是丢到状态里。</p>\n<p>找一个最靠左的点往左边引一条射线并标记沿路经过的点。令 <span class=\"math inline\">\\((x, y, 0/1)\\)</span> 表示走到 <span class=\"math inline\">\\((x, y)\\)</span>，经过关键点偶数次 / 奇数次。边权啥的也没什么好说的，点权前移即可。</p></li>\n<li><p>询问的转化反而不太好想，其实就是问 <span class=\"math inline\">\\((x,y,0)\\)</span> 到 <span class=\"math inline\">\\((x,y,1)\\)</span> 的瓶颈路。</p>\n<p>巧得有些不太自然，然而并没找到合理的解释。</p></li>\n<li><p>询问建个 Kruskal 重构树找 LCA 即可，复杂度 <span class=\"math inline\">\\(O(nm\\log nm)\\)</span>。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int dir[][2] = &#123;&#123; -1, 0 &#125;, &#123; 1, 0 &#125;, &#123; 0, -1 &#125;, &#123; 0, 1 &#125;&#125;;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m, q;\n    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;\n    int cnt = 2 * n * m;\n    std::vector&lt;int&gt; W(1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(2 * n * m + 1);\n    auto fun = [&amp;](int i, int j, int k) &#123;\n        return k * n * m + (i - 1) * m + j;\n    &#125;;\n    &#123;\n        int px = 0, py = m + 1;\n        std::vector&lt;std::vector&lt;char&gt; &gt; a(n + 1, std::vector&lt;char&gt; (m + 1));\n        for (int i = 1; i &lt;= n; ++i)\n            for (int j = 1; j &lt;= m; ++j) &#123;\n                std::cin &gt;&gt; a[i][j];\n                if (a[i][j] == &#39;#&#39; &amp;&amp; j &lt; py)\n                    px = i, py = j;\n            &#125;\n        std::vector&lt;std::vector&lt;int&gt; &gt; w(n + 1, std::vector&lt;int&gt; (m + 1, 0x3f3f3f3f));\n        &#123;\n            std::queue&lt;std::pair&lt;int, int&gt; &gt; q;\n            for (int i = 1; i &lt;= n; ++i)\n                for (int j = 1; j &lt;= m; ++j)\n                    if (a[i][j] == &#39;v&#39;)\n                        q.emplace(i, j), w[i][j] = 0;\n            for (; !q.empty(); ) &#123;\n                auto [x, y] = q.front();\n                q.pop();\n                for (auto [fx, fy] : dir) &#123;\n                    int nx = x + fx, ny = y + fy;\n                    if (nx &gt;= 1 &amp;&amp; nx &lt;= n &amp;&amp; ny &gt;= 1 &amp;&amp; ny &lt;= m &amp;&amp; w[nx][ny] == 0x3f3f3f3f) &#123;\n                        w[nx][ny] = w[x][y] + 1;\n                        q.emplace(nx, ny);\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        struct edge &#123; int u, v, w; &#125;;\n        std::vector&lt;edge&gt; e;\n        for (int i = 1; i &lt;= n; ++i)\n            for (int j = 1; j &lt;= m; ++j)\n                if (a[i][j] != &#39;#&#39;) &#123;\n                    if (j != m &amp;&amp; a[i][j + 1] != &#39;#&#39;) &#123;\n                        e.push_back(&#123; fun(i, j, 0), fun(i, j + 1, 0), std::min(w[i][j], w[i][j + 1]) &#125;);\n                        e.push_back(&#123; fun(i, j, 1), fun(i, j + 1, 1), std::min(w[i][j], w[i][j + 1]) &#125;);\n                    &#125;\n                    if (i != n &amp;&amp; a[i + 1][j] != &#39;#&#39;) &#123;\n                        if (i + 1 == px &amp;&amp; j &lt;= py) &#123;\n                            e.push_back(&#123; fun(i, j, 0), fun(i + 1, j, 1), std::min(w[i][j], w[i + 1][j]) &#125;);\n                            e.push_back(&#123; fun(i, j, 1), fun(i + 1, j, 0), std::min(w[i][j], w[i + 1][j]) &#125;);\n                        &#125;\n                        else &#123;\n                            e.push_back(&#123; fun(i, j, 0), fun(i + 1, j, 0), std::min(w[i][j], w[i + 1][j]) &#125;);\n                            e.push_back(&#123; fun(i, j, 1), fun(i + 1, j, 1), std::min(w[i][j], w[i + 1][j]) &#125;);\n                        &#125;\n                    &#125;\n                &#125;\n        std::sort(e.begin(), e.end(), [&amp;](edge &amp;x, edge &amp;y) &#123; return x.w &gt; y.w; &#125;);\n        std::vector&lt;int&gt; f(2 * n * m + 1);\n        std::iota(f.begin() + 1, f.end(), 1);\n        std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;\n            return x == f[x] ? x : f[x] = find(f[x]);\n        &#125;;\n        for (auto [x, y, w] : e)\n            if (find(x) != find(y)) &#123;\n                f.push_back(++cnt);\n                W.push_back(w), g.emplace_back();\n                g[cnt].push_back(find(x)), g[cnt].push_back(find(y));\n                f[find(x)] = f[find(y)] = cnt;\n            &#125;\n    &#125;\n    std::vector&lt;int&gt; fa(cnt + 1), siz(cnt + 1), dep(cnt + 1), son(cnt + 1), top(cnt + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        siz[x] = 1;\n        for (auto i : g[x]) &#123;\n            dep[i] = dep[x] + 1;\n            DFS(i), fa[i] = x;\n            siz[x] += siz[i];\n            if (siz[i] &gt; siz[son[x]])\n                son[x] = i;\n        &#125;\n        return;\n    &#125;;\n    dep[1] = 1, DFS(cnt);\n    DFS = [&amp;](int x) &#123;\n        if (son[x])\n            top[son[x]] = top[x], DFS(son[x]);\n        for (auto i : g[x])\n            if (i != son[x])\n                top[i] = i, DFS(i);\n        return;\n    &#125;;\n    top[cnt] = cnt, DFS(cnt);\n    auto ask = [&amp;](int x, int y) &#123;\n        for (; top[x] != top[y]; x = fa[top[x]])\n            if (dep[top[x]] &lt; dep[top[y]])\n                std::swap(x, y);\n        return dep[x] &lt; dep[y] ? x : y;\n    &#125;;\n    for (int x, y; q--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        std::cout &lt;&lt; W[ask(fun(x, y, 0), fun(x, y, 1)) - 2 * n * m] &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"e---turtle-and-intersected-segments\">E - Turtle and Intersected Segments</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1981E\" class=\"uri\">https://www.luogu.com.cn/problem/CF1981E</a></p>\n<ul>\n<li><p>考虑绝对值的几何意义，很容易发现有的边注定是无效的：</p>\n<figure>\n<img src=\"image.png\" alt=\"如图中三条线段形成一个环，权值如图，排除掉权值最大的边，发现只会连权值相邻的边\" /><figcaption>如图中三条线段形成一个环，权值如图，排除掉权值最大的边，发现只会连权值相邻的边</figcaption>\n</figure></li>\n<li>换句话说，对于数轴上的这个点，仅需把覆盖之的所有<em>线段序列</em>按 <span class=\"math inline\">\\(a\\)</span> 排序，连接相邻者即可。怎么更快地实现这个过程呢？</li>\n<li><p>发现只需要在这个<em>线段序列</em>变化的时候连新的边，故用 multiset 维护这个序列，扫一遍，在加入新线段时连接它和前驱后继即可（结合前文论述发现删除的时候不用管）。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n;\n        std::cin &gt;&gt; n;\n        struct node &#123; int l, r, v; &#125;;\n        struct edge &#123; int u, v, w; &#125;;\n        std::vector&lt;edge&gt; e;\n        std::vector&lt;node&gt; a(n + 1);\n        for (int i = 1; i &lt;= n; ++i)\n            std::cin &gt;&gt; a[i].l &gt;&gt; a[i].r &gt;&gt; a[i].v;\n        std::sort(a.begin() + 1, a.end(), [&amp;](node &amp;x, node &amp;y) &#123; return x.l &lt; y.l; &#125;);\n        std::set&lt;std::tuple&lt;int, int, int&gt; &gt; t;\n        std::set&lt;std::pair&lt;int, int&gt; &gt; now;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            for (; !t.empty();) &#123;\n                auto [r, v, id] = *t.begin();\n                if (r &gt;= a[i].l)\n                    break;\n                now.erase(std::make_pair(v, id));\n                t.erase(t.begin());\n            &#125;\n            auto p = now.lower_bound(std::make_pair(a[i].v, i));\n            if (p != now.end())\n                e.push_back(&#123; i, p-&gt;second, p-&gt;first - a[i].v &#125;);\n            if (p != now.begin()) &#123;\n                --p;\n                e.push_back(&#123; i, p-&gt;second, a[i].v - p-&gt;first &#125;);\n            &#125;\n            t.emplace(a[i].r, a[i].v, i), now.emplace(a[i].v, i);\n        &#125;\n        std::sort(e.begin(), e.end(), [&amp;](edge &amp;x, edge &amp;y) &#123; return x.w &lt; y.w; &#125;);\n        auto res = 0ll;\n        std::vector&lt;int&gt; f(n + 1);\n        std::iota(f.begin() + 1, f.end(), 1);\n        std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;\n            return x == f[x] ? x : f[x] = find(f[x]);\n        &#125;;\n        int cntm = 0;\n        for (auto [u, v, w] : e)\n            if (find(u) != find(v)) &#123;\n                f[find(u)] = find(v);\n                res += w, ++cntm;\n            &#125;\n        if (cntm == n - 1)\n            std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n        else\n            std::cout &lt;&lt; -1 &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"f---digital-village-extreme-version\">F - Digital Village (Extreme Version)</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF2021E3\" class=\"uri\">https://www.luogu.com.cn/problem/CF2021E3</a></p>\n<ul>\n<li>为啥会想到 DP（。）前面不都是神秘建图题吗（。）</li>\n<li><p>会发现待求即为重构树上 LCA 的权值，但题设中的 Key 是设置了服务器的结点，二者不匹配。如果直接设 <span class=\"math inline\">\\(f_{x,j}\\)</span> 表示 <span class=\"math inline\">\\(x\\)</span> 子树内设了 <span class=\"math inline\">\\(j\\)</span> 个服务器，感觉不太可行。</p>\n<p>当然也可能是因为我没做过重构树上的 DP。Whatever.</p></li>\n<li><p>实际上需要结合重构树的性质考虑。发现一个子树内部不能消化，当且仅当</p></li>\n</ul>\n",
            "tags": [
                "最小生成树",
                "Kruskal 重构树"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20251010/",
            "url": "https://xsc062.netlify.app/20251010/",
            "title": "学习笔记：树状数组",
            "date_published": "2025-10-10T00:12:01.000Z",
            "content_html": "<p>我有一个朋友今天才会树状数组（存疑）</p>\n<span id=\"more\"></span>\n<p>因为到了今天还是不会</p>\n<hr />\n<h2 id=\"单点修改区间查询\">单点修改，区间查询</h2>\n<ul>\n<li><p>树状数组本身是一个多叉树结构。每个点 <span class=\"math inline\">\\(i\\)</span> 上保存 <span class=\"math inline\">\\([i-\\text{lowbit}(i)+1,i]\\)</span> 的和，并指向若干个更小的子区间（彼此不重，且拼起来是自身）</p>\n<figure>\n<img src=\"image-1.png\" alt=\"图源 OI Wiki\" /><figcaption>图源 OI Wiki</figcaption>\n</figure></li>\n<li>修改 <span class=\"math inline\">\\(x\\)</span>：从包含 <span class=\"math inline\">\\(x\\)</span> 的最低点（id 为 <span class=\"math inline\">\\(x\\)</span> 且右端点为 <span class=\"math inline\">\\(x\\)</span>）一直向上修改包含 <span class=\"math inline\">\\(x\\)</span> 的区间。</li>\n<li><p>查询 <span class=\"math inline\">\\([1, x]\\)</span>：从右端点为 <span class=\"math inline\">\\(x\\)</span> 的区间（id 为 <span class=\"math inline\">\\(x\\)</span>）出发，不断找到前方紧邻的区间（<span class=\"math inline\">\\(id\\)</span> 差为 lowbit），累加进答案。</p></li>\n</ul>\n<hr />\n<h2 id=\"区间修改单点查询\">区间修改，单点查询</h2>\n<ul>\n<li>运用序列问题上的技巧，转化为差分数组上的单点修改、前缀查询。</li>\n<li>事实上除了基本结构以外的内容，树状数组本身并没有参与，只需当作<strong>一个输入单点修改，输出前缀和的黑盒</strong>即可。</li>\n</ul>\n<hr />\n<h2 id=\"区间修改区间查询\">区间修改，区间查询</h2>\n<ul>\n<li><p>考虑沿用差分的方法实现区间修改。考虑数学推导表达区间前缀和。</p>\n<p>已知 <span class=\"math inline\">\\(d_i=a_i-a_{i-1}\\)</span>，则：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\n\\sum\\limits_{i=1}^x a_i=&amp;\\sum\\limits_{i=1}^x\\sum_{j=1}^i d_j\\\\\n=&amp;\\sum\\limits_{i=1}^x d_i\\cdot (x-i+1)\\\\\n=&amp;(x+1)\\cdot \\left(\\sum\\limits_{i=1}^x d_i\\right) - \\left(\\sum\\limits_{i=1}^x i\\cdot d_i\\right)\n\\end{aligned}\n\\]</span></p></li>\n<li>故只需要在黑盒中维护 <span class=\"math inline\">\\(d_i\\)</span> 和 <span class=\"math inline\">\\(i\\cdot d_i\\)</span> 的单点修改即可。</li>\n<li><p>在实现时感到违和：对 <span class=\"math inline\">\\([l, r]\\)</span> 做区间修改时，对于 <span class=\"math inline\">\\(l\\)</span> 处的 <span class=\"math inline\">\\(i\\cdot d_i\\)</span> 作出了 <span class=\"math inline\">\\(l\\cdot \\Delta\\)</span> 的修改，为何在 <span class=\"math inline\">\\(r+1\\)</span> 处作 <span class=\"math inline\">\\((r + 1)\\cdot \\Delta\\)</span> 的修改（而非也是 <span class=\"math inline\">\\(l\\cdot \\Delta\\)</span>？）</p>\n<p>事实上，对于 <span class=\"math inline\">\\(i\\cdot d_i\\)</span> 的修改是对 <span class=\"math inline\">\\(d_i\\)</span> 修改的字面反映，这个量本身并没有具体的含义。</p>\n<p>感觉有点唐唐的，也就只有我会有这种疑惑了……</p></li>\n</ul>\n<hr />\n<h3 id=\"excercise\">Excercise</h3>\n<ul>\n<li><p>维护 <span class=\"math inline\">\\(a_i\\)</span> 的区间加、<span class=\"math inline\">\\(a_i\\)</span> 的区间和查询、<span class=\"math inline\">\\(i\\cdot a_i\\)</span> 的区间和查询。</p>\n<p>令 <span class=\"math inline\">\\(d_i=a_i-a_{i-1}\\)</span>，考虑变形：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\n\\sum\\limits_{i=1}^x i\\cdot a_i=&amp;\\sum\\limits_{i=1}^xi\\cdot \\sum_{j=1}^i d_j\\\\\n=&amp;\\sum\\limits_{i=1}^x d_i\\cdot \\left(i+(i+1)+\\cdots +x\\right)\\\\\n=&amp;\\sum\\limits_{i=1}^x d_i\\cdot \\dfrac {(x+i)\\cdot (x-i+1)}2\\\\\n=&amp;\\sum\\limits_{i=1}^x d_i\\cdot \\dfrac {x^2+x-i^2+i}2\\\\\n=&amp;\\dfrac{(x^2+x)\\cdot \\left(\\sum\\limits_{i=1}^x d_i\\right) + \\left(\\sum\\limits_{i=1}^x i\\cdot d_i\\right) - \\left(\\sum\\limits_{i=1}^x i^2\\cdot d_i\\right)}2\n\\end{aligned}\n\\]</span></p></li>\n<li><p>故只需要在黑盒中维护 <span class=\"math inline\">\\(d_i\\)</span>、<span class=\"math inline\">\\(i\\cdot d_i\\)</span> 和 <span class=\"math inline\">\\(i^2\\cdot d_i\\)</span> 的单点修改即可。</p>\n<p>见 <a href=\"/20251007/#c.-相互抵消\">相互抵消</a>。</p></li>\n</ul>\n<hr />\n<h3 id=\"ex.-北校门外的回忆\">Ex. 北校门外的回忆</h3>\n<p><a href=\"https://loj.ac/p/510\" class=\"uri\">https://loj.ac/p/510</a></p>\n<blockquote>\n<p>定义 <span class=\"math inline\">\\(\\text{lowbit}_K(x)\\)</span> 为 <span class=\"math inline\">\\(x\\)</span> 在 <span class=\"math inline\">\\(K\\)</span> 进制下最低非零位的值。有一个异或和树状数组，把原本代码中的 <span class=\"math inline\">\\(\\text{lowbit}_2(x)\\)</span> 全部替换为 <span class=\"math inline\">\\(\\text{lowbit}_K(x)\\)</span>，得到一个正确性和复杂度均错误的『树状数组』，现在给定若干次 <code>add</code> 和 <code>ask</code> 操作，你需要输出错误的代码运行的结果。</p>\n<p><span class=\"math inline\">\\(m\\le 2\\times 10^5\\)</span>。</p>\n</blockquote>\n<ul>\n<li>需要意识到并不是真的要用树状数组模拟这个操作，一边转化一边要想办法把这个错误代码用正常 DS 的操作表述出来。</li>\n<li><code>add</code> 的本质是对于非零最低位乘二并进位。手玩可以发现，有的时候『非零最低位』的位置是不变的，有的时候『非零最低位』变成 <span class=\"math inline\">\\(0\\)</span> 了，就会前移。</li>\n<li><p>这显然是个 <span class=\"math inline\">\\(x\\to 2x\\bmod K\\)</span> 的内向基环树森林，且当存在自环 <span class=\"math inline\">\\(0\\)</span> 时，一个树中的最大跳跃次数为 <span class=\"math inline\">\\(\\log_2K\\)</span>。</p>\n<figure>\n<img src=\"image-2.png\" alt=\"mobai Grisses\" /><figcaption>mobai Grisses</figcaption>\n</figure>\n<p>故这个时候（即 <span class=\"math inline\">\\(x\\)</span> 包含了『<span class=\"math inline\">\\(K\\)</span> 除了 <span class=\"math inline\">\\(2\\)</span> 之外的因子』时 ）暴力跳即可。对于每一位都这么跳是可以接受的。</p></li>\n<li><p><span class=\"math inline\">\\(0\\)</span> 不在树中，最终会有一个循环节。不妨把经过的所有点拉出来成为一条链。</p>\n<p>这个时候可以停下来想一想题目给的两个操作是在做什么。显然每个叶子会引导一条无限长的链，则 <code>add</code> 就是给这个链做了一个后缀加（<span class=\"math inline\">\\(N\\)</span> 的限制是没影响的），<code>ask</code> 则是问了 log 个点值。</p>\n<p>则如果这个链真的可以被处理出来，只需要 bit 维护差分即可。</p></li>\n<li><p>考虑倍增预处理 <span class=\"math inline\">\\(f(i,j)\\)</span> 表示 <span class=\"math inline\">\\(i\\)</span> 走了 <span class=\"math inline\">\\(2^j\\)</span> 步后到的点，模拟跳 <span class=\"math inline\">\\(0\\)</span>、倍增跳循环节即可。</p></li>\n</ul>\n<hr />\n<h2 id=\"bit-上倍增\">BIT 上倍增</h2>\n<p>更偏数据结构技巧了，也重新回到结构上面。</p>\n<p>对标线段树上二分，缺陷在于能维护的数据限制很大，优势在于常数很小。在出题人刻意只放树状数组过，或者<strong>树套树</strong>外层为树状数组的时候用处比较明显。</p>\n<hr />\n<h3 id=\"冰火战士\">冰火战士</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P6619\" class=\"uri\">https://www.luogu.com.cn/problem/P6619</a></p>\n<blockquote>\n<p>给定初始为空的二元组数组 <span class=\"math inline\">\\(A, B\\)</span>。对于阈值 <span class=\"math inline\">\\(k\\)</span>，令 <span class=\"math inline\">\\(s_A\\)</span> 表示 <span class=\"math inline\">\\(A\\)</span> 中关键字一 <span class=\"math inline\">\\(\\le k\\)</span> 的元素关键字二之和，<span class=\"math inline\">\\(s_B\\)</span> 表示 <span class=\"math inline\">\\(B\\)</span> 中关键字一 <span class=\"math inline\">\\(\\ge k\\)</span> 的元素关键字二之和。</p>\n<p>维护若干次 <span class=\"math inline\">\\(A,B\\)</span> 的加点、删点操作，每次操作后输出：</p>\n<ul>\n<li>自由选取 <span class=\"math inline\">\\(k\\)</span>，求 <span class=\"math inline\">\\(\\min\\{s_A,s_B\\}\\)</span> 的最大值。</li>\n</ul>\n<p><span class=\"math inline\">\\(m\\le 2\\times 10^6\\)</span>，<span class=\"math inline\">\\(V\\le 10^9\\)</span>。</p>\n</blockquote>\n<ul>\n<li>不妨考虑固定状态下的询问。容易想到将 <span class=\"math inline\">\\(A,B\\)</span> 按关键字一<strong>升序排序</strong>。随着 <span class=\"math inline\">\\(k\\)</span> 的增大，<span class=\"math inline\">\\(s_A\\)</span> 是 <span class=\"math inline\">\\(A\\)</span> 关键字二的前缀和，<span class=\"math inline\">\\(s_B\\)</span> 是 <span class=\"math inline\">\\(B\\)</span> 关键字二的后缀和。</li>\n<li><p>我并不会三分，但题解说因为有平台所以三分做不了。</p>\n<p>但由于最高点同时是交点，可以二分找到最值点。离散化元素后维护此处的前缀和即可。</p></li>\n<li>容易想到线段树上二分，然而常数太大难以通过。</li>\n<li><p>如果改用树状数组呢？树状数组有办法进行类似线段树上二分的操作吗？</p>\n<p>事实上，bit 的结构更适合倍增。其出发点和线段树上二分是相同的，在于规避重复询问。</p>\n<p>假设当前在一个合法位置 <span class=\"math inline\">\\(p\\)</span>，已经累加到 <span class=\"math inline\">\\(s\\)</span>，要验证 <span class=\"math inline\">\\(p+2^k\\)</span>（<span class=\"math inline\">\\(\\text{lowbit}(p+2^k)=2^k\\)</span>）是否仍然合法，仅需 check <span class=\"math inline\">\\(s+c_{p+2^k}\\)</span> 是否合法（结合树状数组结构想一想）。</p></li>\n</ul>\n<details>\n<p>其实 Peace 是有点难判的…… 我写了个结构题维护了数量用来判断。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int m;\n    std::cin &gt;&gt; m;\n    struct query &#123; int op, k, x, y; &#125;;\n    std::vector&lt;query&gt; a(m + 1);\n    std::vector&lt;int&gt; l(1);\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        std::cin &gt;&gt; a[i].op &gt;&gt; a[i].k;\n        if (a[i].op == 1) &#123;\n            std::cin &gt;&gt; a[i].x &gt;&gt; a[i].y;\n            l.push_back(a[i].x);\n        &#125;\n        else &#123;\n            int k = a[i].k;\n            a[i].op = -1;\n            a[i].k = a[k].k, a[i].x = a[k].x, a[i].y = a[k].y;\n        &#125;\n    &#125;\n    std::sort(l.begin() + 1, l.end());\n    l.erase(std::unique(l.begin() + 1, l.end()), l.end());\n    int n = (int)l.size();\n    std::vector&lt;int&gt; cnt(2);\n    std::vector&lt;long long&gt; sum(2);\n    struct node &#123;\n        int c;\n        long long v;\n        node(void): c(0), v(0ll) &#123;&#125;\n        node(int c1, long long v1): c(c1), v(v1) &#123;&#125;\n        node operator+ (const node &amp;q) const &#123;\n            return node(c + q.c, v + q.v);\n        &#125;\n        node operator- (const node &amp;q) const &#123;\n            return node(c - q.c, v - q.v);\n        &#125;\n        node&amp; operator+= (const node q) &#123;\n            return *this = *this + q;\n        &#125;\n        node &amp;operator-= (const node &amp;q) &#123;\n            return *this = *this - q;\n        &#125;\n    &#125;;\n    std::vector&lt;std::vector&lt;node&gt; &gt; bit(2, std::vector&lt;node&gt; (n + 1)), s(2, std::vector&lt;node&gt; (n + 1));\n    auto lowbit = [&amp;](int x) &#123; return x &amp; -x; &#125;;\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        a[i].x = std::lower_bound(l.begin() + 1, l.end(), a[i].x) - l.begin() + a[i].k;\n        cnt[a[i].k] += a[i].op, sum[a[i].k] += a[i].op * a[i].y;\n        s[a[i].k][a[i].x] += node(a[i].op, a[i].op * a[i].y);\n        for (int j = a[i].x; j &lt;= n; j += lowbit(j))\n            bit[a[i].k][j] += node(a[i].op, a[i].op * a[i].y);\n        if (std::min(cnt[0], cnt[1]) == 0)\n            std::cout &lt;&lt; &quot;Peace\\n&quot;;\n        else &#123;\n            int p = 0;\n            node s0(0, 0ll), s1(cnt[1], sum[1]);\n            for (int i = 20; ~i; --i)\n                if (p + (1 &lt;&lt; i) &lt;= n &amp;&amp; (s0 + bit[0][p + (1 &lt;&lt; i)]).v &lt;= (s1 - bit[1][p + (1 &lt;&lt; i)]).v)\n                    p += (1 &lt;&lt; i), s0 += bit[0][p], s1 -= bit[1][p];\n            if (p + 1 &lt;= n &amp;&amp; s1.c != s[1][p + 1].c &amp;&amp; (s1 - s[1][p + 1]).v &gt;= s0.v) &#123;\n                s1 -= s[1][p + 1], s0 = node(cnt[1], sum[1]), p = 0;\n                for (int i = 20; ~i; --i)\n                    if (p + (1 &lt;&lt; i) &lt;= n &amp;&amp; (s0 - bit[1][p + (1 &lt;&lt; i)]).v &gt;= s1.v)\n                        p += (1 &lt;&lt; i), s0 -= bit[1][p];\n                std::cout &lt;&lt; l[p] &lt;&lt; &#39; &#39; &lt;&lt; 2 * s1.v &lt;&lt; &#39;\\n&#39;;\n            &#125;\n            else if (s0.c)\n                std::cout &lt;&lt; l[p] &lt;&lt; &#39; &#39; &lt;&lt; 2 * s0.v &lt;&lt; &#39;\\n&#39;;\n            else\n                std::cout &lt;&lt; &quot;Peace\\n&quot;;\n        &#125;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"sails-船帆\">sails 船帆</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P4647\" class=\"uri\">https://www.luogu.com.cn/problem/P4647</a></p>\n<ul>\n<li><p>需要意识到<strong>帆的顺序对答案没有影响，同一行帆的个数对答案有影响</strong>。</p>\n<p>从这一点出发会有一个比较显然的贪心：把柱状图斜过来，把柱子按 <span class=\"math inline\">\\(h\\)</span> 从小到大<strong>排序</strong>，问题变为对于第 <span class=\"math inline\">\\(i\\)</span> 次操作，选 <span class=\"math inline\">\\(1\\sim h_i\\)</span> 里最矮的几列使其高度 +1。</p>\n<p>其实会有一些其他的贪心方法，比如我一开始想的是不排序，在 <span class=\"math inline\">\\(1\\sim h_i\\)</span> 内，优先使最矮的高度 +1，高度相同的使编号更大的柱子高度 +1。这个的正确性也比较好证明，但是太复杂了，没什么好的优化。<strong>把贪心策略中的偏序关系提前到一次排序</strong>就会简单很多。</p></li>\n<li><p>现在需要找到最矮的这几列。<del>我会文艺平衡树</del></p>\n<p>考虑更加天才的做法。如果我们需要用 bit，线段树这样的结构来维护操作，就会有一些问题： 为了快速修改，需要保证修改的元素是连续的。简单的方法是让元素有序地在 ds 中排列。但修改操作本身会破坏这样的偏序关系。</p></li>\n<li><p>不妨假设元素降序排列（和后方的 0 衔接），那么需要把 <span class=\"math inline\">\\([h-k+1,h]\\)</span> 这段元素 +1，但这会造成部分元素的前移，考虑前移的过程到底发生了什么。</p>\n<p>考虑这样的场景：</p>\n<p><img src=\"image.png\" /></p>\n<p><strong>由于 delta 为 1，至多只会有一段数发生这样的前移。</strong>先 ask 一下 <span class=\"math inline\">\\(h-k+1\\)</span> 处的值，假设这一段的左右端点为 <span class=\"math inline\">\\([l,r]\\)</span>，只需要修改 <span class=\"math inline\">\\([l,l+(r-(h-k+1))]\\)</span> 和 <span class=\"math inline\">\\([r+1,h]\\)</span> 两段区间即可。</p></li>\n<li><p><span class=\"math inline\">\\([l,r]\\)</span> 是可以通过 bit 上倍增求出的。复杂度 <span class=\"math inline\">\\(O(n\\log n)\\)</span>。</p></li>\n</ul>\n<hr />\n<h3 id=\"insert\">Insert</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_abc392_f\" class=\"uri\">https://www.luogu.com.cn/problem/AT_abc392_f</a></p>\n<ul>\n<li>维护每个数的位置，相当于给值在 <span class=\"math inline\">\\([P_i,i-1]\\)</span> 的元素做区间 +1，显然右端点是单增的，那么就转化为上一题。</li>\n</ul>\n<hr />\n<h3 id=\"买宝石\">买宝石</h3>\n<p><a href=\"https://www.becoder.com.cn/contest/6620/problem/4\" class=\"uri\">https://www.becoder.com.cn/contest/6620/problem/4</a></p>\n<p>见 <a href=\"/20251007-1/#买宝石\">树套树</a>。</p>\n",
            "tags": [
                "树状数组",
                "倍增"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20251007-1/",
            "url": "https://xsc062.netlify.app/20251007-1/",
            "title": "学习笔记：树套树",
            "date_published": "2025-10-07T08:29:52.000Z",
            "content_html": "<p>第一次学树套树时，并没有什么特别的感觉，因为属于我的离线分治，我早已遇见</p>\n<span id=\"more\"></span>\n<p>并非第一次学</p>\n<hr />\n<h2 id=\"线段树\">线段树</h2>\n<ul>\n<li>考虑线段树的本质，即给定序列，能够返回关键字在 <span class=\"math inline\">\\([l,r]\\)</span> 内的可加信息之和</li>\n<li>仅需要保证信息是<strong>可加</strong>的（如众数，mex 等显然不在此列）</li>\n</ul>\n<hr />\n<h2 id=\"树状数组\">树状数组</h2>\n<ul>\n<li>给定序列，能够返回任意关键字处的前缀和 / 后缀和，需要保证信息是<strong>可加</strong>的</li>\n<li>如果要求任意区间内关键字的信息之和，会用到差分，此时还需额外保证信息是<strong>可减</strong>的（如 min / max 显然不在此列）</li>\n</ul>\n<hr />\n<h2 id=\"主席树-可持久化线段树\">主席树 / 可持久化线段树</h2>\n<p>之前有人在争论『主席树』是否等价于『可持久化线段树』，其实从当前 OI 环境的语境下我觉得是等价的</p>\n<ul>\n<li><p>给定序列，存在关键字 A 和关键字 B，能够求出 <span class=\"math inline\">\\(([0, A&#39;], [B_1, B_2])\\)</span> 这个矩形的信息和（这里的矩形可能是 DAG 状的）</p>\n<p>也就是说主席树本身存的是关于 A 的信息前缀和</p></li>\n<li><p>要求 A 只能来源于先前的 A（即 A 具有<strong>单调性</strong>），且底层信息的 delta 为 1</p>\n<p>需要发现这个条件是相当苛刻的，所以这里的 A 通常以时间 / 版本 / DAG 的形式出现</p></li>\n<li><p>如果信息具有<strong>可减</strong>性，对于 <span class=\"math inline\">\\(A_2\\)</span> 和其某个祖先 <span class=\"math inline\">\\(A_1\\)</span>，能够求出 <span class=\"math inline\">\\(([A_1,A_2],[B_1,B_2])\\)</span> 这个矩形的信息和。</p></li>\n</ul>\n<hr />\n<ul>\n<li>考虑为什么主席树不能解决三维偏序</li>\n<li>现在已经对关键字 C 排完序了，我们需要求出 <span class=\"math inline\">\\(([0, A], [0, B])\\)</span> 这个矩形的信息和</li>\n<li>发现 A 是不具备<strong>单调性</strong>的，有没有什么 DS 能够不要求 A 的单调性呢？</li>\n</ul>\n<hr />\n<h2 id=\"树状数组套线段树\">树状数组套线段树</h2>\n<ul>\n<li>用 <span class=\"math inline\">\\(n\\)</span> 棵线段树维护 B 的偏序关系，用类主席树的方式来排列这些树</li>\n<li><p>发现一次修改需要改一段后缀</p>\n<p>这一点我们前面说过了，主席树本身存储的是 A 维的前缀和。</p></li>\n<li>所以直接解决这个问题：维护信息的差分。这样就可以通过询问前缀得到原始信息</li>\n<li><p>这个结构和树状数组是很吻合的，考虑在树状数组的每个点上维护动态开点线段树</p>\n<p>这样就可以只用修改 log 个线段树</p></li>\n<li><p>考虑怎么询问</p>\n<p>我最初的想法是，做一个线段树合并，利用 DS 本身的树形结构可以有一个 dsu on tree 的复杂度（即 <span class=\"math inline\">\\(O(nq\\log^2 n)\\)</span>），但显然这个太糖了</p>\n<p>正常的做法是，注意到每个点的权值线段树结构相同，所以在 log 个线段树上同时维护，当作包含长度 log 的数组的结构体即可</p></li>\n<li>同树状数组，要求信息有<strong>可减性</strong></li>\n<li><p>但由于外层的 DS 本质上舍弃了主席树 DAG 的结构</p>\n<p>导致不能直接简单用于树上问题，而是需要在 <strong>DFS 序</strong>上作文章</p></li>\n<li><p>实际上常数很大，超过 <span class=\"math inline\">\\(10^5\\)</span> 就不太能跑得动了</p></li>\n</ul>\n<hr />\n<h3 id=\"dynamic-rankings-k大数查询\">Dynamic Rankings / K大数查询</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P2617\" class=\"uri\">https://www.luogu.com.cn/problem/P2617</a> / <a href=\"https://www.luogu.com.cn/problem/P3332\" class=\"uri\">https://www.luogu.com.cn/problem/P3332</a></p>\n<ul>\n<li>全局第 <span class=\"math inline\">\\(k\\)</span> 大就是普通的权值线段树上二分，抑或平衡树，抑或 01-Trie（三者等价）</li>\n<li>这里的权值线段树上二分，其实是矩形第二维限制的变体</li>\n<li>发现这里只需要简单地维护元素个数，是具有可减性的。</li>\n</ul>\n<hr />\n<h3 id=\"三维偏序陌上花开\">三维偏序（陌上花开）</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P3810\" class=\"uri\">https://www.luogu.com.cn/problem/P3810</a></p>\n<ul>\n<li>树状数组套权值线段树即可</li>\n</ul>\n<hr />\n<h3 id=\"二逼平衡树\">二逼平衡树</h3>\n<p><a href=\"https://loj.ac/p/106\" class=\"uri\">https://loj.ac/p/106</a></p>\n<ul>\n<li>和 k 大数差不多，都是权值线段树那些东西</li>\n</ul>\n<hr />\n<h3 id=\"网络管理\">网络管理</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P4175\" class=\"uri\">https://www.luogu.com.cn/problem/P4175</a></p>\n<blockquote>\n<p>维护带修树上简单路径第 <span class=\"math inline\">\\(k\\)</span> 大。</p>\n</blockquote>\n<ul>\n<li>做树上差分即可转化为序列第 <span class=\"math inline\">\\(k\\)</span> 大。</li>\n</ul>\n<hr />\n<h3 id=\"买宝石\">买宝石</h3>\n<p><a href=\"https://www.becoder.com.cn/contest/6620/problem/4\" class=\"uri\">https://www.becoder.com.cn/contest/6620/problem/4</a></p>\n<blockquote>\n<p>给定根为 <span class=\"math inline\">\\(1\\)</span> 的树，每个点 <span class=\"math inline\">\\(u\\)</span> 上有 <span class=\"math inline\">\\(k_u\\)</span> 个价钱为 <span class=\"math inline\">\\(w_u\\)</span> 的物品，可以在时间 <span class=\"math inline\">\\(t_u\\)</span> 及之后获得</p>\n<p>给定 <span class=\"math inline\">\\(Q\\)</span> 次询问，从问 <span class=\"math inline\">\\(x\\)</span> 出发到根的路径上所有在时刻 <span class=\"math inline\">\\(T\\)</span> 可以获得的物品全部拿出来排成一列，拥有 <span class=\"math inline\">\\(K\\)</span> 金钱时，按照价值从小到大购买，买到的最后一个物品价值。</p>\n<p><span class=\"math inline\">\\(n\\le 10^5\\)</span>，价钱：<span class=\"math inline\">\\(10^{15}\\)</span>，时间：<span class=\"math inline\">\\(10^5\\)</span>，个数：<span class=\"math inline\">\\(10^5\\)</span>。</p>\n</blockquote>\n<ul>\n<li>信息自带一个有序的时间偏序维 <span class=\"math inline\">\\(T\\)</span> 且原生有序，所以不能整体二分，必须处理 <span class=\"math inline\">\\(k\\)</span> 偏序维和 <span class=\"math inline\">\\(w\\)</span> 二分维。</li>\n<li></li>\n</ul>\n<hr />\n<ul>\n<li>总的来说，就是维护了两个关键字，或者说一个矩形</li>\n<li>根据在 A，B 维需要做的操作选择，以及需要维护的信息类型，选择相应的数据结构</li>\n</ul>\n<hr />\n<h2 id=\"关于整体二分\">关于整体二分</h2>\n<ul>\n<li>考虑动态区间第 K 大这一类的问题，特征是 A 维『求和』，B 维<strong>二分</strong></li>\n<li>此时可以把对 B 维的二分提到外层一起进行，反过来对 A 维应用数据结构</li>\n<li>考虑到树套树常数过大，所以在能用整体二分的时候不推荐用树套树</li>\n</ul>\n",
            "tags": [
                "树套树"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20251007/",
            "url": "https://xsc062.netlify.app/20251007/",
            "title": "杂题选谈",
            "date_published": "2025-10-07T08:29:43.000Z",
            "content_html": "<p>近期模拟赛</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a.-考试\">A. 考试</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6624/problem/1\" class=\"uri\">https://www.becoder.com.cn/contest/6624/problem/1</a></p>\n<blockquote>\n<p><span class=\"math inline\">\\(m\\)</span> 道题，分数是一个 <span class=\"math inline\">\\(m\\)</span> 的排列（初始未知），做对得满分，做错得 0 分</p>\n<p>给定 <span class=\"math inline\">\\(n\\)</span> 个人对于这 <span class=\"math inline\">\\(m\\)</span> 个题的过题情况矩阵，且第 <span class=\"math inline\">\\(i\\)</span> 个人有一个预期分数 <span class=\"math inline\">\\(x_i\\)</span>。</p>\n<p>求每到题的分数，使得每个人实际得分与期望的分差的绝对值之和最大。输出该排列。</p>\n<p><span class=\"math inline\">\\(n\\le 10,m\\le 10^4\\)</span>。</p>\n</blockquote>\n<ul>\n<li>绝对值是贪心一个很大的阻碍</li>\n<li><p>一个典型的『钦定』型贪心，枚举每个人的绝对值是否取反，就可以得到每个题对应的系数。</p>\n<p>因为『就算错了也不会影响最优解』，所以是对的。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;test.out&quot;, &quot;w&quot;, stdout);\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, m;\n        std::cin &gt;&gt; n &gt;&gt; m;\n        std::vector&lt;int&gt; s(n + 1);\n        for (int i = 1; i &lt;= n; ++i)\n            std::cin &gt;&gt; s[i];\n        std::vector&lt;std::vector&lt;int&gt; &gt; pos(n + 1);\n        for (int i = 1; i &lt;= n; ++i)\n            for (int j = 1; j &lt;= m; ++j) &#123;\n                char t;\n                std::cin &gt;&gt; t;\n                if (t == &#39;1&#39;)\n                    pos[i].push_back(j);\n            &#125;\n        auto res = 0ll;\n        int siz = 1 &lt;&lt; n;\n        std::vector&lt;std::vector&lt;int&gt; &gt; id(2 * n + 1);\n        std::vector&lt;int&gt; cnt(m + 1), ans(m + 1), p(m + 1);\n        for (int i = 0; i &lt; siz; ++i) &#123;\n            std::fill(cnt.begin() + 1, cnt.end(), 0);\n            for (int j = 0; j &lt;= 2 * n; ++j)\n                id[j].clear();\n            for (int j = 1; j &lt;= n; ++j)\n                if ((i &gt;&gt; (j - 1)) &amp; 1)\n                    for (auto k : pos[j])\n                        ++cnt[k];\n                else\n                    for (auto k : pos[j])\n                        --cnt[k];\n            for (int j = 1; j &lt;= m; ++j)\n                id[cnt[j] + n].push_back(j);\n            for (int i = 2 * n, k = m; ~i; --i)\n                for (auto j : id[i])\n                    p[j] = k--;\n            auto now = 0ll;\n            for (int i = 1; i &lt;= n; ++i) &#123;\n                int sum = 0;\n                for (auto j : pos[i])\n                    sum += p[j];\n                now += std::abs(sum - s[i]);\n            &#125;\n            if (now &gt;= res)\n                res = now, ans = p;\n        &#125;\n        // std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n        for (int i = 1; i &lt;= m; ++i)\n            std::cout &lt;&lt; ans[i] &lt;&lt; &#39; &#39;;\n        std::cout &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b.-围棋\">B. 围棋</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6624/problem/2\" class=\"uri\">https://www.becoder.com.cn/contest/6624/problem/2</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(n \\times n\\)</span> 的棋盘，上面有黑棋、白棋和空地，定义白棋的『气』为四个方向空地的数量，若一个白棋四连通块中所有白棋的『气』都为 0，则认为这个白棋四连通块中的所有白棋是『死的』。</p>\n<p>现枚举每个棋子，并将其反转颜色，问『死的』白棋数量。操作是独立的。</p>\n<p>3s，<span class=\"math inline\">\\(n\\le 10^3\\)</span>。</p>\n</blockquote>\n<ul>\n<li>分讨题，需要想清楚。首先需要一次 floodfill 完成染色，记录哪些连通块死了。</li>\n<li><p>若反转黑棋：</p>\n<ul>\n<li><p>若黑棋自己有气，或和黑棋相连的白棋四连通块有气，那么黑棋自己，以及所有和黑棋相连的白棋四连通块都是活的。</p>\n<p>此时需要找到所有和黑棋相连的，且死了的白棋四连通块的大小，答案需要减去之。</p></li>\n</ul></li>\n<li><p>否则，黑棋自身贡献 <span class=\"math inline\">\\(1\\)</span> 的答案。</p></li>\n<li><p>若反转白棋：</p>\n<ul>\n<li>若白棋本身是死的：答案 <span class=\"math inline\">\\(-1\\)</span>。</li>\n<li><p>否则，需要考虑有多少个原本是活的白棋此时与有气的白棋不连通，这种情况发生当且仅当有气的白棋是被反转的白棋自身，或者被反转的白棋是割点。</p>\n<p>很奇妙的一个想法是建立超级源点，向所有空地连边，再建圆方树，这样这个点的所有儿子就是待求。圆方树并不需要显式地建出来。</p></li>\n</ul></li>\n</ul>\n<p>代码：不会</p>\n<hr />\n<h2 id=\"c.-相互抵消\">C. 相互抵消</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6624/problem/3\" class=\"uri\">https://www.becoder.com.cn/contest/6624/problem/3</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(a_{1\\sim n}\\)</span>，维护 <span class=\"math inline\">\\(m\\)</span> 次操作：</p>\n<ol type=\"1\">\n<li>区间加。</li>\n<li>给定 <span class=\"math inline\">\\(l,r\\)</span>，查询 <span class=\"math inline\">\\(\\left(\\sum\\limits_{i=l}^r\\sum\\limits_{j=i}^r ((\\sum_{k=i}^j a_k)^2 + (r-l+2)\\times(j-i)\\times a_i\\times a_j)\\right) \\bmod 998244353\\)</span>。</li>\n</ol>\n<p><span class=\"math inline\">\\(n,m\\le 5\\times 10^5\\)</span>，强制在线。</p>\n</blockquote>\n<ul>\n<li>题目名字是真在降低难度吧，强制在线就排除离线历史和了；猜测询问所求可以化成一个比较简单的东西。</li>\n<li><p>推一下：</p>\n<p>（省略）</p>\n<p><span class=\"math display\">\\[\n=-\\left(\\sum_{i=l}^r i\\cdot a_i\\right)^2 + (1-l)(r+1)\\left(\\sum_{i=l}^r a_i\\right)^2+(l+r)\\left(\\sum_{i=l}^r i\\cdot a_i\\right)\\left(\\sum_{i=l}^r a_i\\right)\n\\]</span></p></li>\n<li>故线段树维护 <span class=\"math inline\">\\(\\sum a_i\\)</span> 和 <span class=\"math inline\">\\(\\sum i\\cdot a_i\\)</span> 即可。</li>\n<li><p><a href=\"/20251010/#excercise\">实际上可以用树状数组维护</a>。</p></li>\n</ul>\n<details>\n<p>喜提最优解，不得不说 bit 的速度优势还是很明显的。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353; \nconst int inv2 = (mod + 1) &gt;&gt; 1;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;offset.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;offset.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;./test/20251008/offset/ex_offset5.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T, n, q;\n    std::cin &gt;&gt; T &gt;&gt; n &gt;&gt; q;\n    std::vector&lt;long long&gt; bit(n + 1), bit1(n + 1), bit2(n + 1);\n    auto lowbit = [&amp;](int x) &#123;\n        return x &amp; -x;\n    &#125;;\n    auto add = [&amp;](long long x, long long v) &#123;\n        auto v1 = x * v % mod, v2 = x * x % mod * v % mod;\n        for (; x &lt;= n; x += lowbit(x)) &#123;\n            (bit[x] += v) %= mod;\n            (bit1[x] += v1) %= mod;\n            (bit2[x] += v2) %= mod;\n        &#125;\n        return;\n    &#125;;\n    auto ask = [&amp;](long long x) &#123;\n        auto res = 0ll, res1 = 0ll, res2 = 0ll;\n        for (int i = x; i; i -= lowbit(i))\n            (res += bit[i]) %= mod, (res1 += bit1[i]) %= mod, (res2 += bit2[i]) %= mod;\n        return std::make_pair(((x + 1) * res + mod - res1) % mod, (x * (x + 1) % mod * res % mod + res1 + mod - res2) * inv2 % mod);\n    &#125;;\n    for (int i = 1, x; i &lt;= n; ++i)\n        std::cin &gt;&gt; x, add(i, x), add(i + 1, mod - x);\n    for (int op; q--; ) &#123;\n        static auto la = 0ll;\n        std::cin &gt;&gt; op;\n        if (op == 1) &#123;\n            int l, r, d;\n            std::cin &gt;&gt; l &gt;&gt; r &gt;&gt; d;\n            if (T == 1)\n                l ^= la, r ^= la, d ^= la;\n            add(l, d), add(r + 1, mod - d);\n        &#125;\n        else &#123;\n            long long l, r;\n            std::cin &gt;&gt; l &gt;&gt; r;\n            if (T == 1)\n                l ^= la, r ^= la;\n            auto t1 = ask(r), t2 = ask(l - 1);\n            auto res1 = t1.first + mod - t2.first, res2 = t1.second + mod - t2.second;\n            la = (mod - res2 * res2 % mod + mod - (l - 1) * (r + 1) % mod * res1 % mod * res1 % mod + (l + r) * res1 % mod * res2 % mod) % mod;\n            std::cout &lt;&lt; la &lt;&lt; &#39;\\n&#39;;\n        &#125;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"a.-happylovelyeveryday\">A. Happy·Lovely·Everyday!</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6639/problem/1\" class=\"uri\">https://www.becoder.com.cn/contest/6639/problem/1</a></p>\n<blockquote>\n<p>给定一个长为 <span class=\"math inline\">\\(n\\)</span> 的 01 序列，可以执行任意次（可以为 <span class=\"math inline\">\\(0\\)</span>）『把相邻两个数合并为其异或值』的操作，问最终能得到的本质不同的序列个数。</p>\n<p><span class=\"math inline\">\\(n\\le 2\\times 10^6\\)</span>。</p>\n</blockquote>\n<ul>\n<li>对于一个最终序列，如果认为它是由某个存活元素『吞并』它左侧的连续死亡元素得到的，会发现最终序列中，此处的前缀异或值就是原序列的前缀异或值。</li>\n<li>经典 trick：前缀和可以唯一对应原数组。所以『最终本质不同序列』会和『包含第 <span class=\"math inline\">\\(n\\)</span> 个元素的，原序列前缀异或和的本质不同子序列』形成双射。</li>\n<li><p>统计包含第 <span class=\"math inline\">\\(n\\)</span> 个元素的，原序列前缀异或和的本质不同子序列即可。复杂度 <span class=\"math inline\">\\(O(n)\\)</span>。</p>\n<details>\n<p><summary>How to 本质不同子序列？</summary></p>\n<p>令 <span class=\"math inline\">\\(f_i\\)</span> 表示 DP 到 <span class=\"math inline\">\\(i\\)</span>，且强制选 <span class=\"math inline\">\\(i\\)</span> 的本质不同子序列数量，记 <span class=\"math inline\">\\(pre_i\\)</span> 为 <span class=\"math inline\">\\(i\\)</span> 的前驱（没有则为 <span class=\"math inline\">\\(0\\)</span>）。令 <span class=\"math inline\">\\(f_0=1\\)</span>，那么：</p>\n<p><span class=\"math display\">\\[\nf_i\\gets \\sum\\limits_{j=pre_i}^{i-1} f_{j}\n\\]</span></p>\n<p>或，令 <span class=\"math inline\">\\(f_i\\)</span> 表示 DP 到 <span class=\"math inline\">\\(i\\)</span> 时（不强制选 <span class=\"math inline\">\\(i\\)</span>）本质不同子序列数量，记 <span class=\"math inline\">\\(pre_i\\)</span> 为 <span class=\"math inline\">\\(i\\)</span> 的前驱（没有则为 <span class=\"math inline\">\\(0\\)</span>）。令 <span class=\"math inline\">\\(f_0=0\\)</span>，那么：</p>\n<p><span class=\"math display\">\\[\nf_i=\\begin{cases}\n2\\cdot f_{i-1}+1&amp;pre_i= 0\\\\\n2\\cdot f_{i-1}-f_{pre_i-1}&amp;\\text{otherwise}\n\\end{cases}\n\\]</span></p>\n</details>\n<details>\n<p><summary>How to 强制选第 <span class=\"math inline\">\\(n\\)</span> 个元素的本质不同子序列？</summary></p>\n<p>令 <span class=\"math inline\">\\(f_i\\)</span> 表示 DP 到 <span class=\"math inline\">\\(i\\)</span>，且强制选 <span class=\"math inline\">\\(i\\)</span> 的本质不同子序列数量，则答案为：</p>\n<p><span class=\"math display\">\\[\n\\sum\\limits_{a_i=a_n} f_i\n\\]</span></p>\n<p>或，令 <span class=\"math inline\">\\(f_i\\)</span> 表示 DP 到 <span class=\"math inline\">\\(i\\)</span>，且不强制选 <span class=\"math inline\">\\(i\\)</span> 的本质不同子序列数量，则答案为：</p>\n<p><span class=\"math display\">\\[\n\\sum\\limits_{a_i=a_n}\\begin{cases}\nf_{i-1}+1&amp;pre_i= 0\\\\\nf_{i-1}-f_{pre_i-1}&amp;\\text{otherwise}\n\\end{cases}\n\\]</span></p>\n</details></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;a.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;a.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;./test/20251014/a/a1.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        std::string s;\n        std::cin &gt;&gt; s;\n        int n = (int)s.length();\n        s = &quot;#&quot; + s;\n        std::vector&lt;int&gt; a(n + 1);\n        for (int i = 1; i &lt;= n; ++i)\n            a[i] = a[i - 1] ^ (s[i] - &#39;0&#39;);\n        auto res = 0ll;\n        std::vector&lt;long long&gt; f(n + 1), la(2);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            if (la[a[i]])\n                f[i] = (2 * f[i - 1] + mod - f[la[a[i]] - 1]) % mod;\n            else\n                f[i] = (2 * f[i - 1] + 1) % mod;\n            if (a[i] == a[n]) &#123;\n                if (la[a[i]])\n                    res += (f[i - 1] + mod - f[la[a[i]] - 1]) % mod;\n                else\n                    res += f[i - 1] + 1;\n            &#125;\n            la[a[i]] = i;\n        &#125;\n        std::cout &lt;&lt; res % mod &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b.-敬启致那时的我\">B. 敬启，致那时的我</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6639/problem/2\" class=\"uri\">https://www.becoder.com.cn/contest/6639/problem/2</a></p>\n<blockquote>\n<p>定义 <span class=\"math inline\">\\(f_0=f_1=1,f_i=f_{i-1}+f_{i-2}\\)</span>，给定 <span class=\"math inline\">\\(n,k\\)</span>，求：</p>\n<p><span class=\"math display\">\\[\n\\left(\\sum_{i=0}^n f_{i}\\cdot [\\text{popcount}(i)=k]\\right)\\bmod 10^9+7\n\\]</span></p>\n<p><span class=\"math inline\">\\(n\\le 2^{2000},0\\le k\\le \\log_2(n)\\)</span>。</p>\n</blockquote>\n<ul>\n<li>考虑数位 DP，那么需要能够由 <code>...xxx</code> 向 <code>...0xxx</code> 和 <code>...1xxx</code> 转移。</li>\n<li><p>显然只关心向 <code>...1xxx</code> 的转移，那么需要再转移 <span class=\"math inline\">\\(2^{?}\\)</span> 次，记录转移矩阵的 <span class=\"math inline\">\\(2^{?}\\)</span> 次方即可。</p>\n<p>这一步也可以不用矩阵，而是用斐波那契 <span class=\"math inline\">\\(f(ab)=...\\)</span> 的性质，但显然二者是等价的，无甚必要</p></li>\n<li><p>根据数位 DP 的实现方式，常数上顺序结构肯定是会吊打递归的。然而并不惯写顺序结构的数位 DP，whatever.</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nstruct matrix &#123;\n    long long a[2][2];\n    matrix() &#123;\n        a[0][0] = a[0][1] = a[1][0] = a[1][1] = 0ll;\n        return;\n    &#125;\n    long long* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    matrix operator* (matrix &amp;q) const &#123;\n        matrix res;\n        res[0][0] = (a[0][0] * q[0][0] + a[0][1] * q[1][0]) % mod;\n        res[0][1] = (a[0][0] * q[0][1] + a[0][1] * q[1][1]) % mod;\n        res[1][0] = (a[1][0] * q[0][0] + a[1][1] * q[1][0]) % mod;\n        res[1][1] = (a[1][0] * q[0][1] + a[1][1] * q[1][1]) % mod;\n        return res;\n    &#125;\n    matrix&amp; operator+= (matrix q) &#123;\n        if ((a[0][0] += q[0][0]) &gt;= mod) a[0][0] -= mod;\n        if ((a[0][1] += q[0][1]) &gt;= mod) a[0][1] -= mod;\n        if ((a[1][0] += q[1][0]) &gt;= mod) a[1][0] -= mod;\n        if ((a[1][1] += q[1][1]) &gt;= mod) a[1][1] -= mod;\n        return *this;\n    &#125;\n&#125;;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;b.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;b.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;./test/20251014/b/b4.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    std::vector&lt;int&gt; up(n);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        char t;\n        std::cin &gt;&gt; t, up[n - i] = t - &#39;0&#39;;\n    &#125;\n    matrix init, zmat;\n    init[0][0] = init[0][1] = 1ll;\n    std::vector&lt;matrix&gt; mat(n);\n    mat[0][0][1] = mat[0][1][0] = mat[0][1][1] = 1ll;\n    for (int i = 1; i &lt; n; ++i)\n        mat[i] = mat[i - 1] * mat[i - 1];\n    std::vector&lt;std::vector&lt;int&gt; &gt; tag(n, std::vector&lt;int&gt; (k + 1));\n    std::vector&lt;std::vector&lt;matrix&gt; &gt; f(n, std::vector&lt;matrix&gt; (k + 1));\n    std::function&lt;matrix(int, int, int)&gt; DFS = [&amp;](int x, int k, int fl) &#123;\n        if (x == -1) &#123;\n            if (k == 0)\n                return init;\n            return zmat;\n        &#125;\n        if (!fl &amp;&amp; tag[x][k])\n            return f[x][k];\n        matrix res = DFS(x - 1, k, fl &amp;&amp; !up[x]);\n        if (k &amp;&amp; (!fl || up[x]))\n            res += DFS(x - 1, k - 1, fl) * mat[x];\n        if (!fl)\n            tag[x][k] = 1, f[x][k] = res;\n        return res;\n    &#125;;\n    std::cout &lt;&lt; DFS(n - 1, k, 1)[0][0] &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c.-lead-to-shine-more\">C. Lead to shine more</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6639/problem/3\" class=\"uri\">https://www.becoder.com.cn/contest/6639/problem/3</a></p>\n<blockquote>\n<p>第 <span class=\"math inline\">\\(0\\)</span> 次操作时变量 <span class=\"math inline\">\\(x=1\\)</span>，此后每次操作使 <span class=\"math inline\">\\(x\\gets x+\\text{popcount}(x)\\)</span>，给定 <span class=\"math inline\">\\(m\\)</span> 次询问：</p>\n<ul>\n<li>给定 <span class=\"math inline\">\\(x&#39;\\)</span>，问 <span class=\"math inline\">\\(x\\)</span> 在第几次操作后变为 <span class=\"math inline\">\\(x&#39;\\)</span>，或报告 <span class=\"math inline\">\\(x&#39;\\)</span> 不会被经过。</li>\n</ul>\n<p><span class=\"math inline\">\\(m\\le 10^5,x&#39;\\le 10^{18}\\)</span>。</p>\n</blockquote>\n<ul>\n<li>一个朴素的想法是分高低位，则因为每次操作带来的变化量不超过 60，远远低于低位的 <span class=\"math inline\">\\(2^30\\)</span>，所以一次操作至多给高位带来 1 的变化量。</li>\n<li><p>高位对整体的贡献只取决于其 popcount，所以可以枚举高位 1 的数量，再枚举初始值，找到第一次让高位变化花的次数。</p>\n<p>初始值的可能值有 <span class=\"math inline\">\\(60\\)</span> 个，而外层循环有 <span class=\"math inline\">\\(30\\)</span> 次，内层循环大概是 <span class=\"math inline\">\\(\\dfrac {2^{30}}{60}\\)</span> 的，总之无法通过。</p></li>\n<li><p>题解说方法是对上面的拓展。理解不能。出发点大概是考虑到让第 <span class=\"math inline\">\\(i\\)</span> 位变化相当于让 <span class=\"math inline\">\\(i+1\\)</span> 位变化两次，所以会有一个递推的关系。</p>\n<p>令 <span class=\"math inline\">\\(f_{i, s, d}\\)</span> 为前 <span class=\"math inline\">\\(i-1\\)</span> 位的 popcount 为 <span class=\"math inline\">\\(d\\)</span>，初始值为 <span class=\"math inline\">\\(s\\)</span>，让 <span class=\"math inline\">\\(i\\)</span> 位变化一次的操作次数；<span class=\"math inline\">\\(g_{i,s,d}\\)</span> 为上述变化后 <span class=\"math inline\">\\(x\\)</span> 的值。记 <span class=\"math inline\">\\(pos=g_{i-1,s,d}\\)</span>，那么有：</p>\n<p><span class=\"math display\">\\[\ng_{i,pos,d}=g_{i-1,pos,d+1}\\\\\nf_{i,pos,d}=f_{i-1,s,d}+f_{i-1,pos,d+1}\n\\]</span></p>\n<p>其实是一个类似<strong>倍增</strong>的结构。但恕我实在无法解释怎么想到的。</p></li>\n<li>显然这个式子在 <span class=\"math inline\">\\(i\\le 5\\)</span> 时是有问题的，这部分我们暴力跑即可。忽略这一部分常数，预处理总复杂度 <span class=\"math inline\">\\(O(\\log^3 n)\\)</span>。</li>\n<li><p>考虑查询，按照类似数位 DP 的方法从高位到低位模拟进位过程即可。复杂度 <span class=\"math inline\">\\(O(\\log n)\\)</span>。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;c.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;c.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;./test/20251014/c/c1.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    using arr = std::vector&lt;long long&gt;;\n    using brr = std::vector&lt;arr&gt;;\n    using crr = std::vector&lt;brr&gt;;\n    crr f(61, brr(256, arr(61))), g(61, brr(256, arr(61)));\n    for (int s = 0; s &lt; 256; ++s)\n        for (int d = 0; d &lt;= 60; ++d)\n            if (d || s) &#123;\n                int x = s, cnt = 0;\n                for (; x &lt; 256; x += __builtin_popcount(x) + d, ++cnt);\n                f[8][s][d] = cnt, g[8][s][d] = x &amp; 255;\n            &#125;\n    for (int i = 9; i &lt;= 60; ++i)\n        for (int s = 0; s &lt; 256; ++s)\n            for (int d = 0; d &lt; 60; ++d) &#123;\n                int pos = g[i - 1][s][d];\n                g[i][s][d] = g[i - 1][pos][d + 1];\n                f[i][s][d] = f[i - 1][s][d] + f[i - 1][pos][d + 1];\n            &#125;\n    int m;\n    std::cin &gt;&gt; m;\n    for (long long x; m--; ) &#123;\n        std::cin &gt;&gt; x;\n        auto pos = 1ll, cnt = 0ll, tot = 0ll;\n        for (int i = 60; i &gt;= 8; --i)\n            if ((x &gt;&gt; i) &amp; 1) &#123;\n                cnt += f[i][pos][tot];\n                pos = g[i][pos][tot++];\n            &#125;\n        for (; pos &lt; (x &amp; 255); pos += __builtin_popcountll(pos) + tot, ++cnt);\n        // std::cout &lt;&lt; pos &lt;&lt; &#39; &#39; &lt;&lt; cnt &lt;&lt; &#39;\\n&#39;;\n        if (pos == (x &amp; 255))\n            std::cout &lt;&lt; cnt &lt;&lt; &#39;\\n&#39;;\n        else\n            std::cout &lt;&lt; -1 &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c.-query-on-a-tree-17\">C. Query On A Tree 17</h2>\n<p><a href=\"https://codeforces.com/gym/102759/problem/I\" class=\"uri\">https://codeforces.com/gym/102759/problem/I</a></p>\n<blockquote>\n<p>给定一个以 <span class=\"math inline\">\\(1\\)</span> 为根的树，点权初始为全 <span class=\"math inline\">\\(0\\)</span>。维护 <span class=\"math inline\">\\(m\\)</span> 次修改：</p>\n<ul>\n<li><code>1 u</code>，表示把 <span class=\"math inline\">\\(u\\)</span> 子树内的点权加一。</li>\n<li><code>2 u v</code>，表示把 <span class=\"math inline\">\\(u,v\\)</span> 简单路径上的点权加一。</li>\n</ul>\n<p>每次修改后，输出树深度最小的带权重心。</p>\n<p><span class=\"math inline\">\\(n,m\\le 10^5\\)</span>。</p>\n</blockquote>\n<ul>\n<li><p>考虑链上的问题，考虑一点小奥做法，把所有点重复其出现次数次，从左到右排列，发现答案在中位数上。</p>\n<p>（据组题人所言），这是用来提示正解的。事实上，这是一个和带权重心有关的 trick：</p>\n<blockquote>\n<p>若一个点 <span class=\"math inline\">\\(u\\)</span> 是<strong>深度最小的</strong>带权重心，则其子树权值和必须<strong>严格大于</strong>总权值的一半。</p>\n</blockquote>\n<p>证明显然，但结论不显然。Whatever.</p></li>\n<li><p>由这一点会得到，（参照链上的做法），把点重复点权次，并按 dfn 排成一行，取中位数，那么取到的一定在<strong>深度最小的</strong>重心子树内，（这就是组题人说的提示正解）。</p>\n<p>这一点反而没那么显然，推导过程是，<strong>深度最小的</strong>重心的子树占了大于一半，而其 dfn 又是连续的，（类似滑动窗口），故总能够到中位数。</p>\n<p>考虑非深度最小的重心，此时就从<strong>严格大于</strong>变为<strong>不严格大于</strong>，导致没有办法很好地精准找到，需要从中位数左右偏移一位，显然是很丑陋的。</p></li>\n<li><p>因此可以考虑线段树上二分找到中位数（容易发现线段树的 <span class=\"math inline\">\\(x\\)</span> 轴本来就是 dfn），然后从这个中位数往上跳，一直跳到满足『子树权值和严格大于总权值一半』的点，就是最浅的重心。</p>\n<p>这一点采用倍增即可。</p></li>\n</ul>\n",
            "tags": [
                "DP",
                "树状数组",
                "倍增",
                "贪心"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20251005/",
            "url": "https://xsc062.netlify.app/20251005/",
            "title": "杂题选谈：贪心",
            "date_published": "2025-10-05T00:17:32.000Z",
            "content_html": "<p>不会做的简单题</p>\n<span id=\"more\"></span>\n<hr />\n<ul>\n<li><p>贪心的『策略』是一种很模糊的东西</p>\n<ul>\n<li>如果能找到一种清晰的操作流程，自然是很好的，但如果要从数学角度进行推导，可能有些困难</li>\n<li>否则，如果没办法找到一种确定的操作方式，需要确定答案的上 / 下界是可以取到的</li>\n</ul></li>\n</ul>\n<hr />\n<h2 id=\"饥饿的狐狸\">饥饿的狐狸</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P4801\" class=\"uri\">https://www.luogu.com.cn/problem/P4801</a></p>\n<ul>\n<li><p>第一问，发现不喝水一定不劣，故大小顺序吃饼干即可。</p>\n<p>具体地，若 <span class=\"math inline\">\\(W&lt;a_1\\)</span>，把 <span class=\"math inline\">\\(W\\)</span> 视作 <span class=\"math inline\">\\(a_0\\)</span> 即可；若 <span class=\"math inline\">\\(W&gt;a_n\\)</span>，把 <span class=\"math inline\">\\(W\\)</span> 视作 <span class=\"math inline\">\\(a_{n+1}\\)</span> 即可；</p>\n<p>若 <span class=\"math inline\">\\(a_1&lt;W&lt;a_n\\)</span>，那么由于喝水是没有代价的，可以从 <span class=\"math inline\">\\(W\\)</span> 一直吃到 <span class=\"math inline\">\\(a_1\\)</span>，再喝水，再从 <span class=\"math inline\">\\(W\\)</span> 一直吃到 <span class=\"math inline\">\\(a_n\\)</span>。</p></li>\n<li><p>第二问，我们希望 <span class=\"math inline\">\\(a_i-a_j\\)</span> 这个代价中的 <span class=\"math inline\">\\(a_i\\)</span> 尽可能大，<span class=\"math inline\">\\(a_j\\)</span> 尽可能小。故尝试让前一半当 <span class=\"math inline\">\\(a_j\\)</span>，后一半当 <span class=\"math inline\">\\(a_i\\)</span> 即可，那么顺序其实无所谓，只是需要讨论一下和第一次 <span class=\"math inline\">\\(W\\)</span> 接壤的是 <span class=\"math inline\">\\(a_1\\)</span> 还是 <span class=\"math inline\">\\(a_n\\)</span>。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    long long w;\n    std::cin &gt;&gt; n &gt;&gt; w;\n    std::vector&lt;long long&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::sort(a.begin() + 1, a.end());\n    std::cout &lt;&lt; std::max(w - a[1], 0ll) + std::max(a[n] - w, 0ll) &lt;&lt; &#39; &#39;;\n    auto calc = [&amp;](int op) &#123;\n        long long res = 0ll, now = w;\n        for (int i = 1, l = 1, r = n; i &lt;= n; ++i)\n            if (i % 2 == op)\n                res += std::max(std::abs(a[l] - now), std::abs(a[l] - w)), now = a[l++];\n            else\n                res += std::max(std::abs(a[r] - now), std::abs(a[r] - w)), now = a[r--];\n        return res;\n    &#125;;\n    std::cout &lt;&lt; std::max(calc(0), calc(1)) &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"sam-toy-cars\">SAM-Toy Cars</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P3419\" class=\"uri\">https://www.luogu.com.cn/problem/P3419</a></p>\n<ul>\n<li>有一个大概的感受是每次丢弃『下次出现时间』最晚的一个。</li>\n<li>tip：玩具在地上的时候不会更新队列中的 nex。需要特别处理。</li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, k, p;\n    std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; p;\n    std::vector&lt;int&gt; a(p + 1);\n    for (int i = 1; i &lt;= p; ++i)\n        std::cin &gt;&gt; a[i];\n    std::vector&lt;int&gt; nex(p + 1), la(n + 1, p + 1);\n    for (int i = p; i; --i)\n        nex[i] = la[a[i]], la[a[i]] = i;\n    std::priority_queue&lt;std::pair&lt;int, int&gt; &gt; q;\n    std::vector&lt;int&gt; inq(n + 1);\n    int cnt = 0;\n    for (int i = 1; i &lt;= p; ++i)\n        if (!inq[a[i]]) &#123;\n            if ((int)q.size() == k) &#123;\n                auto [nex, v] = q.top();\n                q.pop();\n                inq[v] = 0;\n            &#125;\n            ++cnt, q.emplace(nex[i], a[i]);\n            inq[a[i]] = 1;\n        &#125;\n        else\n            q.emplace(nex[i], a[i]), ++k;\n    std::cout &lt;&lt; cnt &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"sports-festival\">Sports Festival</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_agc018_b\" class=\"uri\">https://www.luogu.com.cn/problem/AT_agc018_b</a></p>\n<ul>\n<li>会有一个显然的二分做法</li>\n<li>其实可以不用二分，每次删最大的，每次更新答案</li>\n<li>用带一点反证的思路是好证的</li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;std::queue&lt;int&gt; &gt; a(n + 1);\n    std::vector&lt;int&gt; del(m + 1), cnt(m + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = 1, x; j &lt;= m; ++j)\n            std::cin &gt;&gt; x, a[i].push(x);\n        ++cnt[a[i].front()];\n    &#125;\n    int res = n + 1;\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        int mx = 0, id = 0;\n        for (int i = 1; i &lt;= m; ++i)\n            if (cnt[i] &gt; mx)\n                mx = cnt[i], id = i;\n        res = std::min(res, mx);\n        if (i == m)\n            break;\n        del[id] = 1;\n        for (int j = 1; j &lt;= n; ++j) &#123;\n            --cnt[a[j].front()];\n            for (; del[a[j].front()]; a[j].pop());\n            ++cnt[a[j].front()];\n        &#125;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"linguistics\">Linguistics</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1685B\" class=\"uri\">https://www.luogu.com.cn/problem/CF1685B</a></p>\n<ul>\n<li>找到每一段极长交错段，把 <code>AB</code> 和 <code>BA</code> ；处理掉</li>\n<li>发现 ABABA 和 BABAB 对于 <code>AB</code> 和 <code>BA</code> 是等价的，考虑 ABABAB 和 BABABA。发现后二者要么匹配 AB / BA，要么删去首尾后转化为另一者。但这样就会浪费掉一个消去 <code>AB</code> 或 <code>BA</code> 的机会。</li>\n<li>故优先对后二者匹配 AB / BA，实在有多余再删头尾。</li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int A, B, AB, BA;\n        std::string a;\n        std::cin &gt;&gt; A &gt;&gt; B &gt;&gt; AB &gt;&gt; BA &gt;&gt; a;\n        int n = (int)a.length();\n        a = &quot;#&quot; + a;\n        char l = a[1];\n        int len = 0;\n        std::vector&lt;int&gt; ab, ba, c;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            if (i == 1 || a[i] != a[i - 1])\n                ++len;\n            if (i == n || a[i] == a[i - 1]) &#123;\n                if (len != 1) &#123;\n                    // fprintf(stderr, &quot;#1 len = %d, l = %c \\n&quot;, len, l);\n                    if (l == &#39;A&#39; &amp;&amp; a[i] == &#39;B&#39;)\n                        ab.push_back(len);\n                    else if (l == &#39;A&#39;) &#123;\n                        if (!A)\n                            goto nosol;\n                        else\n                            --A, c.push_back(len - 1);\n                    &#125;\n                    else if (a[i] == &#39;A&#39;)\n                        ba.push_back(len);\n                    else if (!B)\n                        goto nosol;\n                    else\n                        --B, c.push_back(len - 1);\n                &#125;\n                else &#123;\n                    // fprintf(stderr, &quot;#2 len = %d, l = %c \\n&quot;, 1, l);\n                    if (l == &#39;A&#39;) &#123;\n                        if (!A)\n                            goto nosol;\n                        --A;\n                    &#125;\n                    else &#123;\n                        if (!B)\n                            goto nosol;\n                        --B;\n                    &#125;\n                &#125;\n                if (i == n &amp;&amp; a[i] == a[i - 1]) &#123;\n                    // fprintf(stderr, &quot;#3 len = %d, l = %c \\n&quot;, 1, a[i]);\n                    if (a[i] == &#39;A&#39;) &#123;\n                        if (!A)\n                            goto nosol;\n                        --A;\n                    &#125;\n                    else &#123;\n                        if (!B)\n                            goto nosol;\n                        --B;\n                    &#125;\n                &#125;\n                len = 1, l = a[i];\n            &#125;\n        &#125;\n        std::sort(ab.begin(), ab.end(), std::greater&lt;int&gt; ());\n        std::sort(ba.begin(), ba.end(), std::greater&lt;int&gt; ());\n        for (; !ab.empty() &amp;&amp; AB; ) &#123;\n            int x = std::min(AB, ab.back() / 2);\n            AB -= x, ab.back() -= x * 2;\n            if (!ab.back())\n                ab.pop_back();\n        &#125;\n        for (; !ba.empty() &amp;&amp; BA; ) &#123;\n            int x = std::min(BA, ba.back() / 2);\n            BA -= x, ba.back() -= x * 2;\n            if (!ba.back())\n                ba.pop_back();\n        &#125;\n        // fprintf(stderr, &quot;AB = %d, BA = %d, A = %d, B = %d \\n&quot;, AB, BA, A, B);\n        for (; !ab.empty() &amp;&amp; BA; ) &#123;\n            if (!A || !B)\n                goto nosol;\n            ab.back() -= 2, --A, --B;\n            int x = std::min(BA, ab.back() / 2);\n            BA -= x, ab.back() -= x * 2;\n            if (!ab.back())\n                ab.pop_back();\n        &#125;\n        for (; !ab.empty(); ) &#123;\n            A -= ab.back() / 2, B -= ab.back() / 2;\n            ab.pop_back();\n        &#125;\n        if (A &lt; 0 || B &lt; 0)\n            goto nosol;\n        for (; !ba.empty() &amp;&amp; AB; ) &#123;\n            if (!A || !B)\n                goto nosol;\n            ba.back() -= 2, --A, --B;\n            int x = std::min(AB, ba.back() / 2);\n            AB -= x, ba.back() -= x * 2;\n            if (!ba.back())\n                ba.pop_back();\n        &#125;\n        for (; !ba.empty(); ) &#123;\n            A -= ba.back() / 2, B -= ba.back() / 2;\n            ba.pop_back();\n        &#125;\n        if (A &lt; 0 || B &lt; 0)\n            goto nosol;\n        for (; !c.empty() &amp;&amp; AB; ) &#123;\n            int x = std::min(AB, c.back() / 2);\n            AB -= x, c.back() -= x * 2;\n            if (!c.back())\n                c.pop_back();\n        &#125;\n        for (; !c.empty() &amp;&amp; BA; ) &#123;\n            int x = std::min(BA, c.back() / 2);\n            BA -= x, c.back() -= x * 2;\n            if (!c.back())\n                c.pop_back();\n        &#125;\n        if (AB || BA)\n            goto nosol;\n        for (; !c.empty(); ) &#123;\n            A -= c.back() / 2, B -= c.back() / 2;\n            c.pop_back();\n        &#125;\n        if (A || B)\n            goto nosol;\n        std::cout &lt;&lt; &quot;YES\\n&quot;;\n        continue;\n    nosol: ;\n        std::cout &lt;&lt; &quot;NO\\n&quot;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"sunnys-crystals\">Sunny’s Crystals</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P5584\" class=\"uri\">https://www.luogu.com.cn/problem/P5584</a></p>\n<ul>\n<li>如果某一时刻同时存在多个可以被删除的数，显然应该删最后一个</li>\n<li>否则，发现删每一个位置对于后方关键点的贡献完全相同，故删第一个即可。</li>\n<li>发现线段树没办法很好地维护『有哪些点是二的次方』，但是我们知道一个很相似的结构『有哪些点是 <span class=\"math inline\">\\(0\\)</span>』，结合起来可以马上反映出来实时维护每个点到最近一个二的此方位置的距离。</li>\n<li>把非关键点 / 被删去的点赋为 inf 即可方便维护。</li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 3e6 + 5;\nconst int inf = 0x3f3f3f3f;\nstruct &#123;\n    int l, r, u, x, d;\n&#125; t[maxn &lt;&lt; 2];\nint tot = 0;\n#define lt t[p].l\n#define rt t[p].r\nvoid pushval(int p, int v) &#123;\n    if (p)\n        t[p].d += v, t[p].u += v;\n    return;\n&#125;\nvoid pushdown(int p) &#123;\n    pushval(lt, t[p].d), pushval(rt, t[p].d);\n    t[p].d = 0;\n    return;\n&#125;\nvoid pushup(int p) &#123;\n    t[p].u = std::min(t[lt].u, t[rt].u);\n    if (t[rt].u == t[p].u)\n        t[p].x = t[rt].x;\n    else\n        t[p].x = t[lt].x;\n    return;\n&#125;\nvoid upd(int &amp;p, int l, int r, int x, int v) &#123;\n    if (!p)\n        p = ++tot;\n    if (l == r) &#123;\n        t[p].u = v, t[p].x = l;\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (l + r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        upd(lt, l, mid, x, v);\n    else\n        upd(rt, mid + 1, r, x, v);\n    pushup(p);\n    return;\n&#125;\nvoid add(int p, int l, int r, int ql, int qr, int v) &#123;\n    if (!p)\n        return;\n    if (ql &lt;= l &amp;&amp; r &lt;= qr) &#123;\n        pushval(p, v);\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (l + r) &gt;&gt; 1;\n    if (ql &lt;= mid)\n        add(lt, l, mid, ql, qr, v);\n    if (qr &gt; mid)\n        add(rt, mid + 1, r, ql, qr, v);\n    pushup(p);\n    return;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, w, m = 0, rt = 0;\n    std::cin &gt;&gt; n &gt;&gt; w, t[0].u = inf;\n    auto to = [&amp;](int x) &#123;\n        return 1 &lt;&lt; std::__lg(x);\n    &#125;;\n    for (int i = 1, x; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; x;\n        if (x == w)\n            ++m, upd(rt, 1, n, i, i - to(i));\n    &#125;\n    std::vector&lt;int&gt; res, del(n + 1);\n    for (int i = 1, now = 1; i &lt;= m; ++i) &#123;\n        for (int j = 1; j &lt;= t[1].u; ++j) &#123;\n            for (; del[now]; ++now);\n            del[now] = 1, res.push_back(now++);\n        &#125;\n        pushval(rt, -t[1].u);\n        int pos = t[1].x;\n        del[pos] = 1, res.push_back(pos);\n        upd(rt, 1, n, pos, inf);\n        if (pos + 1 &lt;= n)\n            add(rt, 1, n, pos + 1, n, -1);\n    &#125;\n    std::cout &lt;&lt; (int)res.size() &lt;&lt; &#39;\\n&#39;;\n    for (auto i : res)\n        std::cout &lt;&lt; i &lt;&lt; &#39; &#39;;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"section\"></h2>\n",
            "tags": [
                "贪心"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20251004/",
            "url": "https://xsc062.netlify.app/20251004/",
            "title": "杂题选谈：生成树 II",
            "date_published": "2025-10-04T07:07:22.000Z",
            "content_html": "<p>为什么要定义最小瓶颈路？似乎并不是很有意义</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a---水筒\">A - 水筒</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_joisc2014_e\" class=\"uri\">https://www.luogu.com.cn/problem/AT_joisc2014_e</a></p>\n<ul>\n<li>即求重构树，考虑 BFS 建图</li>\n<li>代码略</li>\n</ul>\n<hr />\n<h2 id=\"b---difference-of-distance\">B - Difference of Distance</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_abc301_h\" class=\"uri\">https://www.luogu.com.cn/problem/AT_abc301_h</a></p>\n<ul>\n<li>有一个很奇怪的想法，就是当存在多种 Kruskal 重构树时，最大边权最小值是不会变的</li>\n<li>也就是说如果拿掉了这条边，但仍然存在另一条边权相同的边可以『代替』自己时，最大边权最小值不变</li>\n<li>否则，从另一个角度想，就可以仍然选自己，那么答案就会增加 1。</li>\n<li><p>因此，只需要对于不在生成树上的每一条边，标记环上和自己相同的边即可。</p>\n<p>树上差分 + dsu on tree 即可，注意线段树合并是线性的，如果忘了这一点就会和我一样想出虚树 + 树剖的诡异双 log 做法</p></li>\n</ul>\n",
            "tags": [
                "最小生成树"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250929/",
            "url": "https://xsc062.netlify.app/20250929/",
            "title": "杂题选谈：生成树",
            "date_published": "2025-09-29T08:55:28.000Z",
            "content_html": "<p>zyz /bx /bx /bx</p>\n<span id=\"more\"></span>\n<details>\n<p><summary>图论杂谈 by Para.pdf</summary></p>\n<p><a href=\"图论杂谈%20by%20Para.pdf\">link</a></p>\n<iframe src=\"图论杂谈%20by%20Para.pdf\" width=\"100%\" height=\"500px\">\n</iframe>\n</details>\n<hr />\n<h2 id=\"最小公倍树\">最小公倍树</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P8207\" class=\"uri\">https://www.luogu.com.cn/problem/P8207</a></p>\n<ul>\n<li>会想到从数论角度优化。需要想到<strong>最小化 lcm <span class=\"math inline\">\\(\\to\\)</span> 最大化 gcd。</strong></li>\n<li><p>枚举 gcd <span class=\"math inline\">\\(u\\)</span>，那么 <span class=\"math inline\">\\(u\\)</span> 的倍数在 <span class=\"math inline\">\\([L,R]\\)</span> 中呈现为 <span class=\"math inline\">\\(k\\cdot u,(k+1)\\cdot u,(k+2)\\cdot u,\\cdots\\)</span>。<strong>虽然这些数两两之间的 gcd 并不一定为 <span class=\"math inline\">\\(u\\)</span>，但我们在枚举时『钦定』<span class=\"math inline\">\\(u\\)</span> 就是 gcd，故贪心地将所有 <span class=\"math inline\">\\(k+i\\)</span> 和 <span class=\"math inline\">\\(k\\)</span> 连边。</strong></p>\n<p>这种钦定的思想是很重要但我不太容易想到的。许多关于『最优化』的转化都会用到这种钦定的想法。</p></li>\n<li><p>优化建图后跑 Kruskal 即可。</p></li>\n</ul>\n<details>\n<p>古老代码</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\n#define int long long\nnamespace fastIO &#123;\nconst int LEN = (1 &lt;&lt; 20);\n#ifdef ONLINE_JUDGE\ninline int nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF;\n        p = buf;\n    &#125;\n    return *p++;\n&#125;\n#else\n#define nec getchar\n#endif\ninline bool read(int &amp;x) &#123;\n    x = 0;\n    bool f = 0;\n    char ch = nec();\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nvoid print(int x) &#123;\n    if (x &lt; 0)\n        putchar(&#39;-&#39;), x = -x;\n    if (x &gt;= 10) print(x / 10);\n    putchar(x % 10 + &#39;0&#39;);\n    return;\n&#125;\nvoid print(int x, char ch) &#123;\n    print(x), putchar(ch);\n    return;\n&#125;\n&#125; // namespace fastIO\nnamespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 1e6 + 5;\nstruct _ &#123;\n    int x, y, w;\n    _() &#123;&#125;\n    _(int x1, int y1, int w1) &#123;\n        x = x1, y = y1, w = w1;\n    &#125;\n    bool operator&lt; (const _ &amp;q) const &#123;\n        return w &lt; q.w;\n    &#125;\n&#125;;\nint f[maxn];\nstd::vector&lt;_&gt; e;\nint n, res, l, r;\nint find(int x) &#123; return x == f[x] ? x : f[x] = find(f[x]); &#125;\nvoid merge(int x, int y) &#123; f[find(x)] = find(y); &#125;\nint gcd(int x, int y) &#123; return y ? gcd(y, x % y) : x; &#125;\nint lcm(int x, int y) &#123; return x / gcd(x, y) * y; &#125;\nint main() &#123;\n    read(l), read(r);\n    for (int i = 1; i &lt;= r; ++i) &#123;\n        f[i] = i;\n        int x = ((l + i - 1) / i) * i;\n        for(int y = x + i; y &lt;= r; y += i)\n            e.emplace_back(x, y, lcm(x, y));\n    &#125;\n    std::sort(e.begin(), e.end());\n    for (auto i : e) &#123;\n        if (find(i.x) != find(i.y))\n            merge(i.x, i.y), res += i.w;\n    &#125;\n    print(res, &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int\nint main() &#123;\n    XSC062::main();\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"色\">色</h2>\n<p><a href=\"https://www.becoder.com.cn/problem/46791\" class=\"uri\">https://www.becoder.com.cn/problem/46791</a></p>\n<ul>\n<li>容易发现相当于在问最短的边，满足两端颜色不同</li>\n<li><p>进一步地，<strong>『最短边』问题应该思考边是否一定在 mst 上</strong>，就可以借助树的结构。考虑证明：</p>\n<p>若 Kruskal 时，边两端的连通块内部都是同色的，且二者不同色，则这条边是最短的异色边。</p></li>\n<li><p>问题转化为问树上最短异色边。乍一看好像和图没什么区别，困境还是『一次修改影响边数太多』，或『无法简单判定边的类型转化』。</p>\n<p>树上问题经验不足。可以<strong>分为儿子和父亲维护</strong>，儿子<strong>整体维护</strong>每个颜色的个数，对父亲<strong>暴力修改</strong>即可。</p></li>\n<li>另一种做法是，忽略 mst 性质，对图上的<strong>边序列排序后分块</strong>。</li>\n<li>询问时枚举所有块，如果该块中存在异色边，则暴力枚举块中边然后 break。</li>\n<li><p>修改则是祖传哈希，给每条边、每个颜色赋一个随机系数并<strong>强行有向化，起点为加终点为减</strong></p>\n<p><strong>记录每个块中的系数和，最后总和为 0 则块不可选。</strong></p></li>\n</ul>\n<details>\n<p>古老代码</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nusing ull = unsigned long long;\nconst int maxk = 555;\nconst int maxn = 2e5 + 5;\nconst int maxm = 3e5 + 5;\nstruct _ &#123; int u, v, w; &#125;;\n_ g[maxm];\nint l[maxk], r[maxk], a[maxn];\null hash[maxm], w[maxk], to[maxn], val[maxk][maxn];\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n#else\n    freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m, q;\n    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; q &gt;&gt; q;\n    std::mt19937_64 rnd(0xabcdef);\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        std::cin &gt;&gt; g[i].u &gt;&gt; g[i].v &gt;&gt; g[i].w;\n        hash[i] = rnd();\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        for (; !to[a[i]]; to[a[i]] = rnd());\n    &#125;\n    std::sort(g + 1, g + m + 1, [](_ x, _ y) &#123; return x.w &lt; y.w; &#125;);\n    int siz = sqrt(m), k = (m + siz - 1) / siz;\n    for (int i = 1; i &lt;= k; ++i) &#123;\n        l[i] = r[i - 1] + 1, r[i] = std::min(l[i] + siz - 1, m);\n        for (int j = l[i]; j &lt;= r[i]; ++j) &#123;\n            val[i][g[j].u] += hash[j];\n            val[i][g[j].v] -= hash[j];\n            w[i] += hash[j] * (to[a[g[j].u]] - to[a[g[j].v]]);\n        &#125;\n    &#125;\n    for (int x, y; q--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        for (; !to[y]; to[y] = rnd());\n        for (int i = 1; i &lt;= k; ++i)\n            w[i] += val[i][x] * (to[y] - to[a[x]]);\n        a[x] = y;\n        for (int i = 1; i &lt;= k; ++i) &#123;\n            if (w[i]) &#123;\n                for (int j = l[i]; j &lt;= r[i]; ++j)\n                    if (a[g[j].u] != a[g[j].v]) &#123;\n                        std::cout &lt;&lt; g[j].w &lt;&lt; &#39;\\n&#39;;\n                        break;\n                    &#125;\n                break;\n            &#125;\n        &#125;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"dfs-trees\">DFS Trees</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1707C\" class=\"uri\">https://www.luogu.com.cn/problem/CF1707C</a></p>\n<ul>\n<li><p>一个结论：若图中边权两两不同，则图的最小生成树唯一。</p>\n<details>\n<p><summary>借鉴次小生成树的思路证明…</summary></p>\n<p>对于两个 mst <span class=\"math inline\">\\(T_1,T_2\\)</span>，假设二者边集不同但权值相同，对于其对称差 <span class=\"math inline\">\\(S\\)</span>，设 <span class=\"math inline\">\\(e\\)</span> 是其中最小的边，且 <span class=\"math inline\">\\(e\\in T_1,e\\notin T_2\\)</span>。</p>\n<p>将 <span class=\"math inline\">\\(e\\)</span> 加入 <span class=\"math inline\">\\(T_2\\)</span>，则形成的环上存在 <span class=\"math inline\">\\(e&#39;\\)</span> 使得 <span class=\"math inline\">\\(e&#39;\\in T_2,e&#39;\\notin T_1\\)</span>，那么 <span class=\"math inline\">\\(e&#39;\\in S\\)</span>。删掉 <span class=\"math inline\">\\(e&#39;\\)</span> 并加入 <span class=\"math inline\">\\(e\\)</span>，得到 <span class=\"math inline\">\\(T_2&#39;\\)</span>。</p>\n<p>由于 <span class=\"math inline\">\\(e\\)</span> 是 <span class=\"math inline\">\\(S\\)</span> 中最小边，那么 <span class=\"math inline\">\\(e&lt;e&#39;\\)</span>。也即 <span class=\"math inline\">\\(T_2&#39;&lt;T_1\\)</span>，与前提矛盾。</p>\n</details>\n<p>知道了这一点，就很好从 DFS 树的方向下手了。考虑如何什么时候 DFS 树就是 mst。</p></li>\n<li><p>对于一条非 mst 树边 <span class=\"math inline\">\\((u,v,w)\\)</span>：</p>\n<ul>\n<li>由 DFS 树的性质，<strong>若其为横叉边，必被经过。</strong></li>\n<li>由 mst 的性质，<span class=\"math inline\">\\(w\\)</span> 一定比 <span class=\"math inline\">\\(u,v\\)</span> 简单路径上的所有边边权更大，也即，当可以走这条路径时，一定不走 <span class=\"math inline\">\\(w\\)</span>。</li>\n</ul>\n<p>结合起来，<span class=\"math inline\">\\(w\\)</span> 不被经过，当且仅当 <span class=\"math inline\">\\(u,v\\)</span> 间存在祖孙关系。对应子树即为合法根。实现时还是需要倍增来找到差分范围，较为难受。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; e(m + 1);\n    for (int i = 1; i &lt;= m; ++i)\n        std::cin &gt;&gt; e[i].first &gt;&gt; e[i].second;\n    std::vector&lt;int&gt; f(n + 1);\n    std::iota(f.begin() + 1, f.end(), 1);\n    std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;\n        return x == f[x] ? x : f[x] = find(f[x]);\n    &#125;;\n    auto merge = [&amp;](int x, int y) &#123;\n        f[find(x)] = find(y);\n        return;\n    &#125;;\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; u;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        auto &amp;[x, y] = e[i];\n        if (find(x) != find(y)) &#123;\n            g[x].push_back(y), g[y].push_back(x);\n            merge(x, y);\n        &#125;\n        else\n            u.push_back(e[i]);\n    &#125;\n    std::vector&lt;int&gt; dep(n + 1);\n    std::vector&lt;std::array&lt;int, 19&gt; &gt; fa(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        for (auto i : g[x])\n            if (i != fa[x][0]) &#123;\n                dep[i] = dep[x] + 1;\n                fa[i][0] = x;\n                for (int j = 1; j &lt; 19; ++j)\n                    fa[i][j] = fa[fa[i][j - 1]][j - 1];\n                DFS(i);\n            &#125;\n        return;\n    &#125;;\n    dep[1] = 1, DFS(1);\n    auto ask = [&amp;](int x, int y) &#123;\n        if (dep[x] &lt; dep[y])\n            std::swap(x, y);\n        for (int i = 18; ~i; --i)\n            if (dep[fa[x][i]] &gt;= dep[y])\n                x = fa[x][i];\n        if (x == y)\n            return x;\n        for (int i = 18; ~i; --i)\n            if (fa[x][i] != fa[y][i])\n                x = fa[x][i], y = fa[y][i];\n        return fa[x][0];\n    &#125;;\n    std::vector&lt;int&gt; diff(n + 1);\n    for (auto [x, y] : u) &#123;\n        ++diff[x], ++diff[y];\n        if (dep[x] &lt; dep[y])\n            std::swap(x, y);\n        if (ask(x, y) == y) &#123;\n            for (int i = 18; ~i; --i)\n                if (dep[fa[x][i]] &gt; dep[y])\n                    x = fa[x][i];\n            --diff[x];\n        &#125;\n    &#125;\n    std::vector&lt;int&gt; res(n + 1);\n    std::function&lt;void(int, int)&gt; DFS1 = [&amp;](int x, int s) &#123;\n        s += diff[x];\n        res[x] = (s == (int)u.size());\n        for (auto i : g[x])\n            if (i != fa[x][0])\n                DFS1(i, s);\n        return;\n    &#125;;\n    DFS1(1, 0);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cout &lt;&lt; res[i];\n    std::cout &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"minimum-spanning-tree-for-each-edge\">Minimum spanning tree for each edge</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF609E\" class=\"uri\">https://www.luogu.com.cn/problem/CF609E</a></p>\n<p>挺没意思的题…… 略了。</p>\n<p>考虑这个题的孪生版本：</p>\n<h2 id=\"minimum-spanning-tree\">Minimum Spanning Tree</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_icpc2013spring_e\" class=\"uri\">https://www.luogu.com.cn/problem/AT_icpc2013spring_e</a></p>\n<p>用非树边更新环上每条树边的最小取代边即可。类似树上差分。代码略。</p>\n<hr />\n<h2 id=\"power-tree\">Power Tree</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1120D\" class=\"uri\">https://www.luogu.com.cn/problem/CF1120D</a></p>\n<ul>\n<li>容易想到把原问题转化为叶子序列上的差分。那么对于任意一个初始差分序列，我们都需要把它通过这样的差分操作变为 <span class=\"math inline\">\\(1\\sim n\\)</span> 全 0，第 <span class=\"math inline\">\\(n+1\\)</span> 位为 <span class=\"math inline\">\\(-s\\)</span>。</li>\n<li>联想到<strong>差分和连有向边的转化</strong>，那么要求连一个 <span class=\"math inline\">\\(n+1\\)</span> 为唯一汇点的树出来。显然就是原图的 mst。</li>\n<li><p>考虑怎么求出可能被 mst 包含的边。对于每一条非树边，若环上存在边权相同的边，那么这条非树边也能成为树边。</p>\n<p>考虑一个孪生问题：怎么求出一定被 mst 包含的边？</p>\n<p><a href=\"https://www.luogu.com.cn/problem/CF160D\" class=\"uri\">https://www.luogu.com.cn/problem/CF160D</a></p>\n<p>树上差分 + 线段树合并即可，注意单次线段树合并只有线性，直接做 DSU on tree 的复杂度是单 log 的。</p></li>\n<li><p>关于具体实现，可以参考 <a href=\"https://oi-wiki.org/graph/mst/#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E5%94%AF%E4%B8%80%E6%80%A7\">最小生成树的唯一性 - OI Wiki</a>。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\n#define int long long\nnamespace fastIO &#123;\nconst int LEN = (1 &lt;&lt; 20);\n#ifdef ONLINE_JUDGE\ninline int nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF;\n        p = buf;\n    &#125;\n    return *p++;\n&#125;\n#else\n#define nec getchar\n#endif\ninline bool read(int &amp;x) &#123;\n    x = 0;\n    bool f = 0;\n    char ch = nec();\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nvoid print(int x) &#123;\n    if (x &lt; 0)\n        putchar(&#39;-&#39;), x = -x;\n    if (x &gt;= 10) print(x / 10);\n    putchar(x % 10 + &#39;0&#39;);\n    return;\n&#125;\nvoid print(int x, char ch) &#123;\n    print(x), putchar(ch);\n    return;\n&#125;\n&#125; // namespace fastIO\nnamespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 2e5 + 5;\nstruct _ &#123;\n    int x, y, i;\n    _() &#123;&#125;\n    _(int x1, int y1, int i1) &#123;\n        x = x1, y = y1, i = i1;\n    &#125;\n    bool operator&lt; (const _ &amp;q) const;\n&#125;;\n_ t[maxn];\nint a[maxn], f[maxn];\nstd::vector&lt;int&gt; res;\nint n, now, x, y, sum; \nint beg[maxn], to[maxn];\nstd::vector&lt;int&gt; g[maxn];\nbool _::operator&lt; (const _ &amp;q) const &#123;\n    return a[i] &lt; a[q.i];\n&#125;\nint find(int x) &#123; return x == f[x] ? x : f[x] = find(f[x]); &#125;\nvoid merge(int x, int y) &#123;\n    f[find(x)] = find(y);\n    return;\n&#125;\nvoid DFS(int x, int fa) &#123;\n    if (~fa &amp;&amp; (int)g[x].size() == 1)\n        beg[x] = to[x] = ++now;\n    for (auto i : g[x]) &#123;\n        if (i == fa) continue;\n        DFS(i, x);\n        if (!beg[x]) beg[x] = beg[i];\n        to[x] = to[i];\n    &#125;\n    t[x] = _(beg[x], to[x] + 1, x);\n    return;\n&#125;\nvoid add(int x, int y) &#123;\n    g[x].push_back(y);\n    return;\n&#125;\nint main() &#123;\n    read(n);\n    for (int i = 1; i &lt;= n; ++i) read(a[i]);\n    for (int i = 1; i &lt;= n + 1; ++i) f[i] = i;\n    for (int i = 1; i &lt; n; ++i) &#123;\n        read(x), read(y);\n        add(x, y), add(y, x);\n    &#125;\n    DFS(1, -1);\n    std::sort(t + 1, t + n + 1);\n    for (int l = 1, r = 0; l &lt;= n; l = r + 1) &#123;\n        while (r &lt; n &amp;&amp; a[t[r + 1].i] == a[t[l].i]) ++r;\n        for (int i = l; i &lt;= r; ++i) &#123;\n            if (find(t[i].x) != find(t[i].y))\n                res.push_back(t[i].i);\n        &#125;\n        for (int i = l; i &lt;= r; ++i) &#123;\n            if (find(t[i].x) != find(t[i].y))\n                sum += a[t[i].i], merge(t[i].x, t[i].y);\n        &#125;\n    &#125;\n    std::sort(res.begin(), res.end());\n    print(sum, &#39; &#39;), print(res.size(), &#39;\\n&#39;);\n    for (auto i : res) print(i, &#39; &#39;);\n    putchar(&#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int\nint main() &#123;\n    XSC062::main();\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"another-minimum-spanning-tree\">Another Minimum Spanning Tree</h2>\n<p><a href=\"https://www.becoder.com.cn/problem/29212\" class=\"uri\">https://www.becoder.com.cn/problem/29212</a></p>\n<p>goto <a href=\"/20240206/\">曼哈顿最小距离生成树</a>。</p>\n<hr />\n<h2 id=\"a---design-tutorial-inverse-the-problem\">A - Design Tutorial: Inverse the Problem</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF472D\" class=\"uri\">https://www.luogu.com.cn/problem/CF472D</a></p>\n<ul>\n<li>发现给出的完全图的最小生成树就是原树。check 一下是否合法即可。</li>\n<li>图较稠密，需要用 Prim。</li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(n + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; g0(n + 1, std::vector&lt;int&gt; (n + 1));\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = 1; j &lt;= n; ++j)\n            std::cin &gt;&gt; g0[i][j];\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        if (g0[i][i] != 0) &#123;\n            std::cout &lt;&lt; &quot;NO\\n&quot;;\n            return 0;\n        &#125;\n        for (int j = 1; j &lt; i; ++j)\n            if (g0[i][j] != g0[j][i] || !g0[i][j]) &#123;\n                std::cout &lt;&lt; &quot;NO\\n&quot;;\n                return 0;\n            &#125;\n    &#125;\n    std::vector&lt;int&gt; pos(n + 1), tag(n + 1);\n    tag[1] = 1;\n    for (int _ = 1, s = 1; _ &lt; n; ++_) &#123;\n        for (int i = 1; i &lt;= n; ++i)\n            if (!tag[i] &amp;&amp; (!pos[i] || g0[s][i] &lt; g0[pos[i]][i]))\n                pos[i] = s;\n        s = 0;\n        int t = 0;\n        for (int i = 1; i &lt;= n; ++i)\n            if (!tag[i] &amp;&amp; pos[i] &amp;&amp; (!s || g0[pos[i]][i] &lt; g0[pos[s]][s]))\n                s = i, t = pos[i];\n        tag[s] = 1;\n        g[s].emplace_back(t, g0[s][t]), g[t].emplace_back(s, g0[s][t]);\n    &#125;\n    std::vector&lt;int&gt; tab(n + 1), dis(n + 1);\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        static int now = 0;\n        tab[++now] = x;\n        int L = now, R = now;\n        for (auto [i, w] : g[x])\n            if (i != fa) &#123;\n                dis[i] = dis[x] + w;\n                DFS(i, x);\n                for (int p = L; p &lt;= R; ++p)\n                    for (int q = R + 1; q &lt;= now; ++q) &#123;\n                        if (g0[tab[p]][tab[q]] != dis[tab[p]] + dis[tab[q]] - 2 * dis[x]) &#123;\n                            std::cout &lt;&lt; &quot;NO\\n&quot;;\n                            exit(0); // extremely ugly\n                        &#125;\n                    &#125;\n                R = now;\n            &#125;\n        return;\n    &#125;;\n    DFS(1, -1);\n    std::cout &lt;&lt; &quot;YES\\n&quot;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---phoenix-and-earthquake\">B - Phoenix and Earthquake</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1515F\" class=\"uri\">https://www.luogu.com.cn/problem/CF1515F</a></p>\n<ul>\n<li><p>会想到，有解的充要条件是的点权之和 <span class=\"math inline\">\\(\\ge (n-1)\\cdot x\\)</span>。证明方法很广泛，但规约的思想对破题是决定性的。</p>\n<ul>\n<li><p>对于 <span class=\"math inline\">\\(u\\ge x\\)</span>，将 <span class=\"math inline\">\\(u\\)</span> 和任意相邻点合并后缩点，规约为更小规模的问题。</p></li>\n<li><p>对于 <span class=\"math inline\">\\(u&lt;x\\)</span>，一次合并使点权和减少 <span class=\"math inline\">\\(u\\)</span>，点权需求减少 <span class=\"math inline\">\\(x\\)</span>，故子问题合法则该问题合法。</p></li>\n</ul></li>\n<li><p>条件是充要的，则可以任意合并，但这样不太好做，考虑借助规约的结构，若 <span class=\"math inline\">\\(u\\ge x\\)</span> 则直接合并，否则等到其他部分合并完后再合并这一条边。这是一个栈的结构。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m, k;\n    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;\n    std::vector&lt;long long&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    if (std::accumulate(a.begin() + 1, a.end(), 0ll) &lt; (long long)k * (n - 1)) &#123;\n        std::cout &lt;&lt; &quot;NO\\n&quot;;\n        return 0;\n    &#125;\n    std::cout &lt;&lt; &quot;YES\\n&quot;;\n    std::vector&lt;int&gt; f(n + 1);\n    std::iota(f.begin() + 1, f.end(), 1);\n    std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;\n        return x == f[x] ? x : f[x] = find(f[x]);\n    &#125;;\n    auto merge = [&amp;](int x, int y) &#123;\n        f[find(x)] = find(y);\n        return;\n    &#125;;\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(n + 1);\n    for (int i = 1, x, y; m--; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        if (find(x) != find(y)) &#123;\n            g[x].emplace_back(y, i);\n            g[y].emplace_back(x, i);\n            merge(x, y);\n        &#125;\n    &#125;\n    std::vector&lt;int&gt; t;\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        for (auto [i, id] : g[x])\n            if (i != fa) &#123;\n                DFS(i, x);\n                if (a[i] &gt;= k) &#123;\n                    a[x] += a[i] - k;\n                    std::cout &lt;&lt; id &lt;&lt; &#39;\\n&#39;;\n                &#125;\n                else\n                    t.push_back(id);\n            &#125;\n        return;\n    &#125;;\n    DFS(1, -1);\n    for (; !t.empty(); t.pop_back())\n        std::cout &lt;&lt; t.back() &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"最小度限制生成树-easy-version\">最小度限制生成树 (Easy Version)</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P5633\" class=\"uri\">https://www.luogu.com.cn/problem/P5633</a></p>\n<blockquote>\n<p>要求：两只 log。</p>\n</blockquote>\n<p>wqs 二分即可。</p>\n<hr />\n<h2 id=\"最小度限制生成树-hard-version\">最小度限制生成树 (Hard Version)</h2>\n<blockquote>\n<p>要求：一只 log。</p>\n</blockquote>\n<p>注意到涉及的边是固定的，且偏移量相同，故对于『与 <span class=\"math inline\">\\(s\\)</span> 有关的边』和『与 <span class=\"math inline\">\\(s\\)</span> 无关的边』先分别排序作为预处理，二分内部仅需归并即可。</p>\n<hr />\n<h2 id=\"最小度限制生成树-extreme-version\">最小度限制生成树 (Extreme Version)</h2>\n<blockquote>\n<p>要求：</p>\n<ul>\n<li>一只 log；</li>\n<li>对于 <span class=\"math inline\">\\(k=1,2,\\cdots,n\\)</span>，分别输出答案。</li>\n</ul>\n</blockquote>\n<p>观看 <a href=\"https://www.luogu.com.cn/article/ym8ixzr8\" class=\"uri\">https://www.luogu.com.cn/article/ym8ixzr8</a>。</p>\n",
            "tags": [
                "最小生成树"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250924/",
            "url": "https://xsc062.netlify.app/20250924/",
            "title": "杂题选谈：最短路",
            "date_published": "2025-09-24T06:27:15.000Z",
            "content_html": "<p>最短路为背景的题 + 做法是最短路的题</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a---minimum-path\">A - Minimum Path</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1473E\" class=\"uri\">https://www.luogu.com.cn/problem/CF1473E</a></p>\n<ul>\n<li>经典套路，发现可以把 max 和 min 换成任意路径中的边，然后 max 和 min 就会最小化这个式子</li>\n<li>故写一个 Dijkstra + DP，求这个式子的最小值即可</li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    using arr = std::vector&lt;long long&gt;;\n    using brr = std::vector&lt;arr&gt;;\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(n + 1);\n    std::vector&lt;brr&gt; dis(2, brr(2, arr(n + 1, 1e18))), vis(2, brr(2, arr(n + 1)));\n    for (int x, y, w; m--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;\n        g[x].emplace_back(y, w);\n        g[y].emplace_back(x, w);\n    &#125;\n    dis[0][0][1] = 0;\n    std::array&lt;std::array&lt;std::priority_queue&lt;std::pair&lt;long long, int&gt; &gt;, 2&gt;, 2&gt; q;\n    q[0][0].emplace(0, 1);\n    for (int i = 0; i &lt; 2; ++i) &#123;\n        for (int j = 0; j &lt; 2; ++j) &#123;\n            for (; !q[i][j].empty(); ) &#123;\n                int f = q[i][j].top().second;\n                q[i][j].pop();\n                if (vis[i][j][f])\n                    continue;\n                vis[i][j][f] = 1;\n                for (auto k : g[f]) &#123;\n                    if (dis[i][j][k.first] &gt; dis[i][j][f] + k.second) &#123;\n                        dis[i][j][k.first] = dis[i][j][f] + k.second;\n                        q[i][j].emplace(-dis[i][j][k.first], k.first);\n                    &#125;\n                    if (!i &amp;&amp; dis[1][j][k.first] &gt; dis[i][j][f]) &#123;\n                        dis[1][j][k.first] = dis[i][j][f];\n                        q[1][j].emplace(-dis[1][j][k.first], k.first);\n                    &#125;\n                    if (!j &amp;&amp; dis[i][1][k.first] &gt; dis[i][j][f] + 2 * k.second) &#123;\n                        dis[i][1][k.first] = dis[i][j][f] + 2 * k.second;\n                        q[i][1].emplace(-dis[i][1][k.first], k.first);\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    for (int i = 2; i &lt;= n; ++i)\n        std::cout &lt;&lt; std::min(&#123; dis[0][0][i], dis[1][1][i] &#125;) &lt;&lt; &#39; &#39;;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---train-delay\">B - Train Delay</h2>\n<p><a href=\"https://vjudge.net/contest/750645#problem/B\" class=\"uri\">https://vjudge.net/contest/750645#problem/B</a></p>\n<ul>\n<li>简化题目很重要的一个转化是<strong>由于 <span class=\"math inline\">\\(S\\le T\\)</span> 带来的 <span class=\"math inline\">\\(S\\)</span> 和 <span class=\"math inline\">\\(T\\)</span> 地位平等，考虑把出发和到达分别看作一次事件处理。</strong></li>\n<li><p>按照所有事件的发生时刻排序，有：</p>\n<ul>\n<li>对于一次出发事件，可以得到在其之前该站点所有到达事件的 <span class=\"math inline\">\\(\\max\\{T&#39;\\}\\)</span>，用之更新 <span class=\"math inline\">\\(X\\)</span> 即可。</li>\n<li>对于一次到达事件，由于对应的 <span class=\"math inline\">\\(X\\)</span> 已经确定，更新该站点当前最大值即可。</li>\n</ul></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;int&gt; d(m + 1);\n    std::cin &gt;&gt; d[1];\n    struct event &#123;\n        int t, op, id, x;\n    &#125;;\n    std::vector&lt;event&gt; a;\n    std::vector&lt;int&gt; mx(n + 1);\n    for (int i = 1, x, y, s, t; i &lt;= m; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; s &gt;&gt; t;\n        a.push_back(&#123; s, 0, i, x &#125;);\n        a.push_back(&#123; t, 1, i, y &#125;);\n    &#125;\n    std::sort(a.begin(), a.end(), [&amp;](event &amp;x, event &amp;y) &#123; return x.t == y.t ? x.op &gt; y.op : x.t &lt; y.t; &#125;);\n    for (auto [t, op, id, x] : a)\n        if (op == 1)\n            mx[x] = std::max(mx[x], t + d[id]);\n        else if (id != 1)\n            d[id] = std::max(mx[x] - t, 0);\n    for (int i = 2; i &lt;= m; ++i)\n        std::cout &lt;&lt; d[i] &lt;&lt; &#39; &#39;;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---complete-the-graph\">C - Complete The Graph</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF715B\" class=\"uri\">https://www.luogu.com.cn/problem/CF715B</a></p>\n<p>神仙二分</p>\n<ul>\n<li>如果初始把所有白边置为 <span class=\"math inline\">\\(1\\)</span>，那么会想到调整法构造</li>\n<li>但是不知道应该在哪些边上调整，确定调整多少似乎也没有什么简单的做法</li>\n<li><p>故<strong>平均用力</strong>，构造一个 边1 += 1，边2 += 1，边3 += 1, …, 边cnt0 += 1, 边1 += 1, 边2 += 1, … 的操作序列</p>\n容易<strong>发现每次操作最多让当前最短路长度增加 1</strong>，而且有单调性</li>\n<li><p>故二分答案即可</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst __int128 inf = 1e18;\nconst __int128 inff = 1e23;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m, s, t, l, cnt = 0;\n    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; l &gt;&gt; s &gt;&gt; t, ++s, ++t;\n    std::vector&lt;std::tuple&lt;int, int, long long&gt; &gt; u(m + 1);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, long long&gt; &gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt;= m; ++i) &#123;\n        long long w;\n        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; w, ++x, ++y;\n        if (w == 0)\n            w = -(++cnt);\n        g[x].emplace_back(y, w), g[y].emplace_back(x, w);\n        u[i] = &#123; x, y, w &#125;;\n    &#125;\n    std::vector&lt;int&gt; vis(n + 1);\n    std::vector&lt;__int128&gt; dis(n + 1);\n    std::vector&lt;long long&gt; k(cnt + 1);\n    __int128 res = -1;\n    auto check = [&amp;](__int128 x) &#123;\n        for (int i = 1; i &lt;= cnt; ++i)\n            k[i] = x / cnt + (i &lt;= x % cnt);\n        std::fill(vis.begin() + 1, vis.end(), 0);\n        std::fill(dis.begin() + 1, dis.end(), inf);\n        std::priority_queue&lt;std::pair&lt;__int128, int&gt; &gt; q;\n        dis[s] = 0, q.emplace(0, s);\n        for (; !q.empty(); ) &#123;\n            int f = q.top().second;\n            q.pop();\n            if (vis[f])\n                continue;\n            vis[f] = 1;\n            for (auto [v, w] : g[f]) &#123;\n                if (w &lt; 0)\n                    w = k[-w];\n                if (dis[v] &gt; dis[f] + w) &#123;\n                    dis[v] = dis[f] + w;\n                    q.emplace(-dis[v], v);\n                &#125;\n            &#125;\n        &#125;\n        return dis[t] &lt;= l;\n    &#125;;\n    for (__int128 l = cnt, r = cnt * inf, mid; l &lt;= r; ) &#123;\n        mid = (l + r) &gt;&gt; 1;\n        if (check(mid))\n            res = mid, l = mid + 1;\n        else\n            r = mid - 1;\n    &#125;\n    if (res == -1)\n        std::cout &lt;&lt; &quot;NO\\n&quot;;\n    else &#123;\n        check(res);\n        if (dis[t] != l)\n            std::cout &lt;&lt; &quot;NO\\n&quot;;\n        else &#123;\n            std::cout &lt;&lt; &quot;YES\\n&quot;;\n            for (int i = 1; i &lt;= m; ++i) &#123;\n                auto [x, y, w] = u[i];\n                if (w &lt; 0)\n                    w = k[-w];\n                std::cout &lt;&lt; x - 1 &lt;&lt; &#39; &#39; &lt;&lt; y - 1 &lt;&lt; &#39; &#39; &lt;&lt; w &lt;&lt; &#39;\\n&#39;;\n            &#125;\n        &#125;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"a---重力球\">A - 重力球</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P7473\" class=\"uri\">https://www.luogu.com.cn/problem/P7473</a></p>\n<ul>\n<li><span class=\"math inline\">\\(m\\)</span> 相对很小，看看有没有什么基于 <span class=\"math inline\">\\(m\\)</span> 的做法</li>\n<li>每次球停下的位置一定是某个障碍物（或边界）上 / 下 / 左 / 右的格子，故可以在这 <span class=\"math inline\">\\(O(n + m)\\)</span> 个点上建图</li>\n<li>怎么同时维护两个球的信息呢，发现 <span class=\"math inline\">\\(m\\)</span> 还是很小，所以可以把两个球塞一起作为一个状态</li>\n<li><p><span class=\"math inline\">\\(m^2\\)</span> 次 Dij 还是太激进了 进一步思考发现可能的终点共 <span class=\"math inline\">\\(m\\)</span> 个 并且彼此不区分</p>\n<p>故以这 <span class=\"math inline\">\\(m\\)</span> 个终点跑多源最短路即可</p>\n<p>但 5e6 跑 Dij 还是太勉强了。<strong>发现边权为 1，为什么不 BFS 呢 😅</strong></p></li>\n<li><p>发现起点可能不在我们限定的点上，但可以人为选择一次重力方向，然后就回到刚刚的问题了</p>\n<p>或者离线也是一种方法</p></li>\n</ul>\n<p>疑似常数太大，拼尽全力勉强卡过</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int LEN = (1 &lt;&lt; 20);\n#ifdef ONLINE_JUDGE\ninline int nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf)\n            return EOF;\n        p = buf;\n    &#125;\n    return *p++;\n&#125;\n#else\n#define nec getchar\n#endif\ninline bool read(int &amp;x) &#123;\n    x = 0;\n    bool f = 0;\n    char ch = nec();\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF)\n            return 0;\n        if (ch == &#39;-&#39;)\n            f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f)\n        x = -x;\n    return 1;\n&#125;\nvoid print(int x) &#123;\n    if (x &lt; 0) &#123;\n        putchar(&#39;-&#39;);\n        x = -x;\n    &#125;\n    if (x &gt;= 10)\n        print(x / 10);\n    putchar(x % 10 + &#39;0&#39;);\n    return;\n&#125;\nvoid print(int x, char ch) &#123;\n    print(x);\n    putchar(ch);\n    return;\n&#125;\nconst int inf = 0x3f3f3f3f;\nconst int dir[][2] = &#123;&#123; -1, 0 &#125;, &#123; 1, 0 &#125;, &#123; 0, -1 &#125;, &#123; 0, 1 &#125;&#125;;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m, q;\n    read(n), read(m), read(q);\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; pos(m + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; a(n + 1, std::vector&lt;int&gt; (n + 1));\n    for (int i = 1, x, y; i &lt;= m; ++i) &#123;\n        read(x), read(y);\n        pos[i] = &#123; x, y &#125;, a[x][y] = -1;\n    &#125;\n    for (int i = 1; i &lt;= n; ++i)\n        pos.emplace_back(0, i), ++m;\n    for (int i = 1; i &lt;= n; ++i)\n        pos.emplace_back(i, n + 1), ++m;\n    for (int i = 1; i &lt;= n; ++i)\n        pos.emplace_back(n + 1, i), ++m;\n    for (int i = 1; i &lt;= n; ++i)\n        pos.emplace_back(i, 0), ++m;\n    int cnt = 0;\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; u(1);\n    for (int i = 1; i &lt;= m; ++i)\n        for (auto [fx, fy] : dir) &#123;\n            int nx = pos[i].first + fx, ny = pos[i].second + fy;\n            if (nx &gt;= 1 &amp;&amp; nx &lt;= n &amp;&amp; ny &gt;= 1 &amp;&amp; ny &lt;= n &amp;&amp; !a[nx][ny])\n                a[nx][ny] = ++cnt, u.emplace_back(nx, ny);\n        &#125;\n    std::vector&lt;std::vector&lt;std::array&lt;int, 4&gt; &gt; &gt; top(n + 1, std::vector&lt;std::array&lt;int, 4&gt; &gt; (n + 1));\n    for (int j = 1; j &lt;= n; ++j) &#123;\n        for (int i = 1; i &lt;= n; ++i)\n            if (a[i][j] != -1) &#123;\n                if (i == 1 || a[i - 1][j] == -1)\n                    top[i][j][0] = a[i][j];\n                else\n                    top[i][j][0] = top[i - 1][j][0];\n            &#125;\n        for (int i = n; i; --i)\n            if (a[i][j] != -1) &#123;\n                if (i == n || a[i + 1][j] == -1)\n                    top[i][j][1] = a[i][j];\n                else\n                    top[i][j][1] = top[i + 1][j][1];\n            &#125;\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = 1; j &lt;= n; ++j)\n            if (a[i][j] != -1) &#123;\n                if (j == 1 || a[i][j - 1] == -1)\n                    top[i][j][2] = a[i][j];\n                else\n                    top[i][j][2] = top[i][j - 1][2];\n            &#125;\n        for (int j = n; j; --j)\n            if (a[i][j] != -1) &#123;\n                if (j == n || a[i][j + 1] == -1)\n                    top[i][j][3] = a[i][j];\n                else\n                    top[i][j][3] = top[i][j + 1][3];\n            &#125;\n    &#125;\n    const int N = cnt * cnt;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(N + 1);\n    auto encode = [&amp;](int x, int y) &#123;\n        return (x - 1) * cnt + y;\n    &#125;;\n    auto decode = [&amp;](int id) &#123;\n        return std::make_pair((id - 1) / cnt + 1, (id - 1) % cnt + 1);\n    &#125;;\n    for (int i = 1; i &lt;= N; ++i)\n        for (int j = 0; j &lt; 4; ++j) &#123;\n            auto [a, b] = decode(i);\n            g[encode(top[u[a].first][u[a].second][j], top[u[b].first][u[b].second][j])].emplace_back(i);\n        &#125;\n    std::vector&lt;int&gt; dis(N + 1, inf), vis(N + 1);\n    &#123;\n        std::queue&lt;int&gt; q;\n        for (int i = 1; i &lt;= cnt; ++i)\n            dis[encode(i, i)] = 0, q.push(encode(i, i)), vis[encode(i, i)] = 1;\n        for (; !q.empty(); ) &#123;\n            int x = q.front();\n            q.pop();\n            for (auto i : g[x])\n                if (!vis[i])\n                    dis[i] = dis[x] + 1, vis[i] = 1, q.push(i);\n        &#125;\n    &#125;\n    for (int a, b, c, d; q--; ) &#123;\n        read(a), read(b), read(c), read(d);\n        if (a == c &amp;&amp; b == d)\n            print(0, &#39;\\n&#39;);\n        else &#123;\n            int res = inf;\n            for (int j = 0; j &lt; 4; ++j)\n                res = std::min(res, dis[encode(top[a][b][j], top[c][d][j])] + 1);\n            if (res == inf)\n                print(-1, &#39;\\n&#39;);\n            else\n                print(res, &#39;\\n&#39;);\n        &#125;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---矩阵游戏\">B - 矩阵游戏</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P7515\" class=\"uri\">https://www.luogu.com.cn/problem/P7515</a></p>\n<ul>\n<li><p>把问题形式化一下，现在有 <span class=\"math inline\">\\(n\\times m\\)</span> 个未知数和 <span class=\"math inline\">\\((n-1)\\times (m-1)\\)</span> 个方程</p>\n<p>那么可以对边上一圈任意赋值，限制是左上角这 <span class=\"math inline\">\\((n-1)\\times (m-1)\\)</span> 个未知数必须落在 <span class=\"math inline\">\\([0,10^6]\\)</span> 上</p></li>\n<li>有一个很容易观察到的性质，对于一个 <span class=\"math inline\">\\(a\\)</span>，选取一个 <span class=\"math inline\">\\(v\\)</span>，并把棋盘黑白染色，那么把所有黑格 <span class=\"math inline\">\\(+=v\\)</span>，白格 <span class=\"math inline\">\\(-=v\\)</span>，对应的 <span class=\"math inline\">\\(b\\)</span> 是不会变的。</li>\n<li><p><strong>这个操作是涉及全局的，太苛刻了</strong>，有没有什么更 mild 的构造？</p>\n<p>发现只对一行 / 列黑白染色并操作也可以得到相同的结果。能感受到<strong>操作无法再简化了</strong>。考虑用这个版本的操作<strong>调整</strong>。</p></li>\n<li>故大力令周围一圈的临时解 <span class=\"math inline\">\\(a&#39;\\)</span> 为 <span class=\"math inline\">\\(0\\)</span>，令每行、列的调整 delta 为 <span class=\"math inline\">\\(r_i,c_i\\)</span>，可以得到若干个关于 <span class=\"math inline\">\\(0\\)</span> 和 <span class=\"math inline\">\\(10^6\\)</span> 的约束。最后建出来一个完全二分图状物，跑差分约束即可，容易发现复杂度正确。</li>\n<li><p>实现技巧：规划一下 <span class=\"math inline\">\\(r\\)</span> 和 <span class=\"math inline\">\\(c\\)</span> 的染色方式，使得它们错开，可以把所有位置都写作 <span class=\"math inline\">\\(a&#39;_{i,j}+c-r\\)</span> 或 <span class=\"math inline\">\\(a&#39;_{i,j}+r-c\\)</span> 的形式，便于差分约束</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code></code></pre>\n</details>\n<hr />\n<h2 id=\"c---tax\">C - Tax</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P6822\" class=\"uri\">https://www.luogu.com.cn/problem/P6822</a></p>\n<ul>\n<li>容易想到分类讨论，如果钦定是入边贡献边权，那么出边边权不能大于入边边权；否则，出边贡献边权。</li>\n<li>考虑把每个点上的出边按边权从小到大排序，显然需要入边贡献的是一段前缀，需要出边贡献的是一段后缀，就可以做一个前后缀优化建图。</li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst long long inf = 1e18;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    struct edge &#123; int v, w, id, pi, si; &#125;;\n    std::vector&lt;std::vector&lt;edge&gt; &gt; g1(n + 2);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(1);\n    int cnt = 0;\n    for (int x, y, w; m--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;\n        g1[x].push_back(&#123; y, w, ++cnt, 0, 0 &#125;);\n        g1[y].push_back(&#123; x, w, ++cnt, 0, 0 &#125;);\n        g.emplace_back(), g.emplace_back();\n    &#125;\n    int s = ++cnt, t = ++cnt;\n    g1[0].push_back(&#123; 1, 0, s, 0, 0 &#125;), g1[n].push_back(&#123; n + 1, 0, t, 0, 0 &#125;);\n    g.emplace_back(), g.emplace_back();\n    for (int i = 0; i &lt;= n + 1; ++i)\n        if (!g1[i].empty()) &#123;\n            std::sort(g1[i].begin(), g1[i].end(), [&amp;](edge &amp;x, edge &amp;y) &#123; return x.w &lt; y.w; &#125;);\n            for (int j = 0; j &lt; (int)g1[i].size(); ++j) &#123;\n                g1[i][j].pi = ++cnt, g.emplace_back();\n                if (j != 0)\n                    g[cnt].emplace_back(cnt - 1, 0);\n                g[cnt].emplace_back(g1[i][j].id, 0);\n            &#125;\n            for (int j = (int)g1[i].size() - 1; ~j; --j) &#123;\n                g1[i][j].si = ++cnt, g.emplace_back();\n                if (j != (int)g1[i].size() - 1)\n                    g[cnt].emplace_back(cnt - 1, 0);\n                g[cnt].emplace_back(g1[i][j].id, g1[i][j].w);\n            &#125;\n        &#125;\n    for (int i = 0; i &lt;= n + 1; ++i)\n        for (auto &amp;[v, w, id, pi, si] : g1[i]) &#123;\n            auto to = std::upper_bound(g1[v].begin(), g1[v].end(), w, [&amp;](int x, edge &amp;y) &#123; return x &lt; y.w; &#125;);\n            if (to != g1[v].end())\n                g[id].emplace_back(to-&gt;si, 0);\n            if (to != g1[v].begin())\n                g[id].emplace_back((--to)-&gt;pi, w);\n        &#125;\n    std::vector&lt;int&gt; vis(cnt + 1, 0);\n    std::vector&lt;long long&gt; dis(cnt + 1, inf);\n    std::priority_queue&lt;std::pair&lt;long long, int&gt; &gt; q;\n    dis[s] = 0, q.emplace(0, s);\n    for (; !q.empty(); ) &#123;\n        int f = q.top().second;\n        q.pop();\n        if (vis[f])\n            continue;\n        vis[f] = 1;\n        for (auto [v, w] : g[f])\n            if (dis[v] &gt; dis[f] + w) &#123;\n                dis[v] = dis[f] + w;\n                q.emplace(-dis[v], v);\n            &#125;\n    &#125;\n    std::cout &lt;&lt; dis[t] &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d---travelling-through-the-snow-queens-kingdom\">D - Travelling Through the Snow Queen’s Kingdom</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF685E\" class=\"uri\">https://www.luogu.com.cn/problem/CF685E</a></p>\n<p>目前见过的数据范围提示性极弱（误导性极强）的循环结构题：</p>\n<ul>\n<li>[BZOJ3620] 似乎在梦中见过的样子</li>\n<li><a href=\"/20240906/#字符合并\">字符合并</a></li>\n<li><a href=\"/20250907/#e---subset-product-problem\">[ARC205E] Subset Product Problem</a></li>\n</ul>\n<p>正赛因为有部分分，应该不会出现不敢写的问题</p>\n<ul>\n<li>考虑离线询问，逆序加边；原文无边权；边的通行时刻只决定到达点的时刻。</li>\n<li><p>借鉴 <a href=\"/20231113/#b.-商人\">merchant</a> 中的思路，只需要更新当前边两侧点为起点的 DP 数组。</p>\n<p>需要注意边从某种意义上说是『有向』的。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int inf = 0x3f3f3f3f;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m, q;\n    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;\n    struct query &#123; int r, s, t, id; &#125;;\n    std::vector&lt;int&gt; res(q + 1);\n    std::vector&lt;std::vector&lt;query&gt; &gt; u(m + 1);\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; e(m + 1);\n    for (int i = 1; i &lt;= m; ++i)\n        std::cin &gt;&gt; e[i].first &gt;&gt; e[i].second;\n    for (int i = 1, l, r, s, t; i &lt;= q; ++i) &#123;\n        std::cin &gt;&gt; l &gt;&gt; r &gt;&gt; s &gt;&gt; t;\n        u[l].push_back(&#123; r, s, t, i &#125;);\n    &#125;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1, std::vector&lt;int&gt; (n + 1, inf));\n    for (int i = m; i; --i) &#123;\n        auto [x, y] = e[i];\n        g[x][y] = g[y][x] = i;\n        for (int j = 1; j &lt;= n; ++j)\n            g[x][j] = g[y][j] = std::min(g[x][j], g[y][j]);\n        for (auto [r, s, t, id] : u[i])\n            if (g[s][t] &lt;= r)\n                res[id] = 1;\n    &#125;\n    for (int i = 1; i &lt;= q; ++i)\n        std::cout &lt;&lt; (res[i] ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"e---culture-code\">E - Culture Code</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1197E\" class=\"uri\">https://www.luogu.com.cn/problem/CF1197E</a></p>\n<ul>\n<li>先按 <span class=\"math inline\">\\(out\\)</span> 排序，做一个前缀优化建图。</li>\n<li><p>容易发现除了最外层，每一个套娃都会提供 <span class=\"math inline\">\\(in_i-out_i\\)</span> 的代价，而最外层会提供 <span class=\"math inline\">\\(in_x\\)</span> 的代价。</p>\n<del>好在要求的是最长路，这样就可以 Dij 了</del>，并不需要真正把图建出来，发现这个形式更序列，直接在序列上二分前缀 + DP 即可。</li>\n<li><p>求方案是容易的。最后统计 DP 值最大，<strong>且不能被其他套娃包含的元素</strong>即可。</p>\n<p>Tip：在求解过程中并不用考虑当前元素和前缀 min 元素间能否加入其他套娃，因为保证 <span class=\"math inline\">\\(out&gt;in\\)</span>，如果存在这样的套娃，其 DP 值会比前缀 min 更小，矛盾。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; a(n + 1);\n    int mxi = 0;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i].first &gt;&gt; a[i].second;\n        mxi = std::max(mxi, a[i].second);\n    &#125;\n    std::sort(a.begin() + 1, a.end());\n    std::vector&lt;long long&gt; g(n + 1), mxg(n + 1), f(n + 1), mx(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        int j = std::upper_bound(a.begin() + 1, a.begin() + i, std::make_pair(a[i].second, 0x3f3f3f3f)) - a.begin() - 1;\n        if (j == 0)\n            f[i] = a[i].second, g[i] = 1ll;\n        else\n            f[i] = mx[j] + a[i].second, g[i] = mxg[j];\n        long long now = f[i] - a[i].first;\n        if (now &lt; mx[i - 1])\n            mx[i] = now, mxg[i] = g[i];\n        else if (now == mx[i - 1])\n            mx[i] = now, mxg[i] = (mxg[i - 1] + g[i]) % mod;\n        else\n            mx[i] = mx[i - 1], mxg[i] = mxg[i - 1];\n    &#125;\n    auto now = 0x3f3f3f3fll, res = 0ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        if (a[i].first &lt;= mxi)\n            continue;\n        if (f[i] &lt; now)\n            now = f[i], res = g[i];\n        else if (f[i] == now)\n            (res += g[i]) %= mod;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"a---awesome-arrowland-adventure\">A - Awesome Arrowland Adventure</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P6233\" class=\"uri\">https://www.luogu.com.cn/problem/P6233</a></p>\n<ul>\n<li>没什么好说的建图，注意只能顺时针转</li>\n<li>代码略</li>\n</ul>\n<hr />\n<h2 id=\"b---地铁线路\">B - 地铁线路</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P6096\" class=\"uri\">https://www.luogu.com.cn/problem/P6096</a></p>\n<ul>\n<li>考虑做一个神秘拆点，把每个点附上线路和运行方向的信息（所以是单向的）</li>\n<li>认为路径代价是二元组，那么同条线路中的点通行代价为 <span class=\"math inline\">\\((0,-1)\\)</span></li>\n<li>换乘需要优化建图，每个点可以花 <span class=\"math inline\">\\((0,0)\\)</span> 的代价走到这个点的『换乘点』，再花 <span class=\"math inline\">\\((1,0)\\)</span> 的代价走到另一个分点</li>\n<li><p>但 <strong>15 年的时候 SPFA 已经死了</strong>，所以需要好好考虑怎么实现最短路。</p>\n<p>分两问是有提示性在的，可以想到 01 BFS 解决第一个关键字，比较对的想法是<strong>把所有最短路拿出来形成 DAG，在 DAG 上对第二关键字 DP</strong>。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m;\n    std::cin &gt;&gt; m &gt;&gt; n;\n    std::unordered_map&lt;std::string, int&gt; tab;\n    std::vector&lt;std::vector&lt;int&gt; &gt; l(n + 1);\n    std::vector&lt;std::vector&lt;std::tuple&lt;int, int, int&gt; &gt; &gt; g0(n + 1), g1(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::string s;\n        std::cin &gt;&gt; s, tab[s] = i;\n    &#125;\n    int tot = n;\n    for (int i = 1, k; i &lt;= m; ++i) &#123;\n        std::cin &gt;&gt; k;\n        int lp = 0, lq = 0;\n        for (std::string s; k--; ) &#123;\n            std::cin &gt;&gt; s;\n            int p = ++tot, q = ++tot, id = tab[s];\n            g0.emplace_back(), g0.emplace_back();\n            g1.emplace_back(), g1.emplace_back();\n            if (lp) &#123;\n                g0[p].emplace_back(lp, 0, 1), g0[lq].emplace_back(q, 0, 1);\n                g1[lp].emplace_back(p, 0, 1), g1[q].emplace_back(lq, 0, 1);\n            &#125;\n            g0[p].emplace_back(id, 0, 0), g0[id].emplace_back(p, 1, 0);\n            g1[id].emplace_back(p, 0, 0), g1[p].emplace_back(id, 1, 0);\n            g0[q].emplace_back(id, 0, 0), g0[id].emplace_back(q, 1, 0);\n            g1[id].emplace_back(q, 0, 0), g1[q].emplace_back(id, 1, 0);\n            l[id].push_back(p), l[id].push_back(q);\n            lp = p, lq = q;\n        &#125;\n    &#125;\n    int s, t;\n    &#123;\n        std::string s1, s2;\n        std::cin &gt;&gt; s1 &gt;&gt; s2;\n        s = ++tot, t = tab[s2];\n        g0.emplace_back(), g1.emplace_back();\n        int p = tab[s1];\n        for (auto i : l[p])\n            g0[s].emplace_back(i, 1, 0), g1[i].emplace_back(s, 1, 0);\n    &#125;\n    std::vector&lt;int&gt; dis0(tot + 1, 0x3f3f3f3f), dis1(tot + 1, 0x3f3f3f3f);\n    auto BFS = [&amp;](decltype(g0) &amp;g, decltype(dis0) &amp;dis, int s) &#123;\n        std::deque&lt;int&gt; q;\n        std::vector&lt;int&gt; vis(tot + 1);\n        q.push_back(s), dis[s] = 0;\n        for (; !q.empty(); ) &#123;\n            int x = q.front();\n            q.pop_front();\n            if (vis[x])\n                continue;\n            vis[x] = 1;\n            for (auto [v, w1, w2] : g[x])\n                if (dis[x] + w1 &lt; dis[v]) &#123;\n                    dis[v] = dis[x] + w1;\n                    if (w1 == 0)\n                        q.push_front(v);\n                    else\n                        q.push_back(v);\n                &#125;\n        &#125;\n        return;\n    &#125;;\n    BFS(g0, dis0, s), BFS(g1, dis1, t);\n    std::cout &lt;&lt; dis0[t] &lt;&lt; &#39;\\n&#39;;\n    std::vector&lt;int&gt; deg(tot + 1);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(tot + 1);\n    for (int i = 1; i &lt;= tot; ++i)\n        for (auto [j, w1, w2] : g0[i])\n            if (dis0[i] + dis1[j] + w1 == dis0[t])\n                g[i].emplace_back(j, w2), ++deg[j];\n    std::queue&lt;int&gt; q;\n    for (int i = 1; i &lt;= tot; ++i)\n        if (!deg[i])\n            q.push(i);\n    std::vector&lt;int&gt; f(tot + 1);\n    for (; !q.empty(); ) &#123;\n        int x = q.front();\n        q.pop();\n        for (auto [v, w] : g[x]) &#123;\n            f[v] = std::max(f[v], f[x] + w);\n            if (!--deg[v])\n                q.push(v);\n        &#125;\n    &#125;\n    std::cout &lt;&lt; f[t] &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---droga-do-domu\">C - Droga do domu</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P9402\" class=\"uri\">https://www.luogu.com.cn/problem/P9402</a></p>\n<ul>\n<li>还是做一个和上一题类似的优化建图</li>\n<li>此外就是一个普通的 Dij 上 DP 了。<strong>图没有环</strong>，直接拓扑即可。</li>\n<li>可以滚动优化空间，但似乎并无必要。代码略。</li>\n</ul>\n<hr />\n<h2 id=\"d---tickets-p\">D - Tickets P</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P7984\" class=\"uri\">https://www.luogu.com.cn/problem/P7984</a></p>\n<ul>\n<li>没什么好说的线段树优化建图，难点在于如何同时获取 <span class=\"math inline\">\\(1\\)</span> 和 <span class=\"math inline\">\\(N\\)</span> 的信息</li>\n<li><p>发现从某个点走到 <span class=\"math inline\">\\(1\\)</span> 和 <span class=\"math inline\">\\(N\\)</span>，有一种不劣的走法：</p>\n<img src=\"image.png\" /></li>\n<li><p>维护一下每个点单独走到 <span class=\"math inline\">\\(1\\)</span>，<span class=\"math inline\">\\(N\\)</span> 的最小代价和同时走到 <span class=\"math inline\">\\(1,N\\)</span> 的最小代价</p>\n看到一种更加对的写法是<strong>令 <span class=\"math inline\">\\(f_u\\)</span> 表示 <span class=\"math inline\">\\(v\\)</span> 的答案，那么可以用 <span class=\"math inline\">\\(f_v+w(u,v)\\)</span> 更新 <span class=\"math inline\">\\(f_u\\)</span></strong>。</li>\n<li><p>那么可以从 <span class=\"math inline\">\\(1,N\\)</span> 出发做一个 Dij。代码略。</p></li>\n</ul>\n<hr />\n<h2 id=\"e---监狱\">E - 监狱</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P9520\" class=\"uri\">https://www.luogu.com.cn/problem/P9520</a></p>\n<ul>\n<li><p>注意要走简单路径，也就是说不存在绕路让道的可能性。容易推出：若输入合法，总能找到一种方式使得每个人受到的指令是连续给出的。</p>\n<p>P.S. 这个结论挪到图上就不成立了，很容易举出反例。</p>\n<p><img src=\"image-1.png\" /></p></li>\n<li>若一个人的起点 / 终点在另一个人的路径上，那么这两个人之间存在先后关系。建图后检查是否为 DAG 即可。</li>\n<li><p>但建图显然是比较困难的，容易构造出数据使得边数来到 <span class=\"math inline\">\\(n^2\\)</span> 级别。考虑优化建图。</p>\n<p>发现可以用一个树剖 / 倍增的结构来建图。</p>\nTips：这一点同样是一个树上路径问题。参见 <a href=\"/20231117/#树上问题\">树上问题，倍增和树剖的选择？</a></li>\n<li><p>这里的路径要求两端都是开的，这就导致倍增写着很困难（虽然树剖可能也是），不排除我写丑了</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int K = 19;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;01-02.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, m;\n        std::cin &gt;&gt; n;\n        std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);\n        std::vector&lt;int&gt; s(n + 1), t(n + 1);\n        for (int i = 1, x, y; i &lt; n; ++i) &#123;\n            std::cin &gt;&gt; x &gt;&gt; y;\n            g1[x].push_back(y), g1[y].push_back(x);\n        &#125;\n        std::cin &gt;&gt; m;\n        std::vector&lt;std::vector&lt;int&gt; &gt; g(m + 1);\n        std::vector&lt;std::pair&lt;int, int&gt; &gt; a(m + 1);\n        for (int i = 1; i &lt;= m; ++i) &#123;\n            std::cin &gt;&gt; a[i].first &gt;&gt; a[i].second;\n            s[a[i].first] = i;\n            t[a[i].second] = i;\n        &#125;\n        int cnt = m;\n        struct node &#123; int fa, i0, i1; &#125;;\n        std::vector&lt;std::array&lt;node, K + 1&gt; &gt; p(n + 1);\n        std::vector&lt;int&gt; i0(n + 1), i1(n + 1), dep(n + 1), deg(m + 1);\n        auto init = [&amp;](void) &#123;\n            g.emplace_back(), deg.emplace_back();\n            return ++cnt;\n        &#125;;\n        auto add = [&amp;](int x, int y) &#123;\n            g[x].push_back(y), ++deg[y];\n            return;\n        &#125;;\n        for (int i = 1; i &lt;= n; ++i)\n            i0[i] = init(), i1[i] = init();\n        std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n            if (s[x])\n                add(s[x], i1[x]);\n            if (t[x])\n                add(i0[x], t[x]);\n            for (auto i : g1[x])\n                if (i != fa) &#123;\n                    dep[i] = dep[x] + 1;\n                    p[i][0].fa = x;\n                    p[i][0].i0 = init(), p[i][0].i1 = init();\n                    add(p[i][0].i0, i0[i]), add(i1[i], p[i][0].i1);\n                    for (int j = 1; j &lt;= K; ++j) &#123;\n                        p[i][j].fa = p[p[i][j - 1].fa][j - 1].fa;\n                        if (!p[i][j].fa)\n                            break;\n                        p[i][j].i0 = init(), p[i][j].i1 = init();\n                        add(p[i][j].i0, p[i][j - 1].i0);\n                        add(p[i][j].i0, p[p[i][j - 1].fa][j - 1].i0);\n                        add(p[i][j - 1].i1, p[i][j].i1);\n                        add(p[p[i][j - 1].fa][j - 1].i1, p[i][j].i1);\n                    &#125;\n                    DFS(i, x);\n                &#125;\n            return;\n        &#125;;\n        dep[1] = 1, DFS(1, -1);\n        for (int i = 1; i &lt;= m; ++i) &#123;\n            auto [x, y] = a[i];\n            if (x == y)\n                continue;\n            if (t[x])\n                add(i, t[x]);\n            if (s[y])\n                add(s[y], i);\n            if (dep[x] &lt; dep[y])\n                std::swap(x, y);\n            x = p[x][0].fa;\n            if (dep[x] &gt;= dep[y]) &#123;\n                for (int j = K; ~j; --j)\n                    if (dep[p[x][j].fa] &gt;= dep[y]) &#123;\n                        add(i, p[x][j].i0), add(p[x][j].i1, i);\n                        x = p[x][j].fa;\n                    &#125;\n                if (x == y)\n                    continue;\n                add(i, p[x][0].i0), add(p[x][0].i1, i);\n                x = p[x][0].fa;\n            &#125;\n            y = p[y][0].fa;\n            if (x != y) &#123;\n                for (int j = K; ~j; --j)\n                    if (p[x][j].fa != p[y][j].fa) &#123;\n                        add(i, p[x][j].i0), add(i, p[y][j].i0);\n                        add(p[x][j].i1, i), add(p[y][j].i1, i);\n                        x = p[x][j].fa, y = p[y][j].fa;\n                    &#125;\n                add(i, p[x][0].i0), add(i, p[y][0].i0);\n                add(p[x][0].i1, i), add(p[y][0].i1, i);\n                x = p[x][0].fa;\n            &#125;\n            add(i, i0[x]), add(i1[x], i);\n        &#125;\n        std::queue&lt;int&gt; q;\n        for (int i = 1; i &lt;= cnt; ++i)\n            if (!deg[i])\n                q.push(i);\n        int tot = 0;\n        for (; !q.empty(); ) &#123;\n            int x = q.front();\n            q.pop(), ++tot;\n            for (auto i : g[x])\n                if (!--deg[i])\n                    q.push(i);\n        &#125;\n        std::cout &lt;&lt; (tot == cnt ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "DP",
                "二分",
                "倍增",
                "调整法",
                "最短路"
            ]
        }
    ]
}