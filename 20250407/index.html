<!DOCTYPE html>
<html>
<head>
    <!-- 网站图标 -->
<link rel="icon" type="image/png" sizes="32x32" href="/images/icon.svg">
<!-- 其他图标支持 -->
<link rel="stylesheet" href="/css/facss/fa-brands.min.css">
<link rel="stylesheet" href="/css/facss/fa-regular.min.css">
<link rel="stylesheet" href="/css/facss/fa-solid.min.css">
<link rel="stylesheet" href="/css/facss/fontawesome.min.css">
<link rel="stylesheet" href="/css/facss/fontawesome-all.css">
<link href="https://use.fontawesome.com/releases/v5.0.4/css/all.css" rel="stylesheet">
<!-- 网站标题 -->
<title>
	
		组合计数 -
	
	XSC062 的博客
</title>
<!-- js 引入 -->

<script src="/js/afterloaded.js"></script>


<script src="/js/jQuery.js"></script>

<!-- 载入 Valine -->

<script src="/js/Valine.min.js"></script>

<!-- css 引入 -->

<link rel="stylesheet" href="/css/layout.css">


<link rel="stylesheet" href="/css/prcss/prism.css">



<meta charset="utf-8"> 
<meta name="generator" content="Hexo 7.2.0"></head>
<body class="line-numbers match-braces no-brace-select rainbow-braces">
	
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ],
            processEscapes: true
          }
        });
      </script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
            tex2jax: {
              skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
            }
          });
      </script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
              var all = MathJax.Hub.getAllJax(), i;
              for(i=0; i < all.length; i += 1) {
                  all[i].SourceElement().parentNode.className += ' has-jax';
              }
          });
      </script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

	<!-- 搜索 -->
<div id="search-bg">
	<div id="search-box">
		<input type="text" id="search-input" placeholder="Type to search...">
		<div id="search-results"></div>
		<p>恭喜你触发了这个 box，由于我还没有写关闭键，你只能通过刷新页面来关闭它。非常抱歉 ;-)</p>
		<p>为了证明我没有摆烂，在这里放一个进度：</p>
		<p>- 250715：尝试实现搜索功能，初步成功，能够搜索到包含关键词的文章了（也能关掉了）。不知道为啥输入 123 可以匹配所有文章，但是输入 1234 就一篇都匹配不上。</p>
		<p>- 250716：尝试加入关键词上下文来 de 上面的 bug，然后把 js 写成史了，现在这个框框并不具备搜索功能（也不具备关闭功能） :-(</p>
	</div>
</div>
<!-- 顶栏整体导航菜单 -->
<div class="ui top menu">
	<!-- 左对齐 logo -->
	<a class="logo" href="/">
		<img src="/images/icon.png"></img>
		<div id="bartitle">
			XSC062 的博客
		</div>
	</a>
	<!-- 右对齐部分导航 -->
	<script>
		function toSearch() {
			// goto search.ejs
			$("#search-bg, #search-bg *").css("z-index", "1002"); 
			$("#search-bg, #search-bg *").css("opacity", "100%");
		}
	</script>
	<div id="rightali">
		<a class="item" id="Search" type="button" onclick="toSearch()">
			<i class="btn text-muted fa fa-search" id="search-icon" disabled></i>
		</a>
		<a class="item" id="Home" href="/">
			Home
		</a>
		<a class="item" id="Arch" href="/archives">
			Archives
		</a>
		<!-- <a class="item" id="Cate" href="/categories">
			Categories
		</a> -->
		<a class="item" id="Tags" href="/tags">
			Tags
		</a>
		<a class="item" id="Frie" href="/friends">
			Friends
		</a>
		<a class="item" id="Abou" href="/about">
			About
		</a>
	</div>
</div>
    
<link rel="stylesheet" href="/css/post.css">


<script src="/js/post.js"></script>


<div class="main">
	<div id="sidebar">
		<aside id="toc">
			<span id="toctitle">
				<i class="fas fa-list"></i>
				目录
			</span>
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#a.-%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9F%93%E8%89%B2"><span class="toc-text">A. 二分图染色</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#b.-%E4%B8%83%E9%80%89%E4%BA%94"><span class="toc-text">B. 七选五</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#d.-%E7%A1%AC%E5%B8%81%E8%B4%AD%E7%89%A9"><span class="toc-text">D. 硬币购物</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#e.-distinct-multiples"><span class="toc-text">E. Distinct Multiples</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#f.-permutation"><span class="toc-text">F. Permutation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#h.-k-perm-counting"><span class="toc-text">H. ~K Perm Counting</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#a---positions-in-permutations"><span class="toc-text">A - Positions in Permutations</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#d---all-pairs-similarity-p"><span class="toc-text">D - All Pairs Similarity P</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#e---prefix-xors"><span class="toc-text">E - Prefix XORs</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#b---the-top-scorer"><span class="toc-text">B - The Top Scorer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c---sky-full-of-stars"><span class="toc-text">C - Sky Full of Stars</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#d---%E5%8E%BB-m-nom"><span class="toc-text">D - 去 M &#x2F; NoM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#e---kdoi-11%E5%BD%A9%E7%81%AF%E6%99%9A%E4%BC%9A"><span class="toc-text">E - 「KDOI-11」彩灯晚会</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#g---%E5%B0%8F%E6%98%9F%E6%98%9F"><span class="toc-text">G - 小星星</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cf785d-anton-and-school---2"><span class="toc-text">CF785D Anton and School - 2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cf1332e-height-all-the-same"><span class="toc-text">CF1332E Height All the Same</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#a---%E4%BA%A4%E9%94%99%E5%BA%8F%E5%88%97"><span class="toc-text">A - 交错序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#b---different-subsets-for-all-tuples"><span class="toc-text">B - Different Subsets For All Tuples</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#g---gardens"><span class="toc-text">G - Gardens</span></a></li></ol>
		</aside>
	</div>
	<div class="ui post container">
		<div class="ui text container yahei">
			<span id="postcon">
				<span id="postinfo">
					<div class="ui post title">
						<div id="fortitle" data-content="组合计数">
							组合计数
						</div>
						<div class="ui title background">
						</div>
					</div>
					<span id="date">
						<i class="fas fa-calendar-alt" style="margin-right: 4px;"></i>
						2025-04-07
					</span>
				</span>
			</span>
			<div id="posttags" class="dotted border">
				
					
						<a href="/tags/容斥原理/" class="citem">容斥原理</a>
					
						<a href="/tags/数学/" class="citem">数学</a>
					
						<a href="/tags/排列组合/" class="citem">排列组合</a>
					
						<a href="/tags/二项式定理/" class="citem">二项式定理</a>
					
						<a href="/tags/二项式反演/" class="citem">二项式反演</a>
					
				
			</div>
			<!-- 本来用的是 fromNow 然后字符串判断，没想到可以直接调用 moment() -->
			
			<div id="content">
				<p>毅毅：统计不是数学（断章取义 ed）。<del>故删掉了数学标签。</del> 其实并没有。</p>
<span id="more"></span>
<hr />
<h2 id="a.-二分图染色">A. 二分图染色</h2>
<p><a target="_blank" rel="noopener" href="http://222.180.160.110:61235/contest/6181/problem/1" class="uri">http://222.180.160.110:61235/contest/6181/problem/1</a></p>
<p>首先只看红色。显然一个左部点最多只能用红边连接一个右部点，反之同理。把左部点视为下标，其用红边相连的右部点视为值，则一个合法的方案为 <span class="math inline">\(n\)</span> 的只保留一部分元素的排列。显然为 <span class="math inline">\(f(n)=\sum\limits_{i=0}^nC_n^i\cdot A_n^i\)</span>。</p>
<p>再加上蓝色，<span class="math inline">\(f^2(n)\)</span> 会给一条边涂两种颜色，故钦定有两种颜色的边数，容斥得到 <span class="math inline">\(\sum\limits_{i=0}^n(-1)^i\cdot C_n^i\cdot A_n^i\cdot f^2(n-i)\)</span>。发现 <span class="math inline">\(f\)</span> 的计算可能需要优化一下。考虑已经知道 <span class="math inline">\(f(n-1)\)</span>，此时对于新增的第 <span class="math inline">\(n\)</span> 对点：</p>
<ol type="1">
<li>任意连边（显然两个当中只能有一个点发出边），共有 <span class="math inline">\(2n-1\)</span> 种方案，因为 <span class="math inline">\((n, n)\)</span> 会被算重。</li>
<li>不连，共 <span class="math inline">\(1\)</span> 种方案。</li>
<li>发现 1 中可能连到已经有连边的点上了，新边的目的地有 <span class="math inline">\(n-1\)</span> 个选项，目的地原本连接的点也有 <span class="math inline">\(n-1\)</span> 个选项，去掉两边共 <span class="math inline">\(4\)</span> 个点，非法的即为 <span class="math inline">\((n-1)^2\cdot f(n-2)\)</span>。</li>
</ol>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int mod = 1e9 + 7;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;long long&gt; f(n + 1), fac(n + 1), inv(n + 1);
    f[0] = 1ll, f[1] = 2ll;
    fac[0] = 1ll, fac[1] = 1ll, inv[0] = 1ll;
    for (int i = 2; i &lt;= n; ++i) &#123;
        fac[i] = fac[i - 1] * i % mod;
        f[i] = (f[i - 1] * 2 * i % mod + mod - f[i - 2] * (i - 1) % mod * (i - 1) % mod) % mod;
    &#125;
    auto qkp = [](long long x, int y) &#123;
        auto res = 1ll;
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    inv[n] = qkp(fac[n], mod - 2);
    for (int i = n - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    auto C = [&amp;](int n, int m) &#123;
        return fac[n] * inv[n - m] % mod * inv[m] % mod;
    &#125;;
    auto A = [&amp;](int n, int m) &#123;
        return fac[n] * inv[n - m] % mod;
    &#125;;
    long long res = 0ll;
    for (int i = 0, k = 1; i &lt;= n; ++i, k = mod - k)
        (res += k * C(n, i) % mod * A(n, i) % mod * f[n - i] % mod * f[n - i]) %= mod;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="b.-七选五">B. 七选五</h2>
<p><a target="_blank" rel="noopener" href="http://222.180.160.110:61235/contest/6181/problem/2" class="uri">http://222.180.160.110:61235/contest/6181/problem/2</a></p>
<p>首先 <span class="math inline">\(p\)</span> 固定，钦定有 <span class="math inline">\(x\)</span> 个数相等，有 <span class="math inline">\(C_k^x\)</span> 个方案，剩下的就是从 <span class="math inline">\(n-x\)</span> 个元素里选出 <span class="math inline">\(k-x\)</span> 个来错排，考虑钦定相同的个数来容斥：</p>
<p><span class="math display">\[
\sum_{i=0}^{k-x}(-1)^i\cdot C_{k-x}^i\cdot A_{n-x-i}^{k-x-i}
\]</span></p>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int mod = 1e9 + 7;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, k, x;
    std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; x;
    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);
    fac[0] = 1ll, fac[1] = 1ll, inv[0] = 1ll;
    for (int i = 2; i &lt;= n; ++i)
        fac[i] = fac[i - 1] * i % mod;
    auto qkp = [](long long x, int y) &#123;
        auto res = 1ll;
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    inv[n] = qkp(fac[n], mod - 2);
    for (int i = n - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    auto C = [&amp;](int n, int m) &#123;
        return fac[n] * inv[n - m] % mod * inv[m] % mod;
    &#125;;
    auto A = [&amp;](int n, int m) &#123;
        return fac[n] * inv[n - m] % mod;
    &#125;;
    long long res = C(k, x), sum = 0ll;
    for (int i = 0, p = 1; i &lt;= k - x; ++i, p = mod - p)
        (sum += p * C(k - x, i) % mod * A(n - x - i, k - x - i) % mod) %= mod;
    std::cout &lt;&lt; res * sum % mod &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="d.-硬币购物">D. 硬币购物</h2>
<p><a target="_blank" rel="noopener" href="http://222.180.160.110:61235/contest/6181/problem/4" class="uri">http://222.180.160.110:61235/contest/6181/problem/4</a></p>
<p>每次多重背包会超时，考虑用钦定每种硬币是否超额来容斥。令 <span class="math inline">\(f_s\)</span> 表示凑出 <span class="math inline">\(s\)</span> 的方案数（完全背包），那么 <span class="math inline">\(f_{s-c_1\times (d_1 + 1)}\)</span> 就表示钦定第 1 种硬币超额时凑出 <span class="math inline">\(s\)</span> 的方案数，以此类推。</p>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int c[4], T, m = 1e5;
    std::vector&lt;long long&gt; f(m + 1);
    f[0] = 1;
    for (int i = 0; i &lt; 4; ++i) &#123;
        std::cin &gt;&gt; c[i];
        for (int j = c[i]; j &lt;= m; ++j)
            f[j] += f[j - c[i]];
    &#125;
    std::cin &gt;&gt; T;
    for (int d[4], m; T--; ) &#123;
        for (int i = 0; i &lt; 4; ++i)
            std::cin &gt;&gt; d[i];
        std::cin &gt;&gt; m;
        long long res = 0ll;
        for (int i = 0; i &lt; (1 &lt;&lt; 4); ++i) &#123;
            int s = m;
            for (int j = 0; j &lt; 4; ++j)
                if ((i &gt;&gt; j) &amp; 1)
                    s -= (d[j] + 1) * c[j];
            if (s &gt;= 0) &#123;
                int k = (__builtin_popcount(i) &amp; 1) ? -1 : 1;
                res += k * f[s];
            &#125;
        &#125;
        std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="e.-distinct-multiples">E. Distinct Multiples</h2>
<p><a target="_blank" rel="noopener" href="http://222.180.160.110:61235/contest/6181/problem/5" class="uri">http://222.180.160.110:61235/contest/6181/problem/5</a></p>
<p>推式子题。题意转化为，给定 <span class="math inline">\(n\)</span> 个位置可选的值集合，要求任意两个位置值不等，问方案数。</p>
<p>如果把两个位置取等视作在团上选中边，那么有朴素做法钦定选边的集合 <span class="math inline">\(S\)</span> 然后容斥，考虑它们构成的连通块 <span class="math inline">\(\{s\} \subseteq S\)</span>，有 <span class="math inline">\(res=\sum\limits_{S\subseteq V}(-1)^{|S|}\cdot \prod\limits_{s_i} \left\lfloor \frac m{\operatorname{lcm} s_i} \right\rfloor\)</span>。</p>
<p>有个很神奇的操作是把 <span class="math inline">\(S\)</span> 丢掉，直接枚举 <span class="math inline">\(\{s\}\)</span> 尝试子集 DP。有：<span class="math inline">\(res=\sum\limits_{\{s\}}\prod\limits_s f(s)\cdot\left\lfloor \frac m{\operatorname{lcm} s} \right\rfloor\)</span>。其中 <span class="math inline">\(f(s)\)</span> 表示选取一个 <span class="math inline">\(s\)</span> 的导出子图的容斥系数之和，其中次数为导出子图中边数。</p>
<p>怎么把 <span class="math inline">\(f\)</span> 算出来呢？容易发现其值只与 <span class="math inline">\(|s|\)</span> 有关，考虑钦定与 <span class="math inline">\(1\)</span> 连通的点数容斥，则有：</p>
<p><span class="math display">\[
f(n)=\sum\limits_{i=0}^{n - 1} (-1)^i \times C_{n-1}^{i-1} \times f(i) \cdot \sum_{j=0}^{m\gets i\times (i-1)\div 2} (-1)^j\cdot C_m^j
\]</span></p>
<p>我们知道，二项式定理取 <span class="math inline">\(a=1, b = -1\)</span> 有 <span class="math inline">\(0^m=[m=0]=\sum_{j=0}^m(-1)^j\cdot C_m^j\)</span>，代入得：</p>
<p><span class="math display">\[
\begin{aligned}
f(n)&amp;=\sum\limits_{i=0}^{n - 1} (-1)^i \times C_{n-1}^{n-i-1} \times f(n-i)\cdot [m=0\iff i=1]\\
&amp;=(1 - n)\cdot f(n-1)
\end{aligned}
\]</span></p>
<p>然后就能线性求出。再用一个子集 DP，为了保证顺序枚举最小的未被确定的点所在连通块进行转移。</p>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, l;
    long long m;
    std::cin &gt;&gt; n &gt;&gt; m, l = 1 &lt;&lt; n;
    std::vector&lt;long long&gt; d(n), f(n + 1), dp(l), g(l);
    f[1] = 1ll;
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; d[i - 1];
        if (i &gt;= 2)
            f[i] = (1 + mod - i) * f[i - 1] % mod;
        // printf(&quot;f[%d] = %lld\n&quot;, i, f[i]);
    &#125;
    for (int i = 0; i &lt; l; ++i) &#123;
        long long now = 1ll;
        for (int j = 0; j &lt; n; ++j)
            if ((i &gt;&gt; j) &amp; 1) &#123;
                if (now / std::__gcd(now, d[j]) &gt; m / d[j])
                    goto nosol;
                now = now / std::__gcd(now, d[j]) * d[j];
            &#125;
        g[i] = (m / now) % mod;
        // printf(&quot;lcm = %lld, g[%d] = %lld\n&quot;, now, i, g[i]);
    nosol: ;
    &#125;
    dp[0] = 1ll;
    auto lowbit = [](int x) &#123;
        return x &amp; -x;
    &#125;;
    for (int i = 1; i &lt; l; ++i) &#123;
        int to = std::__lg(lowbit(i));
        for (int j = i; j; j = (j - 1) &amp; i)
            if ((j &gt;&gt; to) &amp; 1)
                (dp[i] += dp[i ^ j] * f[__builtin_popcount(j)] % mod * g[j] % mod) %= mod;
    &#125;
    std::cout &lt;&lt; dp[l - 1] &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="f.-permutation">F. Permutation</h2>
<p><a target="_blank" rel="noopener" href="http://222.180.160.110:61235/contest/6181/problem/6" class="uri">http://222.180.160.110:61235/contest/6181/problem/6</a></p>
<p>如果全是 <code>&lt;</code>，方案数为 <span class="math inline">\(1\)</span>。</p>
<p>现在把其中一些 <code>&lt;</code> 变成 <code>?</code>，比如 <code>&lt;&lt;??&lt;?&lt;&lt;&lt;&lt;</code> 的方案数，<del>太好了是多重集排列，我们没救了</del> 显然被 <code>&lt;</code> 连接起来的一段元素只有一种排列方式，所以可以视为多重集排列，方案数为 <span class="math inline">\(\dfrac {11!}{3!\times 2!\times 5!}\)</span>。</p>
<p>似乎只需要枚举把 <code>&gt;</code> 变成 <code>&lt;</code> 或 <code>=</code> 的 <span class="math inline">\(2^k\)</span> 种情况再计算就可以了，可惜 <span class="math inline">\(k\)</span> 有点大。但我们发现它在一定程度上是没有后效性的，比如 <code>&lt;&lt;??&lt;</code> 和 <code>&lt;&lt;?&lt;&lt;</code>，前面的 <code>&lt;&lt;</code> 不会对后面的内容带来影响。</p>
<p>故令 <span class="math inline">\(f_i\)</span> 表示对于前 <span class="math inline">\(i\)</span> 个元素的方案数，枚举最后一个被钦定为 <code>?</code> 的 <code>&gt;</code> <span class="math inline">\(j\)</span>（即 <span class="math inline">\([j + 1, i-1]\)</span> 间的 <code>&gt;</code> 都被替换为 <code>&lt;</code>），带上容斥系数，有 <span class="math inline">\(f_i=\sum\limits_{s_j=\texttt{&#39;&gt;&#39;}}(-1)^{cnt_\texttt{&#39;&gt;&#39;}[j + 1, i - 1]}\times f_j\times\dfrac1{(i-j)!}\)</span>。</p>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int mod = 1e9 + 7;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);
    fac[0] = 1ll, inv[0] = 1ll;
    for (int i = 1; i &lt;= n; ++i)
        fac[i] = fac[i - 1] * i % mod;
    auto qkp = [](long long x, int y) &#123;
        auto res = 1ll;
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    inv[n] = qkp(fac[n], mod - 2);
    for (int i = n - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    std::vector&lt;char&gt; s(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; s[i];
    std::vector&lt;long long&gt; f(n + 1);
    s[0] = &#39;&gt;&#39;, f[0] = 1ll;
    for (int i = 1; i &lt;= n; ++i) &#123;
        int cnt = 0;
        for (int j = i - 1; ~j; --j)
            if (s[j] == &#39;&gt;&#39;) &#123;
                long long k = (cnt &amp; 1) ? mod - 1 : 1;
                (k *= f[j]) %= mod, (k *= inv[i - j]) %= mod;
                (f[i] += k) %= mod;
                ++cnt;
            &#125;
        // printf(&quot;f[%d] = %lld\n&quot;, i, f[i]);
    &#125;
    std::cout &lt;&lt; f[n] * fac[n] % mod &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;</code></pre>
</details>
<hr />
<p><em>忳郁邑余侘傺兮，余独穷困乎此时也。</em></p>
<hr />
<h2 id="h.-k-perm-counting">H. ~K Perm Counting</h2>
<p><a target="_blank" rel="noopener" href="http://222.180.160.110:61235/contest/6181/problem/8" class="uri">http://222.180.160.110:61235/contest/6181/problem/8</a></p>
<p>考虑钦定令几个元素不满足条件进行容斥，即答案为 <span class="math inline">\(\sum\limits_{i=0}^n (-1)^i\cdot f(i)\)</span>。但我们发现 <span class="math inline">\([n-k,n+k]\)</span> 都有两个不能选的值，直接取 <span class="math inline">\(f(i)=\prod 2\)</span> 肯定会选到相同值，一个自然（？）的想法是再容斥一遍，可惜手玩一下发现似乎容不动。考虑把玩意儿拍在棋盘上：</p>
<figure>
<img src="1.png" alt="以 k=2 为例" /><figcaption>以 <span class="math inline">\(k=2\)</span> 为例</figcaption>
</figure>
<p>其中 <span class="math inline">\(\times\)</span> 是非法格子，边是非法格子间的不同选关系，同颜色的边隶属同一条链。容易发现如果棋盘继续扩大，这些链还会继续延长。</p>
<p>会发现这些链互不干扰，就是说我选了这条链上的某个点和链外的点没有任何关系（显然）。把这些链首尾相连拼起来，要做的就是拼接处可以选相邻，其余位置不能选相邻，选出来 <span class="math inline">\(i\)</span> 个的方案数。提前预处理出来整个序列，令 <span class="math inline">\(tag_j\)</span> 表示 <span class="math inline">\(j\)</span> 是否能和 <span class="math inline">\(j-1\)</span> 同选，设 <span class="math inline">\(dp_{j,i,0/1}\)</span> 表示 DP 到了 <span class="math inline">\(j\)</span>，已经选了 <span class="math inline">\(i\)</span> 个数，第 <span class="math inline">\(j\)</span> 个元素（不）选的方案数，那么有：</p>
<p><span class="math display">\[
dp_{j,i,0} = dp_{j - 1, i, 0} + dp_{j-1, i, 1}\\
dp_{j,i,1} = \begin{cases}
dp_{j-1, i - 1, 1} + dp_{j-1,i - 1,0}&amp;tag_j=1
\\
dp_{j-1,i,0}&amp;\text{otherwise}
\end{cases}
\]</span></p>
<p>大力 DP 即可。<span class="math inline">\(f(i)\)</span> 即为 <span class="math inline">\((n-i)!\times (dp_{m, i, 0} + dp_{m, i, 1})\)</span>，其中 <span class="math inline">\(m\)</span> 为总链长。</p>
<details>
<p>注意不滚动可能会 MLE <img src="/em/kt.gif" /></p>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int mod = 924844033;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, k;
    std::cin &gt;&gt; n &gt;&gt; k;
    std::vector&lt;int&gt; tag(1);
    std::vector&lt;long long&gt; fac(n + 1);
    std::vector&lt;std::vector&lt;int&gt; &gt; vis(n + 1, std::vector&lt;int&gt; (n + 1));
    auto calc = [&amp;](int i, int j, int s) &#123;
        tag.push_back(1);
        for (; ; s ^= 1) &#123;
            // printf(&quot;(%d, %d) &quot;, i, j);
            vis[i][j] = 1;
            if (!s) &#123;
                i = j + k;
                if (i &lt;= n)
                    tag.push_back(0);
                else
                    break;
            &#125;
            else &#123;
                j = i + k;
                if (j &lt;= n)
                    tag.push_back(0);
                else
                    break;
            &#125;
        &#125;
        // puts(&quot;&quot;);
        return;
    &#125;;
    fac[0] = 1ll;
    for (int i = 1; i &lt;= n; ++i) &#123;
        fac[i] = fac[i - 1] * i % mod;
        int j = i - k;
        if (j &gt;= 1 &amp;&amp; !vis[i][j])
            calc(i, j, 1);
        j = i + k;
        if (j &lt;= n &amp;&amp; !vis[i][j])
            calc(i, j, 0);
    &#125;
    int m = (int)tag.size() - 1;
    // printf(&quot;m = %d\n&quot;, m);
    std::vector&lt;std::vector&lt;std::vector&lt;long long&gt; &gt; &gt; dp(2, std::vector&lt;std::vector&lt;long long&gt; &gt; (n + 1, std::vector&lt;long long&gt; (2)));
    dp[0][0][0] = 1ll;
    for (int j = 1, now = 1; j &lt;= m; ++j, now ^= 1) &#123;
        for (int i = 0; i &lt;= n &amp;&amp; i &lt;= j; ++i) &#123;
            dp[now][i][0] = dp[!now][i][0];
            dp[now][i][1] = 0ll;
            if (i) &#123;
                (dp[now][i][0] += dp[!now][i][1]) %= mod;
                dp[now][i][1] = dp[!now][i - 1][0];
                if (tag[j]) &#123;
                    (dp[now][i][1] += dp[!now][i - 1][1]) %= mod;
                    // assert(0);
                &#125;
            &#125;
            // printf(&quot;dp[%d][%d] = %lld / %lld\n&quot;, j, i, dp[j][i][0], dp[j][i][1]);
        &#125;
    &#125;
    long long res = 0ll;
    for (int i = 0, p = 1; i &lt;= n; ++i, p = mod - p)
        (res += p * fac[n - i] % mod * (dp[m &amp; 1][i][0] + dp[m &amp; 1][i][1]) % mod) %= mod;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="a---positions-in-permutations">A - Positions in Permutations</h2>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/285/E" class="uri">https://codeforces.com/problemset/problem/285/E</a></p>
<p><del>（看向上一题）这照片是你吗？</del></p>
<p>在上一题的基础上，令 <span class="math inline">\(k=1\)</span>。但是有个小小的问题——所求的「至少」不为 <span class="math inline">\(0\)</span>，无法简单容斥。具体地，如果一个排列一共有 <span class="math inline">\(p\)</span> 个非法排列，那么它会被 <span class="math inline">\(f(i)\)</span> 统计 <span class="math inline">\(C_p^i\)</span> 次。令 <span class="math inline">\(g(p)\)</span> 表示非法格子数恰好为 <span class="math inline">\(p\)</span> 的排列的真实数量，则 <span class="math inline">\(f(i)=\sum\limits_{j=i}^n C_j^i\cdot g(j)\)</span>，二项式反演即可得到真实值 <span class="math inline">\(g(m)=\sum\limits_{j=m}^n (-1)^{j-m}\cdot C_j^m\cdot f(j)\)</span>。</p>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int mod = 1e9 + 7;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, k;
    std::cin &gt;&gt; n &gt;&gt; k;
    std::vector&lt;int&gt; tag(1);
    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);
    std::vector&lt;std::vector&lt;int&gt; &gt; vis(n + 1, std::vector&lt;int&gt; (n + 1));
    auto calc = [&amp;](int i, int j, int s) &#123;
        tag.push_back(1);
        for (; i &lt;= n &amp;&amp; j &lt;= n; s ^= 1) &#123;
            vis[i][j] = 1;
            if (!s) &#123;
                i = j + 1;
                if (i &lt;= n)
                    tag.push_back(0);
            &#125;
            else &#123;
                j = i + 1;
                if (j &lt;= n)
                    tag.push_back(0);
            &#125;
        &#125;
        return;
    &#125;;
    auto qkp = [&amp;](long long x, int y) &#123;
        auto res = 1ll;
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    fac[0] = 1ll, inv[0] = 1ll;
    for (int i = 1; i &lt;= n; ++i) &#123;
        fac[i] = fac[i - 1] * i % mod;
        int j = i - 1;
        if (j &gt;= 1 &amp;&amp; !vis[i][j])
            calc(i, j, 1);
        j = i + 1;
        if (j &lt;= n &amp;&amp; !vis[i][j])
            calc(i, j, 0);
    &#125;
    inv[n] = qkp(fac[n], mod - 2);
    for (int i = n - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    int m = (int)tag.size() - 1;
    std::vector&lt;std::vector&lt;std::vector&lt;long long&gt; &gt; &gt; dp(2, std::vector&lt;std::vector&lt;long long&gt; &gt; (n + 1, std::vector&lt;long long&gt; (2)));
    dp[0][0][0] = 1ll;
    for (int j = 1, now = 1; j &lt;= m; ++j, now ^= 1) &#123;
        for (int i = 0; i &lt;= n &amp;&amp; i &lt;= j; ++i) &#123;
            dp[now][i][0] = dp[!now][i][0];
            dp[now][i][1] = 0ll;
            if (i) &#123;
                (dp[now][i][0] += dp[!now][i][1]) %= mod;
                dp[now][i][1] = dp[!now][i - 1][0];
                if (tag[j])
                    (dp[now][i][1] += dp[!now][i - 1][1]) %= mod;
            &#125;
        &#125;
    &#125;
    auto C = [&amp;](int n, int m) &#123;
        return fac[n] * inv[n - m] % mod * inv[m] % mod;
    &#125;;
    long long res = 0ll;
    for (int i = k, p = 1; i &lt;= n; ++i, p = mod - p) &#123;
        // printf(&quot;%d: %lld\n&quot;, i, C(i, k) * fac[n - i] % mod * (dp[m &amp; 1][i][0] + dp[m &amp; 1][i][1]) % mod);
        (res += p * C(i, k) % mod * fac[n - i] % mod * (dp[m &amp; 1][i][0] + dp[m &amp; 1][i][1]) % mod) %= mod;
    &#125;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="d---all-pairs-similarity-p">D - All Pairs Similarity P</h2>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P11458" class="uri">https://www.luogu.com.cn/problem/P11458</a></p>
<p>省流：求 <span class="math inline">\(\forall\,i,f_i=\sum\limits_{j=1}^n \dfrac{|a_i\cap a_j|}{|a_i\cup a_j|}\)</span>。</p>
<p>首先分离常数，有：</p>
<p><span class="math display">\[
\begin{aligned}
f_i&amp;=\sum\limits_{j=1}^n \dfrac{|a_i\cap a_j|}{|a_i\cup a_j|}\\
&amp;=\sum_{j=1}^n\dfrac {|a_i|+|a_j|-|a_i\cup a_j|}{|a_i\cup a_j|}\\
&amp;=\sum_{j=1}^n \dfrac {|a_i|+|a_j|}{|a_i\cup a_j|}-1
\end{aligned}
\]</span></p>
<p>尽量把分子变得更简：</p>
<p><span class="math display">\[
\begin{aligned}
f_i&amp;=\sum_{j=1}^n \dfrac {|a_i|+|a_j|}{|a_i\cup a_j|}-1\\
&amp;=|a_i|\cdot\left(\sum_{j=1}^n\dfrac 1{|a_i\cup a_j|}\right)-n+\sum_{j=1}^n \dfrac {|a_j|}{|a_i\cup a_j|}
\end{aligned}
\]</span></p>
<p>问题转化为求解 <span class="math inline">\(\sum\limits_{j=1}^n\dfrac 1{|a_i\cup a_j|}\)</span> 和 <span class="math inline">\(\sum\limits_{j=1}^n\dfrac {|a_j|}{|a_i\cup a_j|}\)</span>，以 <span class="math inline">\(*=\sum\limits_{j=1}^n\dfrac 1{|a_i\cup a_j|}\)</span> 为例。令 <span class="math inline">\(b_i\)</span> 为 <span class="math inline">\(a_i\)</span> 补集，则：</p>
<p><span class="math display">\[
\begin{aligned}
*&amp;=\sum\limits_{j=1}^n\dfrac 1{|a_i\cup a_j|}\\
&amp;=\sum_{j=1}^n\dfrac 1{k-|b_i\cap b_j|}
\end{aligned}
\]</span></p>
<p>为什么要做这个转换呢？相比起并集运算，交集运算有着优秀的性质：<span class="math inline">\(s\subseteq(b_i\cap b_j)\iff s\subseteq b_i\land s\subseteq b_j\)</span>，<del>直接取或当然也有相似的性质，但是太烧脑了</del>。</p>
<p>基于这个性质，我们有一个想法：对于所有 <span class="math inline">\(j\)</span>，在 <span class="math inline">\(\forall \, s\subseteq b_j\)</span> 处放置 <span class="math inline">\(\dfrac 1{k-|s|}\)</span> 的贡献；对于 <span class="math inline">\(i\)</span>，将 <span class="math inline">\(\forall \, s\subseteq b_i\)</span> 处的贡献求和。但是这样肯定会拿到很多我们不想要的贡献，例如 <span class="math inline">\(\forall \, s\subset (b_i\cap b_j)\)</span>。</p>
<p>考虑精细布置贡献——构造 <span class="math inline">\(g(|s|)\)</span> 满足 <span class="math inline">\(\sum\limits_{j=1}^n\sum\limits_{s\subseteq b_j}g(|s|)=*\)</span>。</p>
<p>这里可以二项式反演得到 <span class="math inline">\(g\)</span>，具体地，令 <span class="math inline">\(F(|S|)=\dfrac 1{k-|S|}=\sum\limits_{s\subseteq S}g(|s|)=\sum\limits_{j=0}^{|S|} C_{|S|}^j g(j)\)</span>，则 <span class="math inline">\(g(i)=\sum\limits_{j=0}^iC_i^j\cdot \dfrac {(-1)^{i-j}}{k-j}\)</span>。</p>
<p>再令 <span class="math inline">\(h(s)=\sum\limits_{b_j\supseteq s}g(|s|)=g(|s|)\cdot \sum\limits_{b_j\supseteq s}1\)</span>，那么 <span class="math inline">\(h\)</span> 就是高维后缀和。我们正在做的事情就是求解 <span class="math inline">\(*=\sum\limits_{s\subseteq b_i}h(s)\)</span>，这就又是一个高维前缀和了。</p>
<p>对于 <span class="math inline">\(\sum\limits_{j=1}^n\dfrac {|a_j|}{|a_i\cup a_j|}\)</span> 呢，令 <span class="math inline">\(h(s)=\sum\limits_{b_j\supseteq s}g(|s|)\cdot {\color{red}{|a_j|}} = g(|s|) \cdot \sum\limits_{b_j\supseteq s} \color{red}{k - |b_j|}\)</span>，改变高维后缀和求和对象即可。</p>
<p>复杂度就是 <span class="math inline">\(O(n+k\cdot 2^k)\)</span>，其中 <span class="math inline">\(k\cdot 2^k\)</span> 来自整体高维前 / 后缀和，<span class="math inline">\(n\cdot k\)</span> 来自枚举 <span class="math inline">\(i\)</span>。</p>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int mod = 1e9 + 7;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, k, l;
    std::cin &gt;&gt; n &gt;&gt; k, l = 1 &lt;&lt; k;
    std::vector&lt;int&gt; a(n + 1), b(n + 1), cnt(l);
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; a[i], b[i] = (l - 1) ^ a[i];
        ++cnt[b[i]];
    &#125;
    std::vector&lt;long long&gt; g(k + 1), fac(k + 1);
    auto qkp = [&amp;](long long x, int y = mod - 2) &#123;
        auto res = 1ll;
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    auto C = [&amp;](int n, int m) &#123;
        return fac[n] * qkp(fac[n - m]) % mod * qkp(fac[m]) % mod;
    &#125;;
    fac[0] = 1ll;
    for (int i = 1; i &lt;= k; ++i)
        fac[i] = fac[i - 1] * i % mod;
    for (int i = 0; i &lt;= k; ++i) &#123;
        for (int j = 0, p = (i &amp; 1) ? mod - 1 : 1; j &lt;= i; ++j, p = mod - p)
            (g[i] += C(i, j) * p % mod * qkp(k - j) % mod) %= mod;
        // printf(&quot;g[%d] = %lld\n&quot;, i, g[i]);
    &#125;
    // for (int i = 0; i &lt;= k; ++i) &#123;
    //     long long F = 0ll;
    //     for (int j = 0; j &lt;= i; ++j)
    //         (F += C(i, j) * g[j] % mod) %= mod;
    //     printf(&quot;%d: %lld / %lld\n&quot;, i, F, qkp(k - i));
    // &#125;
    std::vector&lt;long long&gt; h(l);
    std::copy(cnt.begin(), cnt.end(), h.begin());
    for (int i = 0; i &lt; k; ++i)
        for (int j = l - 1; ~j; --j)
            if (!((j &gt;&gt; i) &amp; 1))
                (h[j] += h[j ^ (1 &lt;&lt; i)]) %= mod;
    auto f1(h);
    for (int i = 0; i &lt; l; ++i)
        (f1[i] *= g[__builtin_popcount(i)]) %= mod;
    for (int i = 0; i &lt; k; ++i)
        for (int j = 0; j &lt; l; ++j)
            if ((j &gt;&gt; i) &amp; 1)
                (f1[j] += f1[j ^ (1 &lt;&lt; i)]) %= mod;
    for (int i = 0; i &lt; l; ++i)
        h[i] = cnt[i] * (k - __builtin_popcount(i));
    for (int i = 0; i &lt; k; ++i)
        for (int j = l - 1; ~j; --j)
            if (!((j &gt;&gt; i) &amp; 1))
                (h[j] += h[j ^ (1 &lt;&lt; i)]) %= mod;
    auto f2(h);
    for (int i = 0; i &lt; l; ++i)
        (f2[i] *= g[__builtin_popcount(i)]) %= mod;
    for (int i = 0; i &lt; k; ++i)
        for (int j = 0; j &lt; l; ++j)
            if ((j &gt;&gt; i) &amp; 1)
                (f2[j] += f2[j ^ (1 &lt;&lt; i)]) %= mod;
    for (int i = 1; i &lt;= n; ++i) &#123;
        // fprintf(stderr, &quot;%d: %d * %lld - %d + %lld\n&quot;, i, __builtin_popcount(a[i]), f1[b[i]], n, f2[b[i]]);
        std::cout &lt;&lt; (__builtin_popcount(a[i]) * f1[b[i]] % mod + mod - n + f2[b[i]]) % mod &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="e---prefix-xors">E - Prefix XORs</h2>
<p><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/arc137/tasks/arc137_d" class="uri">https://atcoder.jp/contests/arc137/tasks/arc137_d</a></p>
<p>省流：做 <span class="math inline">\(k\)</span> 次前缀和，<span class="math inline">\(k=1,2,\cdots,m\)</span>，分别询问：令 <span class="math inline">\(x_i\gets a_i\)</span> 对 <span class="math inline">\(s_n\)</span> 的贡献次数，则 <span class="math inline">\(\sum a_i\cdot (x_i\bmod 2)\)</span>？</p>
<p>对于 <span class="math inline">\(a_p\)</span>，容易发现第一轮其对任意 <span class="math inline">\(s_q\)</span> 有 <span class="math inline">\(1\)</span> 次贡献，拉开来就是常数列；第二轮有 <span class="math inline">\((q-p+1)\)</span> 次贡献，是公差为 <span class="math inline">\(1\)</span> 的等差数列；第三轮是类三角形数——至此，肯定和组合数有关了。手玩可以发现第 <span class="math inline">\(k\)</span> 轮 <span class="math inline">\(a_p\)</span> 对 <span class="math inline">\(s_n\)</span> 的贡献为 <span class="math inline">\(C_{n-p+(k-2)}^{n-p}\)</span>，尽量令其中一个不动，得到 <span class="math inline">\(C_{n-p+(k-2)}^{k-1}\)</span>。</p>
<p>但是我们发现直接枚举每轮每个数会起飞，而且模数为 <span class="math inline">\(2\)</span> 似乎只能 Lucas（再带个 <span class="math inline">\(\log\)</span>），怎么办呢？</p>
<p>那就 Lucas 呗。由其观察容易发现 <span class="math inline">\(C_{n-p+(k-2)}^{k-2}\bmod2=1\)</span> 当且仅当 <span class="math inline">\((k-2)\subseteq (n-p+k-2)\iff (k-2)\subseteq \complement_U(n-p)\)</span>，故问题转化为高维后缀和，<del>当然你也可以做一次 and-FWT</del>，那么 <span class="math inline">\(res_k=\sum (C_{n-p+(k-2)}^{k-2}\bmod 2)\cdot a_p=S_{k-2}\)</span>，其中 <span class="math inline">\(S\)</span> 为高维后缀和，初值为 <span class="math inline">\(S_{\complement_u(n-i)}\gets a_i\)</span>。</p>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, m, l, k;
    std::cin &gt;&gt; n &gt;&gt; m, k = std::__lg(n + m) + 1, l = 1 &lt;&lt; k;
    std::vector&lt;int&gt; s(l);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; s[l - 1 - (n - i)];
    for (int i = 0; i &lt; k; ++i)
        for (int j = l - 1; ~j; --j)
            if (!((j &gt;&gt; i) &amp; 1))
                s[j] ^= s[j ^ (1 &lt;&lt; i)];
    for (int i = 1; i &lt;= m; ++i)
        std::cout &lt;&lt; s[i - 1] &lt;&lt; &#39; &#39;;
    std::cout &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="b---the-top-scorer">B - The Top Scorer</h2>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1096/E" class="uri">https://codeforces.com/problemset/problem/1096/E</a></p>
<p>鉴于每种方案等概率（翻译没说，但原题面有提到），考虑计算小明能够取胜的方案数，再对总方案数做除法。先枚举最高分 <span class="math inline">\(k\ge r\)</span>，再枚举包括小明在内恰有 <span class="math inline">\(c\ge 1\)</span> 个人 拿到 <span class="math inline">\(k\)</span> 分。但剩下的人呢？显然是不能插板随机分配的，因为存在 <span class="math inline">\(&lt;k\)</span> 的限制。</p>
<p>考虑容斥，钦定剩下的 <span class="math inline">\(p-c\)</span> 个人中拿到 <span class="math inline">\(\ge k\)</span> 分的人数后再可空地插板即可，则总方案数为：</p>
<p><span class="math display">\[
\sum_{k=r}^s\sum_{c=1}^p\dfrac {C_{p - 1}^{c-1}}c\cdot \sum_{i=0}^{p-c}C_{p-c}^i\cdot C_{s-k\cdot (c+i)+(p-c-1)}^{p-c-1}
\]</span></p>
<p>其中分母上的 <span class="math inline">\(c\)</span> 来源于等概率分配给最高分，虽然不是整数，但也代表着「小明获胜可行方案数」。最后将答案除上总方案数 <span class="math inline">\(C_{s-r+p-1}^{p-1}\)</span> 即可。</p>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int p, s, r;
    std::cin &gt;&gt; p &gt;&gt; s &gt;&gt; r;
    std::vector&lt;long long&gt; fac(s + p), inv(s + p);
    fac[0] = inv[0] = 1ll;
    for (int i = 1; i &lt; s + p; ++i) &#123;
        fac[i] = fac[i - 1] * i % mod;
    &#125;
    auto qkp = [&amp;](long long x, int y) &#123;
        auto res = 1ll;
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    inv.back() = qkp(fac.back(), mod - 2);
    for (int i = s + p - 2; i &gt; 0; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    auto C = [&amp;](int n, int m) &#123;
        if (n == -1 &amp;&amp; m == -1)
            return 1ll;
        return fac[n] * inv[n - m] % mod * inv[m] % mod;
    &#125;;
    auto res(0ll);
    for (int k = r; k &lt;= s; ++k)
        for (int c = 1; c &lt;= p; ++c)
            if ((p - c) * (k - 1) + c * k &gt;= s) &#123;
                auto t(0ll);
                for (int i = 0, now = 1; i &lt;= p - c &amp;&amp; k * (c + i) &lt;= s; ++i, now = mod - now)
                    (t += now * C(p - c, i) % mod * C(s - k * (c + i) + (p - c - 1), p - c - 1) % mod) %= mod;
                (res += C(p - 1, c - 1) * qkp(c, mod - 2) % mod * t % mod) %= mod;
            &#125;
    std::cout &lt;&lt; res * qkp(C(s - r + p - 1, p - 1), mod - 2) % mod &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="c---sky-full-of-stars">C - Sky Full of Stars</h2>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/997/C" class="uri">https://codeforces.com/problemset/problem/997/C</a></p>
<p>发现用 <span class="math inline">\(3^{n\times n}\)</span> 减去任意一行一列不同色的方案就是答案。</p>
<p>考虑一元容斥，如令 <span class="math inline">\(f_i\)</span> 表示至少 <span class="math inline">\(i\)</span> 行 <span class="math inline">\(i\)</span> 列同色的方案，但会发现 <span class="math inline">\(f_0\)</span> 中包含 <span class="math inline">\(0\)</span> 行 <span class="math inline">\(1\)</span> 列同色等与预期不符的情况。受此启发考虑令 <span class="math inline">\(f_{i,j}\)</span> 表示至少 <span class="math inline">\(i\)</span> 行 <span class="math inline">\(j\)</span> 列同色进行二元容斥。容易发现当 <span class="math inline">\(i\times j\ne 0\)</span> 时，被选中的 <span class="math inline">\(i\)</span> 行 <span class="math inline">\(j\)</span> 列全部连通，应为同一种颜色；将它们挪到角落，可以发现未被选中的格子共有 <span class="math inline">\((n-i)\times (n-j)\)</span> 个。故有：</p>
<p><span class="math display">\[
f_{i,j}=\begin{cases}
C_n^j\times 3^j\times 3^{n\times(n - j)}&amp;i=0\\
C_n^i\times 3^i\times 3^{n\times(n-i)}&amp;j=0\\
C_n^i\times C_n^j\times 3\times 3^{(n-i)\times (n-j)}&amp;\text{otherwise}
\end{cases}
\]</span></p>
<p>令 <span class="math inline">\(g_{i,j}\)</span> 表示恰好 <span class="math inline">\(i\)</span> 行 <span class="math inline">\(j\)</span> 列同色的方案数，那么答案为 <span class="math inline">\(3^{n\times n}-g_{0,0}\)</span>。二项式反演 / 容斥原理得 <span class="math inline">\(g_{0,0}=\sum\limits_{i=0}^n\sum\limits_{j=0}^n (-1)^{i+j}\cdot f_{i,j}\)</span>。很惊讶地发现这是 <span class="math inline">\(O(n^2)\)</span> 的！考虑优化。把 <span class="math inline">\(f_{1\to n,1\to n}\)</span> 合并同类项，得到：</p>
<p><span class="math display">\[
\begin{aligned}
g_{0, 0}
&amp;=\left[\sum_{j=0}^n (-1)^j\cdot f_{0,j}\right]+\sum_{i=1}^n (-1)^i\cdot f_{i,0}+\sum_{j=1}^n (-1)^{i+j}\cdot C_n^i\times C_n^j\times 3^{(n-i)\times (n-j)+1}\\
&amp;=\left[\sum_{j=0}^n (-1)^j\cdot f_{0,j}\right]+\sum_{i=1}^n (-1)^i\cdot f_{i,0}+(-1)^i\cdot C_n^i\times 3^{n^2-n\times i+1}\times\sum_{j=1}^n (-1)^j\cdot C_n^j\times 3^{j\times(-n+i)}\\
&amp;=\left[\sum_{j=0}^n (-1)^j\cdot f_{0,j}\right]+\sum_{i=1}^n (-1)^i\cdot f_{i,0}+(-1)^i\cdot C_n^i\times 3^{n^2-n\times i+1}\times\left[\left(\sum_{j=0}^n (-1)^j\cdot C_n^j\times (3^{-n+i})^j\right)-1\right]\\
&amp;=\left[\sum_{j=0}^n (-1)^j\cdot f_{0,j}\right]+\sum_{i=1}^n (-1)^i\cdot f_{i,0}+(-1)^i\cdot C_n^i\times 3^{n^2-n\times i+1}\times\left[(-3^{-n+i}+1)^n-1\right]
\end{aligned}
\]</span></p>
<p>由此便可 <span class="math inline">\(O(n\log n)\)</span> 计算。担心超时可以把所有 <span class="math inline">\(3^{-n+i}\)</span> 和 <span class="math inline">\(3^{n\times i}\)</span> 线性预处理出来，复杂度不会变就是了。</p>
<p>这里解释一下最后一步的二项式定理，非常遗憾地发现 <span class="math inline">\(-1\)</span> 和 <span class="math inline">\(3^{-n+i}\)</span> 都是 <span class="math inline">\(j\)</span> 次的，没办法把二者相加减做二项式定理；但由于次数相同，这提示我们可以把 <span class="math inline">\(-1\)</span> 乘到 <span class="math inline">\(3^{-n+i}\)</span> 里去，给每一项配上 <span class="math inline">\(1^{n-k}\)</span> 就可以做 <span class="math inline">\(-3^{n-i}\)</span>（注意不是 <span class="math inline">\((-3)^{n-i}\)</span>） 和 <span class="math inline">\(1\)</span> 的二项式定理。</p>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    long long n;
    std::cin &gt;&gt; n;
    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1), invn(n + 1), invi(n + 1), powi(n + 1), pown(n + 1);
    auto qkp = [&amp;](long long x, long long y) &#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    const long long pnn = qkp(3ll, n * n), pn = qkp(3ll, n);
    fac[0] = inv[0] = invn[0] = invi[0] = powi[0] = pown[0] = 1ll;
    for (int i = 1; i &lt;= n; ++i) &#123;
        fac[i] = fac[i - 1] * i % mod;
        powi[i] = powi[i - 1] * 3 % mod;
        pown[i] = pown[i - 1] * pn % mod;
    &#125;
    inv[n] = qkp(fac[n], mod - 2);
    invi[n] = qkp(powi[n], mod - 2);
    invn[n] = qkp(pown[n], mod - 2);
    for (int i = n - 1; i; --i) &#123;
        inv[i] = inv[i + 1] * (i + 1) % mod;
        invi[i] = invi[i + 1] * 3 % mod;
        invn[i] = invn[i + 1] * pn % mod;
    &#125;
    auto C = [&amp;](int n, int m) &#123;
        return fac[n] * inv[n - m] % mod * inv[m] % mod;
    &#125;;
    long long g = 0ll;
    auto f = [&amp;](int i, int j) &#123; // make sure (!i || !j)
        if (i == 0 &amp;&amp; j == 0)
            return pnn;
        else if (i == 0)
            return C(n, j) * powi[j] % mod * pown[n - j] % mod;
        return C(n, i) * powi[i] % mod * pown[n - i] % mod;
    &#125;;
    for (int j = 0, p = 1; j &lt;= n; ++j, p = mod - p)
        (g += p * f(0, j)) %= mod;
    for (int i = 1, p = mod - 1; i &lt;= n; ++i, p = mod - p)
        (g += p * f(i, 0) % mod + p * C(n, i) % mod * pnn % mod * invn[i] % mod * 3 % mod * (qkp(mod - invi[n - i] + 1, n) + mod - 1) % mod) %= mod;
    std::cout &lt;&lt; (pnn + mod - g) % mod &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="d---去-m-nom">D - 去 M / NoM</h2>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P11316" class="uri">https://www.luogu.com.cn/problem/P11316</a></p>
<p>假设 <span class="math inline">\(f(i)\)</span> 为至少有 <span class="math inline">\(i\)</span> 对不合法元素的方案数，则容斥得到答案 <span class="math inline">\(\sum\limits_{i=0}^n (-1)^i\cdot f(i)\)</span>。考虑怎么计算 <span class="math inline">\(f(i)\)</span>。</p>
<p><mark><span class="math inline">\(M\)</span> 整除 <span class="math inline">\(dis(x, y) \iff (pos_x - pos_y)\bmod M=0\iff pos_x\equiv pos_y\pmod M\)</span>。</mark></p>
<p>考虑把关于 <span class="math inline">\(M\)</span> 同余的位置放在一个组，也就是说需要让一对元素不能选同一组的位置。</p>
<p>考虑容斥，令 <span class="math inline">\(f(i)\)</span> 表示至少有 <span class="math inline">\(i\)</span> 对点选到一组的方案数，考虑怎么计算。假设我们要在第 <span class="math inline">\(k\)</span> 组（size 为 <span class="math inline">\(s_k\)</span>）中选出 <span class="math inline">\(x\)</span> 对位置，实际上只需要选择 <span class="math inline">\(2x\)</span> 个位置然后任意分配给这 <span class="math inline">\(x\)</span> 对数，即 <span class="math inline">\(A_{s_k}^{2x}\)</span>。设 <span class="math inline">\(dp_{i, j}\)</span> 表示 DP 到第 <span class="math inline">\(i\)</span> 个组，已经选了 <span class="math inline">\(j\)</span> 对，那么有 <span class="math inline">\(dp_{i,j}=\sum\limits_{k=0}^jC_{n-(j - k)}^{j-k}\times dp_{i-1,j-k}\times A_{s_i}^{2k}\)</span>。乍一看好像是 <span class="math inline">\(O(n^3)\)</span> 的，但是别忘了 <span class="math inline">\(\sum s_i=2n\)</span>，所以只有 <span class="math inline">\(O(n^2)\)</span>。<span class="math inline">\(f(i)\)</span> 即为 <span class="math inline">\(dp_{m,i}\times (2n-2i)!\)</span>。</p>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int mod = 1e9 + 7;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&lt;int&gt; s(m + 1);
    std::vector&lt;long long&gt; fac(2 * n + 1), inv(2 * n + 1);
    fac[0] = inv[0] = 1ll;
    for (int i = 1; i &lt;= 2 * n; ++i)
        ++s[i % m + 1], fac[i] = fac[i - 1] * i % mod;
    auto qkp = [](long long x, int y) &#123;
        auto res = 1ll;
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    inv[2 * n] = qkp(fac[2 * n], mod - 2);
    for (int i = 2 * n - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    auto A = [&amp;](int n, int m) &#123;
        return fac[n] * inv[n - m] % mod;
    &#125;;
    auto C = [&amp;](int n, int m) &#123;
        return fac[n] * inv[n - m] % mod * inv[m] % mod;
    &#125;;
    std::vector&lt;std::vector&lt;long long&gt; &gt; dp(m + 1, std::vector&lt;long long&gt; (n + 1));
    dp[0][0] = 1ll;
    for (int i = 1; i &lt;= m; ++i)
        for (int j = 0; j &lt;= n; ++j) &#123;
            for (int k = 0; k &lt;= j &amp;&amp; 2 * k &lt;= s[i]; ++k)
                (dp[i][j] += C(n - (j - k), k) * dp[i - 1][j - k] % mod * A(s[i], 2 * k) % mod) %= mod;
            // printf(&quot;s = %d, dp[%d][%d] = %lld\n&quot;, s[i], i, j, dp[i][j]);
        &#125;
    long long res = 0ll;
    for (int i = 0, p = 1; i &lt;= n; ++i, p = mod - p)
        (res += p * dp[m][i] % mod * fac[2 * n - 2 * i] % mod) %= mod;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="e---kdoi-11彩灯晚会">E - 「KDOI-11」彩灯晚会</h2>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P11292" class="uri">https://www.luogu.com.cn/problem/P11292</a></p>
<p>考虑 <span class="math inline">\({cnt_i}^2\)</span> 的含义，即在所有颜色为 <span class="math inline">\(i\)</span>、长度为 <span class="math inline">\(l\)</span> 的链中有放回地选两次的方案数。</p>
<p>显然复杂度里是不能包含 <span class="math inline">\(k\)</span> 的，所以放弃直接统计 <span class="math inline">\(cnt_i\)</span> 的想法。显然每种颜色是等价的，考虑计算选择两条链可以给答案带来的贡献：答案的形式是个和式；对于两条同色链 <span class="math inline">\(p,q\)</span>，假设颜色为 <span class="math inline">\(i\)</span>，那么会对 <span class="math inline">\({cnt_i}^2\)</span> 带来 <span class="math inline">\(k^{n-2l-|p\cap q|}\)</span> 的贡献，对总答案带来 <span class="math inline">\(k^{n-2l-|p\cap q| + 1}\)</span> 的贡献。</p>
<p>然而如果要枚举计算 <span class="math inline">\(|p\cap q|\)</span> 就无法避免 <span class="math inline">\(O(n^5)\)</span>，考虑更有潜力的方法：将问题转化为对于每个 <span class="math inline">\(x\)</span>，求交集大小恰好为 <span class="math inline">\(x\)</span> 的链对个数。然而「恰好」是不方便计算的——假如当前两链在 <span class="math inline">\(u\)</span> 次重合，如果假设下一次在 <span class="math inline">\(v\)</span> 次重合，就需要保证在 <span class="math inline">\(u,v\)</span> 之间不能重合——这并不好操作。二项式反演将恰好转化为至少，则限制减弱。</p>
<p>令 <span class="math inline">\(f_{u,c,l_1,l_2}\)</span> 表示 <span class="math inline">\(p,q\)</span> 当前在 <span class="math inline">\(u\)</span> 处重合，视野内的 <span class="math inline">\(p,q\)</span> 长度为 <span class="math inline">\(l_1,l_2\)</span>，至少已经重合了 <span class="math inline">\(c\)</span> 次的方案数。预处理出走到 <span class="math inline">\(u\)</span> 步数为 <span class="math inline">\(l_1,l_2\)</span> 的方案数为初始值。枚举可能的后续重合点 <span class="math inline">\(v\)</span>（满足 <span class="math inline">\(v\)</span> 的拓扑序 <span class="math inline">\(&gt;u\)</span>）有 <span class="math inline">\(f_{v,c+1,l_1&#39;,l_2&#39;}\gets f_{v,c+1,l_1&#39;,l_2&#39;} + f_{u,c,l_1,l_2}\)</span>。预处理出 <span class="math inline">\(u\to v\)</span> 长度为 <span class="math inline">\(\Delta\)</span> 的方案数（这是 <span class="math inline">\(O(n^3l)\)</span> 的）优化转移，在算出 <span class="math inline">\(nex_{u,l}\)</span> 表示从 <span class="math inline">\(u\)</span> 出发走 <span class="math inline">\(l\)</span> 步的方案数处理答案，则 <span class="math inline">\(F(i)=\sum_{u,l_1,l_2}f_{u,l_1,l_2}\cdot nex_{u,l-l_1}\cdot nex_{u,l-l_2}\)</span>，枚举 <span class="math inline">\(u,c,l_1,l_2,v,l_1&#39;,l_2&#39;\)</span>，就可以达到优秀的 <span class="math inline">\(O(n^2l^5+n^3l)\)</span>！简直是令人震撼 <img src="/em/kt.gif" /></p>
<p>给出第一个优化：发现 <span class="math inline">\(l_1\)</span> 和 <span class="math inline">\(l_2\)</span> 的转移彼此不干扰，考虑建立一个临时数组 <span class="math inline">\(g\)</span>，先从 <span class="math inline">\(f_u,c\)</span> 转移 <span class="math inline">\(l_1\)</span> 到 <span class="math inline">\(g\)</span>，再从 <span class="math inline">\(g\)</span> 转移 <span class="math inline">\(l_2\)</span> 到 <span class="math inline">\(f_{v,c+1}\)</span>，则复杂度降为 <span class="math inline">\(O(n^2l^4+n^3l)\)</span>，仍不足以通过。</p>
<p>DP 过程上的优化已经万策尽，考虑从式子本身消元减少 DP 维度入手。令 <span class="math inline">\(h(i)\)</span> 表示交集大小恰好恰好为 <span class="math inline">\(i\)</span> 的方案数，则此时答案式为 <span class="math inline">\(\sum\limits_{i=0}^l k^{n-2l+i+1}\times h(i)\)</span>。又 <span class="math inline">\(F(i)=\sum\limits_{j=i}^lC_j^i\cdot h(j)\)</span>，二项式反演得：</p>
<p><span class="math display">\[
\begin{aligned}
res&amp;=\sum\limits_{i=0}^lk^{n-2l+i+1}\cdot \sum_{j=i}^l(-1)^{j-i}\cdot C_j^i\cdot F(j)\\
&amp;=k^{n-2l+1}\cdot\sum_{j=0}^l \sum_{i=0}^j k^i\cdot (-1)^{j-i}\cdot C_j^i\cdot F(j)\\
&amp;=k^{n-2l+1}\cdot \sum_{j=0}^l (k-1)^j\cdot F(j)
\end{aligned}
\]</span></p>
<p><mark>注意这里利用了二项式反演的系数可以和交换求和顺序后的 <span class="math inline">\(i\)</span> 次项（或 <span class="math inline">\(j-i\)</span> 次项，参见 <a href="#c---sky-full-of-stars">Sky Full of Stars 中最后一步的处理</a>）组成二项式定理的特点</mark>，以便基于式子结构尽可能消元。</p>
<p>那么此时答案式已经和 <span class="math inline">\(c\)</span> 无关，可以丢掉 <span class="math inline">\(c\)</span> 这一维，和 <span class="math inline">\(c\)</span> 有关的计算已经在转移时处理了。则 <span class="math inline">\(f_{v,l_1&#39;,l_2&#39;}=\sum f_{u,l_1,l_2}\times (k-1)\)</span>，复杂度降为 <span class="math inline">\(O(n^2l^3+n^3l)\)</span>。</p>
<details>
<p>记得还要算上 <span class="math inline">\(F(0)\)</span>，即任选一条合法链的方案数平方。</p>
<pre class="cpp"><code>// 兄弟你好香
// 兄弟你是依托打分，我踏马吃吃吃吃吃
#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;party3.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    using arr = std::vector&lt;long long&gt;;
    using arrr = std::vector&lt;arr&gt;;
    using arrrr = std::vector&lt;arrr&gt;;
    int n, k, l, m;
    std::cin &gt;&gt; n, std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; l &gt;&gt; m;
    std::vector&lt;int&gt; deg(n + 1), id;
    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(n + 1);
    for (int x, y, c; m--; ) &#123;
        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; c;
        ++deg[y], g[x].emplace_back(y, c);
    &#125;
    arrrr to(n + 1, arrr(n + 1, arr(l + 1)));
    arrr pre(n + 1, arr(l + 1)), nex(n + 1, arr(l + 1));
    &#123;
        std::queue&lt;int&gt; q;
        for (int i = 1; i &lt;= n; ++i)
            if (!deg[i])
                q.push(i);
        for (int u; !q.empty(); ) &#123;
            u = q.front(), q.pop();
            to[u][u][0] = 1ll, id.push_back(u);
            for (auto i : id)
                for (int j = 0; j &lt;= l; ++j) &#123;
                    (pre[u][j] += to[i][u][j]) %= mod;
                    // printf(&quot;to[%d][%d][%d] = %lld\n&quot;, i, u, j, to[i][u][j]);
                &#125;
            // for (int j = 0; j &lt;= l; ++j)
            //     printf(&quot;pre[%d][%d] = %lld\n&quot;, u, j, pre[u][j]);
            for (auto [v, c] : g[u]) &#123;
                for (auto i : id)
                    for (int j = 1; j &lt;= l; ++j)
                        (to[i][v][j] += to[i][u][j - 1] * c) %= mod;
                if (!--deg[v])
                    q.push(v);
            &#125;
        &#125;
        for (int u = 1; u &lt;= n; ++u)
            for (int v = 1; v &lt;= n; ++v)
                for (int i = 0; i &lt;= l; ++i)
                    (nex[u][i] += to[u][v][i]) %= mod;
    &#125;
    arrrr f(n + 1, arrr(l + 1, arr(l + 1)));
    &#123;
        for (int i = 1; i &lt;= n; ++i)
            for (int l1 = 1; l1 &lt;= l; ++l1)
                for (int l2 = 1; l2 &lt;= l; ++l2)
                    f[i][l1][l2] = pre[i][l1 - 1] * pre[i][l2 - 1] % mod * (k - 1) % mod;
        for (auto i = 0; i &lt; n; ++i) &#123;
            int u = id[i];
            // for (int l1 = 1; l1 &lt;= l; ++l1)
            //     for (int l2 = 1; l2 &lt;= l; ++l2)
            //         printf(&quot;f[%d][%d][%d] = %lld\n&quot;, u, l1, l2, f[u][l1][l2]);
            for (auto j = i + 1; j &lt; n; ++j) &#123;
                arrr g(l + 1, arr(l + 1));
                int v = id[j];
                for (int l1 = 1; l1 &lt; l; ++l1)
                    for (int _l1 = l1 + 1; _l1 &lt;= l; ++_l1) &#123;
                        auto K = to[u][v][_l1 - l1];
                        if (K)
                            for (int l2 = 1; l2 &lt; l; ++l2)
                                (g[_l1][l2] += f[u][l1][l2] * K) %= mod;
                    &#125;
                for (int _l1 = 2; _l1 &lt;= l; ++_l1)
                    for (int l2 = 1; l2 &lt; l; ++l2)
                        if (g[_l1][l2])
                            for (int _l2 = l2 + 1; _l2 &lt;= l; ++_l2)
                                (f[v][_l1][_l2] += g[_l1][l2] * to[u][v][_l2 - l2] % mod * (k - 1)) %= mod; 
            &#125;
        &#125;
    &#125;
    auto qkp = [](long long x, int y) &#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    auto res(0ll);
    for (int u = 1; u &lt;= n; ++u)
        for (int v = 1; v &lt;= n; ++v)
            (res += to[u][v][l - 1]) %= mod;
    (res *= res) %= mod;
    for (int u = 1; u &lt;= n; ++u)
        for (int l1 = 1; l1 &lt;= l; ++l1)
            for (int l2 = 1; l2 &lt;= l; ++l2)
                (res += f[u][l1][l2] * nex[u][l - l1] % mod * nex[u][l - l2] % mod) %= mod;
    res = res % mod * (qkp(k, n + 1) * qkp(qkp(k, 2 * l), mod - 2) % mod) % mod;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="g---小星星">G - 小星星</h2>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3349" class="uri">https://www.luogu.com.cn/problem/P3349</a></p>
<p>首先考虑比较暴力的做法，那么有 <span class="math inline">\(f_{i,j,S}\)</span> 表示在 <span class="math inline">\(i\)</span> 这个子树里面选了集合 <span class="math inline">\(S\)</span>，且 <span class="math inline">\(i\)</span> 的颜色为 <span class="math inline">\(j\)</span> 的方案数，维数里之所以有 <span class="math inline">\(j\)</span> 是为了满足连边限制。</p>
<p>然后树上子集 DP，发现是 <span class="math inline">\(O(n^4\cdot 2^n)\)</span> 的，</p>
<hr />
<h2 id="cf785d-anton-and-school---2">CF785D Anton and School - 2</h2>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/785/D" class="uri">https://codeforces.com/problemset/problem/785/D</a></p>
<p>容易想到枚举每个 <code>(</code> 作为分界点的情况，那么钦定当前枚举的 <code>(</code> 是要选的。对于当前 <code>(</code>，若其左边（不含）的 <code>(</code> 有 <span class="math inline">\(n\)</span> 个而右边的 <code>)</code> 有 <span class="math inline">\(m\)</span> 个，枚举除了当前 <code>(</code> 还要选 <span class="math inline">\(i\)</span> 个 <code>(</code>，那么答案为 <span class="math inline">\(\sum_{i=0}C_n^{i-1}\cdot C_m^i\)</span>。</p>
<p>发现这个形式可以范德蒙德卷积：<span class="math inline">\(\sum_{i=0}C_n^{i-1}\cdot C_m^i=\sum_{i=0}C_n^{n-i+1}\cdot C_m^i=C_{n+m}^{n+1}\)</span>。</p>
<p>关于怎么记忆范德蒙德卷积，发现上下相加，也可以从组合意义记忆：在 <span class="math inline">\(n\)</span> 个球中选出 <span class="math inline">\(k-i\)</span> 个球，再从 <span class="math inline">\(m\)</span> 个球中选出 <span class="math inline">\(i\)</span> 个球的总方案就是从 <span class="math inline">\(n+m\)</span> 个球中直接选出 <span class="math inline">\(k\)</span> 个球的方案。</p>
<p>注意判断右侧没有 <code>)</code> 的时候贡献为 <span class="math inline">\(0\)</span>。</p>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int mod = 1e9 + 7;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    std::string s;
    std::cin &gt;&gt; s;
    int n = s.length();
    s = &quot; &quot; + s;
    std::vector&lt;int&gt; cnt1(n + 1), cnt2(n + 1);
    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);
    fac[0] = inv[0] = 1ll;
    for (int i = 1; i &lt;= n; ++i) &#123;
        fac[i] = fac[i - 1] * i % mod;
        cnt1[i] = cnt1[i - 1] + (s[i] == &#39;(&#39;);
    &#125;
    auto qkp = [](long long x, int y) &#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    inv[n] = qkp(fac[n], mod - 2);
    cnt2[n] = (s[n] == &#39;)&#39;);
    for (int i = n - 1; i; --i) &#123;
        cnt2[i] = cnt2[i + 1] + (s[i] == &#39;)&#39;);
        inv[i] = inv[i + 1] * (i + 1) % mod;
    &#125;
    long long res = 0ll;
    auto C = [&amp;](int n, int m) &#123;
        if (n &lt; m)
            return 0ll;
        return fac[n] * inv[n - m] % mod * inv[m] % mod;
    &#125;;
    for (int i = 1; i &lt;= n; ++i)
        if (s[i] == &#39;(&#39;)
            (res += C(cnt1[i] + cnt2[i] - 1, cnt1[i])) %= mod;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="cf1332e-height-all-the-same">CF1332E Height All the Same</h2>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1332/E" class="uri">https://codeforces.com/problemset/problem/1332/E</a></p>
<p>容易发现第一个操作是用来改变两个数奇偶性的；而第二个操作能在全图奇偶性相同的任何情况下达成要求。</p>
<p>注意到如果我们想同时仅改变任意两个数的奇偶性，可以在棋盘上任找一条路径一路使用操作一。只要某种奇偶性的元素个数共有偶数个，就能通过若干次操作一把它们全部变成另一种奇偶性。</p>
<p>令 <span class="math inline">\(K_1\)</span> 为 <span class="math inline">\(L\sim R\)</span> 中奇数的个数，<span class="math inline">\(K_2\)</span> 为偶数，那么有：</p>
<p><span class="math display">\[
res=\sum_{i=0}^{nm} C_{nm}^i\times {K_1}^i\cdot {K_2}^{nm-i}\cdot [i\bmod 2=0]
\]</span></p>
<p>我们发现这个东西和二项式定理简直像得不能再像了！但多了一个系数导致没办法省略枚举过程。如果进行变形呢？</p>
<p><span class="math display">\[
res=(K_1+K_2)^{nm}-\sum_{i=0}^{nm} C_{nm}^i\times {K_1}^i\cdot {K_2}^{nm-i}\cdot [i\bmod 2=1]
\]</span></p>
<p>似乎依然没有出路！但这里有个神奇的操作：</p>
<p><span class="math display">\[
res=(-K_1+K_2)^{nm}+\sum_{i=0}^{nm} C_{nm}^i\times {K_1}^i\cdot {K_2}^i\cdot [i\bmod 2=1]
\]</span></p>
<p>二式相加就可以<mark>消元</mark>，得到 <span class="math inline">\(2\cdot res=(K_1+K_2)^{nm}+(K_1-K_2)^{nm}\)</span>。<mark>这启示我们二项式定理中的符号和奇偶性的深切联系。</mark></p>
<details>
<p>如果你使用费马小定理对次数进行了处理，你可能需要注意次数可能为 <span class="math inline">\(\text{mod} -1\)</span> 的倍数。</p>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
const int inv2 = 499122177;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    long long n, m, l, r, k1, k2;
    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; l &gt;&gt; r, k1 = (r - l + 1) / 2, k2 = (r - l + 1) - k1;
    auto qkp = [](long long x, long long y) &#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    if (n * m % 2)
        std::cout &lt;&lt; qkp(r - l + 1, n * m) &lt;&lt; &#39;\n&#39;;
    else
        std::cout &lt;&lt; (qkp(r - l + 1, n * m) + qkp((k1 + mod - k2) % mod, n * m)) % mod * inv2 % mod &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="a---交错序列">A - 交错序列</h2>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4456" class="uri">https://www.luogu.com.cn/problem/P4456</a></p>
<figure>
<img src="2.png" alt="出题人疑似需要加强数学功底（？）" /><figcaption>出题人疑似需要加强数学功底（？）</figcaption>
</figure>
<p>容易想到把答案用二项式定理拆开：</p>
<p><span class="math display">\[
\begin{aligned}
res&amp;=\sum_y f_y\cdot y^b\cdot (n-y)^a\\
&amp;=\sum_y f_y\cdot y^b\cdot \sum_{i=0}^a C_a^i\cdot n^i\cdot(-y)^{a-i}\\
&amp;=\sum_y\sum_{i=0}^a f_y\cdot C_a^i\cdot n^i\cdot(-1)^{a-i}\cdot y^{a+b-i}\\
&amp;=\sum_{i=0}^a C_a^i\cdot n^i\cdot(-1)^{a-i}\cdot \sum_y f_y\cdot y^{a+b-i}\\
\end{aligned}
\]</span></p>
<p>然后发现后面那个 sigma 不太有办法求。一个比较优雅的方法是把 <span class="math inline">\(y^{a+b-i}\)</span> 直接作为系数而非下标塞到 <span class="math inline">\(f\)</span> 里去，即令 <span class="math inline">\(f_{i}\)</span> 表示 <span class="math inline">\(\forall \,y\)</span>，<span class="math inline">\(\sum y^i\)</span> 之和。</p>
<p>具体地，令 <span class="math inline">\(dp_{n,i,0/1}\)</span> 表示当前 DP 到第 <span class="math inline">\(n\)</span> 位，要求幂次为 <span class="math inline">\(i\)</span>，最后一位为 <span class="math inline">\(0/1\)</span> 的答案。则显然有 <span class="math inline">\(dp_{n,i,0}=dp_{n-1,i,0}+dp_{n-1,i,1}\)</span>。对于 <span class="math inline">\(dp_{n,i,1}\)</span>，因为此时 <span class="math inline">\(\forall\, k,k\gets k+1\)</span>，则 <span class="math inline">\((k+1)^i=\sum\limits_{j=0}^i C_i^j \cdot k^j\)</span> 即 <span class="math inline">\(dp_{n,i,1}=\sum\limits_{j=0}^i C_i^j\cdot dp_{n-1,j,0}\)</span>。发现 <span class="math inline">\(i,j\)</span> 的范围是 <span class="math inline">\(90\)</span>，很恐怖的事情是这是可以矩阵的。</p>
<details>
<p>就像我们都知道的那样，矩阵在加完之后再取模就会快很多……</p>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
int mod;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, a, b;
    std::cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; mod;
    std::vector&lt;std::vector&lt;long long&gt; &gt; C(a + b + 1, std::vector&lt;long long&gt;(a + b + 1));
    for (int i = 0; i &lt;= a + b; ++i) &#123;
        C[i][0] = 1ll;
        for (int j = 1; j &lt;= i; ++j)
            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;
    &#125;
    struct mat &#123;
        int n, m;
        std::vector&lt;std::vector&lt;long long&gt; &gt; a;
        mat(int n, int m, bool flag = 0): n(n), m(m), a(n, std::vector&lt;long long&gt; (m)) &#123;
            if (flag)
                for (int i = 0; i &lt; n; ++i)
                    a[i][i] = 1ll;
            return;
        &#125;
        mat operator* (const mat &amp;q) const &#123;
            mat res(n, q.m);
            for (int i = 0; i &lt; n; ++i)
                for (int k = 0; k &lt; q.m; ++k) &#123;
                    for (int j = 0; j &lt; m; ++j)
                        res.a[i][k] += a[i][j] * q.a[j][k];
                    res.a[i][k] %= mod;
                &#125;
            return res;
        &#125;
        mat operator^ (int q) const &#123;
            mat res(n, n, 1), x(*this);
            for (; q; x = x * x, q &gt;&gt;= 1)
                if (q &amp; 1)
                    res = res * x;
            return res;
        &#125;
    &#125; f(1, 2 * (a + b + 1)), op(2 * (a + b + 1), 2 * (a + b + 1));
    auto fun = [&amp;](int i, int j) &#123;
        return i + j * (a + b + 1);
    &#125;;
    f.a[0][fun(0, 0)] = 1ll;
    for (int i = 0; i &lt;= a + b; ++i)
        op.a[fun(i, 0)][fun(i, 0)] = op.a[fun(i, 1)][fun(i, 0)] = 1ll;
    for (int i = 0; i &lt;= a + b; ++i)
        for (int j = 0; j &lt;= i; ++j)
            op.a[fun(j, 0)][fun(i, 1)] = C[i][j];
    f = f * (op ^ n);
    // for (int i = 0; i &lt;= n; ++i) &#123;
    //     if (i)
    //         f = f * op;
    //     for (int j = 0; j &lt;= a + b; ++j)
    //         printf(&quot;f[%d][%d] = %lld / %lld\n&quot;, i, j, f.a[0][fun(j, 0)], f.a[0][fun(j, 1)]);
    // &#125;
    auto res = 0ll;
    for (int i = 0; i &lt;= a; ++i) &#123;
        static auto p(1ll), k((a % 2) ? mod - 1ll : 1ll);
        (res += C[a][i] * p % mod * k % mod * (f.a[0][fun(a + b - i, 0)] + f.a[0][fun(a + b - i, 1)]) % mod) %= mod;
        (p *= n) %= mod, k = mod - k;
    &#125;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="b---different-subsets-for-all-tuples">B - Different Subsets For All Tuples</h2>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF660E" class="uri">https://www.luogu.com.cn/problem/CF660E</a></p>
<p>首先你可能需要知道，如果已知一个序列，如何得到答案？</p>
<p>令 <span class="math inline">\(f_i\)</span> 表示在 <span class="math inline">\(i\)</span> 处取一个子序列的末尾，枚举上一个元素 <span class="math inline">\(x\)</span>，找到 <span class="math inline">\(i\)</span> 之前最靠后的一个 <span class="math inline">\(a_j=x\)</span>，那么有 <span class="math inline">\(f_i=\sum f_j\)</span>，换言之需要保证 <span class="math inline">\((j,i)\)</span> 范围内没有 <span class="math inline">\(x\)</span> 出现。</p>
<p>此时序列未知，令 <span class="math inline">\(f_{i, x}\)</span> 表示在 <span class="math inline">\(i\)</span> 处取一个子序列末尾，且 <span class="math inline">\(i\)</span> 的值为 <span class="math inline">\(x\)</span>；按照贡献的视角来看待，每个可以和 <span class="math inline">\(i\)</span> 组成新子序列的方案可以带来 <span class="math inline">\(m^{i-1}\)</span> 的贡献（因为 <span class="math inline">\(a_i\)</span> 已经固定为 <span class="math inline">\(x\)</span>，其他位置可以任选），那么有 <span class="math inline">\(f_{i,x}=m^i\times \sum_{j&lt;i,y}f_{j,y}\times (m-1)^{i-j-1}\)</span>。</p>
<p>然后就惊讶地发现式子和 <span class="math inline">\(x\)</span> 这一维没有关系了。所以直接带上系数得到：</p>
<p><span class="math display">\[
\begin{aligned}
f_i&amp;=m^i\times \sum_{j&lt;i} f_j\times (m-1)^{i-j-1}\times m\\
&amp;=m^i\times (m-1)^{i-1}\times m\cdot \sum_{j&lt;i} f_j\times (m-1)^{-j}
\end{aligned}
\]</span></p>
<p>前缀和优化一下就可以快速求了。最终的答案就是 <span class="math inline">\(res=m^n+\sum f_i\times (m-1)^{n-i}\)</span>。</p>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int mod = 1e9 + 7;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    if (m == 1)
        std::cout &lt;&lt; (n + 1) &lt;&lt; &#39;\n&#39;;
    else &#123;
        std::vector&lt;long long&gt; f(n + 1), s(n + 1), pm1(n + 1);
        pm1[0] = 1ll;
        for (int i = 1; i &lt;= n; ++i)
            pm1[i] = pm1[i - 1] * (m - 1) % mod;
        auto qkp = [](long long x, int y) &#123;
            auto res(1ll);
            for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
                if (y &amp; 1)
                    (res *= x) %= mod;
            return res;
        &#125;;
        auto res(qkp(m, n));
        const auto invm = qkp(m - 1, mod - 2);
        for (int i = 1; i &lt;= n; ++i) &#123;
            static long long p(m), inv(invm);
            f[i] = (p + pm1[i - 1] * m % mod * s[i - 1] % mod) % mod;
            s[i] = (s[i - 1] + f[i] * inv % mod) % mod;
            (res += f[i] * pm1[n - i] % mod) %= mod;
            (p *= m) %= mod, (inv *= invm) %= mod;
        &#125;
        std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;; 
    &#125;
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="g---gardens">G - Gardens</h2>
<p><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/abc235/tasks/abc235_g" class="uri">https://atcoder.jp/contests/abc235/tasks/abc235_g</a></p>
<p>如果没有『每个人必须有一个元素』这个限制，就可以随便做了。现在加上了这个限制，很容易想到用没得到的人来容斥。钦定至少有 <span class="math inline">\(i\)</span> 个人没拿到，得到答案为 <span class="math inline">\(\sum\limits_{i=0}^n (-1)^i\cdot C_n^i\cdot \left(\sum\limits_{j=0}^a C_i^j\right)\cdot \left(\sum\limits_{j=0}^b C_i^j\right)\cdot \left(\sum\limits_{j=0}^c C_i^j\right)\)</span>。</p>
<p>怎么算 <span class="math inline">\(\sum\limits_{j=0}^a C_i^j\)</span> 呢？当 <span class="math inline">\(a&gt; i\)</span> 时，二项式是好求的；当 <span class="math inline">\(a\le i\)</span> 时呢？看到这个式子很容易带到杨辉三角里去，也就是求一行的前 <span class="math inline">\(a\)</span> 个数。注意到可以用上一行的前 <span class="math inline">\(a\)</span> 个数 <span class="math inline">\(O(1)\)</span> 得到（假设第 <span class="math inline">\(j-1\)</span> 行前 <span class="math inline">\(a\)</span> 个数之和为 <span class="math inline">\(f_a(j-1)\)</span>）：<span class="math inline">\(f_a(j)=f_a(j-1)\times 2-C_{j-1,a}\)</span>。<mark>你需要意识到，由于上一行也是答案中要求的，所以可以使用递推解决问题。<strong>在组合计数中，递推 / DP 无论是在化简式子还是求容斥 / 二项式反演里具体某一限制下的方案数都是很有用的，在需要优化复杂度时，可以从递推 / DP、恒等式、前缀和、预处理等方法入手考虑</strong></mark>。</p>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, a, b, c;
    std::cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; c;
    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1), fa(n + 1), fb(n + 1), fc(n + 1), pow2(n + 1);
    fac[0] = inv[0] = pow2[0] = 1ll;
    for (int i = 1; i &lt;= n; ++i) &#123;
        fac[i] = fac[i - 1] * i % mod;
        pow2[i] = pow2[i - 1] * 2 % mod;
    &#125;
    auto qkp = [&amp;](long long x, int y) &#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    inv[n] = qkp(fac[n], mod - 2);
    for (int i = n - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    auto C = [&amp;](int n, int m) &#123;
        return fac[n] * inv[n - m] % mod * inv[m] % mod;
    &#125;;
    for (int i = 0; i &lt;= a; ++i)
        (fa[a] += C(a, i)) %= mod;
    for (int i = a + 1; i &lt;= n; ++i)
        fa[i] = (2 * fa[i - 1] % mod + mod - C(i - 1, a)) % mod;
    for (int i = 0; i &lt;= b; ++i)
        (fb[b] += C(b, i)) %= mod;
    for (int i = b + 1; i &lt;= n; ++i)
        fb[i] = (2 * fb[i - 1] % mod + mod - C(i - 1, b)) % mod;
    for (int i = 0; i &lt;= c; ++i)
        (fc[c] += C(c, i)) %= mod;
    for (int i = c + 1; i &lt;= n; ++i)
        fc[i] = (2 * fc[i - 1] % mod + mod - C(i - 1, c)) % mod;
    auto res(0ll);
    for (int i = n, p = 1; ~i; --i, p = mod - p)
        (res += p * C(n, i) % mod * (i &gt;= a ? fa[i] : pow2[i]) % mod * (i &gt;= b ? fb[i] : pow2[i]) % mod * (i &gt;= c ? fc[i] : pow2[i]) % mod) %= mod;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;</code></pre>
</details>

			</div>
			<hr class="dotted">
			<div class="post footer">
				<div id="hitokoto">
					<h3 id="hitokoto-title">
						言论
					</h3>
					<div id="hitokoto-content">
					</div>
					<div id="hitokoto-from">
					</div>
				</div>
				<div class="button flex">
					<div id="prev">
						
							<!-- 吐槽，为啥还需要加 / -->
							<a href="/20250419/">
								<i class="fas fa-angle-double-left" style="margin-right: 10px;"></i>
								网格图路径计数
							</a>
						
					</div>
					<div id="next">
						
							<a href="/20250404/">
								杂题选谈
								<i class="fas fa-angle-double-right" style="margin-left: 10px;"></i>
							</a>
						
					</div>
				</div>
				<div id="vcomments" class="yahei"></div>
<script>
	new Valine({
		el: '#vcomments',
		appId: 'OlmvQ0a2Zw7xo3no2bwabOzx-gzGzoHsz',
		appKey: 'TW6t8mFeGLmhPjWisvmllvvo',
		recordIP: true,
		enableQQ: true, 
		// 目前 Valine 的 QQ 自动获取昵称似乎不可用 故不建议开启
		pageSize: 10,
		requiredFields:
			
				['nick']
			,
		placeholder: "The world is but a little place after all...\n能够根据邮箱获取你的 Gravatar 头像。昵称是必填项，长度需不低于 3。",
		avatar: 'mp',
		avatar_cdn: 'https://cravatar.cn/avatar/',
		emojiCDN: 'https://xsc062.netlify.app/em/', 
		emojiMaps: {
			
				"微笑": "wx.gif",
			
				"龇牙": "cy.gif",
			
				"流泪": "ll.gif",
			
				"笑哭": "xk.gif",
			
				"流汗": "lh.gif",
			
				"擦汗": "ch.gif",
			
				"亲亲": "qq.gif",
			
				"色": "se.gif",
			
				"疑问": "yiw.gif",
			
				"发呆": "fd.gif",
			
				"晕": "yun.gif",
			
				"鼓掌": "gz.gif",
			
				"憨笑": "hanx.gif",
			
				"快哭了": "kk.gif",
			
				"得意": "dy.gif",
			
				"狂笑": "kx.gif",
			
				"害羞": "hx.gif",
			
				"妈妈生的": "dz.gif",
			
				"糗大了": "qd.gif",
			
				"吃瓜": "cg.gif",
			
				"睁眼": "zy.webp",
			
				"辣眼睛": "lyj.gif",
			
				"酸了": "nm.gif",
			
				"滚": "gun.webp",
			
				"惊恐": "jk.gif",
			
				"幽灵": "youl.gif",
			
				"无聊": "wul.gif",
			
				"吃": "eat.gif",
			
				"你很棒棒": "bb.gif",
			
				"赞": "qiang.gif",
			
				"踩": "ruo.gif",
			
				"握手": "wsh.gif",
			
				"发抖": "fad.gif",
			
				"挥手": "hsh.gif",
			
				"磕头": "kt.gif",
			
				"怄火": "oh.gif",
			
		},
	})
</script>
			</div>
			<script>setHitokoto();</script>
		</div> 
	</div>
</div>
    <!-- 页脚开始 -->
<div id="footer" class="yahei">
    Powered by
    <a target="_blank" rel="noopener" href="https://hexo.io">
        Hexo
    </a>
    &
    <a href="/about-this-theme">
        iwll
    </a>
    <p style="margin-top: 5px;">
        2021 - 2025
    </p>
</div>
<!-- Valine 相关配置 -->
<script>
    const getValineDomTimer = setInterval(() => {
        // 不知道为什么 我从原博客 js 文件粘过来的参数是
        // "#valine .vcards .vcard"
        // DEBUG 了半天才定位到这个问题。。。
        const vcards =
            document.querySelectorAll('#valine, .vcards, .vcard');
        if (vcards.length > 0) {
            let author = 'XSC062';
            for (let vcard of vcards) {
                const vnick_dom = vcard.querySelector('.vhead .vnick');
                if (vnick_dom != null) {
                    const vnick = vnick_dom.innerHTML;
                    if (vnick === author) {
                        vnick_dom.innerHTML =
                        `${vnick} <span id="rootitem" class="fira">root</span>`
                    }
                }
            }
        }
        else {
            clearInterval(getValineDomTimer);
        }
    }, 2000);
    SetActiveItem();
    setDetailsSummary();
    setTitleAnchor();
    setEmptyToc();
    setCodeClassName();
</script>


<!-- js -->
<!-- 搜索功能相关配置 -->

<script src="/js/search.js"></script>

</script>
<!-- prism 相关配置 -->
<script type="text/javascript" src="/js/prism.js" defer></script>
<!-- 代码块复制功能 -->
<script type="text/javascript" src="/js/clipboard.min.js"></script>
<script type="text/javascript" src="/js/clipboard-use.js"></script>
<!-- 页脚结束 -->
</body>
</html>