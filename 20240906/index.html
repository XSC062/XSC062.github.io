<!DOCTYPE html>
<html>
<head>
    <!-- 网站图标 -->
<link rel="icon" type="image/png" sizes="32x32" href="/images/icon.svg">
<!-- 其他图标支持 -->
<link rel="stylesheet" href="/css/fa-brands.min.css">
<link rel="stylesheet" href="/css/fa-regular.min.css">
<link rel="stylesheet" href="/css/fa-solid.min.css">
<link rel="stylesheet" href="/css/fontawesome.min.css">
<link rel="stylesheet" href="/css/fontawesome-all.css">
<link href="https://use.fontawesome.com/releases/v5.0.4/css/all.css" rel="stylesheet">
<!-- 网站标题 -->
<title>
	
		动！态！规！划！10！题！ -
	
	XSC062 的博客
</title>
<!-- js 引入 -->

<script src="/js/afterloaded.js"></script>


<script src="/js/jQuery.js"></script>

<!-- 载入 Valine -->

<script src="/js/Valine.min.js"></script>

<!-- css 引入 -->

<link rel="stylesheet" href="/css/layout.css">


<link rel="stylesheet" href="/css/prcss/prism.css">



<meta charset="utf-8"> 
<meta name="generator" content="Hexo 7.2.0"></head>
<body class="line-numbers match-braces no-brace-select rainbow-braces">
	
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ],
            processEscapes: true
          }
        });
      </script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
            tex2jax: {
              skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
            }
          });
      </script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
              var all = MathJax.Hub.getAllJax(), i;
              for(i=0; i < all.length; i += 1) {
                  all[i].SourceElement().parentNode.className += ' has-jax';
              }
          });
      </script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

	<!-- 搜索 -->
<div id="search-bg">
	<div id="search-box"></div>
	<!-- <div class="form-group">
		<input type="text" id="local-search-input" name="q" results="0" placeholder="search" class="st-search-input st-default-search-input form-control"/>
	</div>  
	<div id="local-search-result"></div> -->
</div>
<!-- 顶栏整体导航菜单 -->
<div class="ui top menu">
	<!-- 左对齐 logo -->
	<a class="logo" href="/">
		<img src="/images/icon.png"></img>
		<div id="bartitle">
			XSC062 的博客
		</div>
	</a>
	<!-- 右对齐部分导航 -->
	<script>
		function toSearch() {
			$("#search-bg, #search-bg *").css("z-index", "1002");
			$("#search-bg, #search-bg *").css("opacity", "100%");
		}
	</script>
	<div id="rightali">
		<a class="item" id="Search" type="button" onclick="toSearch()">
			<i class="btn text-muted fa fa-search" id="search-icon" disabled></i>
		</a>
		<a class="item" id="Home" href="/">
			Home
		</a>
		<a class="item" id="Arch" href="/archives">
			Archives
		</a>
		<!-- <a class="item" id="Cate" href="/categories">
			Categories
		</a> -->
		<a class="item" id="Tags" href="/tags">
			Tags
		</a>
		<a class="item" id="Frie" href="/friends">
			Friends
		</a>
		<a class="item" id="Abou" href="/about">
			About
		</a>
	</div>
</div>
    
<link rel="stylesheet" href="/css/post.css">


<script src="/js/post.js"></script>


<div class="main">
	<div id="sidebar">
		<aside id="toc">
			<span id="toctitle">
				<i class="fas fa-list"></i>
				目录
			</span>
			<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E5%90%88%E5%B9%B6"><span class="toc-text">1. 字符合并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mod-mod-mod"><span class="toc-text">2. Mod Mod Mod</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stalinsort-algorithm"><span class="toc-text">3. StalinSort Algorithm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#merge-triplets"><span class="toc-text">4. Merge Triplets</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#runaway-quail"><span class="toc-text">5. Runaway Quail</span></a></li></ol>
		</aside>
	</div>
	<div class="ui post container">
		<div class="ui text container yahei">
			<span id="postcon">
				<span id="postinfo">
					<div class="ui post title">
						<div id="fortitle" data-content="动！态！规！划！10！题！">
							动！态！规！划！10！题！
						</div>
						<div class="ui title background">
						</div>
					</div>
					<span id="date">
						<i class="fas fa-calendar-alt" style="margin-right: 4px;"></i>
						2024-09-06
					</span>
				</span>
			</span>
			<div id="posttags" class="dotted border">
				
					
						<a href="/tags/DP/" class="citem">DP</a>
					
				
			</div>
			<!-- 本来用的是 fromNow 然后字符串判断，没想到可以直接调用 moment() -->
			
			<div id="content">
				<p>现在是 10 题。虽然看着很掉价，但是写够了 10 就改成 20
题。以此类推，免得我摆烂（）</p>
<p>自用向，不写太详细，把破题点写出来就差不多了。哦哦这里的破题是动词不是名词。</p>
<span id="more"></span>
<hr />
<h3 id="字符合并">1. 字符合并</h3>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3736"
class="uri">https://www.luogu.com.cn/problem/P3736</a></p>
<p><strong>状压</strong>，<strong>区间 DP</strong>。</p>
<p>注意到 <span class="math inline">\(k\)</span> 只有 <span
class="math inline">\(8\)</span>，独特的输入方式也引导我们注意到状态数为
<span class="math inline">\(10^2\)</span>
级别。合并的背景又让我们本能想到区间 DP，所以刚好盲猜这题是个 <span
class="math inline">\(O(2^k\times n^2)\)</span> 的区间状压 DP。</p>
<ul>
<li><p>然后我觉得最神的一个地方是什么呢？最后的答案一定是一个长度小于
<span class="math inline">\(k\)</span>
的串，<mark>每位展开还原，可以知道，每个合并操作选取的区间互不相交。</mark></p>
<p>看起来很蠢很显然，但这是我们 <span class="math inline">\(n^2\)</span>
区间 DP 的基础啊（（（</p></li>
</ul>
<p>然后我们区间 DP 套路，枚举对于 <span
class="math inline">\([l,r]\)</span>
最左边一位，然后就可以开始大力转移了。</p>
<p>但是这里我们会发现，这一位原本的样子有点多，可以任何一个 <span
class="math inline">\(1 + d\times (k-1)\)</span>，所以只能再来一层 <span
class="math inline">\(\dfrac nk\)</span> 地枚举，极限情况是个有点难绷的
3e9，作为正解只能说这个数据范围的提示性有点令人难评了。</p>
<p>本来我实现着实现着把自己整懵了：<code>00000</code> 和 <code>0</code>
压出来都是
<code>0</code>，但二者代表的含义显然不同，又无法简单区别。但其实<mark>长度为
<span class="math inline">\(1+d\times (k-1)\)</span> 的区间和长度为
<span class="math inline">\(d\)</span>
的最终结果是一一对应的，所以在我们设计的包含了区间作右端点的状态中，压出来的就是我们想要的那个。</mark></p>
<details>
<p>这里的实现比<strong>所有</strong>我找到的题解都更像人打出来的。导致我想对比疗法都找不到合适的代码
<img src="/em/lh.gif" /></p>
<p>换言之，这最像是一份通常的区间 DP
代码，不存在其他题解中乱七八糟的填表啊相互影响啊之类的恶心 feature。</p>
<p>sto rybp orz</p>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int maxn = 305;
const int maxm = (1 &lt;&lt; 8) + 5;
char a[maxn];
int c[maxm], w[maxm];
long long f[maxn][maxn][maxm];
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#else
    freopen(&quot;in.in&quot;, &quot;r&quot;, stdin);
    freopen(&quot;out.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, k;
    std::cin &gt;&gt; n &gt;&gt; k;
    int siz = (1 &lt;&lt; k), si = (1 &lt;&lt; (k - 1));
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    for (int i = 0; i &lt; siz; ++i)
        std::cin &gt;&gt; c[i] &gt;&gt; w[i];
    memset(f, -0x3f, sizeof(f));
    for (int l = 1; l &lt; k; ++l)
        for (int i = 1; i &lt;= n - l + 1; ++i) &#123;
            int j = i + l - 1, now = 0;
            for (int p = i; p &lt;= j; ++p)
                now = now * 2 + a[p] - &#39;0&#39;;
            f[i][j][now] = 0;
        &#125;
    for (int i = 1; i &lt;= n - k + 1; ++i) &#123;
        int now = 0;
        for (int j = i; j &lt;= i + k - 1; ++j)
            now = now * 2 + a[j] - &#39;0&#39;;
        f[i][i + k - 1][c[now]] = w[now];
    &#125;
    for (int l = k + 1; l &lt;= n; ++l)
        for (int i = 1; i &lt;= n - l + 1; ++i) &#123;
            int j = i + l - 1;
            for (int p = i; p &lt; j; p += k - 1) &#123;
                for (int q = 0; q &lt; si; ++q)
                    if (!(q &gt;&gt; ((l - 1) % (k - 1) + 1)))
                        f[i][j][q] = std::max(f[i][j][q], f[i][p][q &gt;&gt; ((l - 1) % (k - 1))] + f[p + 1][j][q &amp; ((1 &lt;&lt; ((l - 1) % (k - 1))) - 1)]);
                if (l % (k - 1) == 1 || k == 2)
                    for (int q = 0; q &lt; siz; ++q)
                        f[i][j][c[q]] = std::max(f[i][j][c[q]], f[i][p][q &gt;&gt; (k - 1)] + f[p + 1][j][q &amp; ((1 &lt;&lt; (k - 1)) - 1)] + w[q]);
            &#125;
        &#125;
    std::cout &lt;&lt; *std::max_element(f[1][n], f[1][n] + si) &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;</code></pre>
</details>
<hr />
<p>其实一开始挺担心会不会因为写博客影响做题时间之类的。</p>
<p>后来发现我可以看知乎看一个上午然后代码动都不动一下，反正不想做题的时候也不能强制让自己做题，那不如写写博客算了
<img src="/em/lh.gif" /></p>
<hr />
<h3 id="mod-mod-mod">2. Mod Mod Mod</h3>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/contest/889/problem/E"
class="uri">https://codeforces.com/contest/889/problem/E</a></p>
<p><strong>技巧 / 特殊性质类 DP</strong>。</p>
<p>小神题。注意到题意可以转化为，找到一个 <span
class="math inline">\(x\)</span>，最大化：</p>
<p><span class="math display">\[
x\bmod a_1 + x\bmod a_1\bmod a_2 + \cdots + x\bmod a_1\bmod
a_2\bmod\cdots\bmod a_n.
\]</span></p>
<p>简称 <span class="math inline">\(x\bmod a_1\bmod a_2\bmod \cdots\bmod
a_i\)</span> 的值为 <span class="math inline">\(f_i\)</span>。</p>
<p>这个时候我们不难注意到，<span class="math inline">\(f_i\)</span>
肯定是单调不升的。形象化地，整个 <span class="math inline">\(f\)</span>
序列肯定是由若干个单调下降的段组成的。并且，必定存在至少一个 <span
class="math inline">\(i\)</span>，使得 <span class="math inline">\(f_i =
a_i-1\)</span>，否则可以将所有 <span class="math inline">\(f_i\gets
f_i+1\)</span>，同时 <span class="math inline">\(\sum f\gets (\sum f) +
n\)</span>。</p>
<p>这启示我们关注 <span class="math inline">\(f_i\)</span>
的值域。假设已经确定了 <span class="math inline">\(f\)</span>
序列的一个前缀 <span class="math inline">\(f_1\sim i\)</span>，对于任意
<span class="math inline">\(0\le k\le
f_{\min}\)</span>（注意由于单调不降，<span
class="math inline">\(f_{\min} = f_i\)</span>），我们可以将所有 <span
class="math inline">\(f_j\gets f_j-k\)</span>，得到一个新的合法的 <span
class="math inline">\(f&#39;_{1\sim i}\)</span>。</p>
<p>形象化地，将 <span class="math inline">\(f_{1\sim i}\)</span>
想象为一个逐渐降低的柱状图，任意切去了一个高度的底部，并且这个高度不高于最矮的元素（即第
<span class="math inline">\(i\)</span> 个元素）。</p>
<p>这时候有一个很美妙的性质，就是我们<mark>对于切之前和切之后的柱状图，其
<strong>最矮元素以上的部分</strong>
长得完全相同</mark>。然后就是神中神之 DP
状态设计。很难想象是在什么样的精神状态下凑出来这种神奇状态的，可能是某种我不了解的
trick？</p>
<p>令 <span class="math inline">\(dp_{i, j}\)</span> 表示对于前缀 <span
class="math inline">\(f_{1, i}\)</span>，当切去的高度为 <span
class="math inline">\(0\sim j\)</span>
时，<strong>最矮元素以上的部分</strong> 的和都为 <span
class="math inline">\(dp_{i, j}\)</span>。那么易得 <span
class="math inline">\(\sum f_{1\sim i}=j\times i + dp_{i,
j}\)</span>。</p>
<p>考虑转移。假设已知所有 <span class="math inline">\(dp_{i - 1,
j}\)</span>，需转移到 <span
class="math inline">\(i\)</span>，我们有三种转移路径：</p>
<ol type="1">
<li><p><span class="math inline">\(j &lt; a_i\)</span>：</p>
<p>对 <span class="math inline">\(a_i\)</span>
取模取不动，不会产生任何影响。<span class="math inline">\(dp_{i, j}\gets
dp_{i - 1, j}\)</span>。</p></li>
<li><p><span class="math inline">\(j\ge a_i\)</span>：</p>
<ul>
<li><p>让 <span class="math inline">\(i\)</span> 承担 <span
class="math inline">\(f_i=a_i-1\)</span> 的责任。我们从 <span
class="math inline">\(0\sim j\)</span> 中找到一个满足 <span
class="math inline">\(j&#39;\bmod a_i=a_i-1\)</span> 的 <span
class="math inline">\(j&#39;\)</span>，<span
class="math inline">\(j&#39;\)</span> 肯定是越大越好，故 <span
class="math inline">\(j&#39;=(\left\lfloor \dfrac
{j}{a_i}\right\rfloor-1)\times a_i+(a_i-1)\)</span>。</p>
<p>此时便有 <span class="math inline">\(dp_{i, a_i-1}\gets dp_{i - 1,
j&#39;} + [j&#39; - (a_i-1)]\times (i-1)\)</span>。</p></li>
<li><p>盲猜 <span class="math inline">\(0\sim i - 1\)</span> 或 <span
class="math inline">\(i+1\sim n\)</span> 中会出现承担 <span
class="math inline">\(f_{i&#39;}=a_{i&#39;-1}\)</span> 的 <span
class="math inline">\(i&#39;\)</span>，故按照 <span
class="math inline">\(j\)</span> 取最大来转移。</p>
<p>此时有 <span class="math inline">\(dp_{i, j\bmod
a_i}=dp_{i-1,j}+(j-j\bmod a_i)\times (i-1)\)</span>。</p></li>
</ul></li>
</ol>
<p>答案即为 <span class="math inline">\(\max\{j\times n+dp_{n,
j}\}\)</span>。由于不存在 <span class="math inline">\(f_i=a_i-1\)</span>
的 <span class="math inline">\(f\)</span>
肯定比存在的要劣，所以我们肯定选到的是正确的答案。</p>
<p>注意到每个 <span class="math inline">\(i\)</span> 只会新增 <span
class="math inline">\(a_i-1\)</span> 一个状态，故状态总数为 <span
class="math inline">\(O(n)\)</span>。把 <span
class="math inline">\(dp\)</span> 开成 map 就可以 <span
class="math inline">\(O(n\log n)\)</span> 地解决问题。</p>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#else
    freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;long long&gt; a(n + 1);
    std::map&lt;long long, long long&gt; t;
    std::cin &gt;&gt; a[1];
    t[a[1] - 1] = 0;
    for (int i = 2; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; a[i];
        for (;;) &#123;
            auto p = t.lower_bound(a[i]);
            if (p == t.end())
                break;
            long long j = p-&gt;first, f = p-&gt;second;
            t[j % a[i]] = std::max(t[j % a[i]], f + (j - j % a[i]) * (i - 1));
            if (j &gt;= a[i]) &#123;
                j = (j / a[i] - 1) * a[i] + a[i] - 1;
                t[a[i] - 1] = std::max(t[a[i] - 1], f + (j - (a[i] - 1)) * (i - 1));
            &#125;
            t.erase(p);
        &#125;
    &#125;
    long long res = 0;
    for (auto i : t)
        res = std::max(res, i.first * n + i.second);
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;</code></pre>
</details>
<hr />
<h3 id="stalinsort-algorithm">3. StalinSort Algorithm</h3>
<p><a target="_blank" rel="noopener" href="https://qoj.ac/problem/1456"
class="uri">https://qoj.ac/problem/1456</a></p>
<p>你会发现<mark>删最少 = 留最多</mark>。</p>
<p>考虑 <span class="math inline">\(i\)</span> 能够转移到的 <span
class="math inline">\(j(j&gt;i)\)</span> 需满足的条件。若令 <span
class="math inline">\(nex_p\)</span> 表示 <span
class="math inline">\(p\)</span> 之后第一个值比 <span
class="math inline">\(a_p\)</span> 大的元素，则 <span
class="math inline">\(j\in [nex_i, nex_{nex_i})\)</span> 且 <span
class="math inline">\(a_j&gt;a_i\)</span>。</p>
<p><mark>赛时误认为右端点为 <span class="math inline">\(i\)</span>
之后第二个值比 <span class="math inline">\(a_i\)</span>
大的元素，导致完全寄掉。</mark></p>
<p>时间复杂度 <span
class="math inline">\(O(n^2)\)</span>，考虑优化。<mark>注意到如果只有
<span class="math inline">\(j\in [nex_i, nex_{nex_i})\)</span>
这个条件很容易用线段树维护，考虑消去 <span
class="math inline">\(a_j&gt;a_i\)</span> 的影响。故考虑按 <span
class="math inline">\(a\)</span> <strong>从小到大</strong> 的顺序选取
<span class="math inline">\(i\)</span>，因为当前最小的 <span
class="math inline">\(i\)</span> 一定已经被刷完表了</mark>。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int maxn = 5e5 + 5;
const int inf = 0x3f3f3f3f;
struct _ &#123; int u, d; &#125; t1[maxn &lt;&lt; 2];
int n, t[maxn &lt;&lt; 2];
#define lt (p &lt;&lt; 1)
#define rt (lt | 1)
void upd(int p, int l, int r, int x, int v) &#123;
    t[p] = std::min(t[p], v);
    if (l == r)
        return;
    int mid = (l + r) &gt;&gt; 1;
    if (x &lt;= mid)
        upd(lt, l, mid, x, v);
    else
        upd(rt, mid + 1, r, x, v);
    return;
&#125;
int ask(int p, int l, int r, int ql, int qr) &#123;
    if (ql &lt;= l &amp;&amp; r &lt;= qr)
        return t[p];
    int mid = (l + r) &gt;&gt; 1, res = n + 1;
    if (ql &lt;= mid)
        res = ask(lt, l, mid, ql, qr);
    if (qr &gt; mid)
        res = std::min(res, ask(rt, mid + 1, r, ql, qr));
    return res;
&#125;
void pushdown(int p) &#123;
    if (t1[p].d) &#123;
        t1[lt].u = std::max(t1[lt].u, t1[p].d);
        t1[lt].d = std::max(t1[lt].d, t1[p].d);       
        t1[rt].u = std::max(t1[rt].u, t1[p].d);
        t1[rt].d = std::max(t1[rt].d, t1[p].d);       
        t1[p].d = 0;
    &#125;
    return;
&#125;
void upd(int p, int l, int r, int ql, int qr, int v) &#123;
    t1[p].u = std::max(t1[p].u, v);
    if (ql &lt;= l &amp;&amp; r &lt;= qr) &#123;
        t1[p].d = std::max(t1[p].d, v);
        return;
    &#125;
    pushdown(p);
    int mid = (l + r) &gt;&gt; 1;
    if (ql &lt;= mid)
        upd(lt, l, mid, ql, qr, v);
    if (qr &gt; mid)
        upd(rt, mid + 1, r, ql, qr, v);
    return;
&#125;
int ask(int p, int l, int r, int x) &#123;
    if (l == r)
        return t1[p].u;
    pushdown(p);
    int mid = (l + r) &gt;&gt; 1;
    if (x &lt;= mid)
        return ask(lt, l, mid, x);
    return ask(rt, mid + 1, r, x);
&#125;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#else
    freopen(&quot;sort3.in&quot;, &quot;r&quot;, stdin);
    // freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int res = 0;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; a(n + 1), ne(n + 1), f(n + 1);
    std::fill(t + 1, t + 4 * n + 1, n + 1);
    std::fill(t1 + 1, t1 + 4 * n + 1, (_)&#123; -inf, 0 &#125;);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    for (int i = n; ~i; --i) &#123;
        ne[i] = ask(1, 0, n, a[i] + 1, n);
        upd(1, 0, n, a[i], i);   
    &#125;
    std::vector&lt;int&gt; id(n + 1);
    std::iota(id.begin(), id.end(), 0);
    std::sort(id.begin(), id.end(), [&amp;](int x, int y) &#123; return a[x] &lt; a[y]; &#125;);
    f[0] = 0;
    for (int i = 0; i &lt;= n; ++i) &#123;
        if (i) &#123;
            f[id[i]] = ask(1, 0, n, id[i]);
            res = std::max(res, f[id[i]]);
        &#125;
        if (ne[id[i]] &lt;= n)
            upd(1, 0, n, ne[id[i]], ne[ne[id[i]]] - 1, f[id[i]] + 1);
    &#125;
    std::cout &lt;&lt; n - res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;</code></pre>
</details>
<hr />
<h3 id="merge-triplets">4. Merge Triplets</h3>
<p><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/agc043/tasks/agc043_d"
class="uri">https://atcoder.jp/contests/agc043/tasks/agc043_d</a></p>
<p>由于要对合法的最终序列进行计数，考虑最终序列的性质。</p>
<p>若序列中 <span
class="math inline">\(a_{i+1}&lt;a_i\)</span>，则说明在某一组中，值为
<span class="math inline">\(a_i\)</span> 的元素下一个就是 <span
class="math inline">\(a_{i+1}\)</span>。否则，因 <span
class="math inline">\(a_{i+1}\)</span> 可选且比 <span
class="math inline">\(a_i\)</span> 小，<span
class="math inline">\(a_{i+1}\)</span> 应排在 <span
class="math inline">\(a_i\)</span> 前面。</p>
<p>否则，<span class="math inline">\(a_{i+1}\)</span> 既可以与 <span
class="math inline">\(a_i\)</span> 不在同一组，也可以是 <span
class="math inline">\(a_i\)</span> 的下一个元素。</p>
<p>一组最多三个元素，也就是说，不能出现 <span
class="math inline">\(a_i&gt;a_{i+1},a_{i+2},a_{i+3}\)</span> 的情况。而
<span class="math inline">\(N=1\)</span> 时序列长度只有 <span
class="math inline">\(3\)</span>，这就是为什么样例一的答案为 <span
class="math inline">\(3!\)</span>。</p>
<p>但这个限制并不能排除所有非法情况。<span
class="math inline">\(N=2\)</span> 时暴搜我们目前限制下的解，共有 276
个，比答案中的 261 个要多，说明包含了其他非法解。</p>
<p>暴搜输出并观察，易得这 15 个非法序列即为满足目前限制且存在 <span
class="math inline">\(3\)</span> 个 <span
class="math inline">\(i\)</span>，满足 <span
class="math inline">\(a_i&gt;a_{i+1}\)</span> 且 <span
class="math inline">\(a_i&lt;a_{i+2}\)</span>
的所有序列，<mark>由前面的推导，必须分为三个长度为 2
的组，而我们要求的是长度为 3
的组。显然无法用前者组合得到后者</mark>。</p>
<p>在我们第一个条件的限制下，必须被分到同一组的数的连续长度，只有 <span
class="math inline">\(1,2,3\)</span> 三种。而：</p>
<ul>
<li>长度为 3 的对答案合法性无影响；</li>
<li>而长度为 1 的既可以和 2 组为一组，也可以和其他两个 1 组为一组；</li>
<li>长度为 2 的只能和 1 组成一组。</li>
</ul>
<p><mark>这时，我们发现所有限制都指向长度为 2 的段，其总个数不能比长度为
1 的段多。</mark></p>
<p>于是乎，上述限制可总结为两点：</p>
<ol type="1">
<li>若令所有满足 <span class="math inline">\(a_l&gt;\max\{a_{l\sim
r}\}\)</span>
的极大区间为一段（易证每段互不重合且覆盖全序列），那么其长度不能超过
3。</li>
<li>其中，长度为 2 的个数不能比长度为 1 的个数多。</li>
</ol>
<p><mark>令 <span class="math inline">\(f_{i, j}\)</span>
表示若当前枚举的最后一段右端点为 <span
class="math inline">\(i\)</span>，长度为 1 的段比长度为 2 的段多 <span
class="math inline">\(j\)</span> 的方案数。</mark></p>
<p>最后答案即为 <span class="math inline">\(\sum\limits_{j=0}^n f_{i,
j}\)</span>。</p>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#else
    freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, mod;
    std::cin &gt;&gt; n &gt;&gt; mod;
    n *= 3;
    std::vector&lt;std::unordered_map&lt;int, long long&gt; &gt; f(n + 1);
    f[0][0] = 1;
    for (int i = 0; i &lt; n; ++i)
        for (auto [j, k] : f[i]) &#123;
            (f[i + 1][j + 1] += k) %= mod;
            if (i + 2 &lt;= n)
                (f[i + 2][j - 1] += k * (i + 1) % mod) %= mod;
            if (i + 3 &lt;= n)
                (f[i + 3][j] += k * (i + 1) % mod * (i + 2) % mod) %= mod;
        &#125;
    long long res = 0;
    for (int i = 0; i &lt;= n; ++i)
        (res += f[n][i]) %= mod;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;</code></pre>
</details>
<hr />
<h3 id="runaway-quail">5. Runaway Quail</h3>
<p><a target="_blank" rel="noopener" href="https://qoj.ac/problem/5978"
class="uri">https://qoj.ac/problem/5978</a></p>
<p>容易发现鸡的奔跑方向从始至终不会变，如果我们要从往左追变成往右追，显而易见地我们会<mark>在追上右边第一只鸡前经过原点</mark>，反之同理。</p>
<p>那么有一个很神奇的状态设计，设 <span
class="math inline">\(f_{i,j}\)</span> 为追上了左边速度第 <span
class="math inline">\(1\sim i - 1\)</span> 大的所有鸡和右边速度第 <span
class="math inline">\(1\sim j - 1\)</span>
大的所有鸡，然后跑回原点的最小时间，这样我们就不用记录这个非常难记录的当前位置信息，对于速度排名
<span class="math inline">\(\ge i,j\)</span>
的所有鸡，当前是否追上我们并不关心——<mark>如果其位置比较远，那么我们会在后续转移中再考虑；如果其位置比较近，在解决速度排名
<span class="math inline">\(&lt;i,j\)</span>
的鸡时就已经抓住</mark>。</p>
<p><mark>我们 <span class="math inline">\(\mathcal O(n)\)</span>
枚举上一次反向是在抓住哪一只鸡时，然后让中间全部同向跑即可</mark>。</p>
<p>也就是说，假设我们要用 <span class="math inline">\(f_{i,j}\)</span>
更新 <span class="math inline">\(f_{k,j}\)</span>（<span
class="math inline">\(k&lt;i\)</span>），那么只需要更新抓住速度排名
<span class="math inline">\(i\sim k+1\)</span>
中跑得最远的一只鸡所需额外时间。按速度排序后可以线性算代价。</p>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const long double eps = 1e-12;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        int v, n;
        std::cin &gt;&gt; v &gt;&gt; n;
        std::vector&lt;std::pair&lt;int, int&gt; &gt; a(n + 1);
        for (int i = 1; i &lt;= n; ++i)
            std::cin &gt;&gt; a[i].first;
        for (int i = 1; i &lt;= n; ++i)
            std::cin &gt;&gt; a[i].second;
        a.emplace_back(0, 0), ++n;
        std::sort(a.begin() + 1, a.end());
        int p = std::lower_bound(a.begin() + 1, a.end(), std::make_pair(0, 0)) - a.begin();
        std::sort(a.begin() + 1, a.begin() + p, [](std::pair&lt;int, int&gt; x, std::pair&lt;int, int&gt; y) &#123; return x.second == y.second ? x.first &lt; y.first : x.second &gt; y.second; &#125;);
        std::sort(a.begin() + p + 1, a.end(), [](std::pair&lt;int, int&gt; x, std::pair&lt;int, int&gt; y) &#123; return x.second == y.second ? x.first &lt; y.first : x.second &lt; y.second; &#125;);
        std::vector&lt;std::vector&lt;long double&gt; &gt; f(n + 1, std::vector&lt;long double&gt; (n + 1, 1e18));
        f[1][n] = 0.;
        auto at = [&amp;](int i, long double t) &#123;
            return std::fabs(a[i].first + t * a[i].second * (i &lt; p ? -1 : 1));
        &#125;;
        auto calc = [&amp;](int i, long double t) &#123;
            return at(i, t) / (v - a[i].second);
        &#125;;
        // for (int i = 1; i &lt;= n; ++i)
        //     printf(&quot;%d: (%d, %d)\n&quot;, i, a[i].first, a[i].second);
        for (int i = 1; i &lt;= p; ++i)
            for (int j = n; j &gt;= p; --j) &#123;
                if (i == p &amp;&amp; j == p)
                    break;
                long double d = 0.;
                // printf(&quot;[%d, %d]: %lf\n&quot;, i, j, f[i][j]);
                for (int k = i; k &lt; p; ++k) &#123;
                    if (at(k, f[i][j]) &gt;= at(i, f[i][j]) - eps)
                        d = std::max(d, calc(k, f[i][j]));
                    // printf(&quot;  k1 = %d, d = %lf\n&quot;, k, d);
                    f[k + 1][j] = std::min(f[k + 1][j], f[i][j] + d + (k != j - 1) * d);
                &#125;
                d = 0.;
                for (int k = j; k &gt; p; --k) &#123;
                    if (at(k, f[i][j]) &gt;= at(j, f[i][j]) - eps)
                        d = std::max(d, calc(k, f[i][j]));
                    // printf(&quot;  k2 = %d, d = %lf\n&quot;, k, d);
                    f[i][k - 1] = std::min(f[i][k - 1], f[i][j] + d + (k != i + 1) * d);
                &#125;
            &#125;
        &#123;
            static int casetot = 0;
            std::cout &lt;&lt; &quot;Case #&quot; &lt;&lt; ++casetot &lt;&lt; &quot;: &quot;;
        &#125;
        std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(9) &lt;&lt; f[p][p] &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;</code></pre>
</details>

			</div>
			<hr class="dotted">
			<div class="post footer">
				<div id="hitokoto">
					<h3 id="hitokoto-title">
						一言 - Hitokoto
					</h3>
					<div id="hitokoto-content">
					</div>
					<div id="hitokoto-from">
					</div>
				</div>
				<div class="button flex">
					<div id="prev">
						
							<!-- 吐槽，为啥还需要加 / -->
							<a href="/20241017/">
								<i class="fas fa-angle-double-left" style="margin-right: 10px;"></i>
								模拟赛
							</a>
						
					</div>
					<div id="next">
						
							<a href="/20240625/">
								媒介素养
								<i class="fas fa-angle-double-right" style="margin-left: 10px;"></i>
							</a>
						
					</div>
				</div>
				<div id="vcomments" class="yahei"></div>
<script>
	new Valine({
		el: '#vcomments',
		appId: 'OlmvQ0a2Zw7xo3no2bwabOzx-gzGzoHsz',
		appKey: 'TW6t8mFeGLmhPjWisvmllvvo',
		recordIP: true,
		enableQQ: true, 
		// 目前 Valine 的 QQ 自动获取昵称似乎不可用 故不建议开启
		pageSize: 10,
		requiredFields:
			
				['nick']
			,
		placeholder: "The world is but a little place after all...\n能够根据邮箱获取你的 Gravatar 头像。昵称是必填项，长度需不低于 3。",
		avatar: 'mp',
		avatar_cdn: 'https://cravatar.cn/avatar/',
		emojiCDN: 'https://xsc062.netlify.app/em/', 
		emojiMaps: {
			
				"微笑": "wx.gif",
			
				"龇牙": "cy.gif",
			
				"流泪": "ll.gif",
			
				"笑哭": "xk.gif",
			
				"流汗": "lh.gif",
			
				"擦汗": "ch.gif",
			
				"亲亲": "qq.gif",
			
				"色": "se.gif",
			
				"疑问": "yiw.gif",
			
				"发呆": "fd.gif",
			
				"晕": "yun.gif",
			
				"鼓掌": "gz.gif",
			
				"憨笑": "hanx.gif",
			
				"快哭了": "kk.gif",
			
				"得意": "dy.gif",
			
				"狂笑": "kx.gif",
			
				"害羞": "hx.gif",
			
				"妈妈生的": "dz.gif",
			
				"糗大了": "qd.gif",
			
				"吃瓜": "cg.gif",
			
				"睁眼": "zy.webp",
			
				"辣眼睛": "lyj.gif",
			
				"酸了": "nm.gif",
			
				"滚": "gun.webp",
			
				"惊恐": "jk.gif",
			
				"幽灵": "youl.gif",
			
				"无聊": "wul.gif",
			
				"吃": "eat.gif",
			
				"你很棒棒": "bb.gif",
			
				"赞": "qiang.gif",
			
				"踩": "ruo.gif",
			
				"握手": "wsh.gif",
			
				"发抖": "fad.gif",
			
				"挥手": "hsh.gif",
			
				"磕头": "kt.gif",
			
				"怄火": "oh.gif",
			
		},
	})
</script>
			</div>
			<script>setHitokoto();</script>
		</div> 
	</div>
</div>
    <!-- 页脚开始 -->
<div id="footer" class="yahei">
    Powered by
    <a target="_blank" rel="noopener" href="https://hexo.io">
        Hexo
    </a>
    &
    <a href="/about-this-theme">
        iwll
    </a>
    <p style="margin-top: 5px;">
        2021 - 2025
    </p>
</div>
<!-- Valine 相关配置 -->
<script>
    const getValineDomTimer = setInterval(() => {
        // 不知道为什么 我从原博客 js 文件粘过来的参数是
        // "#valine .vcards .vcard"
        // DEBUG 了半天才定位到这个问题。。。
        const vcards =
            document.querySelectorAll('#valine, .vcards, .vcard');
        if (vcards.length > 0) {
            let author = 'XSC062';
            for (let vcard of vcards) {
                const vnick_dom = vcard.querySelector('.vhead .vnick');
                if (vnick_dom != null) {
                    const vnick = vnick_dom.innerHTML;
                    if (vnick === author) {
                        vnick_dom.innerHTML =
                        `${vnick} <span id="rootitem" class="fira">root</span>`
                    }
                }
            }
        }
        else {
            clearInterval(getValineDomTimer);
        }
    }, 2000);
    SetActiveItem();
    setDetailsSummary();
    setTitleAnchor();
    setEmptyToc();
    setCodeClassName();
</script>


<!-- js -->
<!-- 搜索功能相关配置 -->

<script src="/js/search.js"></script>

<script type="text/javascript">
var search_path = "search.xml";
if (search_path.length == 0) {
    search_path = "search.xml";
}
var path = "/" + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script>
<!-- prism 相关配置 -->
<script type="text/javascript" src="/js/prism.js" defer></script>
<!-- 代码块复制功能 -->
<script type="text/javascript" src="/js/clipboard.min.js"></script>
<script type="text/javascript" src="/js/clipboard-use.js"></script>
<!-- 页脚结束 -->
</body>
</html>