<!DOCTYPE html>
<html>
<head>
    <!-- 网站图标 -->
<link rel="icon" type="image/png" sizes="32x32" href="/images/icon.svg">
<!-- 其他图标支持 -->
<link rel="stylesheet" href="/css/facss/fa-brands.min.css">
<link rel="stylesheet" href="/css/facss/fa-regular.min.css">
<link rel="stylesheet" href="/css/facss/fa-solid.min.css">
<link rel="stylesheet" href="/css/facss/fontawesome.min.css">
<link rel="stylesheet" href="/css/facss/fontawesome-all.css">
<link href="https://use.fontawesome.com/releases/v5.0.4/css/all.css" rel="stylesheet">
<!-- 网站标题 -->
<title>
	
		练习：数数 & 容斥 -
	
	XSC062 的博客
</title>
<!-- js 引入 -->
<script>
const searchPath = "/search.xml"
</script>

<script src="/js/afterloaded.js"></script>


<script src="/js/jQuery.js"></script>

<!-- 载入 Valine -->

<script src="/js/Valine.min.js"></script>

<!-- css 引入 -->

<link rel="stylesheet" href="/css/layout.css">


<link rel="stylesheet" href="/css/prcss/prism.css">



<!-- rss -->
<link rel="alternate" type="application/rss+xml" title="" href="https://xsc062.netlify.app/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="" href="https://xsc062.netlify.app/atom.xml" />
<link rel="alternate" type="application/json" title="" href="https://xsc062.netlify.app/feed.json" />

<meta charset="utf-8"> 
<meta name="generator" content="Hexo 7.2.0"></head>
<body class="line-numbers match-braces no-brace-select rainbow-braces">
	
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ],
            processEscapes: true
          }
        });
      </script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
            tex2jax: {
              skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
            }
          });
      </script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
              var all = MathJax.Hub.getAllJax(), i;
              for(i=0; i < all.length; i += 1) {
                  all[i].SourceElement().parentNode.className += ' has-jax';
              }
          });
      </script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS_CHTML"></script>

	<!-- 搜索 -->
<script>
	function closeSearchBox() {
		$("#search-bg").css("transition", "null"); 
		$("#search-bg").css("z-index", "-1"); 
		$("#search-bg").css("opacity", "0%");
		return;
	}
</script>
<div id="search-bg">
	<div id="search-box">
		<button id="close-button" onclick="closeSearchBox()">
			<i class="fas fa-times"></i>
		</button>
		<input type="text" id="search-input" placeholder="Type to search...">
		<div id="search-results">
			<div id="emptyInput">
				<p>键入以搜索…</p>
				<p><i>匹配算法</i>：把输入按空格拆分，单独<strong>匹配</strong>每一段输入（不区分大小写，仅匹配文章文本内容），输出取或后的结果。</p>
				<p>模糊搜索似乎很难搞，目前没有相关打算。</p>
			</div>
		</div>
	</div>
</div>
<!-- 顶栏整体导航菜单 -->
<div class="ui top menu">
	<!-- 左对齐 logo -->
	<a class="logo" href="/">
		<img width="25px" height="25px" style="border: solid transparent 2.5px" src="/images/icon.svg"></img>
		<div id="bartitle" class="text">
			XSC062 的博客
		</div>
	</a>
	<!-- 右对齐部分导航 -->
	<div id="rightali" class="serif">
		<a class="item" id="Search" type="button">
			<i class="btn text-muted fa fa-search" id="search-icon" disabled></i>
		</a>
		<a class="item" id="Home" href="/">
			Home
		</a>
		<a class="item" id="Arch" href="/archives">
			Archives
		</a>
		<!-- <a class="item" id="Cate" href="/categories">
			Categories
		</a> -->
		<a class="item" id="Tags" href="/tags">
			Tags
		</a>
		<a class="item" id="Frie" href="/friends">
			Friends
		</a>
		<a class="item" id="Abou" href="/about">
			About
		</a>
	</div>
</div>
    
<link rel="stylesheet" href="/css/post.css">


<script src="/js/post.js"></script>


<div class="main">
	<div id="sidebar" class="text">
		<aside id="toc">
			<span id="toctitle">
				<i class="fas fa-list"></i>
				目录
			</span>
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#a---reversi-2"><span class="toc-text">A - Reversi 2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#b---cigar-box"><span class="toc-text">B - Cigar Box</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c---swap-characters"><span class="toc-text">C - Swap Characters</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#a---leq-and-neq-non-equal-neighbours"><span class="toc-text">A - LEQ and NEQ &#x2F; Non-equal Neighbours</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#b---unbranched"><span class="toc-text">B - Unbranched</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c---%E5%B1%80%E9%83%A8%E6%9E%81%E5%B0%8F%E5%80%BC"><span class="toc-text">C - 局部极小值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#a---%E6%95%B0%E5%88%97"><span class="toc-text">A - 数列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#b---vasya-and-array"><span class="toc-text">B - Vasya and Array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c---road-of-the-king"><span class="toc-text">C - Road of the King</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#d---%E3%83%81%E3%83%BC%E3%83%A0%E5%88%86%E3%81%91"><span class="toc-text">D - チーム分け</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#e---random-isolation"><span class="toc-text">E - Random Isolation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#a---%E6%9F%93%E8%89%B2%E9%97%AE%E9%A2%98"><span class="toc-text">A - 染色问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#b---painting-the-wall"><span class="toc-text">B - Painting The Wall</span></a></li></ol>
		</aside>
	</div>
	<div class="ui post container">
		<div class="ui text container">
			<span id="postcon">
				<span id="postinfo">
					<div class="ui post title serif">
						<div id="fortitle" data-content="练习：数数 & 容斥">
							练习：数数 & 容斥
						</div>
						<div class="ui title background">
						</div>
					</div>
					<span id="date">
						<i class="fas fa-calendar-alt" style="margin-right: 4px;"></i>
						2025-11-03
					</span>
				</span>
			</span>
			<div id="posttags" class="dotted border">
				
					
						<a href="/tags/计数/" class="citem">计数</a>
					
						<a href="/tags/容斥/" class="citem">容斥</a>
					
						<a href="/tags/二项式反演/" class="citem">二项式反演</a>
					
				
			</div>
			<!-- 本来用的是 fromNow 然后字符串判断，没想到可以直接调用 moment() -->
			
			<div id="content">
				<p>数数，但是性质题</p>
<span id="more"></span>
<hr />
<h2 id="a---reversi-2">A - Reversi 2</h2>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/AT_arc189_a" class="uri">https://www.luogu.com.cn/problem/AT_arc189_a</a></p>
<ul>
<li><p>操作可以看成，任选一个点，找到两侧最近的颜色相异的点，进行推平。</p>
<p>或，任选一个极长连续段，推平为其两端的颜色。</p></li>
<li><p>很容易注意到最终序列被分为若干个极长连续段，彼此独立。对于起始序列，容易发现任意区间中的任意操作会减少 2 的不同段数量（故显然最终序列连续段长度应该为奇数，且两端颜色和目标颜色一致）。</p></li>
<li><p>令 <span class="math inline">\(f_i\)</span> 为长度为 <span class="math inline">\(i\)</span> 的连续段被推平的方案数（<span class="math inline">\(i\bmod2=1\)</span>），那么有 <span class="math inline">\(f_i=(i - 2)\times f_{i-2}\)</span>。</p></li>
<li><p>最终方案数应为所有极长段方案的多重集排列乘上它们各自独立方案数之积。</p></li>
</ul>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::syns_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; a(n + 1);
    std::vector&lt;long long&gt; f(n + 1), fac(n + 1), inv(n + 1);
    fac[0] = inv[0] = 1ll;
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; a[i];
        fac[i] = fac[i - 1] * i % mod;
    &#125;
    auto qkp = [&amp;](long long x, int y) &#123;
        auto res = 1ll;
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    inv[n] = qkp(fac[n], mod - 2);
    for (int i = n - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    f[1] = 1;
    for (int i = 3; i &lt;= n; i += 2)
        f[i] = f[i - 2] * (i - 2) % mod;
    auto res = 1ll;
    int L = 1, cnt = 0;
    for (int i = 1; i &lt;= n; ++i)
        if (i == n || a[i + 1] != a[i]) &#123;
            if (a[i] != i % 2 || (i - L + 1) % 2 == 0) &#123;
                std::cout &lt;&lt; 0 &lt;&lt; &#39;\n&#39;;
                return 0;
            &#125;
            (res *= f[i - L + 1]) %= mod;
            (res *= inv[(i - L) / 2]) %= mod;
            cnt += (i - L) / 2;
            L = i + 1;
        &#125;
    std::cout &lt;&lt; res * fac[cnt] % mod &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="b---cigar-box">B - Cigar Box</h2>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/AT_arc112_e" class="uri">https://www.luogu.com.cn/problem/AT_arc112_e</a></p>
<ul>
<li><p>发现一个数的状态只取决于，最后一次以它为主体的操作，及这次操作之后的所有操作</p></li>
<li><p>进一步地发现，按最后一次操作分类，可以分为，向左（<code>L</code>）、向右（<code>R</code>）、没被操作过（<code>M</code>）三种类型。</p>
<p>可以很显然地注意到，最终序列一定是 <code>LLLMMMRRR</code> 的形式，其中，仅要求 <code>M</code> 是递增的；现在需要计算有多少长度为 <span class="math inline">\(m\)</span> 的操作序列对应所有的 <code>LMR</code> 序列（如果认为所有的 <code>M</code> 始终是不动的可能会更好理解）。</p></li>
<li><p>发现同种类数间，『最后一次操作』的相对顺序是固定的。进一步会发现这其实是<a target="_blank" rel="noopener" href="https://oi-wiki.org/math/combinatorics/stirling/">第二类斯特林数</a>，最后答案为：</p></li>
</ul>
<p><span class="math display">\[
\sum_{L,R}\binom{L+R}{L}\cdot \begin{Bmatrix}m\\ L+R\end{Bmatrix}\cdot 2^{m-L-R}
\]</span></p>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::syns_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    using arr = std::vector&lt;long long&gt;;
    arr pw(m + 1), fac(m + 1), inv(m + 1);
    std::vector&lt;arr&gt; f(m + 1, arr(m + 1));
    std::vector&lt;int&gt; a(n + 1);
    std::vector&lt;std::vector&lt;int&gt; &gt; ok(n + 1, std::vector&lt;int&gt; (n + 1));
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    for (int l = 1; l &lt;= n; ++l)
        for (int r = l; r &lt;= n; ++r)
            if (r == l || a[r] &gt; a[r - 1])
                ok[l][r] = 1;
            else
                break;
    f[1][1] = 1ll, pw[0] = fac[0] = inv[0] = 1ll;
    for (int i = 2; i &lt;= m; ++i)
        for (int j = 1; j &lt;= i; ++j)
            f[i][j] = (f[i - 1][j - 1] + f[i - 1][j] * j) % mod;
    for (int i = 1; i &lt;= m; ++i) &#123;
        pw[i] = pw[i - 1] * 2 % mod;
        fac[i] = fac[i - 1] * i % mod;
    &#125;
    auto qkp = [&amp;](long long x, int y) &#123;
        auto res = 1ll;
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    inv[m] = qkp(fac[m], mod - 2);
    for (int i = m - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    auto C = [&amp;](int n, int m) &#123;
        return fac[n] * inv[m] % mod * inv[n - m] % mod;
    &#125;;
    auto res = 0ll;
    for (int L = 0; L &lt;= m &amp;&amp; L &lt;= n; ++L)
        for (int R = 0; L + R &lt;= m &amp;&amp; L + R &lt;= n; ++R)
            if (L + 1 &gt; n - R || ok[L + 1][n - R])
                res += C(L + R, L) * f[m][L + R] % mod * pw[m - L - R] % mod;
    std::cout &lt;&lt; res % mod &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="c---swap-characters">C - Swap Characters</h2>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/AT_arc168_c" class="uri">https://www.luogu.com.cn/problem/AT_arc168_c</a></p>
<ul>
<li><p>考虑值域为 <span class="math inline">\(0\)</span> 和 <span class="math inline">\(1\)</span> 的情况</p>
<p>发现这个很唐 <del>好险，AI 差点比我先做出来了</del>，转化成枚举操作次数 <span class="math inline">\(i\)</span>，答案是</p>
<p><span class="math display">\[
\sum_{i\le\min(s_0,s_1)}\binom{s_0}{i}\cdot\binom{s_1}{i}
\]</span></p></li>
<li><p>根据这个可以得到启发，发现所谓任意交换可以转化为，每个字母的支出和收入相等，故考虑画个表：</p></li>
</ul>
<hr />
<h2 id="a---leq-and-neq-non-equal-neighbours">A - LEQ and NEQ / Non-equal Neighbours</h2>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/AT_arc115_e" class="uri">https://www.luogu.com.cn/problem/AT_arc115_e</a> / <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1591F" class="uri">https://www.luogu.com.cn/problem/CF1591F</a> / <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1585F" class="uri">https://www.luogu.com.cn/problem/CF1585F</a></p>
<ul>
<li><p>容斥，钦定有 <span class="math inline">\(i\)</span> 对相同元素，那么答案为 <span class="math inline">\(\sum\limits_{i=0}^{n-1} (-1)^{n-1-i} \cdot g_i\)</span>，其中 <span class="math inline">\(g_i\)</span> 表示至少有 <span class="math inline">\(i\)</span> 对相同元素的方案数。</p></li>
<li><p>考虑 <span class="math inline">\(g_i\)</span> 的计算，朴素的做法是二维 DP，令 <span class="math inline">\(f_{i, j}\)</span> 表示 DP 到 <span class="math inline">\(i\)</span>，已经有了至多 <span class="math inline">\(j\)</span> 对不同元素的方案数（发现这样才更好 DP）。发现没啥好的 <span class="math inline">\(O(n^2)\)</span> 转移，只能 <span class="math inline">\(O(n^3)\)</span>：</p>
<p><span class="math display">\[
f_{i,j}=\sum_{k&lt;i}f_{k, j-1}\times \min\{A_{k+1\cdots i}\}
\]</span></p></li>
<li><p>一个适用于容斥 DP 的 nb 优化：发现系数只取决于 <span class="math inline">\(j\)</span> 维的奇偶性，发现转移也只关注奇偶性，故设 <span class="math inline">\(f_{i,0/1}\)</span> 减少一维。</p>
<p>同时，很显然存在一个单调栈优化的结构，这样就可以在 <span class="math inline">\(O(n)\)</span> 内完成 DP。</p></li>
</ul>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; a(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    struct node &#123; int mn; long long c0, c1; &#125;;
    std::stack&lt;node&gt; st;
    std::vector&lt;std::array&lt;long long, 2&gt; &gt; f(n + 1);
    f[0][0] = 1ll, f[0][1] = 0ll;
    auto s0 = 0x3f3f3f3fll, s1 = 0ll;
    st.push(&#123; 0x3f3f3f3f, 1ll, 0ll &#125;);
    for (int i = 1; i &lt;= n; ++i) &#123;
        auto p0 = 0ll, p1 = 0ll;
        for (; !st.empty(); ) &#123;
            auto [mn, c0, c1] = st.top();
            if (mn &lt;= a[i])
                break;
            st.pop();
            p0 += c0, p1 += c1;
            (s0 += mod - c0 * (mn - a[i]) % mod) %= mod;
            (s1 += mod - c1 * (mn - a[i]) % mod) %= mod;
        &#125;
        st.push(&#123; a[i], p0 % mod, p1 % mod &#125;);
        f[i][0] = s1, f[i][1] = s0;
        (s0 += f[i][0] * 0x3f3f3f3f % mod) %= mod;
        (s1 += f[i][1] * 0x3f3f3f3f % mod) %= mod;
        st.push(&#123; 0x3f3f3f3f, f[i][0], f[i][1] &#125;);
    &#125;
    std::cout &lt;&lt; (f[n][n &amp; 1] + mod - f[n][(n &amp; 1) ^ 1]) % mod &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="b---unbranched">B - Unbranched</h2>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/AT_abc180_f" class="uri">https://www.luogu.com.cn/problem/AT_abc180_f</a></p>
<ul>
<li><p>注意到只会有环和链两种情况。发现消耗的点数和边数是不同的，再加上题目有边数限制，令 <span class="math inline">\(f_{i,j}\)</span> 表示消耗了 <span class="math inline">\(i\)</span> 个点 <span class="math inline">\(j\)</span> 条边时的方案数。</p></li>
<li><p>转移是显然的：</p>
<p>对于环的情况，答案为圆排列去掉翻折，即 <span class="math inline">\(\dfrac {(k-1)!}2\)</span>。特别地，二元环的圆排列不存在翻折，故答案为 <span class="math inline">\(1\)</span>。</p>
<p>对于链的情况，去掉翻折即可，答案为 <span class="math inline">\(\dfrac {k!}2\)</span>。</p></li>
<li><p>去重，参考典型的图计数问题，钦定没被选的点中，标号最小的必须被选，所以会有 <span class="math inline">\(C(n-(i-k)-1,k-1)\)</span> 的系数。</p></li>
<li><p>显然对于最大值恰好为 <span class="math inline">\(L\)</span> 的限制可以直接记一个 <code>bool</code> 量在状态里；尊重一下容斥的标题，用 <span class="math inline">\(L\)</span> 的答案减去 <span class="math inline">\(L-1\)</span> 的答案亦可。</p></li>
</ul>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int mod = 1e9 + 7;
const int inv2 = (mod + 1) &gt;&gt; 1;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m, L;
    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; L;
    using arr = std::vector&lt;long long&gt;;
    using brr = std::vector&lt;arr&gt;;
    using crr = std::vector&lt;brr&gt;;
    arr fac(n + 1);
    brr C(n + 1, arr(n + 1));
    fac[0] = 1ll, C[0][0] = 1ll;
    for (int i = 1; i &lt;= n; ++i) &#123;
        C[i][0] = 1ll;
        fac[i] = fac[i - 1] * i % mod;
        for (int j = 1; j &lt;= i; ++j)
            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;
    &#125;
    crr f(n + 1, brr(m + 1, arr(2)));
    f[0][0][0] = 1ll;
    auto work = [&amp;](int i, int j, int k, int p1, int p2) &#123;
        if (k == 1)
            f[i][j][p2] += f[i - 1][j][p1];
        else if (k == 2) &#123;
            if (j &gt;= 2)
                f[i][j][p2] += f[i - 2][j - 2][p1] * C[n - (i - k) - 1][k - 1] % mod; 
            if (j &gt;= 1)
                f[i][j][p2] += f[i - 2][j - 1][p1] * C[n - (i - k) - 1][k - 1] % mod;
        &#125;
        else &#123;
            if (j &gt;= k)
                f[i][j][p2] += f[i - k][j - k][p1] * C[n - (i - k) - 1][k - 1] % mod * fac[k - 1] % mod * inv2 % mod;
            if (j &gt;= k - 1)
                f[i][j][p2] += f[i - k][j - k + 1][p1] * C[n - (i - k) - 1][k - 1] % mod * fac[k] % mod * inv2 % mod;
        &#125;
        return;
    &#125;;
    for (int i = 1; i &lt;= n; ++i)
        for (int j = 0; j &lt;= m; ++j) &#123;
            for (int k = 1; k &lt;= i &amp;&amp; k &lt;= L; ++k)
                if (k == L)
                    work(i, j, k, 0, 1), work(i, j, k, 1, 1);
                else
                    work(i, j, k, 0, 0), work(i, j, k, 1, 1);
            f[i][j][0] %= mod, f[i][j][1] %= mod;
        &#125;
    std::cout &lt;&lt; f[n][m][1] &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="c---局部极小值">C - 局部极小值</h2>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3160" class="uri">https://www.luogu.com.cn/problem/P3160</a></p>
<ul>
<li><p>重要性质：一个合法棋盘，<code>X</code> 的数量不会超过八个，故一个想法是只考虑 <code>X</code> 填的数，进而想到容斥</p></li>
<li><p>钦定至少有某些位置是 <code>X</code> 进行容斥，结合上面的性质发现空棋盘上的合法超集共 1000 多个，故可做，考虑单步钦定状态下的答案。</p>
<p>令 <span class="math inline">\(f_{i,S}\)</span> 表示填了 <span class="math inline">\(j\)</span> 个数，目前 <code>X</code> 集合已经填完了 <span class="math inline">\(S\)</span> 内元素的方案数。</p></li>
</ul>
<hr />
<h2 id="a---数列">A - 数列</h2>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P7961" class="uri">https://www.luogu.com.cn/problem/P7961</a></p>
<ul>
<li><p>发现比较合理的 DP 方式是，令 <span class="math inline">\(f_{i,j,k,l}\)</span> 表示当前正在 DP <span class="math inline">\(i\)</span> 这个值，已经填了 <span class="math inline">\(j\)</span> 个数，<span class="math inline">\(2^i\)</span> 的个数，加上『进位』上来的，一共有 <span class="math inline">\(k\)</span> 个，<span class="math inline">\(2^0\sim 2^i\)</span> 总共有 <span class="math inline">\(l\)</span> 个 1 的答案。那么有：</p>
<p><span class="math display">\[
f_{i+1,j+c,\left\lfloor\frac k2\right\rfloor+c,l+\left(\left\lfloor\frac k2\right\rfloor+c\right)\bmod 2}\gets f_{i,j,k,l}\times {v_{i + 1}}^c\times (c!)^{-1}
\]</span></p>
<p>其中 <span class="math inline">\((c!)^{-1}\)</span> 为多重集排列。最后乘上 <span class="math inline">\(n!\)</span> 即可。</p></li>
<li><p>最后若 <span class="math inline">\(l+\text{ctz}\left(\left\lfloor\frac k2\right\rfloor\right)\le K\)</span> 即可统计 <span class="math inline">\(f_{m,n,k,l}\)</span> 的贡献。</p></li>
<li><p>注意到 <span class="math inline">\(k\)</span> 维始终不超过 <span class="math inline">\(n\)</span>，故复杂度 <span class="math inline">\(O(mn^3K)\)</span>，非常可过。</p></li>
</ul>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m, s;
    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;
    using arr = std::vector&lt;long long&gt;;
    using brr = std::vector&lt;arr&gt;;
    brr v(m + 1, arr(n + 1));
    for (int i = 0; i &lt;= m; ++i) &#123;
        v[i][0] = 1ll;
        std::cin &gt;&gt; v[i][1];
        for (int j = 2; j &lt;= n; ++j)
            v[i][j] = v[i][j - 1] * v[i][1] % mod;
    &#125;
    arr inv(n + 1);
    inv[0] = 1ll;
    auto fac = 1ll;
    auto qkp = [&amp;](long long x, int y) &#123;
        auto res = 1ll;
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    for (int i = 1; i &lt;= n; ++i) &#123;
        (fac *= i) %= mod;
        inv[i] = qkp(fac, mod - 2);
    &#125;
    using crr = std::vector&lt;brr&gt;;
    std::vector&lt;crr&gt; f(m + 1, crr(n + 1, brr(n + 1, arr(s + 1))));
    for (int i = 0; i &lt;= n; ++i)
        f[0][i][i][i &amp; 1] = v[0][i] * inv[i] % mod;
    for (int i = 0; i &lt; m; ++i)
      for (int j = 0; j &lt;= n; ++j)
        for (int k = 0; k &lt;= n; ++k)
          for (int l = 0; l &lt;= s; ++l) &#123;
            f[i][j][k][l] %= mod;
            for (int c = 0; j + c &lt;= n &amp;&amp; k / 2 + c &lt;= n &amp;&amp; l + (k / 2 + c) % 2 &lt;= s; ++c)
                f[i + 1][j + c][k / 2 + c][l + (k / 2 + c) % 2] += f[i][j][k][l] * v[i + 1][c] % mod * inv[c] % mod;
          &#125;
    auto res = 0ll;
    for (int k = 0; k &lt;= n; ++k)
        for (int l = 0; l &lt;= s; ++l)
            if (l + __builtin_popcount(k / 2) &lt;= s)
                res += f[m][n][k][l] % mod;
    std::cout &lt;&lt; res % mod * fac % mod &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="b---vasya-and-array">B - Vasya and Array</h2>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1093F" class="uri">https://www.luogu.com.cn/problem/CF1093F</a></p>
<ul>
<li><p>发现正着做避免不了记录相同段长度，所以考虑反过来容斥。</p>
<p>会发现这是一个类似于<a href="/20230418/">两双手</a>的容斥结构。<del>两双手还在输出</del></p></li>
<li><p>令 <span class="math inline">\(f_{i,j}\)</span> 表示前 <span class="math inline">\(i\)</span> 个均合法，且第 <span class="math inline">\(i\)</span> 个元素为 <span class="math inline">\(j\)</span> 的方案数，考虑什么时候会出现『前 <span class="math inline">\(i-1\)</span> 个元素合法，到了第 <span class="math inline">\(i\)</span> 个非法』的情况</p>
<p>发现即当前 <span class="math inline">\(i\)</span> 前面有 <span class="math inline">\(len-1\)</span> 个相同元素，且第 <span class="math inline">\(i\)</span> 个成为第 <span class="math inline">\(len\)</span> 个相同元素的情况。</p></li>
<li><p>显然有转移：</p>
<p><span class="math display">\[
f_{i,j}\gets \left(\sum_l f_{i-1,l}\right)-\left(\sum_{l\ne j} f_{i-len,l}\right)\times [a_{i-len+1\cdots i} = j\text{ is available}]
\]</span></p>
<p>记录一下 <span class="math inline">\(s_i=\sum\limits_{j}f_{i,j}\)</span> 的值即可做到 <span class="math inline">\(O(nk)\)</span>。</p></li>
</ul>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, k, L;
    std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; L;
    std::vector&lt;int&gt; a(n + 1);
    std::vector&lt;std::vector&lt;int&gt; &gt; cnt(n + 1, std::vector&lt;int&gt; (k + 1));
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; a[i];
        for (int j = 1; j &lt;= k; ++j)
            cnt[i][j] = cnt[i - 1][j] + (a[i] == j);
        cnt[i][0] = cnt[i - 1][0] + (a[i] == -1);
    &#125;
    using arr = std::vector&lt;long long&gt;;
    using brr = std::vector&lt;arr&gt;;
    arr s(n + 1);
    brr f(n + 1, arr(k + 1));
    s[0] = 1ll;
    for (int i = 1; i &lt;= n; ++i)
        for (int j = 1; j &lt;= k; ++j)
            if (a[i] == -1 || a[i] == j) &#123;
                f[i][j] = s[i - 1];
                if (i &gt;= L &amp;&amp; (cnt[i][j] - cnt[i - L][j]) + (cnt[i][0] - cnt[i - L][0]) == L) &#123;
                    f[i][j] += mod - (s[i - L] - f[i - L][j]);
                    if (s[i - L] &lt; f[i - L][j])
                        f[i][j] -= mod;
                    if (f[i][j] &gt;= mod)
                        f[i][j] -= mod;
                &#125;
                s[i] += f[i][j];
                if (s[i] &gt;= mod)
                    s[i] -= mod;
            &#125;
    std::cout &lt;&lt; s[n] &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="c---road-of-the-king">C - Road of the King</h2>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/AT_codefestival_2016_final_f" class="uri">https://www.luogu.com.cn/problem/AT_codefestival_2016_final_f</a></p>
<ul>
<li><p>发现最后的图是强连通的，当且仅当<strong>所有点都能走到 1</strong>。</p>
<p>最开始转化成『所有点都能通过操作序列走到 1』，错麻了 /qd</p></li>
<li><p>令 <span class="math inline">\(f_{i,j,k}\)</span> 表示前 <span class="math inline">\(i\)</span> 步，已经使得 <span class="math inline">\(j\)</span> 个点能走到 1，当前已经访问过了 <span class="math inline">\(k\)</span> 个不能走到 <span class="math inline">\(1\)</span> 的点。</p>
<p>如果再次访问 <span class="math inline">\(j\)</span> 个点中的其中一个，那么这 <span class="math inline">\(k\)</span> 个点就能走到 1。转移是容易的。</p></li>
</ul>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int mod = 1e9 + 7;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    using arr = std::vector&lt;long long&gt;;
    using brr = std::vector&lt;arr&gt;;
    std::vector&lt;brr&gt; f(m + 1, brr(n + 1, arr(n + 1)));
    f[0][1][0] = 1ll;
    for (int i = 0; i &lt; m; ++i)
        for (int j = 1; j &lt;= n; ++j) &#123;
            for (int k = 0; k + j &lt;= n &amp;&amp; k + j &lt;= i + 1; ++k) &#123;
                f[i][j][k] %= mod;
                f[i + 1][j][k] += f[i][j][k] * k % mod;
                f[i + 1][j + k][0] += f[i][j][k] * j % mod;
                if (j + k != n)
                    f[i + 1][j][k + 1] += f[i][j][k] * (n - j - k) % mod;
            &#125;
        &#125;
    std::cout &lt;&lt; f[m][n][0] % mod &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="d---チーム分け">D - チーム分け</h2>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/AT_mujin_pc_2018_f" class="uri">https://www.luogu.com.cn/problem/AT_mujin_pc_2018_f</a></p>
<ul>
<li><p>很容易得到一个 <span class="math inline">\(O(n^3)\)</span> 的做法：给 <span class="math inline">\(a\)</span> 排序，从大到小选每个组的『限制者』。</p>
<p><span class="math inline">\(f_{i,j}\)</span> 表示选到 <span class="math inline">\(i\)</span>，还剩 <span class="math inline">\(j\)</span> 个 <span class="math inline">\(\ge a_i\)</span> 的人没有分组，则：</p>
<p><span class="math display">\[
f_{i-1,j+1-k}\gets f_{i,j}\quad(1\le k\le a_i)\\
f_{i-1,j+1}\gets f_{i,j}
\]</span></p></li>
<li><p>后面这个优化还是很难想的…… 主要是要注意到，可以不必在某个 <span class="math inline">\(a_i\)</span> 处钦定其为『限制者』；而是在某个 <span class="math inline">\(i\)</span> 处，给『未分组』的人分大小为 <span class="math inline">\(i\)</span> 的组，而不关心具体谁是限制者，甚至不关心限制者的 <span class="math inline">\(a\)</span> 值。</p>
<p>记 <span class="math inline">\(c_i\)</span> 表示 <span class="math inline">\(i\)</span> 处有几个 <span class="math inline">\(a\)</span>，做多重集组合。仍然记录未分组人数 <span class="math inline">\(j\)</span>，那么一个固定的 <span class="math inline">\(j\)</span> 能贡献的大小为 <span class="math inline">\(i\)</span> 的组满足调和级数，枚举组数 <span class="math inline">\(k\)</span>，有：</p>
<p><span class="math display">\[
f_{i-1,j+c_i-k\cdot i}\gets f_{i+1,j}\times \binom{j+c_i}{i\cdot k}\times \frac{(i\cdot k)!}{(i!)^k\times k!}\quad\left(k\le \frac{j+c_i}i\right)
\]</span></p>
<p><strong>一定要注意分母里的 <span class="math inline">\(k!\)</span> 的含义（消序）！组是无序的。</strong></p></li>
<li><p>复杂度 <span class="math inline">\(O(n^2\log n)\)</span>。</p></li>
</ul>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; c(n + 1);
    for (int i = 1, x; i &lt;= n; ++i)
        std::cin &gt;&gt; x, ++c[x];
    using arr = std::vector&lt;long long&gt;;
    using brr = std::vector&lt;arr&gt;;
    brr C(n + 1, arr(n + 1));
    C[0][0] = 1ll;
    for (int i = 1; i &lt;= n; ++i) &#123;
        C[i][0] = 1ll;
        for (int j = 1; j &lt;= i; ++j)
            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;
    &#125;
    arr fac(n + 1);
    fac[0] = 1ll;
    for (int i = 1; i &lt;= n; ++i)
        fac[i] = fac[i - 1] * i % mod;
    auto qkp = [&amp;](long long x, int y) &#123;
        auto res = 1ll;
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    brr pw(n + 1, arr(n + 1));
    for (int i = 0; i &lt;= n; ++i) &#123;
        pw[i][0] = 1ll, pw[i][1] = qkp(fac[i], mod - 2);
        for (int j = 2; j &lt;= n; ++j)
            pw[i][j] = pw[i][j - 1] * pw[i][1] % mod;
    &#125;
    brr f(n + 2, arr(n + 1));
    f[n + 1][0] = 1ll;
    for (int i = n; i; --i)
        for (int j = 0; j + c[i] &lt;= n; ++j)
            for (int k = 0, l = (j + c[i]) / i; k &lt;= l; ++k)
                (f[i][j + c[i] - k * i] += f[i + 1][j] * C[j + c[i]][i * k] % mod * fac[i * k] % mod * pw[i][k] % mod * pw[k][1] % mod) %= mod;
    std::cout &lt;&lt; f[1][0] &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="e---random-isolation">E - Random Isolation</h2>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/AT_arc165_e" class="uri">https://www.luogu.com.cn/problem/AT_arc165_e</a></p>
<ul>
<li><p>发现期望可以拆贡献，每个局面下，每个大小 <span class="math inline">\(&gt;K\)</span> 的连通块恰好贡献 1 次操作次数。</p>
<p>这里提一下，一开始有这样的想法：每个存在 <span class="math inline">\(&gt;K\)</span> 连通块的局面都可以操作 1 次，所以一个局面有 1 的贡献；这是否和上面得到的结论矛盾？</p>
<p>答案是，统计局面的方案数权值和连通块的方案数权值是不一样的，但总和是一样的。且局面没什么好的统计方法，故统计连通块。</p></li>
<li><p>令 <span class="math inline">\(f_{x,i,j}\)</span> 表示 <span class="math inline">\(x\)</span> 为根，子树内选了大小为 <span class="math inline">\(i\)</span> 的连通块，一共需要删除 <span class="math inline">\(j\)</span> 个点。那么相当于要求这 <span class="math inline">\(j\)</span> 个点的删除时间早于 <span class="math inline">\(i\)</span> 内所有点。树上背包统计方案数，每个点处计算权值与贡献即可。</p></li>
<li><p>最后算权值的时候，把操作序列看成后几项无效的排列，那么要求这 <span class="math inline">\(j\)</span> 个点的操作序列需要在所有 <span class="math inline">\(i\)</span> 个点的前面</p>
<p>可以猜到一个答案：<span class="math inline">\(\dfrac {i!\times j!}{(i+j)!}\)</span>。</p>
<p>但仔细想来并站不住脚：每个连通块的后几项在实际操作序列里是不存在的，整个操作序列的长短甚至都是未知的，好像没什么道理。</p>
<p>问了一圈没人说出来个靠谱的证明。算了。</p></li>
</ul>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, k;
    std::cin &gt;&gt; n &gt;&gt; k;
    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);
    for (int i = 1, x, y; i &lt; n; ++i) &#123;
        std::cin &gt;&gt; x &gt;&gt; y;
        g[x].push_back(y), g[y].push_back(x);
    &#125;
    using arr = std::vector&lt;long long&gt;;
    using brr = std::vector&lt;arr&gt;;
    brr C(n + 1, arr(n + 1));
    for (int i = 0; i &lt;= n; ++i) &#123;
        C[i][0] = 1ll;
        for (int j = 1; j &lt;= i; ++j)
            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;
    &#125;
    auto qkp = [&amp;](long long x, int y) &#123;
        auto res = 1ll;
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    arr fac(n + 1), inv(n + 1);
    fac[0] = inv[0] = 1ll;
    for (int i = 1; i &lt;= n; ++i) &#123;
        fac[i] = fac[i - 1] * i % mod;
        inv[i] = qkp(fac[i], mod - 2);
    &#125;
    std::vector&lt;int&gt; siz(n + 1);
    brr h(n + 1, arr(n + 1));
    std::vector&lt;brr&gt; f(n + 1, brr(n + 1, arr(n + 1)));
    auto res = 0ll;
    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;
        f[x][1][(int)g[x].size()] = 1ll;
        siz[x] = 1;
        for (auto i : g[x])
            if (i != fa) &#123;
                DFS(i, x);
                h = f[x];
                for (int j = siz[x]; j; --j)
                  for (int a = 0; a &lt; n; ++a)
                    if (f[x][j][a + 1])
                      for (int k = siz[i]; ~k; --k)
                        for (int b = 0; a + b &lt; n; ++b)
                          f[x][j + k][a + b] += h[j][a + 1] * f[i][k][b + 1] % mod;
                siz[x] += siz[i];
            &#125;
        for (int i = 1; i &lt;= siz[x]; ++i)
            for (int j = 0; j &lt;= n; ++j)
                f[x][i][j] %= mod;
        for (int i = k + 1; i &lt;= siz[x]; ++i)
            for (int j = 0; i + j &lt;= n; ++j)
                res += f[x][i][j] * fac[i] % mod * fac[j] % mod * inv[i + j] % mod;
        res %= mod;
        return;
    &#125;;
    DFS(1, -1);
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="a---染色问题">A - 染色问题</h2>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P6076" class="uri">https://www.luogu.com.cn/problem/P6076</a></p>
<ul>
<li><p>题述转化成：恰好 <span class="math inline">\(n\)</span> 行，恰好 <span class="math inline">\(m\)</span> 列，恰好 <span class="math inline">\(c\)</span> 种颜色即可容斥</p></li>
<li><p>将无色视为一个不参与容斥的颜色，容易写出答案式：</p>
<p><span class="math display">\[
\sum_{i=0}^{n}\sum_{j=0}^{m}\sum_{k=0}^{c} (-1)^{i+j+k}\times \binom ni\times \binom mj\times \binom ck\times (c-k+1)^{(n-i)(m-j)}
\]</span></p></li>
<li><p>预处理幂次即可。复杂度 <span class="math inline">\(O(nmc)\)</span>。</p></li>
</ul>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int mod = 1e9 + 7;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m, c;
    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; c;
    std::vector&lt;long long&gt; fac(n * m + 1), inv(n * m + 1);
    fac[0] = inv[0] = 1ll;
    for (int i = 1; i &lt;= n * m; ++i)
        fac[i] = fac[i - 1] * i % mod;
    auto qkp = [&amp;](long long x, int y) &#123;
        auto res = 1ll;
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    inv[n * m] = qkp(fac[n * m], mod - 2);
    for (int i = n * m - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    auto C = [&amp;](int n, int m) &#123;
        if (n &lt; m || m &lt; 0)
            return 0ll;
        return fac[n] * inv[m] % mod * inv[n - m] % mod;
    &#125;;
    std::vector&lt;std::vector&lt;long long&gt; &gt; pw(c + 2, std::vector&lt;long long&gt; (n * m + 1));
    for (int i = 1; i &lt;= c + 1; ++i) &#123;
        pw[i][0] = 1ll;
        for (int j = 1; j &lt;= n * m; ++j)
            pw[i][j] = pw[i][j - 1] * i % mod;
    &#125;
    auto res = 0ll;
    for (int i = 0; i &lt;= n; ++i)
        for (int j = 0; j &lt;= m; ++j)
            for (int k = 0; k &lt;= c; ++k) &#123;
                int op = ((i + j + k) &amp; 1) ? mod - 1 : 1;
                res += op * C(n, i) % mod * C(m, j) % mod * C(c, k) % mod * pw[c - k + 1][(n - i) * (m - j)] % mod;
            &#125;
    std::cout &lt;&lt; res % mod &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="b---painting-the-wall">B - Painting The Wall</h2>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF398B" class="uri">https://www.luogu.com.cn/problem/CF398B</a></p>
<ul>
<li><p>观察到初始被标记的行列之间等价，相似地，初始未被标记的行列之间等价。故可以粗暴地塞到状态里。</p></li>
<li><p>参照 <a href="/20240111/">Game with Probability Problem</a> 中解决自转移的思路，考虑解方程。</p>
<p>设 <span class="math inline">\(f_{i,j}\)</span> 表示剩余 <span class="math inline">\(i\)</span> 行 <span class="math inline">\(j\)</span> 列时的期望操作数，列出 DP 式：</p>
<p><span class="math display">\[
f_{i,j}
\]</span></p></li>
</ul>

			</div>
			<hr class="dotted">
			<div class="post footer">
				<div id="hitokoto">
					<h3 id="hitokoto-title">
						言论
					</h3>
					<div id="hitokoto-content">
					</div>
					<div id="hitokoto-from">
					</div>
				</div>
				<div class="button flex">
					<div id="prev">
						
							<!-- 吐槽，为啥还需要加 / -->
							<a href="/20251104/">
								<i class="fas fa-angle-double-left" style="margin-right: 10px;"></i>
								杂题
							</a>
						
					</div>
					<div id="next">
						
							<a href="/20251030/">
								图论思维题 II
								<i class="fas fa-angle-double-right" style="margin-left: 10px;"></i>
							</a>
						
					</div>
				</div>
				<div id="vcomments" class="text"></div>
<script>
	new Valine({
		el: '#vcomments',
		appId: 'OlmvQ0a2Zw7xo3no2bwabOzx-gzGzoHsz',
		appKey: 'TW6t8mFeGLmhPjWisvmllvvo',
		recordIP: true,
		enableQQ: true, 
		// [EDITED] 目前 Valine 的 QQ 自动获取昵称似乎不可用
		// 该问题在 v1.5.3 中已修复
		pageSize: 10,
		requiredFields:
			
				['nick']
			,
		placeholder: "The world is but a little place after all...\n能够根据邮箱获取你的 Gravatar 头像。昵称是必填项，长度需不低于 3。",
		avatar: 'identicon',
		avatar_cdn: 'https://cravatar.cn/avatar/',
		emojiCDN: 'https://xsc062.netlify.app/em/', 
		emojiMaps: {
			
				"微笑": "wx.gif",
			
				"龇牙": "cy.gif",
			
				"流泪": "ll.gif",
			
				"笑哭": "xk.gif",
			
				"流汗": "lh.gif",
			
				"擦汗": "ch.gif",
			
				"亲亲": "qq.gif",
			
				"色": "se.gif",
			
				"疑问": "yiw.gif",
			
				"发呆": "fd.gif",
			
				"晕": "yun.gif",
			
				"鼓掌": "gz.gif",
			
				"憨笑": "hanx.gif",
			
				"快哭了": "kk.gif",
			
				"得意": "dy.gif",
			
				"狂笑": "kx.gif",
			
				"害羞": "hx.gif",
			
				"妈妈生的": "dz.gif",
			
				"糗大了": "qd.gif",
			
				"吃瓜": "cg.gif",
			
				"睁眼": "zy.webp",
			
				"辣眼睛": "lyj.gif",
			
				"酸了": "nm.gif",
			
				"滚": "gun.webp",
			
				"惊恐": "jk.gif",
			
				"幽灵": "youl.gif",
			
				"无聊": "wul.gif",
			
				"吃": "eat.gif",
			
				"你很棒棒": "bb.gif",
			
				"赞": "qiang.gif",
			
				"踩": "ruo.gif",
			
				"握手": "wsh.gif",
			
				"发抖": "fad.gif",
			
				"挥手": "hsh.gif",
			
				"磕头": "kt.gif",
			
				"怄火": "oh.gif",
			
		},
	})
</script>
			</div>
			<script>setHitokoto();</script>
		</div> 
	</div>
</div>
    <!-- 页脚开始 -->
<div id="footer" class="serif">
    Powered by
    <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a>
    &
    <a href="/about-this-theme">
        iwll
    </a>
    <p style="margin-top: 5px;">
        2021 - 2025
    </p>
    <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" id="CCTAG"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/big/by_nc_sa.svg"></a>
</div>
<!-- Valine 相关配置 -->
<script>
    const getValineDomTimer = setInterval(() => {
        // 不知道为什么 我从原博客 js 文件粘过来的参数是
        // "#valine .vcards .vcard"
        // DEBUG 了半天才定位到这个问题。。。
        const vcards =
            document.querySelectorAll('#valine, .vcards, .vcard');
        if (vcards.length > 0) {
            let author = 'XSC062';
            for (let vcard of vcards) {
                const vnick_dom = vcard.querySelector('.vhead .vnick');
                if (vnick_dom != null) {
                    const vnick = vnick_dom.innerHTML;
                    if (vnick === author) {
                        vnick_dom.innerHTML =
                        `${vnick} <span id="rootitem" class="code">root</span>`
                    }
                }
            }
        }
        else {
            clearInterval(getValineDomTimer);
        }
    }, 2000);
    SetActiveItem();
    setDetailsSummary();
    setTitleAnchor();
    setEmptyToc();
    setCodeClassName();
</script>


<!-- js -->
<!-- 搜索功能相关配置 -->

<script src="/js/search.js"></script>


<script src="/js/local-search.js"></script>

</script>
<!-- prism 相关配置 -->
<script type="text/javascript" src="/js/prism.js" defer></script>
<!-- 代码块复制功能 -->
<script type="text/javascript" src="/js/clipboard.min.js"></script>
<script type="text/javascript" src="/js/clipboard-use.js"></script>
<!-- 页脚结束 -->
</body>
</html>