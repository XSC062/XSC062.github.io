<!DOCTYPE html>
<html>
<head>
    <!-- ç½‘ç«™å›¾æ ‡ -->
<link rel="icon" type="image/png" sizes="32x32" href="/images/icon.svg">
<!-- å…¶ä»–å›¾æ ‡æ”¯æŒ -->
<link rel="stylesheet" href="/css/facss/fa-brands.min.css">
<link rel="stylesheet" href="/css/facss/fa-regular.min.css">
<link rel="stylesheet" href="/css/facss/fa-solid.min.css">
<link rel="stylesheet" href="/css/facss/fontawesome.min.css">
<link rel="stylesheet" href="/css/facss/fontawesome-all.css">
<link href="https://use.fontawesome.com/releases/v5.0.4/css/all.css" rel="stylesheet">
<!-- ç½‘ç«™æ ‡é¢˜ -->
<title>
	
		è´¹ç”¨æµç»ƒä¹  -
	
	XSC062 çš„åšå®¢
</title>
<!-- js å¼•å…¥ -->

<script src="/js/afterloaded.js"></script>


<script src="/js/jQuery.js"></script>

<!-- è½½å…¥ Valine -->

<script src="/js/Valine.min.js"></script>

<!-- css å¼•å…¥ -->

<link rel="stylesheet" href="/css/layout.css">


<link rel="stylesheet" href="/css/prcss/prism.css">



<meta charset="utf-8"> 
<meta name="generator" content="Hexo 7.2.0"></head>
<body class="line-numbers match-braces no-brace-select rainbow-braces">
	
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ],
            processEscapes: true
          }
        });
      </script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
            tex2jax: {
              skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
            }
          });
      </script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
              var all = MathJax.Hub.getAllJax(), i;
              for(i=0; i < all.length; i += 1) {
                  all[i].SourceElement().parentNode.className += ' has-jax';
              }
          });
      </script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

	<!-- æœç´¢ -->
<div id="search-bg">
	<div id="search-box">
		<input type="text" id="search-input" placeholder="Type to search...">
		<div id="search-results"></div>
		<p>æ­å–œä½ è§¦å‘äº†è¿™ä¸ª boxï¼Œç”±äºæˆ‘è¿˜æ²¡æœ‰å†™å…³é—­é”®ï¼Œä½ åªèƒ½é€šè¿‡åˆ·æ–°é¡µé¢æ¥å…³é—­å®ƒã€‚éå¸¸æŠ±æ­‰ ;-)</p>
		<p>ä¸ºäº†è¯æ˜æˆ‘æ²¡æœ‰æ‘†çƒ‚ï¼Œåœ¨è¿™é‡Œæ”¾ä¸€ä¸ªè¿›åº¦ï¼š</p>
		<p>- 250715ï¼šå°è¯•å®ç°æœç´¢åŠŸèƒ½ï¼Œåˆæ­¥æˆåŠŸï¼Œèƒ½å¤Ÿæœç´¢åˆ°åŒ…å«å…³é”®è¯çš„æ–‡ç« äº†ï¼ˆä¹Ÿèƒ½å…³æ‰äº†ï¼‰ã€‚ä¸çŸ¥é“ä¸ºå•¥è¾“å…¥ 123 å¯ä»¥åŒ¹é…æ‰€æœ‰æ–‡ç« ï¼Œä½†æ˜¯è¾“å…¥ 1234 å°±ä¸€ç¯‡éƒ½åŒ¹é…ä¸ä¸Šã€‚</p>
		<p>- 250716ï¼šå°è¯•åŠ å…¥å…³é”®è¯ä¸Šä¸‹æ–‡æ¥ de ä¸Šé¢çš„ bugï¼Œç„¶åæŠŠ js å†™æˆå²äº†ï¼Œç°åœ¨è¿™ä¸ªæ¡†æ¡†å¹¶ä¸å…·å¤‡æœç´¢åŠŸèƒ½ï¼ˆä¹Ÿä¸å…·å¤‡å…³é—­åŠŸèƒ½ï¼‰ :-(</p>
	</div>
</div>
<!-- é¡¶æ æ•´ä½“å¯¼èˆªèœå• -->
<div class="ui top menu">
	<!-- å·¦å¯¹é½ logo -->
	<a class="logo" href="/">
		<img src="/images/icon.png"></img>
		<div id="bartitle">
			XSC062 çš„åšå®¢
		</div>
	</a>
	<!-- å³å¯¹é½éƒ¨åˆ†å¯¼èˆª -->
	<script>
		function toSearch() {
			// goto search.ejs
			$("#search-bg, #search-bg *").css("z-index", "1002"); 
			$("#search-bg, #search-bg *").css("opacity", "100%");
		}
	</script>
	<div id="rightali">
		<a class="item" id="Search" type="button" onclick="toSearch()">
			<i class="btn text-muted fa fa-search" id="search-icon" disabled></i>
		</a>
		<a class="item" id="Home" href="/">
			Home
		</a>
		<a class="item" id="Arch" href="/archives">
			Archives
		</a>
		<!-- <a class="item" id="Cate" href="/categories">
			Categories
		</a> -->
		<a class="item" id="Tags" href="/tags">
			Tags
		</a>
		<a class="item" id="Frie" href="/friends">
			Friends
		</a>
		<a class="item" id="Abou" href="/about">
			About
		</a>
	</div>
</div>
    
<link rel="stylesheet" href="/css/post.css">


<script src="/js/post.js"></script>


<div class="main">
	<div id="sidebar">
		<aside id="toc">
			<span id="toctitle">
				<i class="fas fa-list"></i>
				ç›®å½•
			</span>
			<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#a.-%E8%AE%A2%E8%B4%A7"><span class="toc-text">A. è®¢è´§</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#b.-%E7%BD%91%E7%BB%9C%E6%89%A9%E5%AE%B9"><span class="toc-text">B. ç½‘ç»œæ‰©å®¹</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#c.-%E8%88%AA%E7%8F%AD%E5%AE%89%E6%8E%92"><span class="toc-text">C. èˆªç­å®‰æ’</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#d.-%E4%BF%AE%E8%BD%A6"><span class="toc-text">D. ä¿®è½¦</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#e.-%E8%BF%9E%E8%BF%9E%E7%9C%8B"><span class="toc-text">E. è¿è¿çœ‹</span></a></li></ol>
		</aside>
	</div>
	<div class="ui post container">
		<div class="ui text container yahei">
			<span id="postcon">
				<span id="postinfo">
					<div class="ui post title">
						<div id="fortitle" data-content="è´¹ç”¨æµç»ƒä¹ ">
							è´¹ç”¨æµç»ƒä¹ 
						</div>
						<div class="ui title background">
						</div>
					</div>
					<span id="date">
						<i class="fas fa-calendar-alt" style="margin-right: 4px;"></i>
						2023-07-20
					</span>
				</span>
			</span>
			<div id="posttags" class="dotted border">
				
					
						<a href="/tags/ç½‘ç»œæµ/" class="citem">ç½‘ç»œæµ</a>
					
						<a href="/tags/è´¹ç”¨æµ/" class="citem">è´¹ç”¨æµ</a>
					
				
			</div>
			<!-- æœ¬æ¥ç”¨çš„æ˜¯ fromNow ç„¶åå­—ç¬¦ä¸²åˆ¤æ–­ï¼Œæ²¡æƒ³åˆ°å¯ä»¥ç›´æ¥è°ƒç”¨ moment() -->
			
			<div id="content">
				<p><a target="_blank" rel="noopener" href="http://222.180.160.110:61235/contest/3820">è´¹ç”¨æµå…¥é—¨ç»ƒä¹ </a>ã€‚</p>
<span id="more"></span>
<hr />
<h3 id="a.-è®¢è´§">A. è®¢è´§</h3>
<p><a target="_blank" rel="noopener" href="http://222.180.160.110:61235/contest/3820/problem/1" class="uri">http://222.180.160.110:61235/contest/3820/problem/1</a></p>
<p>è¿™ä¸ªå¸¦ç»§æ‰¿å…³ç³»çš„æ¨¡å‹å¾ˆç†Ÿæ‚‰ï¼Œæƒ³åˆ°äº† <a target="_blank" rel="noopener" href="https://www.cnblogs.com/XSC062/p/17548925.html">çŒª</a> é‚£ä¸€é¢˜ã€‚æ‰€ä»¥æˆ‘ä»¬è¯•ç€ä»¿ç…§è¿™ä¸ªæ–¹å¼æ¥å»ºå›¾ã€‚</p>
<p>é¢˜ç›®æåˆ°äº†å•ä½è´¹ç”¨ï¼Œè¿™ç®€ç›´å°±æ˜¯ç›´æ¥æŠŠè¾¹çš„è´¹ç”¨æ‹ä½ è„¸ä¸Šå˜²è®½ã€‚</p>
<p>æˆ‘ä»¬æ‹‰ä¸€ä¸ªå¤§æºç‚¹ï¼Œæœæ¯ä¸ªæœˆè¿ä¸€æ¡å®¹é‡ä¸ºæ— ç©·å¤§ã€è´¹ç”¨ä¸ºå½“æœˆè´­ä¹°å•ä½è´¹ç”¨çš„è¾¹ï¼Œè¡¨ç¤ºæ¯ä¸ªæœˆçš„è´­ä¹°ã€‚</p>
<p>æ‹‰ä¸€ä¸ªå¤§æ±‡ç‚¹ï¼Œæ¯ä¸ªæœˆæœå®ƒè¿ä¸€æ¡å®¹é‡ä¸ºå½“æœˆéœ€æ±‚é‡ã€è´¹ç”¨ä¸º <span class="math inline">\(0\)</span> çš„è¾¹ï¼Œè¡¨ç¤ºæ¯ä¸ªæœˆçš„éœ€æ±‚ã€‚</p>
<p>å†è®©æ¯ä¸ªæœˆæœä¸‹ä¸€ä¸ªæœˆè¿ä¸€æ¡å®¹é‡ä¸ºä»“åº“å®¹é‡ã€è´¹ç”¨ä¸ºè´®å­˜è´¹ç”¨çš„è¾¹ï¼Œè¡¨ç¤ºç»§æ‰¿ã€‚è·‘ä¸€ä¸ªæœ€å°è´¹ç”¨æœ€å¤§æµå³å¯ã€‚</p>
<details>
<pre class="cpp"><code>#define int long long
namespace XSC062 &#123;
using namespace fastIO;
const int maxn = 405;
const int inf = 1e18;
const int maxm = 5e5 + 5;
struct _ &#123;
    int v, c, w, n;
    _() &#123;&#125;
    _(int v1, int c1, int w1, int n1) &#123;
        v = v1, c = c1, w = w1, n = n1;
    &#125;
&#125;;
_ u[maxm];
bool inq[maxn];
int n, m, S, x, res;
int gs, gt, tot = 1;
int h[maxn], dis[maxn];
int fl[maxn], pre[maxn];
int min(int x, int y) &#123;
    return x &lt; y ? x : y;
&#125;
bool SPFA(int s, int n) &#123;
    std::queue&lt;int&gt; q;
    std::fill(dis + 1, dis + n + 1, inf);
    q.push(s), dis[s] = 0, inq[s] = 1;
    pre[s] = inf, pre[gt] = 0, fl[s] = inf;
    while (!q.empty()) &#123;
        int f = q.front();
        q.pop(), inq[f] = 0;
        for (int i = h[f]; i; i = u[i].n) &#123;
            if (u[i].c == 0)
                continue;
            int v = u[i].v, w = u[i].w;
            if (dis[v] &gt; dis[f] + w) &#123;
                pre[v] = i ^ 1;
                dis[v] = dis[f] + w;
                fl[v] = min(fl[f], u[i].c);
                if (!inq[v])
                    inq[v] = 1, q.push(v);
            &#125;
        &#125;
    &#125;
    return pre[gt];
&#125;
void SSP(int s, int n) &#123;
    int p, mn, d;
    while (SPFA(s, n)) &#123;
        mn = fl[gt], d = 0;
        for (p = gt; p != s; p = u[pre[p]].v) &#123;
            u[pre[p]].c += mn;
            u[pre[p] ^ 1].c -= mn;
            d += u[pre[p] ^ 1].w;
        &#125;
        res += mn * d;
    &#125;
    return;
&#125;
void add(int x, int y, int c, int w) &#123;
    u[++tot] = _(y, c, w, h[x]);
    h[x] = tot;
    return;
&#125;
void addf(int x, int y, int c, int w) &#123;
    add(x, y, c, w), add(y, x, 0, -w);
    return;
&#125;
int main() &#123;
    read(n), read(m), read(S);
    gs = n + 1, gt = gs + 1;
    for (int i = 1; i &lt;= n; ++i) &#123;
        read(x);
        addf(i, gt, x, 0);
        if (i != n)
            addf(i, i + 1, S, m);
    &#125;
    for (int i = 1; i &lt;= n; ++i) &#123;
        read(x);
        addf(gs, i, inf, x);
    &#125;    
    SSP(gs, gt);
    print(res, &#39;\n&#39;);
    return 0;
&#125;
&#125; // namespace XSC062
#undef int  </code></pre>
</details>
<hr />
<h3 id="b.-ç½‘ç»œæ‰©å®¹">B. ç½‘ç»œæ‰©å®¹</h3>
<p><a target="_blank" rel="noopener" href="http://222.180.160.110:61235/contest/3820/problem/2" class="uri">http://222.180.160.110:61235/contest/3820/problem/2</a></p>
<p>é‰´äºä¸€é“è´¹ç”¨æµä¸ä¼šæ— ç¼˜æ— æ•…å…ˆè®©ä½ æ±‚ä¸€éæœ€å¤§æµï¼Œæˆ‘ä»¬å…ˆæŒè§‚æœ›æ€åº¦ï¼Œæš‚ä¸”è®¤ä¸ºæœ€å¤§æµå¯¹é¢˜ç›®æœ‰æç¤ºä½œç”¨ <del>è€Œä¸æ˜¯è¯´è¿™é“é¢˜å°±æ˜¯ä¸ªç¼åˆæ€ª</del></p>
<p>å…¶å®çœ‹å®Œé¢˜æˆ‘ä»¬å°±æ‚Ÿäº†ï¼Œè¿™æ€ä¹ˆè¿™ä¹ˆåƒä¸Šä¸‹ç•Œç½‘ç»œæµé‚£ä¸ªå·®é‡ç½‘ç»œå‘€ï¼Œè¦ä¸æˆ‘ä»¬è¯•è¯•è¿™ä¹ˆå¹²ï¼Ÿ</p>
<p>æˆ‘ä»¬å…ˆæ±‚å¾—æ™®é€šç½‘ç»œä¸­çš„æœ€å¤§æµï¼Œç„¶åæ¯æ¡è¾¹å‡å»æµé‡ï¼Œå°±æˆä¸ºäº†ä¸€ä¸ªã€Œå·®é‡ç½‘ç»œ Proã€ã€‚é‚£ä¹ˆæˆ‘ä»¬ç°åœ¨å°±è¦é€šè¿‡æ‰©å®¹è®©è¯¥ç½‘ç»œä¸­çš„æœ€å¤§æµå˜ä¸º <span class="math inline">\(K\)</span>ã€‚å¯¹äºæ‰©å®¹çš„æ“ä½œï¼Œä¸éš¾æƒ³åˆ°æŠŠæ¯æ¡è¾¹çš„è¾¹æƒè®¾ä¸ºæ­£æ— ç©·ï¼Œç„¶åè´¹ç”¨è®¾ä¸ºæ‰©å®¹è´¹ç”¨ã€‚</p>
<p>ç°åœ¨æœ‰äº†ä¸€ä¸ªé—®é¢˜ï¼šåŸå›¾ä¸­æœªç•™æ»¡çš„è¾¹ï¼Œåœ¨ç°åœ¨çš„æ–°ç½‘ç»œä¸­çš„æ®‹ä½™å®¹é‡åº”è¯¥å¦‚ä½•å¤„ç†å‘¢ï¼Ÿå¾ˆç®€å•ï¼Œæˆ‘ä»¬å°±æŠŠå®ƒå½“ä½œå·²ç»æ‰©è¿‡äº†è¿™ä¹ˆå¤šå®¹ï¼Œé€šè¿‡æ‹†è¾¹æ“ä½œæ‹†å‡ºæ¥ä¸€æ¡å®¹é‡ä¸ºåŸå›¾ä¸­æ®‹ä½™å®¹é‡ã€è´¹ç”¨ä¸º <span class="math inline">\(0\)</span>ã€Œä¼šå‘˜é€šé“ã€ï¼Œé‚£ä¹ˆç®—æ³•å°±ä¼šä¼˜å…ˆé€‰æ‹©è¿™æ¡è¾¹ã€‚</p>
<p>æ€ä¹ˆå»æ§åˆ¶æµé‡ä¸º <span class="math inline">\(K\)</span>ï¼Ÿè”æƒ³åˆ°ä¹‹å‰çš„æ‹†è¾¹æ“ä½œï¼Œæˆ‘ä»¬è€ƒè™‘æ‹†ç‚¹ã€‚åœ¨ <span class="math inline">\(1\)</span> å’Œ <span class="math inline">\(N\)</span> ä¸­ä»»é€‰ä¸€ä¸ªæ‹†å¼€ä½œä¸ºæ–°çš„æºç‚¹ / æ±‡ç‚¹ï¼Œæ–°ç‚¹å’Œæ—§ç‚¹ä¹‹é—´çš„å®¹é‡ä¸º <span class="math inline">\(K\)</span>ã€è´¹ç”¨ä¸º <span class="math inline">\(0\)</span> å³å¯ã€‚</p>
<p>ç„¶åè·‘ä¸€ä¸ªæœ€å°è´¹ç”¨æœ€å¤§æµå°±è¡Œã€‚<del>è¯¥è¯´ä¸è¯´é¢˜ç›®çš„æ­£è§£æ€è·¯å¼•å¯¼åšå¾—è¿˜æŒºå¥½çš„</del></p>
<p>å…¶å®æ³¨æ„åˆ°åœ¨è·‘å®Œæœ€å¤§æµä¹‹åï¼Œæ‰€æœ‰æ­£å‘è¾¹çš„æ®‹ä½™å®¹é‡å·²ç»æ±‚å¾—ï¼Œåªè¦åœ¨è·‘æœ€å¤§æµæ—¶ä»¤æ‰€æœ‰è¾¹çš„è´¹ç”¨ä¸º <span class="math inline">\(0\)</span>ï¼ˆæ¯•ç«Ÿæœ€å¤§æµä¸å…³å¿ƒè´¹ç”¨ï¼‰ï¼Œå°±å¯ä»¥æ²¿ç”¨åŸå›¾ï¼ŒåªåŠ æ–°è¾¹å†è·‘è´¹ç”¨æµã€‚</p>
<details>
<pre class="cpp"><code>#define int long long
namespace XSC062 &#123;
using namespace fastIO;
const int inf = 1e18;
const int maxn = 1e3 + 5;
const int maxm = 5e5 + 5;
struct _ &#123;
    int v, c, w, n;
    _() &#123;&#125;
    _(int v1, int c1, int w1, int n1) &#123;
        v = v1, c = c1, w = w1, n = n1;
    &#125;
&#125;;
struct __ &#123; int x, y, c, w; &#125;;
_ u[maxm];
__ w[maxm];
bool inq[maxn];
int n, m, k, res;
int gs, gt, tot = 1;
int h[maxn], dis[maxn];
int fl[maxn], pre[maxn];
int vis[maxn], now[maxn], dep[maxn];
int min(int x, int y) &#123;
    return x &lt; y ? x : y;
&#125;
bool BFS(int n) &#123;
    std::fill(vis + 1, vis + n + 1, 0);
    std::fill(dep + 1, dep + n + 1, 0); 
    std::queue&lt;int&gt; q;
    dep[gs] = 1, vis[gs] = 1;
    q.push(gs), now[gs] = h[gs];
    while (!q.empty()) &#123;
        int f = q.front();
        q.pop();
        for (int i = h[f]; i; i = u[i].n) &#123;
            int v = u[i].v, w = u[i].c;
            if (vis[v] == 1 || w == 0)
                continue;
            vis[v] = 1, now[v] = h[v];
            dep[v] = dep[f] + 1, q.push(v);
            if (v == gt)
                return 1;
        &#125;
    &#125;
    return 0;
&#125;
int findP(int x, int flow = inf) &#123;
    if (x == gt)
        return flow;
    int rest = flow, i;
    for (i = now[x]; rest &amp;&amp; i; i = u[i].n) &#123;
        int v = u[i].v, w = u[i].c;
        now[x] = i;
        if (dep[v] != dep[x] + 1 || w == 0)
            continue;
        int t = findP(v, min(rest, w));
        if (t == 0)
            dep[v] = 0;
        rest -= t;
        u[i].c -= t, u[i ^ 1].c += t;
    &#125;
    return flow - rest;
&#125;
int Dinic(int n) &#123;
    int res = 0;
    while (BFS(n)) &#123;
        int t = findP(gs);
        while (t) &#123;
            res += t;
            t = findP(gs);
        &#125;
    &#125;
    return res;
&#125;
bool SPFA(int s, int n) &#123;
    std::queue&lt;int&gt; q;
    std::fill(dis + 1, dis + n + 1, inf);
    q.push(s), dis[s] = 0, inq[s] = 1;
    pre[s] = inf, pre[gt] = 0, fl[s] = inf;
    while (!q.empty()) &#123;
        int f = q.front();
        q.pop(), inq[f] = 0;
        for (int i = h[f]; i; i = u[i].n) &#123;
            if (u[i].c == 0)
                continue;
            int v = u[i].v, w = u[i].w;
            if (dis[v] &gt; dis[f] + w) &#123;
                pre[v] = i ^ 1;
                dis[v] = dis[f] + w;
                fl[v] = min(fl[f], u[i].c);
                if (!inq[v])
                    inq[v] = 1, q.push(v);
            &#125;
        &#125;
    &#125;
    return pre[gt];
&#125;
void SSP(int s, int n) &#123;
    int p, mn, d;
    while (SPFA(s, n)) &#123;
        mn = fl[gt], d = 0;
        for (p = gt; p != s; p = u[pre[p]].v) &#123;
            u[pre[p]].c += mn;
            u[pre[p] ^ 1].c -= mn;
            d += u[pre[p] ^ 1].w;
        &#125;
        res += mn * d;
    &#125;
    return;
&#125;
void add(int x, int y, int c, int w) &#123;
    u[++tot] = _(y, c, w, h[x]);
    h[x] = tot;
    return;
&#125;
void addf(int x, int y, int c, int w = 0) &#123;
    add(x, y, c, w), add(y, x, 0, -w);
    return;
&#125;
int main() &#123;
    read(n), read(m), read(k);
    gs = 1, gt = n;
    for (int i = 1; i &lt;= m; ++i) &#123;
        read(w[i].x), read(w[i].y);
        read(w[i].c), read(w[i].w);
        addf(w[i].x, w[i].y, w[i].c);
    &#125;
    print(Dinic(n), &#39; &#39;);
    gs = n + 1, addf(gs, 1, k, 0);
    for (int i = 1; i &lt;= m; ++i)
        addf(w[i].x, w[i].y, inf, w[i].w);
    SSP(gs, gt);
    print(res, &#39;\n&#39;);
    return 0;
&#125;
&#125; // namespace XSC062
#undef int</code></pre>
</details>
<hr />
<h3 id="c.-èˆªç­å®‰æ’">C. èˆªç­å®‰æ’</h3>
<p><a target="_blank" rel="noopener" href="http://222.180.160.110:61235/contest/3820/problem/3" class="uri">http://222.180.160.110:61235/contest/3820/problem/3</a></p>
<p>å¾ˆç®€å•ä¸€ä¸ªé“ç†ï¼Œæ—¶é—´çš„å…·ä½“å€¼å¯¹æˆ‘ä»¬æ¥è¯´å¹¶ä¸é‡è¦ã€‚èƒ½åˆ°å°±æ˜¯èƒ½åˆ°ï¼Œä¸èƒ½åˆ°å°±æ˜¯ä¸èƒ½åˆ°ã€‚</p>
<p>è¾¹æƒçŸ©é˜µä¹Ÿå¹¶ä¸æ˜¯å…¨éƒ¨æœ‰ç”¨ï¼Œè¿™æ¡è¾¹å’Œä»»åŠ¡æœ‰å…³ç³»å—ï¼Ÿæ²¡æœ‰ï¼Œé‚£å°±å½“å®ƒæ˜¯ç©ºæ°”ã€‚</p>
<p>é‚£ä»€ä¹ˆä¼šå¯¹æˆ‘ä»¬äº§ç”Ÿé™åˆ¶ï¼Ÿé£æœºæ•°é‡ã€‚æ•…å®¹é‡ç”±é£æœºæ•°é‡å†³å®šã€‚ä»€ä¹ˆæ˜¯æˆ‘ä»¬è¦æœ€å¤§åŒ–çš„å€¼ï¼Ÿæ”¶ç›Šï¼Œæ•…æˆ‘ä»¬çš„è´¹ç”¨æ˜¯æ”¯å‡ºã€‚</p>
<p>å¦‚æœé£æœºèƒ½åœ¨ä¸€ä¸ªä»»åŠ¡ç»“æŸä¹‹åï¼Œåœ¨å¦ä¸€ä¸ªä»»åŠ¡å¼€å§‹ä¹‹å‰é£è¿‡å»ï¼Œé‚£å°±å°†ä¸¤ä¸ªä»»åŠ¡è¿è¾¹ï¼Œå®¹é‡ä¸º <span class="math inline">\(1\)</span>ï¼Œè´¹ç”¨ä¸ºä¸¤ç‚¹é—´èŠ±è´¹ã€‚ç‰¹åˆ«åœ°ï¼Œåº”å°†æœºåœºæ‹†ä¸ºå¤§æºç‚¹å’Œå¤§æ±‡ç‚¹ï¼Œå¹¶åœ¨äºŒè€…ä¸­ä»»é€‰å…¶ä¸€æ‹†ç‚¹ï¼ˆå’Œ T2 ç±»ä¼¼ï¼‰ï¼Œå¥½ä½œå‡º <span class="math inline">\(K\)</span> çš„æµé‡é™åˆ¶ã€‚</p>
<p>è¿˜æœ‰ä¸€ä¸ªå°ç»†èŠ‚ï¼Œå¯¹äºä¸€ä¸ªä»»åŠ¡çš„æµé‡æˆ‘ä»¬ä¹Ÿè¦åŠ ä»¥çº¦æŸï¼Œä¸ç„¶ç¢°åˆ°æµå…¥ <span class="math inline">\(2\)</span> æµå‡º <span class="math inline">\(2\)</span> è¿™ç§å¹³è¡¡ä½†ä¸åˆæ³•çš„æƒ…å†µå°±ä¸è¡Œäº†ï¼Œæ‰€ä»¥å¯¹äºä»»åŠ¡æˆ‘ä»¬ä¹Ÿè¦æŒ‰è€å¥—è·¯æ‹†ç‚¹ã€‚</p>
<details>
<pre class="cpp"><code>#define int long long
namespace XSC062 &#123;
using namespace fastIO;
const int inf = 1e18;
const int maxn = 405;
const int maxm = 4e5 + 5;
struct _ &#123;
    int v, c, w, n;
    _() &#123;&#125;
    _(int v1, int c1, int w1, int n1) &#123;
        v = v1, c = c1, w = w1, n = n1;
    &#125;
&#125;;
struct __ &#123;
    int x, y, l, r, c;
    bool operator&lt; (const __ &amp;q) const &#123;
        return l &lt; q.l;
    &#125;
&#125;;
_ u[maxm];
__ w[maxn];
bool inq[maxn];
int gs, gt, tot = 1;
int h[maxn], dis[maxn];
int fl[maxn], pre[maxn];
int n, m, k, T, res, fs, ft;
int t[maxn][maxn], f[maxn][maxn];
int min(int x, int y) &#123;
    return x &lt; y ? x : y;
&#125;
bool SPFA(int s, int n) &#123;
    std::queue&lt;int&gt; q;
    std::fill(dis + 1, dis + n + 1, inf);
    q.push(s), dis[s] = 0, inq[s] = 1;
    pre[s] = inf, pre[gt] = 0, fl[s] = inf;
    while (!q.empty()) &#123;
        int f = q.front();
        q.pop(), inq[f] = 0;
        for (int i = h[f]; i; i = u[i].n) &#123;
            if (u[i].c == 0)
                continue;
            int v = u[i].v, w = u[i].w;
            if (dis[v] &gt; dis[f] + w) &#123;
                pre[v] = i ^ 1;
                dis[v] = dis[f] + w;
                fl[v] = min(fl[f], u[i].c);
                if (!inq[v])
                    inq[v] = 1, q.push(v);
            &#125;
        &#125;
    &#125;
    return pre[gt];
&#125;
void SSP(int s, int n) &#123;
    int p, mn, d;
    while (SPFA(s, n)) &#123;
        mn = fl[gt], d = 0;
        for (p = gt; p != s; p = u[pre[p]].v) &#123;
            u[pre[p]].c += mn;
            u[pre[p] ^ 1].c -= mn;
            d += u[pre[p] ^ 1].w;
        &#125;
        res += mn * d;
    &#125;
    return;
&#125;
void add(int x, int y, int c, int w) &#123;
    u[++tot] = _(y, c, w, h[x]);
    h[x] = tot;
    return;
&#125;
void addf(int x, int y, int c, int w) &#123;
    add(x, y, c, w), add(y, x, 0, -w);
    return;
&#125;
int main() &#123;
    read(n), read(m), read(k), read(T);
    fs = 2 * m + 1, ft = 2 * m + 2;
    gs = 2 * m + 3, gt = 2 * m + 4;
    addf(gs, fs, k, 0), addf(ft, gt, k, 0);
    for (int i = 1; i &lt;= n; ++i) &#123;
        for (int j = 1; j &lt;= n; ++j)
            read(t[i][j]);
    &#125;
    for (int i = 1; i &lt;= n; ++i) &#123;
        for (int j = 1; j &lt;= n; ++j)
            read(f[i][j]);
    &#125;
    for (int i = 1; i &lt;= m; ++i) &#123;
        read(w[i].x), read(w[i].y);
        read(w[i].l), read(w[i].r);
        read(w[i].c), ++w[i].x, ++w[i].y;
    &#125;
    for (int i = 1; i &lt;= m; ++i) &#123;
        addf(i + m, i, 1, 0);
        if (t[1][w[i].x] &lt;= w[i].l) &#123;
            addf(fs, i + m, 1,
                f[1][w[i].x] - w[i].c);
        &#125;
        if (w[i].r + t[w[i].y][1] &lt;= T)
            addf(i, ft, 1, f[w[i].y][1]);
        for (int j = 1; j &lt;= m; ++j) &#123;
            if (i != j &amp;&amp; w[i].r +
                t[w[i].y][w[j].x] &lt;= w[j].l) &#123;
                addf(i, j + m, 1,
                    f[w[i].y][w[j].x] - w[j].c);
            &#125;
        &#125;
    &#125;
    SSP(gs, gt);
    print(-res, &#39;\n&#39;);
    return 0;
&#125;
&#125; // namespace XSC062
#undef int</code></pre>
</details>
<hr />
<h3 id="d.-ä¿®è½¦">D. ä¿®è½¦</h3>
<p><a target="_blank" rel="noopener" href="http://222.180.160.110:61235/contest/3820/problem/4" class="uri">http://222.180.160.110:61235/contest/3820/problem/4</a></p>
<p>é¡¾å®¢æ•°ä¸€å®šï¼Œæ‰€è°“å¹³å‡ç­‰å¾…æ—¶é—´ä¸è¿‡æ˜¯ä¸ªå¹Œå­ï¼Œåªéœ€è¦æ±‚å¾—æœ€å°ç­‰å¾…æ€»æ—¶é—´ã€‚</p>
<p>æŠ€æœ¯äººå‘˜ä¸èƒ½åŒæ—¶ä¿®ä¸¤è¾†è½¦ï¼Œ<span class="math inline">\(M\)</span> çš„èŒƒå›´åˆè¿™ä¹ˆå°ï¼Œä¸å¾€æ‹†ç‚¹æƒ³éƒ½éš¾ã€‚å¯é—®é¢˜æ¥äº†ï¼Œæ€ä¹ˆæ‹†å‘¢ï¼Ÿ</p>
<p>æˆ‘ä¸€å¼€å§‹çš„æƒ³æ³•æ˜¯ï¼Œç”¨ç‚¹ <span class="math inline">\((i, j)\)</span> è¡¨ç¤ºäºº <span class="math inline">\(i\)</span> ä¿®è½¦ <span class="math inline">\(j\)</span>ï¼Œä½†æ˜¯è¿™æ ·å»ºå›¾æ€æ ·ä¹Ÿæ— æ³•è¾¾åˆ°ç›®çš„ã€‚</p>
<p>äºæ˜¯æˆ‘æ·»åŠ äº†ä¸€ä¸ªç»´åº¦ <span class="math inline">\(k\)</span>ï¼Œç”¨ç‚¹ <span class="math inline">\((i, j, k)\)</span> è¡¨ç¤ºäºº <span class="math inline">\(i\)</span> ä¿®è½¦ <span class="math inline">\(j\)</span>ï¼Œå¹¶ä¸”è¿™æ˜¯ä»–ä¿®çš„å€’æ•°ç¬¬ <span class="math inline">\(k\)</span> è¾†è½¦ï¼Œè¿™æ ·å»ºå›¾å°±è½»è€Œæ˜“ä¸¾äº†ã€‚ä½†æ¥ä¸‹æ¥å°±é¢ä¸´äº†ä¸€ä¸ªé—®é¢˜ï¼šè¿™æ•°æ®èŒƒå›´è·‘ä¸è¿‡ã€‚äºæ˜¯ä¹å®¡è§†æˆ‘ä»¬çš„ç‚¹ï¼Œå…¶å® <span class="math inline">\(j\)</span> è¿™ä¸ªç»´åº¦æ˜¯å¯ä»¥è¢«åˆå¹¶çš„ï¼Œåªä¿ç•™ <span class="math inline">\((i, k)\)</span>ï¼Œå› ä¸ºä¸å¯èƒ½å­˜åœ¨ä¸¤è¾†è½¦åŒæ—¶ä¸ºäºº <span class="math inline">\(i\)</span> çš„å€’æ•°ç¬¬ <span class="math inline">\(k\)</span> è¾†è½¦ã€‚</p>
<p>æ•…å°†å¤§æºç‚¹å’Œæ¯è¾†è½¦è¿è¾¹ï¼Œå®¹é‡ä¸º <span class="math inline">\(1\)</span>ï¼Œè´¹ç”¨ä¸º <span class="math inline">\(0\)</span>ï¼›å°†æ¯è¾†è½¦ <span class="math inline">\(j\)</span> å’Œæ¯ä¸ª <span class="math inline">\((i, k)\)</span> è¿è¾¹ï¼Œå®¹é‡ä¸º <span class="math inline">\(1\)</span>ï¼Œè´¹ç”¨ä¸º <span class="math inline">\(T_{i, j}\times k\)</span>ã€‚</p>
<p>è¿™é‡Œæœ‰ä¸€ç‚¹ç‚¹è´¹ç”¨æå‰è®¡ç®—çš„æ„æ€ï¼Œæ‰€ä»¥å°±ç›´æ¥å°†æ¯ä¸ª <span class="math inline">\((i, j)\)</span> å’Œå¤§æ±‡ç‚¹è¿è¾¹ï¼Œå®¹é‡ä¸º <span class="math inline">\(1\)</span>ï¼Œè´¹ç”¨ä¸º <span class="math inline">\(0\)</span>ã€‚</p>
<details>
<pre class="cpp"><code>#define int long long
namespace XSC062 &#123;
using namespace fastIO;
const int inf = 1e18;
const int maxn = 1e4 + 5;
const int maxm = 1e6 + 5;
struct _ &#123;
    int v, c, w, n;
    _() &#123;&#125;
    _(int v1, int c1, int w1, int n1) &#123;
        v = v1, c = c1, w = w1, n = n1;
    &#125;
&#125;;
_ u[maxm];
bool inq[maxn];
int n, m, x, res;
int gs, gt, tot = 1;
int h[maxn], dis[maxn];
int fl[maxn], pre[maxn];
int fun(int i, int j) &#123;
    return n + (i - 1) * n + j;
&#125;
int min(int x, int y) &#123;
    return x &lt; y ? x : y;
&#125;
bool SPFA(int s, int n) &#123;
    std::queue&lt;int&gt; q;
    std::fill(dis + 1, dis + n + 1, inf);
    q.push(s), dis[s] = 0, inq[s] = 1;
    pre[s] = inf, pre[gt] = 0, fl[s] = inf;
    while (!q.empty()) &#123;
        int f = q.front();
        q.pop(), inq[f] = 0;
        for (int i = h[f]; i; i = u[i].n) &#123;
            if (u[i].c == 0)
                continue;
            int v = u[i].v, w = u[i].w;
            if (dis[v] &gt; dis[f] + w) &#123;
                pre[v] = i ^ 1;
                dis[v] = dis[f] + w;
                fl[v] = min(fl[f], u[i].c);
                if (!inq[v])
                    inq[v] = 1, q.push(v);
            &#125;
        &#125;
    &#125;
    return pre[gt];
&#125;
void SSP(int s, int n) &#123;
    int p, mn, d;
    while (SPFA(s, n)) &#123;
        mn = fl[gt], d = 0;
        for (p = gt; p != s; p = u[pre[p]].v) &#123;
            u[pre[p]].c += mn;
            u[pre[p] ^ 1].c -= mn;
            d += u[pre[p] ^ 1].w;
        &#125;
        res += mn * d;
    &#125;
    return;
&#125;
void add(int x, int y, int c, int w) &#123;
    u[++tot] = _(y, c, w, h[x]);
    h[x] = tot;
    return;
&#125;
void addf(int x, int y, int c, int w) &#123;
    add(x, y, c, w), add(y, x, 0, -w);
    return;
&#125;
int main() &#123;
    read(m), read(n);
    gs = n * m + n + 1, gt = gs + 1;
    for (int i = 1; i &lt;= n; ++i)
        addf(gs, i, 1, 0);
    for (int i = 1; i &lt;= n * m; ++i)
        addf(i + n, gt, 1, 0);
    for (int i = 1; i &lt;= n; ++i) &#123;
        for (int j = 1; j &lt;= m; ++j) &#123;
            read(x);
            for (int k = 1; k &lt;= n; ++k) &#123;
                addf(i, fun(j, k),
                            1, x * k);
            &#125;
        &#125;
    &#125;
    SSP(gs, gt);
    printf(&quot;%.2lf&quot;, res * 1.0 / n);
    return 0;
&#125;
&#125; // namespace XSC062
#undef int</code></pre>
</details>
<hr />
<h3 id="e.-è¿è¿çœ‹">E. è¿è¿çœ‹</h3>
<p><a target="_blank" rel="noopener" href="http://222.180.160.110:61235/contest/3820/problem/5" class="uri">http://222.180.160.110:61235/contest/3820/problem/5</a></p>
<p>æ ·ä¾‹å·²ç»å‘Šè¯‰äº†æˆ‘ä»¬äº‹å®ï¼šå°å¿ƒåˆ æ•°ï¼Œå› ä¸ºä¼šæœ‰æ•°åŒæ—¶å‡ºç°åœ¨å¤šç»„å‹¾è‚¡æ•°ä¸­ã€‚</p>
<p>è¿˜æ˜¯ç†Ÿæ‚‰çš„å•ç‚¹ <span class="math inline">\(1\)</span> æµé‡é™åˆ¶ï¼Œæ•…æ‹†ç‚¹ä¸ºå…¥ç‚¹å’Œå‡ºç‚¹ï¼Œå…¥ç‚¹è¿å¤§æºç‚¹å®¹é‡ä¸º <span class="math inline">\(1\)</span> è´¹ç”¨ä¸º <span class="math inline">\(0\)</span>ï¼Œå‡ºç‚¹è¿å¤§æ±‡ç‚¹å®¹é‡ä¸º <span class="math inline">\(1\)</span> è´¹ç”¨ä¸º <span class="math inline">\(0\)</span>ï¼Œæ»¡è¶³æ¡ä»¶çš„ <span class="math inline">\(x\)</span> å’Œ <span class="math inline">\(y\)</span> æˆ‘ä»¬ä¸ºäº†ä¸æ•´ç»†èŠ‚å°±æš´åŠ›åœ°è¿åŒå‘è¾¹ç„¶åè·‘æœ€å¤§è´¹ç”¨æœ€å¤§æµã€‚</p>
<p>ç”±äºåŒå‘è¾¹è¿™ä¸ªç¥å¿…æ“ä½œï¼Œæœ€åçš„æœ€å¤§æµå’Œæœ€å¤§è´¹ç”¨éƒ½ä¼šç¿»å€ï¼Œè¾“å‡ºçš„æ—¶å€™è¦å‡åŠã€‚</p>
<details>
<pre class="cpp"><code>#define int long long
namespace XSC062 &#123;
using namespace fastIO;
const int inf = 1e18;
const int maxn = 2e3 + 5;
const int maxm = 4e5 + 5;
struct _ &#123;
    int v, c, w, n;
    _() &#123;&#125;
    _(int v1, int c1, int w1, int n1) &#123;
        v = v1, c = c1, w = w1, n = n1;
    &#125;
&#125;;
_ u[maxm];
bool inq[maxn];
int l, r, res, cnt;
bool f[maxn][maxn];
int gs, gt, tot = 1;
int h[maxn], dis[maxn];
int fl[maxn], pre[maxn];
int gcd(int x, int y) &#123;
    return y ? gcd(y, x % y) : x;
&#125;
int min(int x, int y) &#123;
    return x &lt; y ? x : y;
&#125;
bool SPFA(int s, int n) &#123;
    std::queue&lt;int&gt; q;
    std::fill(dis + 1, dis + n + 1, -inf);
    q.push(s), dis[s] = 0, inq[s] = 1;
    pre[s] = inf, pre[gt] = 0, fl[s] = inf;
    while (!q.empty()) &#123;
        int f = q.front();
        q.pop(), inq[f] = 0;
        for (int i = h[f]; i; i = u[i].n) &#123;
            if (u[i].c == 0)
                continue;
            int v = u[i].v, w = u[i].w;
            if (dis[v] &lt; dis[f] + w) &#123;
                pre[v] = i ^ 1;
                dis[v] = dis[f] + w;
                fl[v] = min(fl[f], u[i].c);
                if (!inq[v])
                    inq[v] = 1, q.push(v);
            &#125;
        &#125;
    &#125;
    return pre[gt];
&#125;
void SSP(int s, int n) &#123;
    int p, mn, d;
    while (SPFA(s, n)) &#123;
        mn = fl[gt], d = 0;
        for (p = gt; p != s; p = u[pre[p]].v) &#123;
            u[pre[p]].c += mn;
            u[pre[p] ^ 1].c -= mn;
            d += u[pre[p] ^ 1].w;
        &#125;
        res += mn * d, cnt += mn;
    &#125;
    return;
&#125;
void add(int x, int y, int c, int w) &#123;
    u[++tot] = _(y, c, w, h[x]);
    h[x] = tot;
    return;
&#125;
void addf(int x, int y, int c, int w) &#123;
    if (f[x][y])
        return;
    f[x][y] = f[y][x] = 1;
    add(x, y, c, w), add(y, x, 0, -w);
    return;
&#125;
bool check(int x, int y) &#123;
    int z = sqrt(x * x - y * y);
    if (z * z + y * y == x * x)
        return (gcd(z, y) == 1);
    return 0;
&#125;
int main() &#123;
    read(l), read(r);
    gs = 2 * r + 1, gt = 2 * r + 2;
    for (int i = l; i &lt;= r; ++i) &#123;
        addf(gs, i, 1, 0);
        addf(i + r, gt, 1, 0);
        for (int j = l; j &lt; i; ++j) &#123;
            if (check(i, j)) &#123;
                addf(j, i + r, 1, i + j);
                addf(i, j + r, 1, i + j);
            &#125;
        &#125;
    &#125;
    SSP(gs, gt);
    print(cnt / 2, &#39; &#39;), print(res / 2, &#39;\n&#39;);
    return 0;
&#125;
&#125; // namespace XSC062
#undef int</code></pre>
</details>
<hr />
<p>ä¾æˆ‘çœ‹ï¼Œé˜Ÿåå°±å«ã€Œæ›¾æ€»è¯´çš„éƒ½é˜Ÿã€å§ ğŸµ</p>

			</div>
			<hr class="dotted">
			<div class="post footer">
				<div id="hitokoto">
					<h3 id="hitokoto-title">
						è¨€è®º
					</h3>
					<div id="hitokoto-content">
					</div>
					<div id="hitokoto-from">
					</div>
				</div>
				<div class="button flex">
					<div id="prev">
						
							<!-- åæ§½ï¼Œä¸ºå•¥è¿˜éœ€è¦åŠ  / -->
							<a href="/20230722/">
								<i class="fas fa-angle-double-left" style="margin-right: 10px;"></i>
								ç½‘ç»œæµ 24 é¢˜
							</a>
						
					</div>
					<div id="next">
						
							<a href="/20230717/">
								å­¦ä¹ å°ç»„
								<i class="fas fa-angle-double-right" style="margin-left: 10px;"></i>
							</a>
						
					</div>
				</div>
				<div id="vcomments" class="yahei"></div>
<script>
	new Valine({
		el: '#vcomments',
		appId: 'OlmvQ0a2Zw7xo3no2bwabOzx-gzGzoHsz',
		appKey: 'TW6t8mFeGLmhPjWisvmllvvo',
		recordIP: true,
		enableQQ: true, 
		// ç›®å‰ Valine çš„ QQ è‡ªåŠ¨è·å–æ˜µç§°ä¼¼ä¹ä¸å¯ç”¨ æ•…ä¸å»ºè®®å¼€å¯
		pageSize: 10,
		requiredFields:
			
				['nick']
			,
		placeholder: "The world is but a little place after all...\nèƒ½å¤Ÿæ ¹æ®é‚®ç®±è·å–ä½ çš„ Gravatar å¤´åƒã€‚æ˜µç§°æ˜¯å¿…å¡«é¡¹ï¼Œé•¿åº¦éœ€ä¸ä½äº 3ã€‚",
		avatar: 'mp',
		avatar_cdn: 'https://cravatar.cn/avatar/',
		emojiCDN: 'https://xsc062.netlify.app/em/', 
		emojiMaps: {
			
				"å¾®ç¬‘": "wx.gif",
			
				"é¾‡ç‰™": "cy.gif",
			
				"æµæ³ª": "ll.gif",
			
				"ç¬‘å“­": "xk.gif",
			
				"æµæ±—": "lh.gif",
			
				"æ“¦æ±—": "ch.gif",
			
				"äº²äº²": "qq.gif",
			
				"è‰²": "se.gif",
			
				"ç–‘é—®": "yiw.gif",
			
				"å‘å‘†": "fd.gif",
			
				"æ™•": "yun.gif",
			
				"é¼“æŒ": "gz.gif",
			
				"æ†¨ç¬‘": "hanx.gif",
			
				"å¿«å“­äº†": "kk.gif",
			
				"å¾—æ„": "dy.gif",
			
				"ç‹‚ç¬‘": "kx.gif",
			
				"å®³ç¾": "hx.gif",
			
				"å¦ˆå¦ˆç”Ÿçš„": "dz.gif",
			
				"ç³—å¤§äº†": "qd.gif",
			
				"åƒç“œ": "cg.gif",
			
				"ççœ¼": "zy.webp",
			
				"è¾£çœ¼ç›": "lyj.gif",
			
				"é…¸äº†": "nm.gif",
			
				"æ»š": "gun.webp",
			
				"æƒŠæ": "jk.gif",
			
				"å¹½çµ": "youl.gif",
			
				"æ— èŠ": "wul.gif",
			
				"åƒ": "eat.gif",
			
				"ä½ å¾ˆæ£’æ£’": "bb.gif",
			
				"èµ": "qiang.gif",
			
				"è¸©": "ruo.gif",
			
				"æ¡æ‰‹": "wsh.gif",
			
				"å‘æŠ–": "fad.gif",
			
				"æŒ¥æ‰‹": "hsh.gif",
			
				"ç£•å¤´": "kt.gif",
			
				"æ€„ç«": "oh.gif",
			
		},
	})
</script>
			</div>
			<script>setHitokoto();</script>
		</div> 
	</div>
</div>
    <!-- é¡µè„šå¼€å§‹ -->
<div id="footer" class="yahei">
    Powered by
    <a target="_blank" rel="noopener" href="https://hexo.io">
        Hexo
    </a>
    &
    <a href="/about-this-theme">
        iwll
    </a>
    <p style="margin-top: 5px;">
        2021 - 2025
    </p>
</div>
<!-- Valine ç›¸å…³é…ç½® -->
<script>
    const getValineDomTimer = setInterval(() => {
        // ä¸çŸ¥é“ä¸ºä»€ä¹ˆ æˆ‘ä»åŸåšå®¢ js æ–‡ä»¶ç²˜è¿‡æ¥çš„å‚æ•°æ˜¯
        // "#valine .vcards .vcard"
        // DEBUG äº†åŠå¤©æ‰å®šä½åˆ°è¿™ä¸ªé—®é¢˜ã€‚ã€‚ã€‚
        const vcards =
            document.querySelectorAll('#valine, .vcards, .vcard');
        if (vcards.length > 0) {
            let author = 'XSC062';
            for (let vcard of vcards) {
                const vnick_dom = vcard.querySelector('.vhead .vnick');
                if (vnick_dom != null) {
                    const vnick = vnick_dom.innerHTML;
                    if (vnick === author) {
                        vnick_dom.innerHTML =
                        `${vnick} <span id="rootitem" class="fira">root</span>`
                    }
                }
            }
        }
        else {
            clearInterval(getValineDomTimer);
        }
    }, 2000);
    SetActiveItem();
    setDetailsSummary();
    setTitleAnchor();
    setEmptyToc();
    setCodeClassName();
</script>


<!-- js -->
<!-- æœç´¢åŠŸèƒ½ç›¸å…³é…ç½® -->

<script src="/js/search.js"></script>

</script>
<!-- prism ç›¸å…³é…ç½® -->
<script type="text/javascript" src="/js/prism.js" defer></script>
<!-- ä»£ç å—å¤åˆ¶åŠŸèƒ½ -->
<script type="text/javascript" src="/js/clipboard.min.js"></script>
<script type="text/javascript" src="/js/clipboard-use.js"></script>
<!-- é¡µè„šç»“æŸ -->
</body>
</html>